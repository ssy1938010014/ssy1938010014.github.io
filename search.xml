<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小沈同学的Tape提问箱</title>
    <url>/2022/10/24/Tape%E6%8F%90%E9%97%AE%E7%AE%B1/</url>
    <content><![CDATA[<p><a href="https://www.askbox.ink/h5/uu/1398QUTQ">点击此处获取 进入小沈同学的Tape提问箱</a></p>
<h3 id="欢迎来到我的Tape提问箱，在这里你可以："><a href="#欢迎来到我的Tape提问箱，在这里你可以：" class="headerlink" title="欢迎来到我的Tape提问箱，在这里你可以："></a>欢迎来到我的Tape提问箱，在这里你可以：</h3><ul>
<li><h4 id="说说你学习的烦恼，尽管我不一定能够解答，但我可以倾听"><a href="#说说你学习的烦恼，尽管我不一定能够解答，但我可以倾听" class="headerlink" title="说说你学习的烦恼，尽管我不一定能够解答，但我可以倾听"></a>说说你学习的烦恼，尽管我不一定能够解答，但我可以倾听</h4></li>
<li><h4 id="聊聊你生活的琐碎，让我用浅薄的人生经历来开导你"><a href="#聊聊你生活的琐碎，让我用浅薄的人生经历来开导你" class="headerlink" title="聊聊你生活的琐碎，让我用浅薄的人生经历来开导你"></a>聊聊你生活的琐碎，让我用浅薄的人生经历来开导你</h4></li>
<li><h4 id="如果对小沈同学本人比较感兴趣，也欢迎提问"><a href="#如果对小沈同学本人比较感兴趣，也欢迎提问" class="headerlink" title="如果对小沈同学本人比较感兴趣，也欢迎提问"></a>如果对小沈同学本人比较感兴趣，也欢迎提问</h4></li>
<li><h4 id="提问均是匿名的，不要害怕"><a href="#提问均是匿名的，不要害怕" class="headerlink" title="提问均是匿名的，不要害怕"></a>提问均是匿名的，不要害怕</h4></li>
<li><h4 id="可以提问了！"><a href="#可以提问了！" class="headerlink" title="可以提问了！"></a>可以提问了！</h4></li>
</ul>
<span id="more"></span>
]]></content>
      <categories>
        <category>生活碎片</category>
      </categories>
      <tags>
        <tag>提问箱</tag>
      </tags>
  </entry>
  <entry>
    <title>小沈同学本科期末复习宝典</title>
    <url>/2022/11/10/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<p><strong>复习宝典，懂的都懂！</strong></p>
<h1 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h1><p>$\quad$$\bullet$<a href="https://kdocs.cn/l/ctpZMOJFAxiL?f=301">点击此处获取 电子学期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://kdocs.cn/l/ccd4wueFeZQQ?f=301">点击此处获取 微机原理期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://kdocs.cn/l/caCTc3XTkmNH?f=301">点击此处获取 逻辑设计期末复习宝典</a></p>
<hr>
<h1 id="大三上"><a href="#大三上" class="headerlink" title="大三上"></a>大三上</h1><p>$\quad$$\bullet$<a href="https://kdocs.cn/l/ccw4xqZt9fi8?f=201">点击此处获取 离散时间信号期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://kdocs.cn/l/cp4hTnBPBX98?f=201">点击此处获取 电磁场原理期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://kdocs.cn/l/ctA3HhFJ7cVy?f=201">点击此处获取 结构化数字设计期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://kdocs.cn/l/ctuf7X9L3vop?f=201">点击此处获取 单片机期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://kdocs.cn/l/ciRMFDobYUGZ?f=201">点击此处获取 线性控制系统期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://kdocs.cn/l/ctEmQSsjDeRw?f=201">点击此处获取 电力电子期末复习宝典</a></p>
<hr>
<h1 id="大三下"><a href="#大三下" class="headerlink" title="大三下"></a>大三下</h1><p>$\quad$$\bullet$<a href="https://maifile.cn/est/a2766785580734/pdf">点击此处获取 固态电子学期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://maifile.cn/est/a2246785582686/pdf">点击此处获取 模拟集成电路设计期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://maifile.cn/est/a3246785588277/pdf">点击此处获取 通信原理期末复习宝典</a></p>
<p>$\quad$$\bullet$<a href="https://maifile.cn/est/a2676785586772/pdf">点击此处获取 超大规模数字集成电路设计期末复习宝典</a></p>
<span id="more"></span>
<hr>
<ul>
<li><h3 id="打赏任意金额后邮箱联系我（备注需要哪一个学期的），获取任一学期的pdf密码"><a href="#打赏任意金额后邮箱联系我（备注需要哪一个学期的），获取任一学期的pdf密码" class="headerlink" title="打赏任意金额后邮箱联系我（备注需要哪一个学期的），获取任一学期的pdf密码"></a>打赏任意金额后邮箱联系我（备注需要哪一个学期的），获取任一学期的pdf密码</h3></li>
<li><h3 id="相信我，小沈匠心整理，一定对得起你打赏的金额！"><a href="#相信我，小沈匠心整理，一定对得起你打赏的金额！" class="headerlink" title="相信我，小沈匠心整理，一定对得起你打赏的金额！"></a>相信我，小沈匠心整理，一定对得起你打赏的金额！</h3></li>
<li><h3 id="想考高分，怎么能够没有一套复习宝典！"><a href="#想考高分，怎么能够没有一套复习宝典！" class="headerlink" title="想考高分，怎么能够没有一套复习宝典！"></a>想考高分，怎么能够没有一套复习宝典！</h3></li>
<li><h3 id="需要其他资料请邮箱联系！"><a href="#需要其他资料请邮箱联系！" class="headerlink" title="需要其他资料请邮箱联系！"></a>需要其他资料请邮箱联系！</h3></li>
</ul>
]]></content>
      <categories>
        <category>知识共享</category>
      </categories>
      <tags>
        <tag>期末复习宝典</tag>
        <tag>付费内容</tag>
      </tags>
  </entry>
  <entry>
    <title>小沈同学的本科学习笔记</title>
    <url>/2022/10/24/%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a90991742709@pdf">点击此处获取 数字集成电路设计笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a98598744206@pdf">点击此处获取 模拟集成电路分析与设计笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a94779689222@pdf">点击此处获取 信号与系统笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a89787007590@pdf">点击此处获取 结构化数字设计笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a93405366625@pdf">点击此处获取 常微分笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a98876697093@pdf">点击此处获取 单片机原理笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a92482261038@pdf">点击此处获取 电力电子笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a94485666137@pdf">点击此处获取 电子学2笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a93437690158@pdf">点击此处获取 概率论笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a89559702311@pdf">点击此处获取 离散时间信号笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a93447374661@pdf">点击此处获取 逻辑设计笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a94852670052@pdf">点击此处获取 数据结构笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a95788708750@pdf">点击此处获取 自动控制原理笔记</a></p>
<p>$\quad$$\bullet$<a href="https://maiimg.com/dec/a89660723835@pdf">点击此处获取 电磁场原理笔记</a></p>
<span id="more"></span>
<hr>
<ul>
<li><h2 id="整理不易，请取之有道，转载务必注明出处！"><a href="#整理不易，请取之有道，转载务必注明出处！" class="headerlink" title="整理不易，请取之有道，转载务必注明出处！"></a>整理不易，请取之有道，转载务必注明出处！</h2></li>
<li><h2 id="文件较大，加载可能比较费时，请耐心等待！"><a href="#文件较大，加载可能比较费时，请耐心等待！" class="headerlink" title="文件较大，加载可能比较费时，请耐心等待！"></a>文件较大，加载可能比较费时，请耐心等待！</h2></li>
<li><h2 id="若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！"><a href="#若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！" class="headerlink" title="若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！"></a>若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！</h2></li>
</ul>
]]></content>
      <categories>
        <category>知识共享</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA实现CNN之github开源代码阅读</title>
    <url>/2024/09/23/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8Bgithub%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>本节主要分享在github中阅读学习别人开源代码的感悟。</p>
<span id="more"></span>
<h1 id="https-github-com-omarelhedaby-CNN-FPGA"><a href="#https-github-com-omarelhedaby-CNN-FPGA" class="headerlink" title="https://github.com/omarelhedaby/CNN-FPGA"></a><a href="https://github.com/omarelhedaby/CNN-FPGA">https://github.com/omarelhedaby/CNN-FPGA</a></h1><ul>
<li><p>该代码展开得很少，更多得考虑资源，架构上没有啥特色，就是乘加运算的堆叠【浮点乘加】</p>
</li>
<li><p>但其提供的设计文档很详细</p>
</li>
<li><p>不建议细看</p>
</li>
<li><p>卷积模块设计框图：</p>
<p><img src="/2024/09/23/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8Bgithub%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/image-20240923221927480.png" alt="image-20240923221927480"></p>
</li>
<li><p>softmax模块设计框图：</p>
<p><img src="/2024/09/23/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8Bgithub%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/image-20240923222011978.png" alt="image-20240923222011978" style="zoom: 50%;"></p>
</li>
<li><p>平均池化设计框图：</p>
<p><img src="/2024/09/23/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8Bgithub%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/image-20240923222056732.png" alt="image-20240923222056732"></p>
</li>
<li><p>这里面有个串行加法器的写法有点意思：</p>
<p><img src="/2024/09/23/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8Bgithub%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/image-20240923221812752.png" alt="image-20240923221812752"></p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>verilog</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之编解码</title>
    <url>/2024/05/29/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E7%BC%96%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>本节主要对常见的编解码方式进行学习与记录。</p>
<span id="more"></span>
<h1 id="格雷编码与解码"><a href="#格雷编码与解码" class="headerlink" title="格雷编码与解码"></a>格雷编码与解码</h1><ul>
<li><p><strong>格雷码的主要特点是相邻编码值中只有一个比特发生变化</strong></p>
</li>
<li><p>格雷编码被广泛应用于使用两个不同时钟的异步FIFO中。</p>
</li>
<li><p>当位宽为多个比特的信号从一个时钟域传输到另外一个时钟域时，需要如图的转化电路</p>
<p><img src="/2024/05/29/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E7%BC%96%E8%A7%A3%E7%A0%81/image-20240529152839512.png" alt="image-20240529152839512" style="zoom:50%;"></p>
<ul>
<li>该信号开始时转化为格雷码，然后进入源时钟域的寄存器</li>
<li>此后，通过两级同步器同步到目的时钟域，实现同步后，通过相反的译码过程，就可以实现多比特值在两个时钟域之间的传递</li>
</ul>
</li>
<li><p>看了网上很多博客，我觉得只有这篇把在fifo中为什么要使用格雷码说清楚：<a href="https://blog.csdn.net/qq_43365647/article/details/102660669">异步FIFO：为什么要用格雷码_异步fifo为什么用格雷码-CSDN博客</a></p>
<ul>
<li>其中，有很重要一句话是：<strong>在fifo中格雷码的关键不在于发生亚稳态的概率小了，而在于即使发生了亚稳态，也没问题。</strong></li>
<li>我的理解是：因为相邻格雷码之间只有1bit发生变化，如果这一bit发生了亚稳态，稳定后，此bit要么是0，要么是1，即在fifo中要么是指针保持不变或者指针加1，但这不会影响fifo的结果，具体看这篇的解释（<a href="https://blog.csdn.net/justinlee2015/article/details/106527301">异步FIFO为什么要使用格雷码(笔记)_异步fifo使用格雷码的目的-CSDN博客</a>）</li>
<li>还有一点就是，格雷码计数要变化的bit少，那么可能的中间状态就少。多一个中间状态，就相当于多一次变化，而每次变化都可能出现亚稳态</li>
</ul>
</li>
</ul>
<h2 id="1-格雷码编码"><a href="#1-格雷码编码" class="headerlink" title="1.格雷码编码"></a>1.格雷码编码</h2><ul>
<li><p>binary_to_gray.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> binary_to_gray #(</span><br><span class="line">    <span class="keyword">parameter</span>   PTR = <span class="number">8</span> </span><br><span class="line">    )(</span><br><span class="line">    <span class="keyword">input</span>   [PTR : <span class="number">0</span>]    binary_value,</span><br><span class="line">    <span class="keyword">output</span>  [PTR : <span class="number">0</span>]    gray_value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">genvar</span> i;</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; PTR; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">assign</span> gray_value[i] = binary_value[i] ^ binary_value[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> gray_value[PTR] = binary_value[PTR];</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-格雷码解码"><a href="#2-格雷码解码" class="headerlink" title="2.格雷码解码"></a>2.格雷码解码</h2><ul>
<li><p>gray_to_binary.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gray_to_binary #(</span><br><span class="line">    <span class="keyword">parameter</span>   PTR = <span class="number">8</span></span><br><span class="line">    )(</span><br><span class="line">        <span class="keyword">input</span>   [PTR : <span class="number">0</span>]    gray_value,</span><br><span class="line">        <span class="keyword">output</span>  [PTR : <span class="number">0</span>]    binary_value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> binary_value[PTR] = gray_value[PTR];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">genvar</span> i;</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; PTR; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">assign</span> binary_value[i] = binary_value[i + <span class="number">1</span>] ^ gray_value[i];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Testbench"><a href="#3-Testbench" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><ul>
<li><p>transfer_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> transfer_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span>  PTR = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>                clk               ;</span><br><span class="line">    <span class="keyword">reg</span>   [PTR : <span class="number">0</span>]    binary_value      ;</span><br><span class="line">    <span class="keyword">wire</span>  [PTR : <span class="number">0</span>]    gray_value        ;</span><br><span class="line">    <span class="keyword">wire</span>  [PTR : <span class="number">0</span>]    binary_value_tf   ;</span><br><span class="line"></span><br><span class="line">    binary_to_gray #(</span><br><span class="line">        <span class="variable">.PTR</span>(PTR) </span><br><span class="line">    )binary_to_gray_u1(</span><br><span class="line">        <span class="variable">.binary_value</span>   (binary_value),</span><br><span class="line">        <span class="variable">.gray_value</span>     (gray_value  )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    gray_to_binary #(</span><br><span class="line">        <span class="variable">.PTR</span>(PTR) </span><br><span class="line">    )gray_to_binary_u1(</span><br><span class="line">        <span class="variable">.gray_value</span>     (gray_value),</span><br><span class="line">        <span class="variable">.binary_value</span>   (binary_value_tf)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        binary_value &lt;= &#123;(PTR + <span class="number">1</span>)&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> clk) binary_value &lt;= binary_value + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>仿真结果：</p>
<p><img src="/2024/05/29/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E7%BC%96%E8%A7%A3%E7%A0%81/image-20240530010242387.png" alt="image-20240530010242387"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="优先级编码"><a href="#优先级编码" class="headerlink" title="优先级编码"></a>优先级编码</h1><ul>
<li><p>其实正常想法就是用if-else语句去写，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> priority_encoder(</span><br><span class="line">    <span class="keyword">input</span>  D0, D1, D2, D3, D4, D5, D6, D7,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] Q2Q1Q0</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        Q2Q1Q0 = <span class="number">3&#x27;b000</span>;</span><br><span class="line">        <span class="keyword">if</span>(D0) Q2Q1Q0 = <span class="number">3&#x27;b000</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(D1) Q2Q1Q0 = <span class="number">3&#x27;b001</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(D2) Q2Q1Q0 = <span class="number">3&#x27;b010</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(D3) Q2Q1Q0 = <span class="number">3&#x27;b011</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(D4) Q2Q1Q0 = <span class="number">3&#x27;b100</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(D5) Q2Q1Q0 = <span class="number">3&#x27;b101</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(D6) Q2Q1Q0 = <span class="number">3&#x27;b110</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(D7) Q2Q1Q0 = <span class="number">3&#x27;b111</span>;    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>其RTL原理图如下：</p>
<p><img src="/2024/05/29/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E7%BC%96%E8%A7%A3%E7%A0%81/image-20240607013821245.png" alt="image-20240607013821245"></p>
</li>
</ul>
</li>
<li><p>但在书上看到一种很神奇的case写法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> encoder(</span><br><span class="line">    <span class="keyword">input</span>  D0, D1, D2, D3, D4, D5, D6, D7,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] Q2Q1Q0</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        Q2Q1Q0 = <span class="number">3&#x27;b000</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1&#x27;b1</span>)</span><br><span class="line">            D0: Q2Q1Q0 = <span class="number">3&#x27;b000</span>;</span><br><span class="line">            D1: Q2Q1Q0 = <span class="number">3&#x27;b001</span>;</span><br><span class="line">            D2: Q2Q1Q0 = <span class="number">3&#x27;b010</span>;</span><br><span class="line">            D3: Q2Q1Q0 = <span class="number">3&#x27;b011</span>;</span><br><span class="line">            D4: Q2Q1Q0 = <span class="number">3&#x27;b100</span>;</span><br><span class="line">            D5: Q2Q1Q0 = <span class="number">3&#x27;b101</span>;</span><br><span class="line">            D6: Q2Q1Q0 = <span class="number">3&#x27;b110</span>;</span><br><span class="line">            D7: Q2Q1Q0 = <span class="number">3&#x27;b111</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>其RTL原理图如下：</p>
<p><img src="/2024/05/29/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E7%BC%96%E8%A7%A3%E7%A0%81/image-20240607013506799.png" alt="image-20240607013506799" style="zoom:50%;"></p>
</li>
<li><p>其实它相当于是对D0~D7依次扫描，优先级依次减小，哪个等于1，就执行其后对应的语句</p>
</li>
</ul>
</li>
<li><p>其实这两种写法综合出来的资源是一样的，都如下图所示</p>
<p><img src="/2024/05/29/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E7%BC%96%E8%A7%A3%E7%A0%81/image-20240607015927247.png" alt="image-20240607015927247" style="zoom: 67%;"></p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA系统设计之PetaLinux</title>
    <url>/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/</url>
    <content><![CDATA[<p>本节主要介绍了如何借助petalinux工具构建一个linux基础xi’ton</p>
<span id="more"></span>
<h1 id="PetaLinux基本介绍"><a href="#PetaLinux基本介绍" class="headerlink" title="PetaLinux基本介绍"></a>PetaLinux基本介绍</h1><ul>
<li><p>PetaLinux工具可简化赛灵思器件上的嵌入式Linux开发</p>
</li>
<li><p>PetaLinux工具只需要7条命令即可简化基于Linux的产品开发</p>
<p><img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/image-20240523225506173.png" alt="image-20240523225506173" style="zoom: 67%;"></p>
<ul>
<li>我也是第一次接触操作系统，不太清楚PetaLinux具体的工作是啥，但上面这幅图就很形象，它能帮我们完成Linux操作系统搭建的一系列步骤，然后我们就可以更多的关注实际应用开发本身</li>
</ul>
</li>
<li><p>具体参考Xilinx官方介绍视频：<a href="https://china.xilinx.com/video/hardware/xilinx-embedded-linux-build-flows-petalinux-tools.html">赛灵思嵌入式 Linux 构建流程：PetaLinux 工具（中文字幕） (xilinx.com)</a></p>
</li>
</ul>
<hr>
<h1 id="PetaLinux安装"><a href="#PetaLinux安装" class="headerlink" title="PetaLinux安装"></a>PetaLinux安装</h1><ul>
<li><p>应该可以在xilinx的官网上找到安装包，我直接在同门那拷贝了一份（如果有找不到的可以邮箱私信我取）</p>
</li>
<li><p>直接chmod 777 ./petalinux-v2023.1-05012318-installer.run进行安装，但是可能会缺少依赖的库，报啥错就对应安装对应的库</p>
</li>
<li><p>安装后可以输入echo $PETALINUX，如果出现安装路径，则说明安装正确</p>
<p><img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/image-20240523233634446.png" alt="image-20240523233634446"></p>
</li>
</ul>
<hr>
<h1 id="PetaLinux的七条命令"><a href="#PetaLinux的七条命令" class="headerlink" title="PetaLinux的七条命令"></a>PetaLinux的七条命令</h1><ul>
<li><p><strong>petalinux-create可创建对象并将其包含到PetaLinux工程中，包括PetaLinux工程本身、应用以及模块</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">petalinux-create --type project --template &lt;PLATFORM&gt; --name &lt;PROJECT_NAME&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数如下：<ul>
<li>—template <PLATFORM> <ul>
<li>zynqMP (UltraScale+™ MPSoC)</li>
<li>zynq (Zynq-7000 器件)</li>
<li>microblaze (MicroBlaze™ CPU)</li>
</ul>
</PLATFORM></li>
<li>—name <PROJECT_NAME> - 您正在构建的工程名称。</PROJECT_NAME></li>
</ul>
</li>
</ul>
</li>
<li><p>petalinux-config工具允许在工程级别或工程组件级别进行自定义，它还可提供工作空间用于安装软件补丁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">petalinux-config --get-hw-description=&lt;path-to-directory-containinghardware description-file&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>利用 petalinux-config 命令导入硬件描述， 按如下要求提供含有 .hdf/.dsa 文件的目录路径</strong>  </li>
</ul>
</li>
<li><p>petalinux-build工具可构建整个嵌入式Linux系统，也可构建Linux系统的指定组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">petalinux-build</span><br></pre></td></tr></table></figure>
</li>
<li><p>petalinux-boot工具用于加载并启动PetaLinux镜像，包括利用实体板上的JTAG或借助系统的QEMU模型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">petalinux-package --boot --fsbl &lt;FSBL image&gt; --fpga &lt;FPGA bitstream&gt; --u-boot</span><br></pre></td></tr></table></figure>
<ul>
<li>按照上面的步骤生成 .BIN 格式的启动镜像  </li>
</ul>
</li>
<li><p>petalinux-package工具可将PetaLinux工具封装为适合部署的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">petalinux-package --image -c kernel --format uImage</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想使用 uImage，请使用 petalinux-package —image  </li>
</ul>
</li>
<li><p>petalinux-util工具支持您访问GDB等各种实用工具</p>
</li>
<li><p>petalinux-upgrade工具可执行次要版本升级以使用最新系统软件组件</p>
<p><img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/image-20240523235315369.png" alt="image-20240523235315369" style="zoom:50%;"></p>
<ul>
<li>图中绿色标注均为可选命令</li>
</ul>
</li>
</ul>
<hr>
<h1 id="PetaLinux搭建一个基础的Linux系统"><a href="#PetaLinux搭建一个基础的Linux系统" class="headerlink" title="PetaLinux搭建一个基础的Linux系统"></a>PetaLinux搭建一个基础的Linux系统</h1><ul>
<li><p>具体步骤如下：<strong>但需要注意的是在create完成一个petalinux的project后，一定cd到对应project文件夹下执行后续操作</strong></p>
<p><img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/image-20240525234421768.png" alt="image-20240525234421768"></p>
<p><img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/image-20240525234519979.png" alt="image-20240525234519979"></p>
<p><img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/image-20240525234709743.png" alt="image-20240525234709743"></p>
</li>
<li><p>接下来将生成的文件拷贝至sd卡中</p>
<p><img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/image-20240525235112745.png" alt="image-20240525235112745"></p>
<ul>
<li><p>这里需要用到虚拟机，因为服务器上是看不到sd卡的分区的</p>
</li>
<li><p>SD 中将 RootFS （rootfs.tar.gz）加载到 ext4 分区， 所有其他启动镜像（boot.scr、BOOT.BIIN、image.ub）加载到 FAT32 分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssy@ssy-virtual-machine:~$ cd /mnt/</span><br><span class="line">ssy@ssy-virtual-machine:/mnt$ ls</span><br><span class="line">BOOT  hgfs  RootFS</span><br><span class="line">ssy@ssy-virtual-machine:/mnt$ sudo mount /dev/sdb1 BOOT/</span><br><span class="line">ssy@ssy-virtual-machine:/mnt$ sudo mount /dev/sdb2 RootFS/</span><br><span class="line">ssy@ssy-virtual-machine:/mnt$ cd BOOT/</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/BOOT$ ls</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/BOOT$ cd ..</span><br><span class="line">ssy@ssy-virtual-machine:/mnt$ cd BOOT/</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/BOOT$ sudo cp ~/BOOT.BIN .</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/BOOT$ sudo cp ~/boot.scr .</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/BOOT$ sudo cp ~/image.ub .</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/BOOT$ sync</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/BOOT$ cd ..</span><br><span class="line">ssy@ssy-virtual-machine:/mnt$ cd RootFS/</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/RootFS$ ls</span><br><span class="line">lost+found</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/RootFS$ sudo rm -rf *</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/RootFS$ ls -l</span><br><span class="line">total 0</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/RootFS$ sudo tar -xzvf ~/rootfs.tar.gz </span><br><span class="line">ssy@ssy-virtual-machine:/mnt/RootFS$ sync</span><br><span class="line">ssy@ssy-virtual-machine:/mnt/RootFS$ cd ..</span><br><span class="line">ssy@ssy-virtual-machine:/mnt$ sudo umount /dev/sdb*</span><br><span class="line">umount: /dev/sdb: not mounted.</span><br><span class="line">ssy@ssy-virtual-machine:/mnt$ sudo umount /dev/sdb*</span><br><span class="line">umount: /dev/sdb: not mounted.</span><br><span class="line">umount: /dev/sdb1: not mounted.</span><br><span class="line">umount: /dev/sdb2: not mounted.</span><br><span class="line">ssy@ssy-virtual-machine:/mnt$ sudo umount /dev/sdb*</span><br><span class="line">umount: /dev/sdb: not mounted.</span><br><span class="line">umount: /dev/sdb1: not mounted.</span><br><span class="line">umount: /dev/sdb2: not mounted.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="搭建Petalinux后代码下载"><a href="#搭建Petalinux后代码下载" class="headerlink" title="搭建Petalinux后代码下载"></a>搭建Petalinux后代码下载</h1><ul>
<li><p>这里发现了一个bug，那就是如果把每个vivado工程都生成bit流，然后运行petalinux那几条命令，如果直接将文件下载到sd卡中，有可能会导致系统卡死（反正我当时加了个dma系统直接卡死了）</p>
</li>
<li><p>解决办法：用空工程（ps的最小系统）利用petalinux搭建操作系统，然后进入到操作系统后，直接把bitstream在线加载到系统中（2024.06.24更新<strong>：直接弄一个空工程在线下载比特流能进系统但可能操作不了ps端，所以如果是ps部分或ps与pl部分交互部分的bd有修改，那么直接用.xsa重新创建一个petalinux，如果只修改了pl，则可以在线更新bit流</strong>）</p>
<ul>
<li><p>将bit文件打包成bit.bin文件（假设你的bit文件名称是mybit.bit，新建一个xxx.bif，内容如下）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:&#123;</span><br><span class="line"> mybit.bit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在服务器上使用命令行 <code>bootgen -image xxx.bif -arch zynqmp -process_bitstream bin</code>，这样就可以得到mybit.bit.bin文件，接着将该文件下载到自己电脑上</li>
</ul>
</li>
<li><p>打开板子进入系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ifconfig eth0 xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure>
<ul>
<li>这个xxx.xxx.xxx.xxx是你给板子的IP地址，用来给你的电脑和板子之间进行通信</li>
<li>找一条网线，分别连接板子和你的电脑</li>
<li>然后你的电脑的网口IP更改成xxx.xxx.xxx.1，保证和板子的IP在同一个网段</li>
</ul>
</li>
<li><p>之后用远程工具，SSH登录xxx.xxx.xxx.xxx，也就是板子的IP，远程使用板子上的命令行，这时候可以用SSH把文件传到板子上。</p>
</li>
<li><p>最后用如下命令将bit流下载到板子中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo fpgautil -b xxx.bit.bin -f Full</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>其实后面执行编译好的xxx.o文件也是同样的扒拉文件到板子操作系统上的流程。注意要添加权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod +x ./xxx.o</span><br><span class="line">sudo ./xxx.o</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="附加知识点"><a href="#附加知识点" class="headerlink" title="附加知识点"></a>附加知识点</h1><ul>
<li><p>如何在虚拟机上对sd卡分盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mzmylhz@ubuntu:/mnt$ sudo umount /dev/sdb*</span><br><span class="line">mzmylhz@ubuntu:/mnt$ sudo fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sdb: 119.38 GiB, 128177930240 bytes, 250347520 sectors</span><br><span class="line">Disk model: Storage Device  </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x7245180a</span><br><span class="line"></span><br><span class="line">Device     Boot    Start       End   Sectors   Size Id Type</span><br><span class="line">/dev/sdb1           2048  11111240  11109193   5.3G 83 Linux</span><br><span class="line">/dev/sdb2       11112448 250347519 239235072 114.1G 83 Linux</span><br><span class="line"></span><br><span class="line">Command (m for help): d</span><br><span class="line">Partition number (1,2, default 2): </span><br><span class="line"></span><br><span class="line">Partition 2 has been deleted.</span><br><span class="line"></span><br><span class="line">Command (m for help): </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help): d</span><br><span class="line"></span><br><span class="line">Selected partition 1</span><br><span class="line">Partition 1 has been deleted.</span><br><span class="line"></span><br><span class="line">Command (m for help): </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 119.38 GiB, 128177930240 bytes, 250347520 sectors</span><br><span class="line">Disk model: Storage Device  </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x7245180a</span><br><span class="line"></span><br><span class="line">Command (m for help): n</span><br><span class="line">Partition type</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended (container for logical partitions)</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1-4, default 1):  </span><br><span class="line">First sector (2048-250347519, default 2048): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-250347519, default 250347519): 11111240</span><br><span class="line"></span><br><span class="line">Created a new partition 1 of type &#x27;Linux&#x27; and of size 5.3 GiB.</span><br><span class="line">Partition #1 contains a vfat signature.</span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: y</span><br><span class="line"></span><br><span class="line">The signature will be removed by a write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): n</span><br><span class="line">Partition type</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended (container for logical partitions)</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (2-4, default 2): </span><br><span class="line">First sector (11111241-250347519, default 11112448): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (11112448-250347519, default 250347519): </span><br><span class="line"></span><br><span class="line">Created a new partition 2 of type &#x27;Linux&#x27; and of size 114.1 GiB.</span><br><span class="line">Partition #2 contains a ext4 signature.</span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: y</span><br><span class="line"></span><br><span class="line">The signature will be removed by a write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): w</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line">mzmylhz@ubuntu:/mnt$ sudo mkfs.fat /dev/sdb1</span><br><span class="line">mkfs.fat 4.1 (2017-01-24)</span><br><span class="line">mzmylhz@ubuntu:/mnt$ sudo mkfs.ext4 /dev/sdb2</span><br><span class="line">mke2fs 1.45.5 (07-Jan-2020)</span><br><span class="line">Creating filesystem with 29904384 4k blocks and 7479296 inodes</span><br><span class="line">Filesystem UUID: 3b09766c-cc62-4cba-a6fa-a72be0b39f82</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </span><br><span class="line">	4096000, 7962624, 11239424, 20480000, 23887872</span><br><span class="line"></span><br><span class="line">Allocating group tables: done                            </span><br><span class="line">Writing inode tables: done                            </span><br><span class="line">Creating journal (131072 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br></pre></td></tr></table></figure>
</li>
<li><p>VScode连接远程服务器：<a href="https://blog.csdn.net/zhaxun/article/details/120568402">vscode连接远程服务器（傻瓜式教学）-CSDN博客</a></p>
</li>
<li><p>在系统上编译因为文件是CPP报错（如下原因就是petalinux系统默认是C文件，需要在petalinux-config中将C++的包添加进去）解决办法：</p>
<p><img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/41fe3b867d47ec49074d304edb61c3b.png" alt="41fe3b867d47ec49074d304edb61c3b"></p>
<ul>
<li><p>解决办法：petalinux-config -c rootfs</p>
<p> <img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/c91351d7859a679d230fcc43c8d8429.png" alt="c91351d7859a679d230fcc43c8d8429" style="zoom:50%;"><img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/82d576196ce055c432159f337a7c537.png" alt="82d576196ce055c432159f337a7c537" style="zoom: 36%;"></p>
<p> <img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/e2294b82cdc9b0340ead0f34c1602fa.png" alt="e2294b82cdc9b0340ead0f34c1602fa" style="zoom:40%;"> <img src="/2024/05/23/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BPetaLinux/1b6b65a480c4303750b04d7a219f3e8.png" alt="1b6b65a480c4303750b04d7a219f3e8" style="zoom:40%;"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog之易错易忘知识点</title>
    <url>/2024/05/17/Verilog%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>本文主要记录在Verilog学习的过程中容易出错、容易遗忘的知识点，会不定期更新</p>
<span id="more"></span>
<h1 id="组合逻辑易错点"><a href="#组合逻辑易错点" class="headerlink" title="组合逻辑易错点"></a>组合逻辑易错点</h1><h2 id="1-always块语句"><a href="#1-always块语句" class="headerlink" title="1.always块语句"></a>1.always块语句</h2><ul>
<li><p>在Verilog中可以使用两种方法描述组合逻辑：使用always组合块或assign语句</p>
<ul>
<li>当使用<strong>always</strong>组合块描述时，变量需声明为<strong>reg</strong>类型（此时必须用 <code>=</code> 赋值，否则综合后可能会出错）</li>
<li>当使用<strong>assign</strong>语句描述时，变量需声明为<strong>wire</strong>类型</li>
</ul>
</li>
<li><p><strong>在always块内部开始时为变量分配默认值，可以确保综合后不会生成锁存器</strong></p>
<ul>
<li><p>以if_else为例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span> : <span class="number">0</span>] cnter, cnter_nxt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//put all default values here</span></span><br><span class="line">    cnter_nxt = cnter;</span><br><span class="line">    <span class="comment">//describe the equation in an algorithmic manner</span></span><br><span class="line">    <span class="keyword">if</span>(reset_cnter) </span><br><span class="line">        cnter_nxt = <span class="number">&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnter == <span class="number">2&#x27;b11</span>) </span><br><span class="line">        cnter_nxt = <span class="number">&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cnter_nxt = cnter + <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以case为例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    state_nxt = state;	<span class="comment">//declare the default value in the beginning</span></span><br><span class="line">    <span class="keyword">case</span>(state) </span><br><span class="line">        IDLE: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(start_write)</span><br><span class="line">                start_nxt = WRITE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(start_read)</span><br><span class="line">                start_nxt = READ；</span><br><span class="line">            <span class="comment">//else start_nxt = state; already covered in beginning</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        WRITE: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(end_write)</span><br><span class="line">                state_nxt = IDLE;</span><br><span class="line">            <span class="comment">//else start_nxt = state; already covered in beginning</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        READ: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(end_read)</span><br><span class="line">                state_nxt = IDLE;</span><br><span class="line">            <span class="comment">//else start_nxt = state; already covered in beginning</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="2-移位操作符"><a href="#2-移位操作符" class="headerlink" title="2.移位操作符"></a>2.移位操作符</h2><ul>
<li><p>算数左移<code>&lt;&lt;</code>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">7</span> : <span class="number">0</span>] a, b, c;</span><br><span class="line"><span class="keyword">assign</span> c = a &lt;&lt; b;	<span class="comment">//将a向左移b位，低位用0填充</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在不发生溢出时，左移可以用来进行某些乘法运算</strong>，这里的溢出，指的是a最大能表示的范围，如果a左移后的值超过a能表示的最大范围，还用左移来代替乘法运算，就会出错！！！</li>
<li>例如a = 8’b11000011（195），将a左移2位后（就是乘以4），c = 8’b00001100，最高两位就丢失了（因为195*4后是780，而8bit无符号数最多表示255，故会发生溢出）</li>
</ul>
</li>
<li><p>算数右移<code>&gt;&gt;</code>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">7</span> : <span class="number">0</span>] a, b, c;</span><br><span class="line"><span class="keyword">assign</span> c = a &gt;&gt; b;	<span class="comment">//将a向右移b位，高位用0填充</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="函数与任务"><a href="#函数与任务" class="headerlink" title="函数与任务"></a>函数与任务</h1><ul>
<li>函数<code>function</code>：<ul>
<li><strong>函数可以用来生成可综合的组合逻辑</strong>。当同一逻辑功能在多处使用时，可以采用Verilog函数来描述其功能，上层电路可以调用该函数，这样有利于提高代码的可读性和电路的可重用性</li>
<li>函数内部所描述的逻辑功能是可综合的，综合后得到的是组合逻辑，<strong>其内部不能出现与时间控制相关的语句，如wait，@或 #</strong>；</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Verilog中的-ifdef"><a href="#Verilog中的-ifdef" class="headerlink" title="Verilog中的`ifdef"></a>Verilog中的`ifdef</h1><ul>
<li><p>在模块内部，设计者可以在ifdef和对应的else后面插入一些语句。综合工具进行RTL代码编译处理时，将首先判断是否对其后面的字符串进行了定义，如果进行了定义，那么将其后面的语句插入电路代码中，否则它将else后面的语句插入电路代码中。有时ifdef和else后面没有需要插入的语句</p>
</li>
<li><p>下面是一个具体的例子：</p>
<ul>
<li><p>创建一个含有`define定义的头文件：chiptop_defines.vh</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//`define CHIP_XYZ_SEL1</span></span><br><span class="line"><span class="comment">//`define CHIP_XYZ_SEL2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用`include语句包含.vh文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;chiptop_defines.vh&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ifdef用法举例</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifdef</span> CHIP_XYZ_SEL1</span></span><br><span class="line">    <span class="keyword">assign</span> d_nxt = a + b;</span><br><span class="line">    <span class="keyword">assign</span> e_nxt = a + c;</span><br><span class="line"><span class="meta">`<span class="keyword">elsif</span> CHIP_XYZ_SEL2</span></span><br><span class="line">    <span class="keyword">assign</span> d_nxt = a - b;</span><br><span class="line">    <span class="keyword">assign</span> e_nxt = a - c;</span><br><span class="line"><span class="meta">`<span class="keyword">else</span> </span></span><br><span class="line">    <span class="keyword">assign</span> d_nxt = a * b;</span><br><span class="line">    <span class="keyword">assign</span> e_nxt = a * c;</span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面是一个具有多个条件编译分支的例子。如果在chiptop_defines.vh文件中对CHIP_XYZ_SEL1进行了定义，编译后将在电路代码中插入d_nxt = a + b;e_nxt = a + c;否则将判断是否定义了CHIP_XYZ_SEL2，如果没有定义，那么编译器将进入最后一个分支。</li>
<li>注意：是<code>`elsif</code>，不是`else if（这么写会报错）【《Verilog高级数字系统设计计数与实例分析》这本书咋这么多错误，还得自己敲敲代码】</li>
</ul>
</li>
<li><p>仿真结果如下：</p>
<p><img src="/2024/05/17/Verilog%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20240517164526920.png" alt="image-20240517164526920"></p>
</li>
</ul>
</li>
<li><p>`ifdef的用法与mux语句的区别：</p>
<ul>
<li><strong>在一个mux语句中，不同的分支都会出现在综合后的网表中</strong>，根据select信号（选择控制信号）的值决定执行其中的一条路路径</li>
<li><strong>在`ifdef中，只有某一个分支对应的代码会在网表中实际出现</strong></li>
<li>如果设计者需要在芯片中保留两条路径，并且可以根据需要进行选择，那么应使用mux而不是`ifdef</li>
</ul>
</li>
</ul>
<hr>
<h1 id="用于验证的Verilog语法"><a href="#用于验证的Verilog语法" class="headerlink" title="用于验证的Verilog语法"></a>用于验证的Verilog语法</h1><h2 id="1-random"><a href="#1-random" class="headerlink" title="1.$random"></a>1.$random</h2><ul>
<li><p>$random可以产生一个有符号的32bit随机整数，一般的用法为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">$random</span> % b;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>num的范围在-(b-1)~(b-1)的随机数</strong></li>
</ul>
</li>
<li><p>产生随机正整数：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">num = &#123;<span class="built_in">$random</span>&#125; % b;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>num的范围在0~(b-1)中的随机数</strong></li>
</ul>
</li>
<li><p><strong>产生一个在min，max之间随机数</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">num = min + &#123;<span class="built_in">$random</span>&#125; % (max - min + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h2><ul>
<li><p>while循环语句在执行时，只要其后的表达式为真，则循环执行后面对应的语句。当表达式的值为假时，退出该循环</p>
</li>
<li><p>在while循环内，建议加入与定时控制有关的语句，以免形成定时环路，造成死循环</p>
</li>
<li><p>下面是一个while循环的例子，在这段代码中，需要从某个基地址开始，按照一定的地址增量产生新的地址对存储器进行访问，当地址大于预先设定的最大地址时，跳出while循环</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> while_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span>   INIT_ADDR = <span class="number">32&#x27;h0000_0020</span>,</span><br><span class="line">                MAX_ADDR = <span class="number">32&#x27;h0000_003C</span>,</span><br><span class="line">                ADDR_INCR = <span class="number">8&#x27;h04</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">32</span> : <span class="number">0</span>] mem_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        mem_addr = INIT_ADDR;</span><br><span class="line">        <span class="keyword">while</span>(mem_addr &lt;= MAX_ADDR) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> clk);</span><br><span class="line">            <span class="comment">//---do the task here</span></span><br><span class="line">            <span class="comment">//---end of task</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;memory address = %h&quot;</span>, mem_addr);</span><br><span class="line">            mem_addr = mem_addr + ADDR_INCR;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>仿真结果：</p>
<p> <img src="/2024/05/17/Verilog%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20240527110056644.png" alt="image-20240527110056644" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="多个if综合效果"><a href="#多个if综合效果" class="headerlink" title="多个if综合效果"></a>多个if综合效果</h1><ul>
<li><p>（20240604）附：<strong>第一次知道原来一个always中多个if并行，编译器不会编译成多个mux并行（针对在多个if中对同一个变量赋值的情况），还是级联的mux，最后一个if的优先级最高（越靠近输出）</strong>（在我另一篇文章中也有记录<a href="https://ssy1938010014.github.io/2023/11/06/FPGA数字信号处理之高速度结构设计/">FPGA数字信号处理之高速度结构设计 | ssy的小天地 (ssy1938010014.github.io)</a>）</p>
</li>
<li><p>可参考：<a href="https://blog.csdn.net/weixin_39520719/article/details/107809003">Verilog中单if语句、多if语句和case语句与优先级的关系_verilog if else if 执行顺序-CSDN博客</a></p>
</li>
<li><p>我当时是测试了这样一段代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>      </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">1</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">2</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">3</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">4</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>      </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">5</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">6</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">7</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>     </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>综合结果：（圈起来的优先级最高cfar_flag[7]）</p>
<p><img src="/2024/05/17/Verilog%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20240604111607659.png" alt="image-20240604111607659"></p>
</li>
<li><p>如果把if放在不同always中，那么就会综合出并行的效果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">genvar</span> i;</span><br><span class="line"><span class="keyword">generate</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cfar_flag[i]) <span class="keyword">begin</span></span><br><span class="line">                object &lt;= <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">end</span>        </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>综合结果：</p>
<p><img src="/2024/05/17/Verilog%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20240604114309065.png" alt="image-20240604114309065" style="zoom:80%;"></p>
</li>
<li><p>但这种方式综合会报CW（critical warning），布线会报错</p>
<p><img src="/2024/05/17/Verilog%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20240604120117359.png" alt="image-20240604120117359"></p>
</li>
</ul>
<hr>
<h1 id="ILA与总线模式"><a href="#ILA与总线模式" class="headerlink" title="ILA与总线模式"></a>ILA与总线模式</h1><ul>
<li><p><strong>若测试接口用总线模式输出，此时若ila单独一根一根线拉出去观察，就会把之前总线覆盖，所以此时ila也要用总线模式</strong></p>
<ul>
<li><p>错误的：</p>
<p> <img src="/2024/05/17/Verilog%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20240624134811042.png" alt="image-20240624134811042" style="zoom: 33%;"></p>
</li>
<li><p>正确的：</p>
<p> <img src="/2024/05/17/Verilog%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20240624134844215.png" alt="image-20240624134844215" style="zoom:33%;"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>QT之基础用法</title>
    <url>/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要记录学习QT基础使用方法的流程，利用零碎的时间更新，不定期更新。工具上的东西主要是多练，我也是看视频学习的，记录得有点乱……</p>
<span id="more"></span>
<h1 id="基本使用熟悉"><a href="#基本使用熟悉" class="headerlink" title="基本使用熟悉"></a>基本使用熟悉</h1><h2 id="1-编写一个Hello-World程序"><a href="#1-编写一个Hello-World程序" class="headerlink" title="1.编写一个Hello World程序"></a>1.编写一个Hello World程序</h2><ul>
<li><p>跟随这个视频上手就好：<a href="https://www.bilibili.com/video/BV1km4y1k7CW/?p=4&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">1.3编写一个Hello World程序_哔哩哔哩_bilibili</a>（后续内容基本都是跟着这个UP主学习的）</p>
</li>
<li><p>主要注意创建工程时选择Qt widgets（带GUI）以及qmake就好</p>
</li>
<li><p>最后效果点击三角运行程序就好</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240515234739062.png" alt="image-20240515234739062" style="zoom: 25%;"></p>
</li>
</ul>
<h2 id="2-Signals-and-Slots-Editor的简单使用"><a href="#2-Signals-and-Slots-Editor的简单使用" class="headerlink" title="2.Signals and Slots Editor的简单使用"></a>2.Signals and Slots Editor的简单使用</h2><ul>
<li><p>pushButton发送clicked()信号，被widget接收，然后widget窗口会close()关闭</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240516001511022.png" alt="image-20240516001511022" style="zoom: 33%;"></p>
</li>
<li><p>也可以在widget.cpp中修改代码去控制GUI界面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;你好QT&quot;</span>);</span><br><span class="line">ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭窗口&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终效果：</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240516001844998.png" alt="image-20240516001844998" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="3-可视化UI设计"><a href="#3-可视化UI设计" class="headerlink" title="3.可视化UI设计"></a>3.可视化UI设计</h2><ul>
<li><p>创建工程时选择qdialog（此时GUI界面的基类变成了qdialog）</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240516003238849.png" alt="image-20240516003238849" style="zoom: 50%;"></p>
</li>
<li><p>大致布局如下：</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240516164419008.png" alt="image-20240516164419008"></p>
</li>
<li><p>对于除颜色外其他按键的设置：</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240516164622118.png" alt="image-20240516164622118" style="zoom: 33%;"> <img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240516164821234.png" alt="image-20240516164821234" style="zoom: 33%;"></p>
<ul>
<li><p>在dialog中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::on_pushButton_clear_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;plainTextEdit-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::on_checkBox_underline_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QFont font=ui-&gt;plainTextEdit-&gt;<span class="built_in">font</span>();   <span class="comment">//得到当前的字体</span></span><br><span class="line">    font.<span class="built_in">setUnderline</span>(checked);             <span class="comment">//根据bool checked修改字体的下划线</span></span><br><span class="line">    ui-&gt;plainTextEdit-&gt;<span class="built_in">setFont</span>(font);       <span class="comment">//重新给字体加上下划线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::on_checkBox_italic_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QFont font=ui-&gt;plainTextEdit-&gt;<span class="built_in">font</span>();   <span class="comment">//得到当前的字体</span></span><br><span class="line">    font.<span class="built_in">setItalic</span>(checked);                <span class="comment">//根据修改bool checked字体的斜体</span></span><br><span class="line">    ui-&gt;plainTextEdit-&gt;<span class="built_in">setFont</span>(font);       <span class="comment">//重新给字体加上斜体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::on_checkBox_bold_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QFont font=ui-&gt;plainTextEdit-&gt;<span class="built_in">font</span>();   <span class="comment">//得到当前的字体</span></span><br><span class="line">    font.<span class="built_in">setBold</span>(checked);                  <span class="comment">//根据修改bool checked字体的粗体</span></span><br><span class="line">    ui-&gt;plainTextEdit-&gt;<span class="built_in">setFont</span>(font);       <span class="comment">//重新给字体加上粗体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对于颜色的按键：</p>
<ul>
<li><p>首先在dialog.cpp中定义函数do_FontColor，可右击定义处，在重构中选择下图所示，这样可以直接跳转到函数编辑处</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240516165853434.png" alt="image-20240516165853434" style="zoom:50%;"></p>
</li>
<li><p>其次，在dialog.cpp中编写函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::do_FontColor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPalette plet=ui-&gt;plainTextEdit-&gt;<span class="built_in">palette</span>();     <span class="comment">//QPalette是Qt中用于管理部件的调色板（颜色和样式）的类</span></span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;radioButton_black-&gt;<span class="built_in">isChecked</span>())          <span class="comment">//如果radioButton_black按键按下isChecked()，那么就将plet的颜色改为黑色</span></span><br><span class="line">        plet.<span class="built_in">setColor</span>(QPalette::Text,Qt::black);</span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;radioButton_red-&gt;<span class="built_in">isChecked</span>())            <span class="comment">//如果radioButton_black按键按下isChecked()，那么就将plet的颜色改为红色</span></span><br><span class="line">        plet.<span class="built_in">setColor</span>(QPalette::Text,Qt::red);</span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;radioButton_blue-&gt;<span class="built_in">isChecked</span>())           <span class="comment">//如果radioButton_black按键按下isChecked()，那么就将plet的颜色改为蓝色</span></span><br><span class="line">        plet.<span class="built_in">setColor</span>(QPalette::Text,Qt::blue);</span><br><span class="line">    ui-&gt;plainTextEdit-&gt;<span class="built_in">setPalette</span>(plet);            <span class="comment">//重新设置当前对象的颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，在dialog.cpp中利用connect函数链接颜色按键与文本的关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Dialog::<span class="built_in">Dialog</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Dialog)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;radioButton_black, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_FontColor</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;radioButton_red, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_FontColor</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;radioButton_blue, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_FontColor</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最终，大致结果如下：</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240516170132526.png" alt="image-20240516170132526" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="4-代码UI设计"><a href="#4-代码UI设计" class="headerlink" title="4.代码UI设计"></a>4.代码UI设计</h2><h3 id="4-1-布局实现"><a href="#4-1-布局实现" class="headerlink" title="4.1 布局实现"></a>4.1 布局实现</h3><ul>
<li><p>纯coding的话，不需要UI布局界面，在创建工程时需要取消generate form</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240518002810755.png" alt="image-20240518002810755" style="zoom: 50%;"></p>
</li>
<li><p>布局的代码学过一点点C++的应该都能比较快速的看懂</p>
<ul>
<li><p>dialog.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QCheckBox</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QRadioButton</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QPlainTextEdit</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QPushButton</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QCheckBox *chkBoxUnder;</span><br><span class="line">    QCheckBox *chkBoxItalic;</span><br><span class="line">    QCheckBox *chkBoxBold;</span><br><span class="line"></span><br><span class="line">    QRadioButton *radioBlack;</span><br><span class="line">    QRadioButton *radioRed;</span><br><span class="line">    QRadioButton *radioBlue;</span><br><span class="line"></span><br><span class="line">    QPlainTextEdit *txtEdit;</span><br><span class="line"></span><br><span class="line">    QPushButton *btnOK;</span><br><span class="line">    QPushButton *btnCancel;</span><br><span class="line">    QPushButton *btnClose;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dialog</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dialog</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DIALOG_H</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dialog.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加布局要用到的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCheckBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRadioButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPlainTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dialog::<span class="built_in">Dialog</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建要用的布局组件</span></span><br><span class="line">    chkBoxUnder = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;下划线&quot;</span>);</span><br><span class="line">    chkBoxItalic = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;斜体&quot;</span>);</span><br><span class="line">    chkBoxBold = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;加粗&quot;</span>);</span><br><span class="line">    QHBoxLayout *HLay = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    HLay -&gt; <span class="built_in">addWidget</span>(chkBoxUnder);</span><br><span class="line">    HLay -&gt; <span class="built_in">addWidget</span>(chkBoxItalic);</span><br><span class="line">    HLay -&gt; <span class="built_in">addWidget</span>(chkBoxBold);</span><br><span class="line"></span><br><span class="line">    radioBlack = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">    radioRed = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">    radioBlue = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;蓝色&quot;</span>);</span><br><span class="line">    QHBoxLayout *HLay2 = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    HLay2 -&gt; <span class="built_in">addWidget</span>(radioBlack);</span><br><span class="line">    HLay2 -&gt; <span class="built_in">addWidget</span>(radioRed);</span><br><span class="line">    HLay2 -&gt; <span class="built_in">addWidget</span>(radioBlue);</span><br><span class="line"></span><br><span class="line">    txtEdit = <span class="keyword">new</span> QPlainTextEdit;</span><br><span class="line">    txtEdit -&gt; <span class="built_in">setPlainText</span>(<span class="string">&quot;Hello world\n 手工创建！&quot;</span>);</span><br><span class="line">    QFont font = txtEdit -&gt; <span class="built_in">font</span>();</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">20</span>);</span><br><span class="line">    txtEdit -&gt; <span class="built_in">setFont</span>(font);</span><br><span class="line"></span><br><span class="line">    btnOK = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;确定&quot;</span>);</span><br><span class="line">    btnCancel = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;取消&quot;</span>);</span><br><span class="line">    btnClose = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">    QHBoxLayout *HLay3 = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addStretch</span>();</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addWidget</span>(btnOK);</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addStretch</span>();</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addWidget</span>(btnCancel);</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addWidget</span>(btnClose);</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *VLay = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">    VLay -&gt; <span class="built_in">addLayout</span>(HLay);</span><br><span class="line">    VLay -&gt; <span class="built_in">addLayout</span>(HLay2);</span><br><span class="line">    VLay -&gt; <span class="built_in">addWidget</span>(txtEdit);</span><br><span class="line">    VLay -&gt; <span class="built_in">addLayout</span>(HLay3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setLayout</span>(VLay);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dialog::~<span class="built_in">Dialog</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最终运行结果如下：</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240518010511328.png" alt="image-20240518010511328" style="zoom: 50%;"></p>
</li>
</ul>
<h3 id="4-2-信号槽连接"><a href="#4-2-信号槽连接" class="headerlink" title="4.2 信号槽连接"></a>4.2 信号槽连接</h3><ul>
<li><p>其实跟可视化UI设计时写的代码类似，无非是加上信号与槽的关系，编写槽函数，然后connect连接</p>
<ul>
<li><p>dialog.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QCheckBox</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QRadioButton</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QPlainTextEdit</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QPushButton</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QCheckBox *chkBoxUnder;</span><br><span class="line">    QCheckBox *chkBoxItalic;</span><br><span class="line">    QCheckBox *chkBoxBold;</span><br><span class="line"></span><br><span class="line">    QRadioButton *radioBlack;</span><br><span class="line">    QRadioButton *radioRed;</span><br><span class="line">    QRadioButton *radioBlue;</span><br><span class="line"></span><br><span class="line">    QPlainTextEdit *txtEdit;</span><br><span class="line"></span><br><span class="line">    QPushButton *btnOK;</span><br><span class="line">    QPushButton *btnCancel;</span><br><span class="line">    QPushButton *btnClose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:  <span class="comment">//代表下面都是槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_chkBoxUnder</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_chkBoxItalic</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_chkBoxBold</span><span class="params">(<span class="type">bool</span> checked)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_setFontColor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dialog</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Dialog</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DIALOG_H</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dialog.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加布局要用到的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCheckBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRadioButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPlainTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::do_chkBoxUnder</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QFont font = txtEdit -&gt; <span class="built_in">font</span>();</span><br><span class="line">    font.<span class="built_in">setUnderline</span>(checked);</span><br><span class="line">    txtEdit -&gt; <span class="built_in">setFont</span>(font);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::do_chkBoxItalic</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QFont font = txtEdit -&gt; <span class="built_in">font</span>();</span><br><span class="line">    font.<span class="built_in">setItalic</span>(checked);</span><br><span class="line">    txtEdit -&gt; <span class="built_in">setFont</span>(font);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::do_chkBoxBold</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QFont font = txtEdit -&gt; <span class="built_in">font</span>();</span><br><span class="line">    font.<span class="built_in">setBold</span>(checked);</span><br><span class="line">    txtEdit -&gt; <span class="built_in">setFont</span>(font);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::do_setFontColor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPalette plet = txtEdit -&gt; <span class="built_in">palette</span>();</span><br><span class="line">    <span class="keyword">if</span>(radioBlack -&gt; <span class="built_in">isChecked</span>())</span><br><span class="line">        plet.<span class="built_in">setColor</span>(QPalette::Text, Qt::black);</span><br><span class="line">    <span class="keyword">if</span>(radioRed -&gt; <span class="built_in">isChecked</span>())</span><br><span class="line">        plet.<span class="built_in">setColor</span>(QPalette::Text, Qt::red);</span><br><span class="line">    <span class="keyword">if</span>(radioBlue -&gt; <span class="built_in">isChecked</span>())</span><br><span class="line">        plet.<span class="built_in">setColor</span>(QPalette::Text, Qt::blue);</span><br><span class="line">    txtEdit -&gt; <span class="built_in">setPalette</span>(plet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dialog::<span class="built_in">Dialog</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建要用的布局组件</span></span><br><span class="line">    chkBoxUnder = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;下划线&quot;</span>);</span><br><span class="line">    chkBoxItalic = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;斜体&quot;</span>);</span><br><span class="line">    chkBoxBold = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;加粗&quot;</span>);</span><br><span class="line">    QHBoxLayout *HLay = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    HLay -&gt; <span class="built_in">addWidget</span>(chkBoxUnder);</span><br><span class="line">    HLay -&gt; <span class="built_in">addWidget</span>(chkBoxItalic);</span><br><span class="line">    HLay -&gt; <span class="built_in">addWidget</span>(chkBoxBold);</span><br><span class="line"></span><br><span class="line">    radioBlack = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">    radioRed = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">    radioBlue = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;蓝色&quot;</span>);</span><br><span class="line">    QHBoxLayout *HLay2 = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    HLay2 -&gt; <span class="built_in">addWidget</span>(radioBlack);</span><br><span class="line">    HLay2 -&gt; <span class="built_in">addWidget</span>(radioRed);</span><br><span class="line">    HLay2 -&gt; <span class="built_in">addWidget</span>(radioBlue);</span><br><span class="line"></span><br><span class="line">    txtEdit = <span class="keyword">new</span> QPlainTextEdit;</span><br><span class="line">    txtEdit -&gt; <span class="built_in">setPlainText</span>(<span class="string">&quot;Hello world\n 手工创建！&quot;</span>);</span><br><span class="line">    QFont font = txtEdit -&gt; <span class="built_in">font</span>();</span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">20</span>);</span><br><span class="line">    txtEdit -&gt; <span class="built_in">setFont</span>(font);</span><br><span class="line"></span><br><span class="line">    btnOK = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;确定&quot;</span>);</span><br><span class="line">    btnCancel = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;取消&quot;</span>);</span><br><span class="line">    btnClose = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">    QHBoxLayout *HLay3 = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addStretch</span>();</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addWidget</span>(btnOK);</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addStretch</span>();</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addWidget</span>(btnCancel);</span><br><span class="line">    HLay3 -&gt; <span class="built_in">addWidget</span>(btnClose);</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *VLay = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">    VLay -&gt; <span class="built_in">addLayout</span>(HLay);</span><br><span class="line">    VLay -&gt; <span class="built_in">addLayout</span>(HLay2);</span><br><span class="line">    VLay -&gt; <span class="built_in">addWidget</span>(txtEdit);</span><br><span class="line">    VLay -&gt; <span class="built_in">addLayout</span>(HLay3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setLayout</span>(VLay);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(chkBoxUnder, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_chkBoxUnder</span>(<span class="type">bool</span>)));</span><br><span class="line">    <span class="built_in">connect</span>(chkBoxItalic, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_chkBoxItalic</span>(<span class="type">bool</span>)));</span><br><span class="line">    <span class="built_in">connect</span>(chkBoxBold, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_chkBoxBold</span>(<span class="type">bool</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(radioBlack, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_setFontColor</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(radioRed, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_setFontColor</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(radioBlue, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_setFontColor</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(btnOK, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">accept</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(btnCancel, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">reject</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(btnClose, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>(<span class="type">bool</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;手工打造UI&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dialog::~<span class="built_in">Dialog</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最终效果如下：</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240518012809682.png" alt="image-20240518012809682" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="5-Qt-Creator的一些快捷键"><a href="#5-Qt-Creator的一些快捷键" class="headerlink" title="5.Qt Creator的一些快捷键"></a>5.Qt Creator的一些快捷键</h2><ul>
<li>F4：在同名的头文件和源程序文件之间切换</li>
<li>F2：变量：跳转到声明；函数：声明和定义切换</li>
<li>Ctrl+Shift+S：保存所有文件</li>
</ul>
<hr>
<h1 id="元对象系统功能示例"><a href="#元对象系统功能示例" class="headerlink" title="元对象系统功能示例"></a>元对象系统功能示例</h1><ul>
<li><p>Qt的元对象系统（Meta-Object System）是Qt编程的基础，它对标准C++语言进行了扩展，支持信号与槽、属性等特性</p>
</li>
<li><p>本示例基于QObject自定义了一个类TPerson，演示元对象系统一些特性的使用，包括自定义类信息，定义属性，定义动态属性，自定义信号等</p>
</li>
<li><p>目前我的理解是：Qt里面原本有很多已写好了的类可以直接调用，如果要新定义一些自己的类进行一些操作，就需要用QObject新定义类进行操作</p>
<ul>
<li><p>tperson.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TPERSON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TPERSON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tperson</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="comment">//添加一些类的信息</span></span><br><span class="line">    <span class="built_in">Q_CLASSINFO</span>(<span class="string">&quot;auther&quot;</span>, <span class="string">&quot;Shen&quot;</span>)</span><br><span class="line">    <span class="built_in">Q_CLASSINFO</span>(<span class="string">&quot;university&quot;</span>, <span class="string">&quot;xmu&quot;</span>)</span><br><span class="line">    <span class="built_in">Q_CLASSINFO</span>(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类属性</span></span><br><span class="line">    <span class="built_in">Q_PROPERTY</span>(<span class="type">int</span> age READ age WRITE setAge NOTIFY ageChanged FINAL)</span><br><span class="line">    <span class="built_in">Q_PROPERTY</span>(QString name MEMBER m_name)</span><br><span class="line">    <span class="built_in">Q_PROPERTY</span>(<span class="type">int</span> score MEMBER m_score)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Tperson</span><span class="params">(QString name, QObject *parent = <span class="literal">nullptr</span>)</span></span>;    <span class="comment">//构造函数：它在对象被创建时自动调用，用于初始化对象的成员变量并执行任何必要的设置</span></span><br><span class="line">    ~<span class="built_in">Tperson</span>(); <span class="comment">//析构函数：当该类型对象被销毁时，析构函数会自动调用（析构函数不能带有参数，且不返回任何值）</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ageChanged</span><span class="params">(<span class="type">int</span> ageValue)</span></span>;   <span class="comment">//当年龄发生变化的时候，需要将改变后的年龄传递出去</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span></span>;  <span class="comment">//读age</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> ageValue)</span></span>; <span class="comment">//写age</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incAge</span><span class="params">()</span></span>;   <span class="comment">//增加年龄，点击增长一岁时，调用此函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//QString m_sexl</span></span><br><span class="line">    QString m_name;</span><br><span class="line">    <span class="type">int</span> m_age = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> m_score = <span class="number">79</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TPERSON_H</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>tperson.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tperson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Tperson::<span class="built_in">Tperson</span>(QString name, QObject *parent)</span><br><span class="line">    :QObject&#123;parent&#125;, m_name&#123;name&#125;  <span class="comment">//m_name&#123;name&#125;必须放在QObject&#123;parent&#125;之后，不然会报警告</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Tperson::~<span class="built_in">Tperson</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;TPerson类的对象被删除&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Tperson::age</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tperson::setAge</span><span class="params">(<span class="type">int</span> ageValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_age != ageValue)&#123;</span><br><span class="line">        m_age = ageValue;</span><br><span class="line">        <span class="function">emit <span class="title">ageChanged</span><span class="params">(m_age)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tperson::incAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++m_age;</span><br><span class="line">    <span class="function">emit <span class="title">ageChanged</span><span class="params">(m_age)</span></span>; <span class="comment">//年龄加1后，将结果发送出去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>widget.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tperson</span>;</span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br><span class="line">&#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Tperson *boy;</span><br><span class="line">    Tperson *girl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_ageChanged</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_spinChanged</span><span class="params">(<span class="type">int</span> arg1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_btnBoyInc_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_btnGirlInc_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_btnClear_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_btnClassInfo_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>widget.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tperson.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QMetaProperty&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义类</span></span><br><span class="line">    boy = <span class="keyword">new</span> <span class="built_in">Tperson</span>(<span class="string">&quot;小明&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    boy -&gt; <span class="built_in">setAge</span>(<span class="number">10</span>);</span><br><span class="line">    boy -&gt; <span class="built_in">setProperty</span>(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;boy&quot;</span>);</span><br><span class="line">    boy -&gt; <span class="built_in">setProperty</span>(<span class="string">&quot;score&quot;</span>, <span class="number">70</span>);</span><br><span class="line"></span><br><span class="line">    girl = <span class="keyword">new</span> <span class="built_in">Tperson</span>(<span class="string">&quot;小红&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    girl -&gt; <span class="built_in">setAge</span>(<span class="number">20</span>);</span><br><span class="line">    girl -&gt; <span class="built_in">setProperty</span>(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;girl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    ui -&gt; spinBoy -&gt; <span class="built_in">setProperty</span>(<span class="string">&quot;isBoy&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    ui -&gt; spinGirl -&gt; <span class="built_in">setProperty</span>(<span class="string">&quot;isBoy&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先通过spinBox改变年龄，年龄改变后，其值传递给do_spinChanged，再在此函数里面setAge</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;spinBoy, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_spinChanged</span>(<span class="type">int</span>))); <span class="comment">//在运行时，当信号发出时，Qt会自动将信号的参数值传递给槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;spinGirl, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_spinChanged</span>(<span class="type">int</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从而会触发ageChanged，把修改后的年龄传递给do_ageChanged打印</span></span><br><span class="line">    <span class="built_in">connect</span>(boy, <span class="built_in">SIGNAL</span>(<span class="built_in">ageChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_ageChanged</span>(<span class="type">int</span>)));</span><br><span class="line">    <span class="built_in">connect</span>(girl, <span class="built_in">SIGNAL</span>(<span class="built_in">ageChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">do_ageChanged</span>(<span class="type">int</span>)));</span><br><span class="line">    <span class="built_in">connect</span>(boy, <span class="built_in">SIGNAL</span>(<span class="built_in">ageChanged</span>(<span class="type">int</span>)), ui -&gt; spinBoy, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));      <span class="comment">//这两条语句是为了当btn改变时，spinBox也对应改变</span></span><br><span class="line">    <span class="built_in">connect</span>(girl, <span class="built_in">SIGNAL</span>(<span class="built_in">ageChanged</span>(<span class="type">int</span>)), ui -&gt; spinGirl, <span class="built_in">SLOT</span>(<span class="built_in">setValue</span>(<span class="type">int</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::do_ageChanged</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tperson *person = <span class="built_in">qobject_cast</span>&lt;Tperson*&gt;(<span class="built_in">sender</span>()); <span class="comment">//通过sender()获取发送对象，再把这个对象类型强制转化为TPerson</span></span><br><span class="line">    QString str = <span class="built_in">QString</span>(<span class="string">&quot;%1, %2, 年龄 = %3&quot;</span>)</span><br><span class="line">                      .<span class="built_in">arg</span>(person -&gt; <span class="built_in">property</span>(<span class="string">&quot;name&quot;</span>).<span class="built_in">toString</span>(), person -&gt; <span class="built_in">property</span>(<span class="string">&quot;sex&quot;</span>).<span class="built_in">toString</span>(), QString::<span class="built_in">number</span>(value));</span><br><span class="line">    ui -&gt; plainTextEdit -&gt; <span class="built_in">appendPlainText</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::do_spinChanged</span><span class="params">(<span class="type">int</span> arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSpinBox *spinBox = <span class="built_in">qobject_cast</span>&lt;QSpinBox*&gt;(<span class="built_in">sender</span>());</span><br><span class="line">    <span class="keyword">if</span>(spinBox -&gt; <span class="built_in">property</span>(<span class="string">&quot;isBoy&quot;</span>).<span class="built_in">toBool</span>())</span><br><span class="line">        boy -&gt; <span class="built_in">setAge</span>(arg1);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        girl -&gt; <span class="built_in">setAge</span>(arg1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_btnBoyInc_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boy -&gt; <span class="built_in">incAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_btnGirlInc_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    girl -&gt; <span class="built_in">incAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_btnClear_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui -&gt; plainTextEdit -&gt; <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_btnClassInfo_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> QMetaObject * meta = boy -&gt; <span class="built_in">metaObject</span>();</span><br><span class="line">    ui -&gt; plainTextEdit -&gt; <span class="built_in">appendPlainText</span>(<span class="built_in">QString</span>(<span class="string">&quot;类名称: %1\n&quot;</span>).<span class="built_in">arg</span>(meta -&gt; <span class="built_in">className</span>()));</span><br><span class="line"></span><br><span class="line">    ui -&gt; plainTextEdit -&gt; <span class="built_in">appendPlainText</span>(<span class="string">&quot;属性: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = meta -&gt; <span class="built_in">propertyOffset</span>(); i &lt; meta -&gt; <span class="built_in">propertyCount</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* propName = meta -&gt; <span class="built_in">property</span>(i).<span class="built_in">name</span>();</span><br><span class="line">        QString propValue = boy -&gt; <span class="built_in">property</span>(propName).<span class="built_in">toString</span>();</span><br><span class="line">        ui -&gt; plainTextEdit -&gt;<span class="built_in">appendPlainText</span>(<span class="built_in">QString</span>(<span class="string">&quot;属性名称 = %1, 属性值 = %2&quot;</span>).<span class="built_in">arg</span>(propName, propValue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ui -&gt; plainTextEdit -&gt; <span class="built_in">appendPlainText</span>(<span class="string">&quot;\n类信息（classInfo）: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = meta -&gt; <span class="built_in">classInfoOffset</span>(); i &lt; meta -&gt; <span class="built_in">classInfoCount</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QMetaClassInfo classInfo = meta -&gt; <span class="built_in">classInfo</span>(i);</span><br><span class="line">        ui -&gt; plainTextEdit -&gt; <span class="built_in">appendPlainText</span>(</span><br><span class="line">            <span class="built_in">QString</span>(<span class="string">&quot;Name = %1; Value = %2&quot;</span>).<span class="built_in">arg</span>(classInfo.<span class="built_in">name</span>(), classInfo.<span class="built_in">value</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终结果如下：</p>
<p><img src="/2024/05/12/QT%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/image-20240528212644502.png" alt="image-20240528212644502" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h1><ul>
<li>QT库提供了一组通用的基于模板的容器类，可用于存储指定类型的项，类似C++中的vector。例如，如果需要一个大小可变的QString数组，可以使用<code>QList&lt;QString&gt;</code>或QStringList</li>
</ul>
<h2 id="1-顺序容器"><a href="#1-顺序容器" class="headerlink" title="1.顺序容器"></a>1.顺序容器</h2><ul>
<li><p>QList、QStack和QQueue</p>
</li>
<li><p>对于大多数应用程序来说，QList是最好的选择，它提供了非常快的追加。如果确实需要使用链表，可以使用std::list</p>
</li>
<li><p>QStack和QQueue是便利类，提供了LIFO和FIFO语义</p>
</li>
<li><p>QList将数据项存储在相邻的内存位置，并提供快速的基于索引的访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QList&lt;<span class="type">float</span>&gt; list;					<span class="comment">//定义一个float类型的数据列表</span></span><br><span class="line">QList&lt;<span class="type">int</span>&gt; list = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;	<span class="comment">//初始化列表数据</span></span><br><span class="line"><span class="function">QList&lt;<span class="type">int</span>&gt; <span class="title">list</span><span class="params">(<span class="number">100</span>)</span></span>;				<span class="comment">//初始化列表元素个数为100，所有元素默认为0</span></span><br><span class="line"><span class="function">QList&lt;QString&gt; <span class="title">strList</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;pass&quot;</span>)</span></span>;	<span class="comment">//10个元素，每个元素都被初始化为pass</span></span><br><span class="line"></span><br><span class="line">QList&lt;QString&gt; list;</span><br><span class="line">list&lt;&lt;<span class="string">&quot;Monday&quot;</span>&lt;&lt;<span class="string">&quot;Tuesday&quot;</span>&lt;&lt;<span class="string">&quot;Wednesday&quot;</span>&lt;&lt;<span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&quot;Friday&quot;</span>);</span><br><span class="line">QString str1 = list[<span class="number">0</span>];</span><br><span class="line">QString str2 = list.<span class="built_in">at</span>(<span class="number">1</span>);		<span class="comment">//就是访问list[1]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2.关联容器"></a>2.关联容器</h2><ul>
<li><p>QMap、QMultiMap（统一个key对应多个value）、QHash、QMultiHash和QSet</p>
</li>
<li><p>“multi”容器支持与一个键关联的多个值</p>
</li>
<li><p>“hash”容器通过使用散列函数而不是在有序集合上进行二分查找，从而提供了更快的查找速度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMap&lt;QString, <span class="type">int</span>&gt; map;</span><br><span class="line">map[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">map[<span class="string">&quot;seven&quot;</span>] = <span class="number">7</span>;</span><br><span class="line">map.<span class="built_in">insert</span>(<span class="string">&quot;twelve&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="type">int</span> num1 = map[<span class="string">&quot;one&quot;</span>];</span><br><span class="line"><span class="comment">//如果在map中没有指定键的项，这些函数返回一个默认构造的值</span></span><br><span class="line"><span class="type">int</span> num2 = map[<span class="string">&quot;thirteen&quot;</span>];</span><br><span class="line"><span class="type">int</span> num3 = map.<span class="built_in">value</span>(<span class="string">&quot;thirteen&quot;</span>);</span><br><span class="line"><span class="comment">//还有一个value()重载方法，如果指定的键不存在，则使用第二个参数作为默认值</span></span><br><span class="line"><span class="type">int</span> num4 = map.<span class="built_in">value</span>(<span class="string">&quot;thirteen&quot;</span>, <span class="number">13</span>);	<span class="comment">//&#x27;&#x27;thirteen&#x27;&#x27;不存在时查找value值，就会返回13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历QMap</span></span><br><span class="line">QMap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">...</span><br><span class="line">QMap&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator i;</span><br><span class="line"><span class="keyword">for</span>(i = map.<span class="built_in">constBegin</span>(); i != map.<span class="built_in">constEnd</span>(); ++i)</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; i.<span class="built_in">key</span>() &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; i.<span class="built_in">value</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="QString与QChar基本使用"><a href="#QString与QChar基本使用" class="headerlink" title="QString与QChar基本使用"></a>QString与QChar基本使用</h1><ul>
<li><strong>QChar用UTF-16编码（16bit）表示一个字符</strong>，所以能表示汉字</li>
<li>QString存储一个由QCha组成的字符串</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>UVM白皮书之UVM基础</title>
    <url>/2024/05/06/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8BUVM%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文基于《UVM实战》白皮书，记录UVM学习的过程，本章是对第三章：UVM基础的学习与记录。</p>
<span id="more"></span>
<h1 id="uvm-component与uvm-object"><a href="#uvm-component与uvm-object" class="headerlink" title="uvm_component与uvm_object"></a>uvm_component与uvm_object</h1><h2 id="1-uvm-component派生自uvm-object"><a href="#1-uvm-component派生自uvm-object" class="headerlink" title="1.uvm_component派生自uvm_object"></a>1.uvm_component派生自uvm_object</h2><ul>
<li>坏了呀，感觉UVM东西好多，对UVM的热度降下来了，等到哪天实在要学的时候再继续看</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>UVM</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA设计之实用小工具</title>
    <url>/2024/04/26/FPGA%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>本节主要介绍一些在FPGA设计中一些实用的小工具，这篇会不定期更新。</p>
<span id="more"></span>
<h1 id="TimeGen"><a href="#TimeGen" class="headerlink" title="TimeGen"></a>TimeGen</h1><ul>
<li>TimeGen工具就是用来画时序图</li>
<li>简单的使用教学视频可参考：<a href="https://www.bilibili.com/video/BV1fC4y1u7o5/?spm_id_from=333.337.search-card.all.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">画时序图-TimeGen_哔哩哔哩_bilibili</a></li>
<li>剩下的就自己摸索好啦，软件的使用很方便，摸着摸着就会啦</li>
<li>如果我在使用中遇到值得记录的点，会在这更新的。</li>
</ul>
<hr>
<h1 id="Draw-io"><a href="#Draw-io" class="headerlink" title="Draw.io"></a>Draw.io</h1><ul>
<li>用来画图的软件，主要觉得Visio太难用了，这款画图软件很容易上手，但其提供的功能和库也不多，不过一般够用了</li>
<li>下载地址：<a href="https://github.com/jgraph/drawio-desktop/releases/tag/v24.1.0">Release 24.1.0 · jgraph/drawio-desktop · GitHub</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>UVM白皮书之一个简单的UVM验证</title>
    <url>/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p>本文基于《UVM实战》白皮书，记录UVM学习的过程，本章是对第二章：一个简单的UVM验证的学习与记录。</p>
<span id="more"></span>
<h1 id="验证平台的组成"><a href="#验证平台的组成" class="headerlink" title="验证平台的组成"></a>验证平台的组成</h1><ul>
<li><p>一个验证平台要实现如下基本功能：</p>
<ul>
<li>验证平台要模拟DYT的各种真实使用情况，这意味着要给DUT施加各种激励。<strong>激励的功能是由driver来实现的</strong>。</li>
<li>验证平台要能够根据DUT的输出来判断DUT的行为是否与预期相符合，<strong>完成这个功能的是scoreboard</strong></li>
<li>验证平台要能收集DUT的输出并把它们传递给scoreboard，<strong>完成这个功能的是monitor</strong></li>
<li>验证平台要能够给出预期结果，在driver传递给DUT计算的同时，验证平台中也需要有一个模块能完成相应的计算结果，给出预期。完成这个功能的是reference model</li>
</ul>
</li>
<li><p>一个简单的验证平台框图如下：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240429011111379.png" alt="image-20240429011111379" style="zoom: 33%;"></p>
</li>
<li><p>在UVM中，引入了agent和sequence的概念，因此UVM中验证平台的典型框图如下：</p>
<p> <img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240429011144579.png" alt="image-20240429011144579" style="zoom:40%;"></p>
</li>
</ul>
<hr>
<h1 id="只有driver的验证平台"><a href="#只有driver的验证平台" class="headerlink" title="只有driver的验证平台"></a>只有driver的验证平台</h1><h2 id="1-最简单的验证平台"><a href="#1-最简单的验证平台" class="headerlink" title="1.最简单的验证平台"></a>1.最简单的验证平台</h2><ul>
<li><p><strong>driver是验证平台最基本的组件，是整个验证平台数据流的源泉。</strong>（本节以一个简单的DUT为例，说明一个只有driver的UVM验证平台是如何搭建的）</p>
</li>
<li><p>dut.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module dut(clk,</span><br><span class="line">           rst_n, </span><br><span class="line">           rxd,</span><br><span class="line">           rx_dv,</span><br><span class="line">           txd,</span><br><span class="line">           tx_en);</span><br><span class="line">   input clk;</span><br><span class="line">   input rst_n;</span><br><span class="line">   input[7:0] rxd;</span><br><span class="line">   input rx_dv;</span><br><span class="line">   output [7:0] txd;</span><br><span class="line">   output tx_en;</span><br><span class="line"></span><br><span class="line">   reg[7:0] txd;</span><br><span class="line">   reg tx_en;</span><br><span class="line"></span><br><span class="line">   always @(posedge clk) begin</span><br><span class="line">      if(!rst_n) begin</span><br><span class="line">         txd &lt;= 8&#x27;b0;</span><br><span class="line">         tx_en &lt;= 1&#x27;b0;</span><br><span class="line">      end</span><br><span class="line">      else begin</span><br><span class="line">         txd &lt;= rxd;</span><br><span class="line">         tx_en &lt;= rx_dv;</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>UVM是一个库，在这个库中，几乎所有的东西使用类（class）来实现</strong>。driver、monitor、reference model、scoreboard等组成部分都是类</p>
</li>
<li><p>类有函数（function），另外还可以有任务（task），还有成员变量，这些成员变量可以控制类的行为，如控制driver的行为</p>
</li>
<li><p>当要实现一个功能时，首先应该想到的是<strong>从UVM的某个类派生出一个新的类</strong>，在这个新的类中实现所期望的功能</p>
</li>
<li><p>使用UVM的第一条原则是：<strong>验证平台中所有的组件应该派生自UVM中的类</strong></p>
</li>
<li><p><strong>UVM验证平台中的driver应该派生自uvm_driver</strong></p>
</li>
<li><p>一个简答的driver如下例所示：my_driver.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_DRIVER__SV</span><br><span class="line">`define MY_DRIVER__SV</span><br><span class="line"></span><br><span class="line">class my_driver extends uvm_driver;</span><br><span class="line">   </span><br><span class="line">   function new(string name = &quot;my_driver&quot;, uvm_component parent = null);</span><br><span class="line">      super.new(name, parent);</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   extern virtual task main_phase(uvm_phase phase);</span><br><span class="line"></span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   top_tb.rxd &lt;= 8&#x27;b0; </span><br><span class="line">   top_tb.rx_dv &lt;= 1&#x27;b0;</span><br><span class="line">   while(!top_tb.rst_n)</span><br><span class="line">      @(posedge top_tb.clk);</span><br><span class="line">   for(int i = 0; i &lt; 256; i++)begin</span><br><span class="line">      @(posedge top_tb.clk);</span><br><span class="line">      top_tb.rxd &lt;= $urandom_range(0, 255);</span><br><span class="line">      top_tb.rx_dv &lt;= 1&#x27;b1;</span><br><span class="line">      `uvm_info(&quot;my_driver&quot;, &quot;data is drived&quot;, UVM_LOW)</span><br><span class="line">   end</span><br><span class="line">   @(posedge top_tb.clk);</span><br><span class="line">   top_tb.rx_dv &lt;= 1&#x27;b0;</span><br><span class="line">endtask</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<ul>
<li><p>分析上述代码：</p>
<ul>
<li><p>所有派生自<strong>uvm_driver</strong>的类的new函数有两个参数，一个是string类型的name，一个是uvm_component类型的parent。事实上，这两个参数是由<strong>uvm_component</strong>要求的，每个派生自uvm_component或其派生的类在new函数中都要声明name和parent。<strong>uvm_driver是一个派生自uvm_component的类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function new(string name = &quot;my_driver&quot;, uvm_component parent = null);</span><br></pre></td></tr></table></figure>
</li>
<li><p>driver所做的事情几乎都在main_phase中完成。UVM由phase来管理验证平台的运行，<strong>这些phase统一以xxx.phase命名，且都有一个类型为uvm_phase、名字为phase的参数</strong>。<strong>main_phase是uvm_driver中预先定义好的一个任务。</strong>因此几乎可以简单认为，实现一个driver等于实现其main_phase（感觉归根到底不就是实现了一个函数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码中还出现了uvm_info宏。这个宏的功能与verilog中display语句的功能类似，但是它比display语句更加强大。它有三个参数：<strong>第一个参数是字符串，用于把打印的信息归类，第二个参数也是字符串，是具体需要打印的信息，第三个参数则是冗余级别</strong>（在验证平台中，某些信息是非常关键的，这样的信息可以设置为UVM_LOW，而有些信息可有可无，就可以设置为UVM_HIGH，介于两者之间的就是UVM_MEDIUM。UVM默认只显示UVM_MEDIUM或者UVM_HIGH的信息）。<strong>在搭建验证平台时应尽量使用uvm_info宏取代display语句。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`uvm_info(&quot;my_driver&quot;, &quot;data is drived&quot;, UVM_LOW)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对my_driver实例化并且最终搭建的验证平台如下：（top_tb.sv）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`timescale 1ns/1ps</span><br><span class="line">`include &quot;uvm_macros.svh&quot;</span><br><span class="line"></span><br><span class="line">import uvm_pkg::*;</span><br><span class="line">`include &quot;my_driver.sv&quot;</span><br><span class="line"></span><br><span class="line">module top_tb;</span><br><span class="line"></span><br><span class="line">    reg clk;</span><br><span class="line">    reg rst_n;</span><br><span class="line">    reg[7:0] rxd;</span><br><span class="line">    reg rx_dv;</span><br><span class="line">    wire[7:0] txd;</span><br><span class="line">    wire tx_en;</span><br><span class="line"></span><br><span class="line">    dut my_dut(.clk(clk),</span><br><span class="line">               .rst_n(rst_n),</span><br><span class="line">               .rxd(rxd),</span><br><span class="line">               .rx_dv(rx_dv),</span><br><span class="line">               .txd(txd),</span><br><span class="line">               .tx_en(tx_en));</span><br><span class="line"></span><br><span class="line">    initial begin</span><br><span class="line">       my_driver drv;</span><br><span class="line">       drv = new(&quot;drv&quot;, null);</span><br><span class="line">       drv.main_phase(null);</span><br><span class="line">       $finish();</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    initial begin</span><br><span class="line">       clk = 0;</span><br><span class="line">       forever begin</span><br><span class="line">          #100 clk = ~clk;</span><br><span class="line">       end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    initial begin</span><br><span class="line">       rst_n = 1&#x27;b0;</span><br><span class="line">       #1000;</span><br><span class="line">       rst_n = 1&#x27;b1;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<ul>
<li><p>分析上述代码：</p>
<ul>
<li><p><strong>uvm_macro.svh</strong>文件通过include语句包含进来。<strong>这是UVM中的一个文件，里面包含了众多的宏定义</strong>，只需要包含一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`include &quot;uvm_macros.svh&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过import语句将整个<strong>uvm_pkg</strong>导入验证平台中。<strong>只有导入了这个库，编译器在编译my_driver.sv文件时才会认识其中的uvm_driver等类名</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import uvm_pkg::*;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义drv为my_driver的实例，并将其例化。调用new函数时，其传入的名字参数为drv（<strong>uvm_info宏的打印信息时出现的代表路径索引的drv就是在这里传入的参数drv</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_driver drv;</span><br><span class="line">drv = new(&quot;drv&quot;, null);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示地调用my_driver的main_phase</strong>。在main_phase的声明中，有一个uvm_phase类型的参数phase（在真正的验证平台中，这个参数是不需要用户理会的，本节的验证平台还算不上一个完整的UVM验证平台，所以暂且传入null）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drv.main_phase(null);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>该例最后的仿真打印结果如下：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240428202136398.png" alt="image-20240428202136398"></p>
<ul>
<li><p>“data is drived”被输出了256次</p>
</li>
<li><p>关于uvm_info宏打印的结果中有如下几项：</p>
<ul>
<li><p><strong>UVM_INFO关键字</strong>：表明这是一个uvM宏打印的结果</p>
</li>
<li><p>my_driver.sv(23)：指明该条打印信息的来源，其中<strong>括号的数字表示原始的uvm_info打印语句在my_driver.sv中的行号</strong></p>
</li>
<li><p>@后面的数字，比如51100表示此条信息的打印时间</p>
</li>
<li><p><strong>drv</strong>：<strong>这是driver在UVM数中的路径索引（其实就是后面实例调用时new传入的第一个参数）</strong>。UVM采用树形结构，对于树中任何一个节点，都有一个与其相应的字符串类型的路径索引。路径索引可以通过get_full_name函数来获取，把下列代码加入任何UVM数的节点中就可以得知当前节点的路径索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$display(&quot;the full name of current component is: %s&quot;, get_full_name());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-加入factory机制"><a href="#2-加入factory机制" class="headerlink" title="2.加入factory机制"></a>2.加入factory机制</h2><ul>
<li><p><strong>factory机制的实现被集成在了一个宏中：uvm_component_utils</strong>。这个宏所做的事情非常多，其中之一就是将my_driver登记在UVM内部的一张表中，这张表是factory功能实现的基础。</p>
</li>
<li><p><strong>只要在定义一个新的类时使用这个宏，就相当于把这个类注册到了这张表中</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class my_driver extends uvm_driver;</span><br><span class="line">   `uvm_component_utils(my_driver)</span><br><span class="line"></span><br><span class="line">   function new(string name = &quot;my_driver&quot;, uvm_component parent = null);</span><br><span class="line">      super.new(name, parent);</span><br><span class="line">      `uvm_info(&quot;my_driver&quot;, &quot;new is called&quot;, UVM_LOW);</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   extern virtual task main_phase(uvm_phase phase);</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>
</li>
<li><p>在给driver中加入factory机制后，还需要对top_tb做一些改动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initial begin</span><br><span class="line">   run_test(&quot;my_driver&quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用一个run_test语句替换掉了前一小结中top_tb.sv中第23-28行的my_driver实例化以及main_phase的显示调用。</li>
<li><strong>一个run_test语句会创建一个my_driver的实例，并且会自动调用my_driver的main_phase</strong>。</li>
<li><strong>给run_test传递的是一个字符串，UVM根据这个字符串创建了其所代表类的一个实例</strong></li>
</ul>
</li>
<li><p><strong>根据类名创建一个类的实例，这是uvm_component_utils宏所带来的效果</strong>，只有在类定义时声明了这个宏，才能使用这个功能。从某种程度上来说，这个宏起到了注册的作用。只有经过注册的类，才能使用这个功能，否则根本不能使用。</p>
</li>
<li><p><strong>所有派生自uvm_component及其派生类的类都应该使用uvm_component_utils宏注册</strong>（所谓注册，就是在定义一个新类时加上<code>`uvm_component_utils(my_driver)</code>）</p>
</li>
<li><p><strong>在UVM验证平台中，只要一个类使用uvm_component_utils注册且此类被实例化（这里的实例化是通过run_test语句实现的）了，那么这个类的main_phase就会被自动调用</strong>。</p>
</li>
<li><p>经过上述修改后的代码（本书的代码开源，我就不一一粘贴了，网上随手一搜都能搜到），其仿真结果如下（并未打印256次data is driver，关于这个问题，牵扯UVM的objection机制）：（仿真波形也卡住了）</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240428215538079.png" alt="image-20240428215538079"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240428222429417.png" alt="image-20240428222429417"></p>
</li>
</ul>
<h2 id="3-加入objection机制"><a href="#3-加入objection机制" class="headerlink" title="3.加入objection机制"></a>3.加入objection机制</h2><ul>
<li><p>在上一节中，虽然输出了“main_phase is called”，但是“data is drived”并没有输出，而main_phase是一个完整的任务，没有理由只执行第一句，而后面的代码不执行。看上去似乎main_phase在执行的过程中被外力”杀死“了，事实上也确实如此。</p>
</li>
<li><p><strong>UVM中通过objection机制来控制验证平台的关闭</strong></p>
</li>
<li><p><strong>在每个phase中，UVM会检查是否有objection被提起（raise_objection），如果有，那么等待这个objection被撤销（drop_objection）后停止仿真；如果没有，马上结束当前phase</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phase.raise_objection(this);</span><br><span class="line">...</span><br><span class="line">phase.drop_objection(this);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在drop_objection语句之前必须先调用raise_objection语句，drop_objection和raise_objection总是成对出现的。加入objection机制后再运行验证平台，可以发现”data is drived”按照预期输出了256次。</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240428222048974.png" alt="image-20240428222048974"></p>
</li>
<li><p><strong>raise_objection语句必须在main_phase中第一个消耗仿真时间的语句之前</strong>。如<code>$display</code>语句是不消耗仿真时间的，这些语句可以放在raise_objection之前，但是类似@(posedge top_tb.clk)等语句是要消耗仿真时间的。若my_driver.sv的代码修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@(posedge top_tb.clk);</span><br><span class="line">phase.raise_objection(this);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其结果如下：（甚至连仿真波形都会卡住）</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240428222357817.png" alt="image-20240428222357817"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240428222429417.png" alt="image-20240428222429417"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-加入virtual-interface"><a href="#4-加入virtual-interface" class="headerlink" title="4.加入virtual interface"></a>4.加入virtual interface</h2><ul>
<li><p>在前面的例子中，driver中等待时钟时间@(posedge top.clk)、给DUT中输入端口赋值（top.rx_dv&lt;=1’b1）都是使用绝对路径，绝对路径的使用大大减弱了验证平台的可移植性。一个最简单的例子就是假设clk信号的层次从top.clk变成了top.clk_inst.clk，那么就需要对driver中的相关代码做大量修改。因此，从根本上来说，应该尽量杜绝在验证平台中使用绝对路径。</p>
</li>
<li><p>避免绝对路径的一个方法是使用宏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`define TOP top_tb</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样，当路径修改时，只需要修改宏的定义即可。但是假设clk的冷酷就变为了top_tb.clk_inst.clk，而rst_n的路径变为了top_tb.rst_inst.rst_n，那么单纯地修改宏定义是无法起到作用的。</p>
</li>
<li><p>避免绝对路径的另外一种方式是使用interface。<strong>在SV中使用interface来连接验证平台与DUT的端口。</strong></p>
</li>
<li><p>interface的定义比较简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_IF__SV</span><br><span class="line">`define MY_IF__SV</span><br><span class="line"></span><br><span class="line">   interface my_if(input clk, input rst_n);</span><br><span class="line"></span><br><span class="line">      logic [7:0] data;</span><br><span class="line">      logic valid;</span><br><span class="line">   endinterface</span><br><span class="line"></span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义了interface后，在top_tb中实例化DUT时，就可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_if input_if(clk, rst_n);</span><br><span class="line">my_if output_if(clk, rst_n);</span><br><span class="line"></span><br><span class="line">dut my_dut(.clk(clk),</span><br><span class="line">         .rst_n(rst_n),</span><br><span class="line">         .rxd(input_if.data),</span><br><span class="line">         .rx_dv(input_if.valid),</span><br><span class="line">         .txd(output_if.data),</span><br><span class="line">         .tx_en(output_if.valid));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在类中使用的是virtual interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class my_driver extends uvm_driver;</span><br><span class="line">   virtual my_if vif;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在声明了vif后，就可以在main_phase中使用如下方式驱动其中的信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   phase.raise_objection(this);</span><br><span class="line"></span><br><span class="line">   `uvm_info(&quot;my_driver&quot;, &quot;main_phase is called&quot;, UVM_LOW);</span><br><span class="line"></span><br><span class="line">   vif.data &lt;= 8&#x27;b0; </span><br><span class="line">   vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">   while(!vif.rst_n)</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   for(int i = 0; i &lt; 256; i++)begin</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      vif.data &lt;= $urandom_range(0, 255);</span><br><span class="line">      vif.valid &lt;= 1&#x27;b1;</span><br><span class="line">      `uvm_info(&quot;my_driver&quot;, &quot;data is drived&quot;, UVM_LOW);</span><br><span class="line">   end</span><br><span class="line">   @(posedge vif.clk);</span><br><span class="line">   vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">   </span><br><span class="line">   phase.drop_objection(this);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>UVM引进了config_db机制</strong>，来将top_tb中input_if和my_driver中的vif对应起来。</p>
</li>
<li><p>在config_db机制中，分为set和get两步操作。所谓set操作，可以简单地理解成是”寄信“，而set则相当于是”收信“。</p>
</li>
<li><p><strong>在top_tb中执行set操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initial begin</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top&quot;, &quot;vif&quot;, input_if);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在my_driver中，执行get操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtual function void build_phase(uvm_phase phase);</span><br><span class="line">   super.build_phase(phase);</span><br><span class="line">   `uvm_info(&quot;my_driver&quot;, &quot;build_phase is called&quot;, UVM_LOW);</span><br><span class="line">   if(!uvm_config_db#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span><br><span class="line">      `uvm_fatal(&quot;my_driver&quot;, &quot;virtual interface must be set for vif!!!&quot;)</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里引入了<strong>build_phase</strong>。与main_phase一样，build_phase也是UVM中内建的一个phase。<strong>当UVM启动后，会自动执行build_phase，build_phase在new函数之后main_phase之前执行</strong>。</p>
<ul>
<li>这里需要加入<strong>super.build_phase</strong>语句，因为在其父类的build_phase中执行了一些必要的操作，这里必须显式地调用并执行它</li>
<li>build_phase与main_phase不同的一点在于，<strong>build_phase是一个函数phase，而main_phase是一个任务phase，build_phase是不消耗仿真时间的，build_phase总是在仿真时间为0时执行。</strong></li>
<li>在build_phase中出现了<strong>uvm_fatal宏</strong>，uvm_fatal宏是一个类似于uvm_info的宏，但是它只有两个参数，这两个参数于uvm_info宏的前两个参数的意义完全一样。<strong>当uvm_fatal打印出第二个参数之后，会直接调用verilog的finish函数来结束仿真，其意味着验证平台出现了重大问题而无法继续下去</strong>，必须停止仿真并做相应的检查。</li>
<li>config_db的set和get函数都有四个参数，<strong>这两个函数的第三个参数必须完全一致</strong><ul>
<li>set函数：<ul>
<li>第一个参数：当使用 <code>null</code> 作为这个参数时，它意味着设置的配置项是全局可用的。</li>
<li>第二个参数：表示路径索引，<strong>UVM通过run_test创建了一个my_driver的实例，其实例名即为uvm_test_top</strong></li>
<li>第三个参数：<strong>指定配置项的名称，为一个与get第三个参数连接的虚拟接口</strong></li>
<li>第四个参数：<strong>表示要将哪个interface通过config_db传递给my_driver</strong>（即把input_if接口给”vif”这个虚拟接口）</li>
</ul>
</li>
<li>get函数：<ul>
<li>第一个参数：<code>this</code>。这是调用<code>get</code>方法的组件的句柄。它定义了查询配置数据库的上下文。通常，它指的是希望获取配置信息的组件的实例。</li>
<li>第二个参数：<code>&quot;&quot;</code>。这是一个字符串，定义了配置信息的作用域。空字符串表示全局作用域，即搜索整个UVM环境以找到匹配的配置项。如果这里指定了一个特定的层级路径，那么<code>uvm_config_db</code>将只在指定的层级内搜索配置信息。</li>
<li>第三个参数：<strong>指定了要获取的配置项的名称，虚拟接口罢了</strong></li>
<li>第四个参数：<strong>表示把得到的interface传递给哪个my_driver的成员变量</strong>（即从”vif”这个虚拟接口收到的接口传递给vif这个成员变量）</li>
</ul>
</li>
</ul>
</li>
<li><strong>set和get函数前面使用双冒号的原因是这两个函数都是静态函数</strong></li>
<li><code>uvm_config_db#(virtual my_if)</code>则是一个参数化的类，其参数就是要寄信的类型，这里是<code>virtual my_if</code>，假设要传递一个int类型的数据，那么久写为<code>uvm_config_db#(int)</code></li>
</ul>
</li>
<li><p>最终，加入上述所述机制的代码如下：</p>
<ul>
<li><p>my_driver.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_DRIVER__SV</span><br><span class="line">`define MY_DRIVER__SV</span><br><span class="line"></span><br><span class="line">   class my_driver extends uvm_driver;</span><br><span class="line">      virtual my_if vif;</span><br><span class="line"></span><br><span class="line">      `uvm_component_utils(my_driver)</span><br><span class="line">      function new(string name = &quot;my_driver&quot;, uvm_component parent = null);</span><br><span class="line">         super.new(name, parent);</span><br><span class="line">         `uvm_info(&quot;my_driver&quot;, &quot;new is called&quot;, UVM_LOW);</span><br><span class="line">      endfunction</span><br><span class="line"></span><br><span class="line">      virtual function void build_phase(uvm_phase phase);</span><br><span class="line">         super.build_phase(phase);</span><br><span class="line">         `uvm_info(&quot;my_driver&quot;, &quot;build_phase is called&quot;, UVM_LOW);</span><br><span class="line">         if(!uvm_config_db#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span><br><span class="line">            `uvm_fatal(&quot;my_driver&quot;, &quot;virtual interface must be set for vif!!!&quot;)</span><br><span class="line">      endfunction</span><br><span class="line"></span><br><span class="line">      extern virtual task main_phase(uvm_phase phase);</span><br><span class="line">   endclass</span><br><span class="line"></span><br><span class="line">   task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">      phase.raise_objection(this);</span><br><span class="line"></span><br><span class="line">      `uvm_info(&quot;my_driver&quot;, &quot;main_phase is called&quot;, UVM_LOW);</span><br><span class="line"></span><br><span class="line">      vif.data &lt;= 8&#x27;b0; </span><br><span class="line">      vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">      while(!vif.rst_n)</span><br><span class="line">         @(posedge vif.clk);</span><br><span class="line">      for(int i = 0; i &lt; 256; i++)begin</span><br><span class="line">         @(posedge vif.clk);</span><br><span class="line">         vif.data &lt;= $urandom_range(0, 255);</span><br><span class="line">         vif.valid &lt;= 1&#x27;b1;</span><br><span class="line">         `uvm_info(&quot;my_driver&quot;, &quot;data is drived&quot;, UVM_LOW);</span><br><span class="line">      end</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">      </span><br><span class="line">      phase.drop_objection(this);</span><br><span class="line">   endtask</span><br><span class="line"></span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>my_if.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_IF__SV</span><br><span class="line">`define MY_IF__SV</span><br><span class="line"></span><br><span class="line">   interface my_if(input clk, input rst_n);</span><br><span class="line"></span><br><span class="line">      logic [7:0] data;</span><br><span class="line">      logic valid;</span><br><span class="line">   endinterface</span><br><span class="line"></span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>top_tb.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`timescale 1ns/1ps</span><br><span class="line">`include &quot;uvm_macros.svh&quot;</span><br><span class="line"></span><br><span class="line">import uvm_pkg::*;</span><br><span class="line">`include &quot;my_if.sv&quot;</span><br><span class="line">`include &quot;my_driver.sv&quot;</span><br><span class="line"></span><br><span class="line">module top_tb;</span><br><span class="line"></span><br><span class="line">   reg clk;</span><br><span class="line">   reg rst_n;</span><br><span class="line">   reg[7:0] rxd;</span><br><span class="line">   reg rx_dv;</span><br><span class="line">   wire[7:0] txd;</span><br><span class="line">   wire tx_en;</span><br><span class="line"></span><br><span class="line">   my_if input_if(clk, rst_n);</span><br><span class="line">   my_if output_if(clk, rst_n);</span><br><span class="line"></span><br><span class="line">   dut my_dut(.clk(input_if.clk),</span><br><span class="line">            .rst_n(input_if.rst_n),</span><br><span class="line">            .rxd(input_if.data),</span><br><span class="line">            .rx_dv(input_if.valid),</span><br><span class="line">            .txd(output_if.data),</span><br><span class="line">            .tx_en(output_if.valid));</span><br><span class="line"></span><br><span class="line">   initial begin</span><br><span class="line">      clk = 0;</span><br><span class="line">      forever begin</span><br><span class="line">         #100 clk = ~clk;</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   initial begin</span><br><span class="line">      rst_n = 1&#x27;b0;</span><br><span class="line">      #1000;</span><br><span class="line">      rst_n = 1&#x27;b1;</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   initial begin</span><br><span class="line">      run_test(&quot;my_driver&quot;);</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   initial begin</span><br><span class="line">      uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top&quot;, &quot;vif&quot;, input_if);</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
</li>
<li><p>仿真结果如下：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240429005146960.png" alt="image-20240429005146960"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240429005224640.png" alt="image-20240429005224640"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="为验证平台加入各个组件"><a href="#为验证平台加入各个组件" class="headerlink" title="为验证平台加入各个组件"></a>为验证平台加入各个组件</h1><h2 id="1-加入transaction"><a href="#1-加入transaction" class="headerlink" title="1.加入transaction"></a>1.加入transaction</h2><ul>
<li><p>在UVM的各个组件之间，信息的传递时基于transaction的。一般来说，物理协议中的数据交换都是以帧或者包为单位的，通常在一帧或者一个包中要定义好各项参数，每个包的大小不一样。很少会有协议是以bit或者byte为单位来进行数据交换的，以以太网为例，每个包的大小至少是64byte，这个包中要包含源地址、目的地址、包的类型、整个包的CRC校验数据等<strong>。transaction就是用于模拟这种实际情况，一笔transaction就是一个包</strong>。</p>
</li>
<li><p>一个简单的transaction的定义如下：(my_transaction.sv)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_TRANSACTION__SV</span><br><span class="line">`define MY_TRANSACTION__SV</span><br><span class="line"></span><br><span class="line">   class my_transaction extends uvm_sequence_item;</span><br><span class="line"></span><br><span class="line">      rand bit[47:0] dmac;</span><br><span class="line">      rand bit[47:0] smac;</span><br><span class="line">      rand bit[15:0] ether_type;</span><br><span class="line">      rand byte      pload[];</span><br><span class="line">      rand bit[31:0] crc;</span><br><span class="line"></span><br><span class="line">      constraint pload_cons&#123;</span><br><span class="line">         pload.size &gt;= 46;</span><br><span class="line">         pload.size &lt;= 1500;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      function bit[31:0] calc_crc();</span><br><span class="line">         return 32&#x27;h0;</span><br><span class="line">      endfunction</span><br><span class="line"></span><br><span class="line">      function void post_randomize();</span><br><span class="line">         crc = calc_crc;</span><br><span class="line">      endfunction</span><br><span class="line"></span><br><span class="line">      `uvm_object_utils(my_transaction)</span><br><span class="line"></span><br><span class="line">      function new(string name = &quot;my_transaction&quot;);</span><br><span class="line">         super.new();</span><br><span class="line">      endfunction</span><br><span class="line">   endclass</span><br><span class="line">   </span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<ul>
<li>其中dmac是48bit的以太网目的地址，smac是48bit的以太网源地址，ether_type是以太网类型，pload是其携带数据的大小（通过pload_cons约束可以看到，其大小被限制在46~1500byte），CRC是前面所有数据的校验值（这里只是在post_randomize中加了一个空函数calc_crc，post_randomize是SV中提供的一个函数，当某个类的实例的randomize函数被调用后，post_randomize会紧随其后无条件地被调用）</li>
<li><strong>my_transaction的基类是uvm_sequence_item</strong>，在UVM中，所有的transaction都是从uvm_sequence_item派生，只有从uvm_sequence_item派生的transaction才可以使用后文讲述的UVM中强大的sequence机制</li>
<li>从本质上来说，my_transaction与my_driver是有区别的，在整个仿真期间，my_driver是一直存在的，my_transaction不同，它有生命周期，它在仿真的某一个时间产生，经过driver驱动，再经过reference model处理，最终由scoreboard比较完成后，其生命周期就结束了</li>
<li>一般来说，这种类都是派生自uvm_objection或者uvm_objection的派生类，<strong>uvm_objection_item的祖先就是uvm_objection</strong>。<strong>UVM中具有这种特征的类都要使用uvm_objection_utils宏来实现。</strong></li>
</ul>
</li>
<li><p>当完成transaction的定义后，就可以在my_driver中实现基于transaction的驱动：（my_driver.sv)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_DRIVER__SV</span><br><span class="line">`define MY_DRIVER__SV</span><br><span class="line"></span><br><span class="line">   class my_driver extends uvm_driver;</span><br><span class="line"></span><br><span class="line">      virtual my_if vif;</span><br><span class="line"></span><br><span class="line">      `uvm_component_utils(my_driver)</span><br><span class="line">      function new(string name = &quot;my_driver&quot;, uvm_component parent = null);</span><br><span class="line">         super.new(name, parent);</span><br><span class="line">      endfunction</span><br><span class="line"></span><br><span class="line">      virtual function void build_phase(uvm_phase phase);</span><br><span class="line">         super.build_phase(phase);</span><br><span class="line">         if(!uvm_config_db#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span><br><span class="line">            `uvm_fatal(&quot;my_driver&quot;, &quot;virtual interface must be set for vif!!!&quot;)</span><br><span class="line">      endfunction</span><br><span class="line"></span><br><span class="line">      extern task main_phase(uvm_phase phase);</span><br><span class="line">      extern task drive_one_pkt(my_transaction tr);</span><br><span class="line">   endclass</span><br><span class="line"></span><br><span class="line">   task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">      my_transaction tr;</span><br><span class="line">      phase.raise_objection(this);</span><br><span class="line">      vif.data &lt;= 8&#x27;b0;</span><br><span class="line">      vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">      while(!vif.rst_n)</span><br><span class="line">         @(posedge vif.clk);</span><br><span class="line">      for(int i = 0; i &lt; 2; i++) begin </span><br><span class="line">         tr = new(&quot;tr&quot;);</span><br><span class="line">         assert(tr.randomize() with &#123;pload.size == 200;&#125;);</span><br><span class="line">         drive_one_pkt(tr);</span><br><span class="line">      end</span><br><span class="line">      repeat(5) @(posedge vif.clk);</span><br><span class="line">      phase.drop_objection(this);</span><br><span class="line">   endtask</span><br><span class="line"></span><br><span class="line">   task my_driver::drive_one_pkt(my_transaction tr);</span><br><span class="line">      bit [47:0] tmp_data;</span><br><span class="line">      bit [7:0] data_q[$]; </span><br><span class="line">   </span><br><span class="line">      //push dmac to data_q</span><br><span class="line">      tmp_data = tr.dmac;</span><br><span class="line">      for(int i = 0; i &lt; 6; i++) begin</span><br><span class="line">         data_q.push_back(tmp_data[7:0]);</span><br><span class="line">         tmp_data = (tmp_data &gt;&gt; 8);</span><br><span class="line">      end</span><br><span class="line">      //push smac to data_q</span><br><span class="line">      tmp_data = tr.smac;</span><br><span class="line">      for(int i = 0; i &lt; 6; i++) begin</span><br><span class="line">         data_q.push_back(tmp_data[7:0]);</span><br><span class="line">         tmp_data = (tmp_data &gt;&gt; 8);</span><br><span class="line">      end</span><br><span class="line">      //push ether_type to data_q</span><br><span class="line">      tmp_data = tr.ether_type;</span><br><span class="line">      for(int i = 0; i &lt; 2; i++) begin</span><br><span class="line">         data_q.push_back(tmp_data[7:0]);</span><br><span class="line">         tmp_data = (tmp_data &gt;&gt; 8);</span><br><span class="line">      end</span><br><span class="line">      //push payload to data_q</span><br><span class="line">      for(int i = 0; i &lt; tr.pload.size; i++) begin</span><br><span class="line">         data_q.push_back(tr.pload[i]);</span><br><span class="line">      end</span><br><span class="line">      //push crc to data_q</span><br><span class="line">      tmp_data = tr.crc;</span><br><span class="line">      for(int i = 0; i &lt; 4; i++) begin</span><br><span class="line">         data_q.push_back(tmp_data[7:0]);</span><br><span class="line">         tmp_data = (tmp_data &gt;&gt; 8);</span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">      `uvm_info(&quot;my_driver&quot;, &quot;begin to drive one pkt&quot;, UVM_LOW);</span><br><span class="line">      repeat(3) @(posedge vif.clk);</span><br><span class="line"></span><br><span class="line">      while(data_q.size() &gt; 0) begin</span><br><span class="line">         @(posedge vif.clk);</span><br><span class="line">         vif.valid &lt;= 1&#x27;b1;</span><br><span class="line">         vif.data &lt;= data_q.pop_front(); </span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">      `uvm_info(&quot;my_driver&quot;, &quot;end drive one pkt&quot;, UVM_LOW);</span><br><span class="line">   endtask</span><br><span class="line"></span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>在main_phase中，先使用randomize将tr随机化，之后通过drive_one_pkt任务将tr的内容驱动到DUT端口上</strong></p>
</li>
<li><p>这里定义了一个48位的临时变量<code>tmp_data</code>和一个<strong>动态大小的队列</strong>（使用<code>$</code>）<code>data_q</code>，用于存储8位宽的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit [47:0] tmp_data;</span><br><span class="line">bit [7:0] data_q[$]; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取随机的目的地址：这部分代码从传入的事务<code>tr</code>中取出目的MAC地址，将其每8位截取并放入<code>data_q</code>。此循环执行6次，因为MAC地址总共有48位。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//push dmac to data_q</span><br><span class="line">tmp_data = tr.dmac;</span><br><span class="line">for(int i = 0; i &lt; 6; i++) begin</span><br><span class="line">   data_q.push_back(tmp_data[7:0]);</span><br><span class="line">   tmp_data = (tmp_data &gt;&gt; 8);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>开始传输数据</strong>：传输开始前，等待三个时钟周期，然后通过<code>vif</code>接口逐字节传输<code>data_q</code>中的数据。每个时钟上升沿，从队列前端弹出一个字节数据，直到队列为空。数据传输结束后，清除<code>valid</code>信号，表示数据包传输完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat(3) @(posedge vif.clk);</span><br><span class="line"></span><br><span class="line">while(data_q.size() &gt; 0) begin</span><br><span class="line">   @(posedge vif.clk);</span><br><span class="line">   vif.valid &lt;= 1&#x27;b1;</span><br><span class="line">   vif.data &lt;= data_q.pop_front(); </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">@(posedge vif.clk);</span><br><span class="line">vif.valid &lt;= 1&#x27;b0;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其实是通过push操作，先存下通过transaction生成的一个以太网格式的数据包，然后再发送</strong></p>
</li>
</ul>
</li>
<li><p>最终仿真结果如下：（以太网数据包总共发送了两次）</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240429151021108.png" alt="image-20240429151021108"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240429151013179.png" alt="image-20240429151013179"></p>
</li>
</ul>
<h2 id="2-加入env"><a href="#2-加入env" class="headerlink" title="2.加入env"></a>2.加入env</h2><ul>
<li><p>在验证平台中加入reference model、scoreboard等之前，思考一个问题：假设这些组件已经定义好了，那么在验证平台的什么位置对它们进行实例化呢？</p>
</li>
<li><p>这个问题的解决方案是引入一个容器类，在这个容器类中实例化driver、monitor、reference model和scoreboard等。<strong>在调用run_test时，传递的参数不再是my_driver，而是这个容器类，即让UVM自动创建这个容器类的实例</strong>（my_env.sv）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_ENV__SV</span><br><span class="line">`define MY_ENV__SV</span><br><span class="line"></span><br><span class="line">   class my_env extends uvm_env;</span><br><span class="line"></span><br><span class="line">      my_driver drv;</span><br><span class="line"></span><br><span class="line">      function new(string name = &quot;my_env&quot;, uvm_component parent);</span><br><span class="line">         super.new(name, parent);</span><br><span class="line">      endfunction</span><br><span class="line"></span><br><span class="line">      virtual function void build_phase(uvm_phase phase);</span><br><span class="line">         super.build_phase(phase);</span><br><span class="line">         drv = my_driver::type_id::create(&quot;drv&quot;, this); </span><br><span class="line">      endfunction</span><br><span class="line"></span><br><span class="line">      `uvm_component_utils(my_env)</span><br><span class="line">   endclass</span><br><span class="line">   </span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有的env应该派生自uvm_env，且与my_driver一样，容器类在仿真中也是一直存在的，<strong>使用uvm_component_utils宏来实现factory的注册</strong></p>
</li>
<li><p><strong>验证平台中的组件在实例化时都应该使用<code>type_name::type_id::create</code>的方式</strong></p>
</li>
<li><p><strong>在drv实例化时，传递了两个参数，一个名字drv，另一个是this指针</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drv = my_driver::type_id::create(&quot;drv&quot;, this); </span><br></pre></td></tr></table></figure>
</li>
<li><p>回顾一下my_driver的new函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function new(string name = &quot;my_driver&quot;, uvm_component parent = null);</span><br><span class="line">   super.new(name, parent);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这个new函数有两个参数，<strong>第一个参数是实例的名字，第二个则是parent</strong>。由于my_driver在uvm_env中实例化，所以my_driver的父节点（parent）就是my_env，通过parent的形式，UVM建立起了树形的组织结构。</p>
</li>
<li><p>在这种树形的组织结构中，由run_test创建的实例是数根（这里是my_env），并且树根的名字是固定的，为uvm_test_top，<strong>在树根之后会生长出枝叶（这里只有my_driver），长出枝叶的过程需要在my_env的build_phase中手动实现</strong>。无论是树根还是树叶，都必须由uvm_component或者其派生类继承而来。</p>
</li>
<li><p>当加入了my_env后，整个验证平台中存在两个build_phase，一个是my_env的，一个是my_driver的，其执行顺序：</p>
<ul>
<li>在UVM的树形结构中，build_phase的执行遵照<strong>从树根到树叶</strong>的顺序，即<strong>先执行my_env的build_phase，再执行my_driver的build_phase</strong>。当把整棵树的build_phase都执行完毕后，再执行后面的phase。</li>
</ul>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240429213951777.png" alt="image-20240429213951777" style="zoom:33%;"></p>
</li>
</ul>
</li>
<li><p><strong>my_driver在验证平台中的层次结构发生了变化，所以在top_tb中使用config_db机制传递virtual my_if时，要改变相应的路径；同时，run_test的参数也要从my_driver变为my_env</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initial begin</span><br><span class="line">   run_test(&quot;my_env&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top.drv&quot;, &quot;vif&quot;, input_if);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>set函数的第二个参数从uvm_test_top变为了uvm_test_top.drv，其中uvm_test_top是UVM自动创建的树根的名字，而drv则是在my_env的build_phase中实例化drv（new创建时）时传递过去的名字</strong>。如果在实例化drv时传递的名字时my_drv，那么set函数的第二个参数中也应该是my_drv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class my_env extends uvm_env;</span><br><span class="line">...</span><br><span class="line">   virtual function void build_phase(uvm_phase phase);</span><br><span class="line">      super.build_phase(phase);</span><br><span class="line">       drv = my_driver::type_id::create(&quot;my_drv&quot;, this); </span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_env)</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">module top_tb;</span><br><span class="line">...</span><br><span class="line">   initial begin</span><br><span class="line">      uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top.my_drv&quot;, &quot;vif&quot;, input_if);</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发现UVM不管创建的类对象赋值给了哪个变量，但其实传递的时候都是用实例的名字（new的第一个参数字符串），与赋值给的等式左边的那个变量名字无关</strong></p>
</li>
<li><p>仿真结果如下：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240429220500560.png" alt="image-20240429220500560"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240429220520164.png" alt="image-20240429220520164"></p>
</li>
</ul>
<h2 id="3-加入monitor"><a href="#3-加入monitor" class="headerlink" title="3.加入monitor"></a>3.加入monitor</h2><ul>
<li><p>验证平台必须检测DUT的行为，只有知道DUT的输入输出信号变化之后，才能根据这些信号变化来判断DUT的行为是否正确</p>
</li>
<li><p><strong>验证平台中实现监测DUT行为的组件是monitor</strong></p>
</li>
<li><p>driver负责把transaction级别的数据转变成DUT的端口级别，并驱动给DUT，<strong>monitor的行为与其相对，用于收集DUT的端口数据，并将其转化成transaction交给后续的组件如reference model、scoreboard等处理</strong></p>
</li>
<li><p>一个monitor的定义如下：（my_monitor.sv）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_MONITOR__SV</span><br><span class="line">`define MY_MONITOR__SV</span><br><span class="line">class my_monitor extends uvm_monitor;</span><br><span class="line"></span><br><span class="line">   virtual my_if vif;</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_monitor)</span><br><span class="line">   function new(string name = &quot;my_monitor&quot;, uvm_component parent = null);</span><br><span class="line">      super.new(name, parent);</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   virtual function void build_phase(uvm_phase phase);</span><br><span class="line">      super.build_phase(phase);</span><br><span class="line">      if(!uvm_config_db#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span><br><span class="line">         `uvm_fatal(&quot;my_monitor&quot;, &quot;virtual interface must be set for vif!!!&quot;)</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   extern task main_phase(uvm_phase phase);</span><br><span class="line">   extern task collect_one_pkt(my_transaction tr);</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">task my_monitor::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   while(1) begin</span><br><span class="line">      tr = new(&quot;tr&quot;);</span><br><span class="line">      collect_one_pkt(tr);</span><br><span class="line">   end</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">task my_monitor::collect_one_pkt(my_transaction tr);</span><br><span class="line">   bit[7:0] data_q[$]; </span><br><span class="line">   int psize;</span><br><span class="line">   while(1) begin</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      if(vif.valid) break;</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   `uvm_info(&quot;my_monitor&quot;, &quot;begin to collect one pkt&quot;, UVM_LOW);</span><br><span class="line">   while(vif.valid) begin</span><br><span class="line">      data_q.push_back(vif.data);</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   end</span><br><span class="line">   //pop dmac</span><br><span class="line">   for(int i = 0; i &lt; 6; i++) begin</span><br><span class="line">      tr.dmac = &#123;tr.dmac[39:0], data_q.pop_front()&#125;;</span><br><span class="line">   end</span><br><span class="line">   //pop smac</span><br><span class="line">   for(int i = 0; i &lt; 6; i++) begin</span><br><span class="line">      tr.smac = &#123;tr.smac[39:0], data_q.pop_front()&#125;;</span><br><span class="line">   end</span><br><span class="line">   //pop ether_type</span><br><span class="line">   for(int i = 0; i &lt; 2; i++) begin</span><br><span class="line">      tr.ether_type = &#123;tr.ether_type[7:0], data_q.pop_front()&#125;;</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   psize = data_q.size() - 4;</span><br><span class="line">   tr.pload = new[psize];</span><br><span class="line">   //pop payload</span><br><span class="line">   for(int i = 0; i &lt; psize; i++) begin</span><br><span class="line">      tr.pload[i] = data_q.pop_front();</span><br><span class="line">   end</span><br><span class="line">   //pop crc</span><br><span class="line">   for(int i = 0; i &lt; 4; i++) begin</span><br><span class="line">      tr.crc = &#123;tr.crc[23:0], data_q.pop_front()&#125;;</span><br><span class="line">   end</span><br><span class="line">   `uvm_info(&quot;my_monitor&quot;, &quot;end collect one pkt, print it:&quot;, UVM_LOW);</span><br><span class="line">    tr.my_print();</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>所有的monitor类应该派生自uvm_monitor</strong></p>
</li>
<li><p>与driver类似，在my_monitor中也需要有一个virtual my_if</p>
</li>
<li><p><strong>uvm_monitor在整个仿真中是一直存在的，所以它是一个component，要使用uvm_component_utils宏注册</strong></p>
</li>
<li><p><strong>由于monitor需要时刻收集数据，永不停歇，所以在main_phase中使用while(1)循环来实现这一目的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_monitor::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   while(1) begin</span><br><span class="line">      tr = new(&quot;tr&quot;);</span><br><span class="line">      collect_one_pkt(tr);</span><br><span class="line">   end</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
</li>
<li><p>当收集完一个transaction后，通过my_print函数将其打印出来，my_print在my_transaction中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function void my_print();</span><br><span class="line">   $display(&quot;dmac = %0h&quot;, dmac);</span><br><span class="line">   $display(&quot;smac = %0h&quot;, smac);</span><br><span class="line">   $display(&quot;ether_type = %0h&quot;, ether_type);</span><br><span class="line">   for(int i = 0; i &lt; pload.size; i++) begin</span><br><span class="line">      $display(&quot;pload[%0d] = %0h&quot;, i, pload[i]);</span><br><span class="line">   end</span><br><span class="line">   $display(&quot;crc = %0h&quot;, crc);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
</li>
<li><p>当完成monitor的定义后，可以在env中对其进行实例化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtual function void build_phase(uvm_phase phase);</span><br><span class="line">   super.build_phase(phase);</span><br><span class="line">   drv = my_driver::type_id::create(&quot;drv&quot;, this); </span><br><span class="line">   i_mon = my_monitor::type_id::create(&quot;i_mon&quot;, this);</span><br><span class="line">   o_mon = my_monitor::type_id::create(&quot;o_mon&quot;, this);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<ul>
<li>实例了两个monitor，一个用来监测DUT的输入口，一个用来监测DUT的输出口（书中作者推荐）</li>
</ul>
</li>
</ul>
</li>
<li><p>现在，整棵UVM数的结构如下：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430014221095.png" alt="image-20240430014221095" style="zoom: 67%;"></p>
</li>
<li><p>仿真结果如下：（仿真打印数据太多就不粘贴了，有发收发收共四次打印的结果）</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430012131785.png" alt="image-20240430012131785"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430012241270.png" alt="image-20240430012241270"></p>
</li>
</ul>
<h2 id="4-封装成agent"><a href="#4-封装成agent" class="headerlink" title="4.封装成agent"></a>4.封装成agent</h2><ul>
<li><p><strong>UVM中通常将driver和monitor二者封装在一起，成为一个agent</strong></p>
</li>
<li><p><strong>所有的agent都要派生自uvm_agent类</strong>，且其<strong>本身是一个component</strong>，应该使用uvm_component_utils宏来来实现factory注册</p>
</li>
<li><p>my_agent.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_AGENT__SV</span><br><span class="line">`define MY_AGENT__SV</span><br><span class="line"></span><br><span class="line">class my_agent extends uvm_agent ;</span><br><span class="line">   my_driver     drv;</span><br><span class="line">   my_monitor    mon;</span><br><span class="line">   </span><br><span class="line">   function new(string name, uvm_component parent);</span><br><span class="line">      super.new(name, parent);</span><br><span class="line">   endfunction </span><br><span class="line">   </span><br><span class="line">   extern virtual function void build_phase(uvm_phase phase);</span><br><span class="line">   extern virtual function void connect_phase(uvm_phase phase);</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_agent)</span><br><span class="line">endclass </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function void my_agent::build_phase(uvm_phase phase);</span><br><span class="line">   super.build_phase(phase);</span><br><span class="line">   if (is_active == UVM_ACTIVE) begin</span><br><span class="line">       drv = my_driver::type_id::create(&quot;drv&quot;, this);</span><br><span class="line">   end</span><br><span class="line">   mon = my_monitor::type_id::create(&quot;mon&quot;, this);</span><br><span class="line">endfunction </span><br><span class="line"></span><br><span class="line">function void my_agent::connect_phase(uvm_phase phase);</span><br><span class="line">   super.connect_phase(phase);</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>在uvm_agent中，is_active的值默认为UVM_ACTIVE，在这种模式下，是需要实例化driver的（貌似也会自动实例化一个monitor），is_active=UVM_PASSIVE时只需要实例化monitor</strong></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430134044322.png" alt="image-20240430134044322" style="zoom:67%;"></p>
</li>
</ul>
</li>
<li><p><strong>在完成i_agt和o_agt的声明后，在my_env的build_phase中对它们进行实例化后，需要指定各自的工作模式是active模式还是passive模式</strong>（my_env.sv）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_ENV__SV</span><br><span class="line">`define MY_ENV__SV</span><br><span class="line"></span><br><span class="line">class my_env extends uvm_env;</span><br><span class="line"></span><br><span class="line">   my_agent  i_agt;</span><br><span class="line">   my_agent  o_agt;</span><br><span class="line">   </span><br><span class="line">   function new(string name = &quot;my_env&quot;, uvm_component parent);</span><br><span class="line">      super.new(name, parent);</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   virtual function void build_phase(uvm_phase phase);</span><br><span class="line">      super.build_phase(phase);</span><br><span class="line">      i_agt = my_agent::type_id::create(&quot;i_agt&quot;, this);</span><br><span class="line">      o_agt = my_agent::type_id::create(&quot;o_agt&quot;, this);</span><br><span class="line">      i_agt.is_active = UVM_ACTIVE;</span><br><span class="line">      o_agt.is_active = UVM_PASSIVE;</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_env)</span><br><span class="line">endclass</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，整课UVM树变为：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430134946557.png" alt="image-20240430134946557" style="zoom: 67%;"></p>
<ul>
<li><strong>只有uvm_component才能作为树的结点</strong>，像my_transaction这种使用uvm_object_utils宏实现的类是不能作为UVM树的结点的</li>
<li><strong>UVM要求UVM树最晚在build_phase时段完成</strong>，一般都在build_phase中完成实例化</li>
</ul>
</li>
<li><p>由于agent的加入，driver和monitor的层次结构改变了，在top_tb中使用config_db设置virtual my_if时要注意改变路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initial begin</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top.i_agt.drv&quot;, &quot;vif&quot;, input_if);</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top.i_agt.mon&quot;, &quot;vif&quot;, input_if);</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top.o_agt.mon&quot;, &quot;vif&quot;, output_if);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>仿真结果如下：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430144920312.png" alt="image-20240430144920312"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430144943654.png" alt="image-20240430144943654"></p>
</li>
</ul>
<h2 id="5-加入reference-model"><a href="#5-加入reference-model" class="headerlink" title="5.加入reference model"></a>5.加入reference model</h2><ul>
<li><p><strong>reference model的输出被scoreboard接收，用于和DUT的输出相比较</strong>。DUT如果很复杂，那么reference model也会相当复杂。本章的DUT很简单，所以reference model也很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_MODEL__SV</span><br><span class="line">`define MY_MODEL__SV</span><br><span class="line"></span><br><span class="line">class my_model extends uvm_component;</span><br><span class="line">   </span><br><span class="line">   uvm_blocking_get_port #(my_transaction)  port;</span><br><span class="line">   uvm_analysis_port #(my_transaction)  ap;</span><br><span class="line"></span><br><span class="line">   extern function new(string name, uvm_component parent);</span><br><span class="line">   extern function void build_phase(uvm_phase phase);</span><br><span class="line">   extern virtual  task main_phase(uvm_phase phase);</span><br><span class="line"></span><br><span class="line">   `uvm_component_utils(my_model)</span><br><span class="line">endclass </span><br><span class="line"></span><br><span class="line">function my_model::new(string name, uvm_component parent);</span><br><span class="line">   super.new(name, parent);</span><br><span class="line">endfunction </span><br><span class="line"></span><br><span class="line">function void my_model::build_phase(uvm_phase phase);</span><br><span class="line">   super.build_phase(phase);</span><br><span class="line">   port = new(&quot;port&quot;, this);</span><br><span class="line">   ap = new(&quot;ap&quot;, this);</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">task my_model::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   my_transaction new_tr;</span><br><span class="line">   super.main_phase(phase);</span><br><span class="line">   while(1) begin</span><br><span class="line">      port.get(tr);</span><br><span class="line">      new_tr = new(&quot;new_tr&quot;);</span><br><span class="line">      new_tr.my_copy(tr);</span><br><span class="line">      `uvm_info(&quot;my_model&quot;, &quot;get one transaction, copy and print it:&quot;, UVM_LOW)</span><br><span class="line">      new_tr.my_print();</span><br><span class="line">      ap.write(new_tr);</span><br><span class="line">   end</span><br><span class="line">endtask</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在my_model的main_phase中，只是单纯地复制一份从i_agt得到的tr，并传递给后级的scoreboard中</p>
</li>
<li><p>my_copy是一个在my_transaction中定义的函数（my_transaction.sv）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function void my_copy(my_transaction tr);</span><br><span class="line">   if(tr == null)</span><br><span class="line">      `uvm_fatal(&quot;my_transaction&quot;, &quot;tr is null!!!!&quot;)</span><br><span class="line">   dmac = tr.dmac;</span><br><span class="line">   smac = tr.smac;</span><br><span class="line">   ether_type = tr.ether_type;</span><br><span class="line">   pload = new[tr.pload.size()];</span><br><span class="line">   for(int i = 0; i &lt; pload.size(); i++) begin</span><br><span class="line">      pload[i] = tr.pload[i];</span><br><span class="line">   end</span><br><span class="line">   crc = tr.crc;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>加入my_model后，整棵UVM树变成了：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430152130099.png" alt="image-20240430152130099" style="zoom: 67%;"></p>
</li>
<li><p><strong>my_model是从i_agt中得到my_transaction，并把my_transaction传递给my_scoreboard</strong></p>
</li>
<li><p>在UVM中，通常使用TLM（Transaction Level Modeling）实现component之间的transaction级别通信</p>
</li>
<li><p>在UVM的transaction级别的通信中，<strong>数据的发送</strong>有多种方式，其中一种是使用<strong>uvm_analysis_port</strong>，<strong>需要在my_monitor.sv中声明及实例化，并写入</strong>：</p>
<ul>
<li><p><strong>在monitor中的声明：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uvm_analysis_port #(my_transaction)  ap;</span><br></pre></td></tr></table></figure>
<ul>
<li>uvm_analysis_port是一个参数化的类，其参数就是这个analysis_port需要传递的数据类型，在本节中是my_transaction</li>
</ul>
</li>
<li><p><strong>在monitor的build_phase中将其实例化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtual function void build_phase(uvm_phase phase);</span><br><span class="line">...</span><br><span class="line">   ap = new(&quot;ap&quot;, this);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在monitor的main_phase中，当收集完一个transaction后，需要将其写入ap中：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_monitor::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   while(1) begin</span><br><span class="line">      tr = new(&quot;tr&quot;);</span><br><span class="line">      collect_one_pkt(tr);</span><br><span class="line">      ap.write(tr);</span><br><span class="line">   end</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>write是uvm_analysis_port的一个内建函数</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>UVM的transaction级别通信的<strong>数据接收</strong>方式也有多种，其中一种就是使用<strong>uvm_blocking_get_port</strong>。这也是一个参数化的类，其参数是要在其中传递的transaction的类型。<strong>需要在my_model.sv中声明及实例化，并发送</strong>：</p>
<ul>
<li><p><strong>在model中声明：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uvm_blocking_get_port #(my_transaction)  port;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在model的build_phase中将其实例化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function void my_model::build_phase(uvm_phase phase);</span><br><span class="line">   super.build_phase(phase);</span><br><span class="line">   port = new(&quot;port&quot;, this);</span><br><span class="line">   ...</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在monitor的main_phase中，通过port.get任务来得到从i_agt的monitor中发出的transaction：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_model::main_phase(uvm_phase phase);</span><br><span class="line">   my_transaction tr;</span><br><span class="line">   my_transaction new_tr;</span><br><span class="line">   super.main_phase(phase);</span><br><span class="line">   while(1) begin</span><br><span class="line">      port.get(tr);</span><br><span class="line">      new_tr = new(&quot;new_tr&quot;);</span><br><span class="line">      new_tr.my_copy(tr);</span><br><span class="line">      `uvm_info(&quot;my_model&quot;, &quot;get one transaction, copy and print it:&quot;, UVM_LOW)</span><br><span class="line">      new_tr.my_print();</span><br><span class="line">      ap.write(new_tr);</span><br><span class="line">   end</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在my_monitor和my_model中定义并实现了各自的端口之后，通信的功能并没有实现，<strong>还需要在my_env中使用fifo将两个端口联系在一起</strong></p>
<ul>
<li><p><strong>在my_env中定义一个fifo，并在build_phase中将其实例化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uvm_tlm_analysis_fifo #(my_transaction) agt_mdl_fifo;</span><br><span class="line">...</span><br><span class="line">virtual function void build_phase(uvm_phase phase);</span><br><span class="line">...</span><br><span class="line">   agt_mdl_fifo = new(&quot;agt_mdl_fifo&quot;, this);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>之后，在connect_phase中将fifo分别与my_monitor中的analysis_port和my_model中的blocking_get_port相连：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function void my_env::connect_phase(uvm_phase phase);</span><br><span class="line">   super.connect_phase(phase);</span><br><span class="line">   i_agt.ap.connect(agt_mdl_fifo.analysis_export);</span><br><span class="line">   mdl.port.connect(agt_mdl_fifo.blocking_get_export);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<ul>
<li>这里引入了<strong>connect_phase</strong>，与build_phase及main_phase类似，<strong>connect_phase也是UVM内建的一个phase，它在build_phase执行完成之后马上执行</strong>。但是与build_phase不同的是，它的执行顺序并不是从树根到树叶，而是从树叶到树根：<strong>先执行driver和monitor的connect_phase，再执行agent的connect_phase，最后执行env的connect_phase</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>在如上的连接中，用到了i_agt的一个成员变量ap，</strong></p>
<ul>
<li><p>它的定义与my_monitor中ap的<strong>定义</strong>完全一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    uvm_analysis_port #(my_transaction)  ap;</span><br><span class="line">    </span><br><span class="line">  - 与my_monitor中的ap不同的是，**不需要对my_agent中的ap进行实例化，而只需要在my_agent的connect_phase中将monitor的值赋给它。换句话说，这相当于是一个指向my_monitor的ap的指针**</span><br><span class="line">  </span><br><span class="line">    ```systemverilog</span><br><span class="line">    function void my_agent::connect_phase(uvm_phase phase);</span><br><span class="line">       super.connect_phase(phase);</span><br><span class="line">       ap = mon.ap;</span><br><span class="line">    endfunction</span><br><span class="line">  </span><br><span class="line">- 仿真结果如下：</span><br><span class="line"></span><br><span class="line">  ![image-20240430160945765](UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430160945765.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240430161005072](UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430161005072.png)</span><br><span class="line"></span><br><span class="line">## 6.加入scoreboard</span><br><span class="line"></span><br><span class="line">- 在验证平台中加入reference model和monitor之后，最后一步是加入scoreboard，其代码如下：（my.scoreboard.sv）</span><br><span class="line"></span><br><span class="line">  ```systemverilog</span><br><span class="line">  `ifndef MY_SCOREBOARD__SV</span><br><span class="line">  `define MY_SCOREBOARD__SV</span><br><span class="line">  class my_scoreboard extends uvm_scoreboard;</span><br><span class="line">     my_transaction  expect_queue[$];</span><br><span class="line">     uvm_blocking_get_port #(my_transaction)  exp_port;</span><br><span class="line">     uvm_blocking_get_port #(my_transaction)  act_port;</span><br><span class="line">     `uvm_component_utils(my_scoreboard)</span><br><span class="line">  </span><br><span class="line">     extern function new(string name, uvm_component parent = null);</span><br><span class="line">     extern virtual function void build_phase(uvm_phase phase);</span><br><span class="line">     extern virtual task main_phase(uvm_phase phase);</span><br><span class="line">  endclass </span><br><span class="line">  </span><br><span class="line">  function my_scoreboard::new(string name, uvm_component parent = null);</span><br><span class="line">     super.new(name, parent);</span><br><span class="line">  endfunction </span><br><span class="line">  </span><br><span class="line">  function void my_scoreboard::build_phase(uvm_phase phase);</span><br><span class="line">     super.build_phase(phase);</span><br><span class="line">     exp_port = new(&quot;exp_port&quot;, this);</span><br><span class="line">     act_port = new(&quot;act_port&quot;, this);</span><br><span class="line">  endfunction </span><br><span class="line">  </span><br><span class="line">  task my_scoreboard::main_phase(uvm_phase phase);</span><br><span class="line">     my_transaction  get_expect,  get_actual, tmp_tran;</span><br><span class="line">     bit result;</span><br><span class="line">   </span><br><span class="line">     super.main_phase(phase);</span><br><span class="line">     fork </span><br><span class="line">        while (1) begin</span><br><span class="line">           exp_port.get(get_expect);</span><br><span class="line">           expect_queue.push_back(get_expect);</span><br><span class="line">        end</span><br><span class="line">        while (1) begin</span><br><span class="line">           act_port.get(get_actual);</span><br><span class="line">           if(expect_queue.size() &gt; 0) begin</span><br><span class="line">              tmp_tran = expect_queue.pop_front();</span><br><span class="line">              result = get_actual.my_compare(tmp_tran);</span><br><span class="line">              if(result) begin </span><br><span class="line">                 `uvm_info(&quot;my_scoreboard&quot;, &quot;Compare SUCCESSFULLY&quot;, UVM_LOW);</span><br><span class="line">              end</span><br><span class="line">              else begin</span><br><span class="line">                 `uvm_error(&quot;my_scoreboard&quot;, &quot;Compare FAILED&quot;);</span><br><span class="line">                 $display(&quot;the expect pkt is&quot;);</span><br><span class="line">                 tmp_tran.my_print();</span><br><span class="line">                 $display(&quot;the actual pkt is&quot;);</span><br><span class="line">                 get_actual.my_print();</span><br><span class="line">              end</span><br><span class="line">           end</span><br><span class="line">           else begin</span><br><span class="line">              `uvm_error(&quot;my_scoreboard&quot;, &quot;Received from DUT, while Expect Queue is empty&quot;);</span><br><span class="line">              $display(&quot;the unexpected pkt is&quot;);</span><br><span class="line">              get_actual.my_print();</span><br><span class="line">           end </span><br><span class="line">        end</span><br><span class="line">     join</span><br><span class="line">  endtask</span><br><span class="line">  `endif</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><strong>my_scoreboard要比较的数据一是来源于reference model，二是来源于o_agt的monitor，前者通过exp_port获取，后者通过act_port获取</strong></li>
<li>在main_phase中通过fork建立了两个进程：<ul>
<li>一个进程处理exp_port的数据，当收到数据后，把数据放入expect_queue中</li>
<li>另一个进程处理act_port的数据，这是DUT的输出数据</li>
<li>当收集到这些数据后，从expect_queue中弹出之前从exp_port收到的数据，并调用my_transaction的my_compare函数</li>
</ul>
</li>
<li>采用这种比较处理方式的前提是exp_port要比act_port先收到数据</li>
<li>由于DUT处理数据需要延时，而reference model是基于高级语言的处理，一般不需要延时，因此可以保证exp_port的数据在act_port的数据之前到来</li>
</ul>
</li>
<li><p>o_agt和act_port的ap的连接方式及reference model和exp_port的ap的连接方式与前一节类似（my_env.sv）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function void my_env::connect_phase(uvm_phase phase);</span><br><span class="line">   super.connect_phase(phase);</span><br><span class="line">   i_agt.ap.connect(agt_mdl_fifo.analysis_export);</span><br><span class="line">   mdl.port.connect(agt_mdl_fifo.blocking_get_export);</span><br><span class="line">   mdl.ap.connect(mdl_scb_fifo.analysis_export);</span><br><span class="line">   scb.exp_port.connect(mdl_scb_fifo.blocking_get_export);</span><br><span class="line">   o_agt.ap.connect(agt_scb_fifo.analysis_export);</span><br><span class="line">   scb.act_port.connect(agt_scb_fifo.blocking_get_export); </span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>i_agt中monitor的transaction送给reference model，reference model处理后的transaction送给scoreboard的exp_port，o_agt中monitor的transaction送给scoreboard的act_port，最后比较exp_port与act_port这两个端口。</strong></li>
</ul>
</li>
<li><p>完成my_scoreboard的定义后，也需要在my_env中将其实例化，此时，整棵UVM树为：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430164929758.png" alt="image-20240430164929758" style="zoom: 67%;"></p>
</li>
<li><p>仿真结果如下：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430165343036.png" alt="image-20240430165343036"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430165409392.png" alt="image-20240430165409392"></p>
</li>
</ul>
<h2 id="7-加入field-automation机制"><a href="#7-加入field-automation机制" class="headerlink" title="7.加入field_automation机制"></a>7.加入field_automation机制</h2><ul>
<li><p>通过field_automation可以实现自动调用一些函数，在my_transaction中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_TRANSACTION__SV</span><br><span class="line">`define MY_TRANSACTION__SV</span><br><span class="line"></span><br><span class="line">class my_transaction extends uvm_sequence_item;</span><br><span class="line"></span><br><span class="line">   rand bit[47:0] dmac;</span><br><span class="line">   rand bit[47:0] smac;</span><br><span class="line">   rand bit[15:0] ether_type;</span><br><span class="line">   rand byte      pload[];</span><br><span class="line">   rand bit[31:0] crc;</span><br><span class="line"></span><br><span class="line">   constraint pload_cons&#123;</span><br><span class="line">      pload.size &gt;= 46;</span><br><span class="line">      pload.size &lt;= 1500;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function bit[31:0] calc_crc();</span><br><span class="line">      return 32&#x27;h0;</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   function void post_randomize();</span><br><span class="line">      crc = calc_crc;</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   `uvm_object_utils_begin(my_transaction)</span><br><span class="line">      `uvm_field_int(dmac, UVM_ALL_ON)</span><br><span class="line">      `uvm_field_int(smac, UVM_ALL_ON)</span><br><span class="line">      `uvm_field_int(ether_type, UVM_ALL_ON)</span><br><span class="line">      `uvm_field_array_int(pload, UVM_ALL_ON)</span><br><span class="line">      `uvm_field_int(crc, UVM_ALL_ON)</span><br><span class="line">   `uvm_object_utils_end</span><br><span class="line"></span><br><span class="line">   function new(string name = &quot;my_transaction&quot;);</span><br><span class="line">      super.new();</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">endclass</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用<code>uvm_object_utils_begin</code>和<code>uvm_object_utils_end</code>来实现my_transaction的factory注册，在这两个宏中，使用uvm_field宏注册所有字段。</li>
<li>uvm_field系列宏随着transaction成员变量的不同而不同，如上面的定义中出现了针对bit类型的<code>uvm_field_int</code>及针对byte类型动态数组的uvm_field_array_int</li>
<li><strong>当上述宏注册之后，可以直接调用copy、compare、print等函数</strong>，无需自己定义</li>
</ul>
</li>
<li><p>引入field_automation机制的另外一大好处是简化了driver和monitor</p>
</li>
<li><p>my_driver.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_driver::drive_one_pkt(my_transaction tr);</span><br><span class="line">   byte unsigned     data_q[];</span><br><span class="line">   int  data_size;</span><br><span class="line">   </span><br><span class="line">   data_size = tr.pack_bytes(data_q) / 8; </span><br><span class="line">   `uvm_info(&quot;my_driver&quot;, &quot;begin to drive one pkt&quot;, UVM_LOW);</span><br><span class="line">   repeat(3) @(posedge vif.clk);</span><br><span class="line">   for ( int i = 0; i &lt; data_size; i++ ) begin</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      vif.valid &lt;= 1&#x27;b1;</span><br><span class="line">      vif.data &lt;= data_q[i]; </span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   @(posedge vif.clk);</span><br><span class="line">   vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">   `uvm_info(&quot;my_driver&quot;, &quot;end drive one pkt&quot;, UVM_LOW);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pack_bytes</code>将tr中所有的字段变成了byte流放入data_q中，<strong>pack_bytes极大地减少了代码量，在把所有的字段变成byte流放入data_q中时，字段按照uvm_field系列书写的顺序排列</strong>。在上述代码中是先放入dmac，再依次放入smac、ether_type、pload、crc</li>
</ul>
</li>
<li><p>my_monitor.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_monitor::collect_one_pkt(my_transaction tr);</span><br><span class="line">   byte unsigned data_q[$];</span><br><span class="line">   byte unsigned data_array[];</span><br><span class="line">   logic [7:0] data;</span><br><span class="line">   logic valid = 0;</span><br><span class="line">   int data_size;</span><br><span class="line">   </span><br><span class="line">   while(1) begin</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">      if(vif.valid) break;</span><br><span class="line">   end</span><br><span class="line">   </span><br><span class="line">   `uvm_info(&quot;my_monitor&quot;, &quot;begin to collect one pkt&quot;, UVM_LOW);</span><br><span class="line">   while(vif.valid) begin</span><br><span class="line">      data_q.push_back(vif.data);</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   end</span><br><span class="line">   data_size  = data_q.size();   </span><br><span class="line">   data_array = new[data_size];</span><br><span class="line">   for ( int i = 0; i &lt; data_size; i++ ) begin</span><br><span class="line">      data_array[i] = data_q[i]; </span><br><span class="line">   end</span><br><span class="line">   tr.pload = new[data_size - 18]; //da sa, e_type, crc</span><br><span class="line">   data_size = tr.unpack_bytes(data_array) / 8; </span><br><span class="line">   `uvm_info(&quot;my_monitor&quot;, &quot;end collect one pkt&quot;, UVM_LOW);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用unpack_bytes函数将data_q中的byte流转换成tr中的各个字段</li>
<li>在 Ethernet 数据包中，有一部分是以太网帧头（Ethernet Frame Header），其中包含了目的MAC地址（6字节）、源MAC地址（6字节）、以太网类型（2字节）和 CRC 校验码（4字节），共计18字节。那么包数量占data_size - 18个bytes，所以有这行代码<code>tr.pload = new[data_size - 18];</code> </li>
</ul>
</li>
<li><p>仿真结果：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430190504439.png" alt="image-20240430190504439"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240430190530419.png" alt="image-20240430190530419"></p>
</li>
</ul>
<hr>
<h1 id="UVM的终极大作：sequence"><a href="#UVM的终极大作：sequence" class="headerlink" title="UVM的终极大作：sequence"></a>UVM的终极大作：sequence</h1><h2 id="1-在验证平台中加入sequencer"><a href="#1-在验证平台中加入sequencer" class="headerlink" title="1.在验证平台中加入sequencer"></a>1.在验证平台中加入sequencer</h2><ul>
<li><p>sequence机制用于产生激励，它是UVM中最重要的机制之一</p>
</li>
<li><p>在一个规范化的UVM验证平台中，driver只负责驱动transaction，而不负责产生transaction</p>
</li>
<li><p>sequence机制有两大组成部分，一是sequence，二是sequencer</p>
</li>
<li><p><strong>sequencer的定义非常简单，派生自uvm_sequencer，并使用uvm_component_utils宏来注册到factory中</strong>。uvm_sequencer是一个参数化的类，其参数是my_transaction，即此sequencer产生transaction的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef MY_SEQUENCER__SV</span><br><span class="line">`define MY_SEQUENCER__SV</span><br><span class="line"></span><br><span class="line">class my_sequencer extends uvm_sequencer #(my_transaction);</span><br><span class="line">   </span><br><span class="line">   function new(string name, uvm_component parent);</span><br><span class="line">      super.new(name, parent);</span><br><span class="line">   endfunction </span><br><span class="line">   </span><br><span class="line">   `uvm_component_utils(my_sequencer)</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sequencer产生transaction，而driver负责接收transaction</strong></p>
</li>
<li><p>由于uvm_driver也是一个参数化的类，应该在定义driver时指明此driver要驱动的transaction类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class my_driver extends uvm_driver#(my_transaction);</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样定义的好处是可以直接使用uvm_driver中的某些预先定义好的成员变量，如uvm_driver中有成员变量req，它的类型就是传递给uvm_driver的参数，在这里就是my_transaction，可以直接使用req</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   phase.raise_objection(this);</span><br><span class="line">   vif.data &lt;= 8&#x27;b0;</span><br><span class="line">   vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">   while(!vif.rst_n)</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   for(int i = 0; i &lt; 2; i++) begin </span><br><span class="line">      req = new(&quot;req&quot;);</span><br><span class="line">      assert(req.randomize() with &#123;pload.size == 200;&#125;);</span><br><span class="line">      drive_one_pkt(req);</span><br><span class="line">   end</span><br><span class="line">   repeat(5) @(posedge vif.clk);</span><br><span class="line">   phase.drop_objection(this);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<ul>
<li>这里依然在driver中产生激励，下一节中将会把激励产生的功能从driver中移除</li>
</ul>
</li>
<li><p><strong>在完成sequencer的定义后，由于sequencer与driver的关系非常密切，因此要把其加入agent中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function void my_agent::build_phase(uvm_phase phase);</span><br><span class="line">   super.build_phase(phase);</span><br><span class="line">   if (is_active == UVM_ACTIVE) begin</span><br><span class="line">      sqr = my_sequencer::type_id::create(&quot;sqr&quot;, this);</span><br><span class="line">      drv = my_driver::type_id::create(&quot;drv&quot;, this);</span><br><span class="line">   end</span><br><span class="line">   mon = my_monitor::type_id::create(&quot;mon&quot;, this);</span><br><span class="line">endfunction </span><br></pre></td></tr></table></figure>
</li>
<li><p>在加入sequencer后，整个UVM树的结构变成了如下图的形式：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515151639843.png" alt="image-20240515151639843" style="zoom:50%;"></p>
</li>
<li><p>验证平台的框图：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515154658315.png" alt="image-20240515154658315" style="zoom:50%;"></p>
</li>
<li><p>其仿真结果与前序一致</p>
</li>
</ul>
<h2 id="2-sequence机制"><a href="#2-sequence机制" class="headerlink" title="2.sequence机制"></a>2.sequence机制</h2><ul>
<li><p>sequence不属于验证平台的任何一部分，但是它与sequencer之间有密切的联系</p>
<ul>
<li><strong>只有在sequencer的帮助下，sequence产生出的transaction才能最终送给driver</strong></li>
<li>没有sequence，sequencer就几乎没有任何作用</li>
<li>sequence就像是一个弹夹，里面的子弹就是transaction，而sequencer是一把枪。弹夹只有放入枪中才有意义，枪只有在放入弹夹后才能发挥威力</li>
</ul>
</li>
<li><p>从本质上来说<strong>，sequencer是一个uvm_component，而sequence是一个uvm_object</strong>。与my_transaction一样，sequence也有其生命周期。它的生命周期比my_transaction要更长一些，其内的transaction全部发送完毕后，它的生命周期也就结束了。<strong>因此，一个sequence应该使用uvm_object_utils宏注册到factory中</strong>（my_sequence.sv）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class my_sequence extends uvm_sequence #(my_transaction);</span><br><span class="line">   my_transaction m_trans;</span><br><span class="line"></span><br><span class="line">   function new(string name= &quot;my_sequence&quot;);</span><br><span class="line">      super.new(name);</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   virtual task body();</span><br><span class="line">      repeat (10) begin</span><br><span class="line">         `uvm_do(m_trans)</span><br><span class="line">      end</span><br><span class="line">      #1000;</span><br><span class="line">   endtask</span><br><span class="line"></span><br><span class="line">   `uvm_object_utils(my_sequence)</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>每一个sequence都有一个body任务，当一个sequence启动之后，会自动执行body中的代码</strong></li>
<li>在上面的例子中，用到了一个全新的宏：<code>uvm_do</code>，这个宏是UVM中最常见的宏之一，它用于：<ul>
<li><strong>创建一个my_transaction的实例m_trans</strong></li>
<li><strong>将其随机化</strong></li>
<li><strong>最终将其送给sequencer</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>一个sequece在向sequencer发送transaction前，要先向sequencer发送一个请求</strong>，sequencer把这个请求放在一个仲裁队列中，<strong>作为sequencer，它需要做两件事情：</strong></p>
<ul>
<li><strong>第一，检验仲裁队列里是否有某个sequence发送transaction的请求</strong></li>
<li><p><strong>第二，检测driver是否申请transaction</strong></p>
</li>
<li><p>如果仲裁队列里有发送请求，但driver没有申请transaction，那么sequencer将会一直处于等待driver的状态，直到driver申请新的transaction。此时，sequencer同意sequence的发送请求，sequence在得到sequencer的批准后，产生出一个transaction并交给sequencer，后者把这个transaction交给driver</p>
</li>
<li><p>如果仲裁队列中没有发送请求，但driver向sequencer申请新的transaction，那么sequencer将会处于等待sequence的状态，一直到有sequence递交发送请求，sequencer马上同意这个请求，sequence产生的transaction并交给sequencer，最终driver获得这个transaction</p>
</li>
<li>如果仲裁队列中有发送请求，同时driver也在向sequencer申请新的transaction，那么将会同意发送请求，sequence产生transaction并交给sequencer，最终driver获得这个transaction</li>
</ul>
</li>
<li><p>driver如何向sequencer申请transaction呢？</p>
<ul>
<li><p><strong>在uvm_driver中有成员变量seq_item_port，而在uvm_sequencer中有成员变量seq_item_export</strong>，这两者之间可以建立一个“通道”</p>
</li>
<li><p><strong>在my_agent中，使用connect函数把两者联系在一起</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function void my_agent::connect_phase(uvm_phase phase);</span><br><span class="line">   super.connect_phase(phase);</span><br><span class="line">   if (is_active == UVM_ACTIVE) begin</span><br><span class="line">      drv.seq_item_port.connect(sqr.seq_item_export);</span><br><span class="line">   end</span><br><span class="line">   ap = mon.ap;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
</li>
<li><p>当把二者连接好之后，就可以在driver中通过get_next_item任务向sequencer申请新的transaction</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   vif.data &lt;= 8&#x27;b0;</span><br><span class="line">   vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">   while(!vif.rst_n)</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   while(1) begin</span><br><span class="line">      seq_item_port.get_next_item(req);</span><br><span class="line">      drive_one_pkt(req);</span><br><span class="line">      seq_item_port.item_done();</span><br><span class="line">   end</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
</li>
<li><p>在如上的代码中，一个最显著的特征是使用了while(1)循环，因为driver只负责驱动transaction，而不负责产生，只要有transaction就驱动，所以必须做成一个无限循环的形式</p>
</li>
<li><p><strong>通过get_next_item任务来得到一个新的req，并且驱动它，驱动完成后调用item_done通知sequencer</strong>（如果在下次调用get_next_item前，item_done被调用，那么sequencer就认为driver已经得到了这个transaction）</p>
</li>
<li><p>sequence中uvm_do宏产生了一个transaction并交给sequencer，driver取走这transaction后，uvm_do并不会立刻返回执行下一次的uvm_do宏，而是等待在那里，直到driver返回item_done信号。此时，uvm_do宏才算执行完毕，返回后开始执行下一个uvm_do，并产生新的transaction</p>
</li>
<li><p>其实，除get_next_item之外，还可以使用try_next_item。<strong>get_next_item是阻塞的，它会一直等到有新的transaction才会返回，try_next_item是非阻塞的，它尝试着询问sequencer是否有新的transaction，如果有，则得到此transaction，否则就直接返回</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_driver::main_phase(uvm_phase phase);</span><br><span class="line">   vif.data &lt;= 8&#x27;b0;</span><br><span class="line">   vif.valid &lt;= 1&#x27;b0;</span><br><span class="line">   while(!vif.rst_n)</span><br><span class="line">      @(posedge vif.clk);</span><br><span class="line">   while(1) begin</span><br><span class="line">      seq_item_port.try_next_item(req);</span><br><span class="line">      if(req == null)</span><br><span class="line">          @(posedge vif.clk);</span><br><span class="line">      else begin</span><br><span class="line">          drive_one_pkt(req);</span><br><span class="line">          seq_item_port.item_done();</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>相比于get_next_item，try_next_item的行为更加接近真实driver的行为，当有数据时，就驱动数据，否则总线将一直处于空闲状态</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>sequence如何向sequencer中发送transaction呢？</p>
<ul>
<li><p>前面已经定义sequence，只需要在某个component（如my_sequencer、my_env）的main_phase中启动这个sequence即可，以在my_env中启动为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task my_env::main_phase(uvm_phase phase);</span><br><span class="line">   my_sequence seq;</span><br><span class="line">   phase.raise_objection(this);</span><br><span class="line">   seq = my_sequence::type_id::create(&quot;seq&quot;);</span><br><span class="line">   seq.start(i_agt.sqr); </span><br><span class="line">   phase.drop_objection(this);</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先常见一个my_sequence的实例seq</p>
</li>
<li><p>之后调用start任务，任务的参数是一个sequencer指针，如果不指明此指针，则sequence不知道将产生的transaction交给哪个sequencer</p>
</li>
</ul>
</li>
<li><p>仿真结果如下：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515170158447.png" alt="image-20240515170158447"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515170236610.png" alt="image-20240515170236610"></p>
</li>
</ul>
<h2 id="3-default-sequence的使用"><a href="#3-default-sequence的使用" class="headerlink" title="3.default_sequence的使用"></a>3.default_sequence的使用</h2><ul>
<li><p>在上一节的例子中，sequence是在my_env的main_phase中手工启动的，但在实际应用中，使用最多的还是通过default_sequence的方式启动sequence</p>
</li>
<li><p>使用default_sequence的方式非常简单，只需要在某个component（如my_env）的build_phase中设置如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtual function void build_phase(uvm_phase phase);</span><br><span class="line">   super.build_phase(phase);</span><br><span class="line">   ...</span><br><span class="line">   uvm_config_db#(uvm_object_wrapper)::set(this,</span><br><span class="line">                                           &quot;i_agt.sqr.main_phase&quot;,</span><br><span class="line">                                           &quot;default_sequence&quot;,</span><br><span class="line">                                            my_sequence::type_id::get());</span><br><span class="line"></span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<ul>
<li>上述set参数的第二个参数，取决于在哪个地方启动sequence</li>
</ul>
</li>
<li><p>如果在top_tb中设置default_sequence，则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module top_tb;</span><br><span class="line">...</span><br><span class="line">initial begin</span><br><span class="line">    uvm_config_db#(uvm_object_wrapper)::set(null,</span><br><span class="line">                                           &quot;uvm_test_top.i_agt.sqr.main_phase&quot;,</span><br><span class="line">                                           &quot;default_sequence&quot;,</span><br><span class="line">                                            my_sequence::type_id::get());</span><br><span class="line">end</span><br><span class="line">endmodule </span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在my_agent的build_phase里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function void my_agent::build_phase(uvm_phase phase);</span><br><span class="line">   super.build_phase(phase);</span><br><span class="line">   ...</span><br><span class="line">   uvm_config_db#(uvm_object_wrapper)::set(this,</span><br><span class="line">                                           &quot;sqr.main_phase&quot;,</span><br><span class="line">                                           &quot;default_sequence&quot;,</span><br><span class="line">                                            my_sequence::type_id::get());</span><br><span class="line"></span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在sequence中使用starting_phase进行提起和撤销objection</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class my_sequence extends uvm_sequence #(my_transaction);</span><br><span class="line">   my_transaction m_trans;</span><br><span class="line"></span><br><span class="line">   function new(string name= &quot;my_sequence&quot;);</span><br><span class="line">      super.new(name);</span><br><span class="line">   endfunction</span><br><span class="line"></span><br><span class="line">   virtual task body();</span><br><span class="line">      if(starting_phase != null) </span><br><span class="line">         starting_phase.raise_objection(this);</span><br><span class="line">      repeat (10) begin</span><br><span class="line">         `uvm_do(m_trans)</span><br><span class="line">      end</span><br><span class="line">      #1000;</span><br><span class="line">      if(starting_phase != null) </span><br><span class="line">         starting_phase.drop_objection(this);</span><br><span class="line">   endtask</span><br><span class="line"></span><br><span class="line">   `uvm_object_utils(my_sequence)</span><br><span class="line">endclass</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>仿真结果同上一节一致</p>
</li>
</ul>
<hr>
<h1 id="建造测试用例"><a href="#建造测试用例" class="headerlink" title="建造测试用例"></a>建造测试用例</h1><h2 id="1-加入base-test"><a href="#1-加入base-test" class="headerlink" title="1.加入base_test"></a>1.加入base_test</h2><ul>
<li><p>UVM使用的是一种树形结构，最初这棵树的树根是my_driver，后来由于要放置其他component，树根变成了my_env</p>
</li>
<li><p>但在一个实际应用的UVM验证平台中，my_env并不是树根，<strong>通常来说，树根是一个基于uvm_test派生的类。真正的测试用例都是基于base_test派生的一个类</strong>（base_test.sv）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef BASE_TEST__SV</span><br><span class="line">`define BASE_TEST__SV</span><br><span class="line"></span><br><span class="line">class base_test extends uvm_test;</span><br><span class="line"></span><br><span class="line">   my_env         env;</span><br><span class="line">   </span><br><span class="line">   function new(string name = &quot;base_test&quot;, uvm_component parent = null);</span><br><span class="line">      super.new(name,parent);</span><br><span class="line">   endfunction</span><br><span class="line">   </span><br><span class="line">   extern virtual function void build_phase(uvm_phase phase);</span><br><span class="line">   extern virtual function void report_phase(uvm_phase phase);</span><br><span class="line">   `uvm_component_utils(base_test)</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function void base_test::build_phase(uvm_phase phase);</span><br><span class="line">   super.build_phase(phase);</span><br><span class="line">   env  =  my_env::type_id::create(&quot;env&quot;, this); </span><br><span class="line">   uvm_config_db#(uvm_object_wrapper)::set(this,</span><br><span class="line">                                           &quot;env.i_agt.sqr.main_phase&quot;,</span><br><span class="line">                                           &quot;default_sequence&quot;,</span><br><span class="line">                                            my_sequence::type_id::get());</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function void base_test::report_phase(uvm_phase phase);</span><br><span class="line">   uvm_report_server server;</span><br><span class="line">   int err_num;</span><br><span class="line">   super.report_phase(phase);</span><br><span class="line"></span><br><span class="line">   server = get_report_server();</span><br><span class="line">   err_num = server.get_severity_count(UVM_ERROR);</span><br><span class="line"></span><br><span class="line">   if (err_num != 0) begin</span><br><span class="line">      $display(&quot;TEST CASE FAILED&quot;);</span><br><span class="line">   end</span><br><span class="line">   else begin</span><br><span class="line">      $display(&quot;TEST CASE PASSED&quot;);</span><br><span class="line">   end</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>
<ul>
<li><p>base_test派生自uvm_test，使用uvm_component_utils宏来注册到factory中</p>
</li>
<li><p>在build_phase中实例化my_env，并设置sequencer的default_sequence</p>
</li>
<li><p>上面的代码中出现了report_phase，在report_phase中根据UVM_ERROR的数量来打印不同的信息。report_phase也是UVM内建的一个phase，它在main_phase结束之后执行</p>
</li>
<li><p>通常在base_test中做如下事情：</p>
<ul>
<li>第一，设置整个验证平台的超时退出时间</li>
<li>第二，通过config_db设置验证平台中某些参数的值</li>
</ul>
</li>
</ul>
</li>
<li><p>在把my_env放入base_test中之后，UVM树的层次结构变成：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515200335301.png" alt="image-20240515200335301" style="zoom:50%;"></p>
</li>
<li><p>top_tb中run_test的参数从my_env变成了base_test，并且config_db中设置virtual interface的路径参数要做如下改变：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initial begin</span><br><span class="line">   run_test(&quot;base_test&quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt.drv&quot;, &quot;vif&quot;, input_if);</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top.env.i_agt.mon&quot;, &quot;vif&quot;, input_if);</span><br><span class="line">   uvm_config_db#(virtual my_if)::set(null, &quot;uvm_test_top.env.o_agt.mon&quot;, &quot;vif&quot;, output_if);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>仿真结果如下：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515200749358.png" alt="image-20240515200749358"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515200805663.png" alt="image-20240515200805663"></p>
</li>
</ul>
<h2 id="2-UVM中测试用例的启动"><a href="#2-UVM中测试用例的启动" class="headerlink" title="2.UVM中测试用例的启动"></a>2.UVM中测试用例的启动</h2><ul>
<li><p><strong>UVM会利用UVM_TESTNAME从命令行中寻找测试用例（以测试不同的sequence）的名字，创建它的实例并运行</strong>（注意<code>+UVM_TESTNAME=my_case1</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vsim -t ns -voptargs=+acc -sv_lib $UVM_DPI_DIR/uvm_dpi work_design.top_tb +UVM_TESTNAME=my_case1</span><br></pre></td></tr></table></figure>
</li>
<li><p>整个启动及执行的流程：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515211542137.png" alt="image-20240515211542137" style="zoom: 33%;"></p>
</li>
<li><p>启动后，整棵UVM树的结构：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515211633841.png" alt="image-20240515211633841" style="zoom:50%;"></p>
</li>
<li><p>仿真结果：</p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515211745672.png" alt="image-20240515211745672"></p>
<p><img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240515211803920.png" alt="image-20240515211803920"></p>
</li>
</ul>
<hr>
<h1 id="附加知识点"><a href="#附加知识点" class="headerlink" title="附加知识点"></a>附加知识点</h1><ul>
<li><p>modelsim下运行UVM仿真平台</p>
<p> <img src="/2024/04/23/UVM%E7%99%BD%E7%9A%AE%E4%B9%A6%E4%B9%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84UVM%E9%AA%8C%E8%AF%81%E5%B9%B3%E5%8F%B0/image-20240428204545137.png" alt="image-20240428204545137" style="zoom:50%;"></p>
</li>
<li><p>run.do（每行脚本含义可参考<a href="https://ssy1938010014.github.io/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/中附加知识点部分）`UVM_HOME`、`UVM_DPI_DIR`在modelsim的安装目录下找">https://ssy1938010014.github.io/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/中附加知识点部分）`UVM_HOME`、`UVM_DPI_DIR`在modelsim的安装目录下找</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vlib ./lib/</span><br><span class="line">vlib ./lib/work_design</span><br><span class="line"></span><br><span class="line">vmap work_design ./lib/work_design</span><br><span class="line"></span><br><span class="line">set UVM_HOME D:/SoftWare/ModelSim/verilog_src/uvm-1.1d/src</span><br><span class="line">set WORK_HOME D:/App_Data_File/ModelSim_project/UVM_Sim/UVM_learning_project</span><br><span class="line">set UVM_DPI_DIR D:/SoftWare/ModelSim/uvm-1.1d/win64</span><br><span class="line"></span><br><span class="line">vlog +incdir+$UVM_HOME -L mtiAvm -L mtiOvm -L mtiUvm -L mtiUPF $UVM_HOME/uvm_pkg.sv</span><br><span class="line">vlog -work work_design $WORK_HOME/ch2/dut/dut.sv $WORK_HOME/ch2/section2.2/2.2.1/sim/top_tb.sv </span><br><span class="line"></span><br><span class="line">vsim -t ns -voptargs=+acc -sv_lib $UVM_DPI_DIR/uvm_dpi work_design.top_tb  </span><br><span class="line"></span><br><span class="line">add wave -position insertpoint sim:/top_tb/*</span><br><span class="line"></span><br><span class="line">run -all</span><br></pre></td></tr></table></figure>
<ul>
<li>有关-sv_lib的解释：<code>-sv_lib</code>：这个选项用于指定一个SystemVerilog的DPI（Direct Programming Interface）库。DPI允许SystemVerilog代码调用C/C++函数，常用于模拟外部设备或高级功能。（来自GPT4）</li>
<li><code>-position</code>：这是一个选项，用来指定信号在波形窗口中的添加位置。</li>
<li><p><code>insertpoint</code>：这个参数的值指定了具体的插入点。在ModelSim的波形窗口中，<code>insertpoint</code> 指的是当前选中的波形组或信号的位置。如果你在波形窗口中选中了一个特定的信号或波形组，并执行带有 <code>-position insertpoint</code> 的命令，新添加的信号会被放置在选中的波形或组之后。</p>
<ul>
<li>举个例子：<ul>
<li>如果你没有选中任何波形或信号，新的信号通常会被添加到波形列表的最前面或最后面，具体取决于ModelSim的默认行为或之前的配置。</li>
<li>如果你选中了一个信号，然后运行带有 <code>-position insertpoint</code> 的 <code>add wave</code> 命令，新的信号将被插入到你选中的信号后面。（来自GPT4）</li>
</ul>
</li>
</ul>
</li>
<li><p>本人能力和时间有限，有关run.do中的一些脚本命令，我也不是很清楚，但用到的都会在此记录。</p>
</li>
</ul>
</li>
<li><p>搭建UVM仿真平台时，一开始会一直报vlog(12110)以及vlog一行出错的命令，折腾了我很久（因为以为是vlog使用有问题，其实是modelsim自身的问题），最后参考<a href="https://blog.csdn.net/ye_ming_sheng/article/details/105166714">vlog 12110错误及解决-CSDN博客</a>，重启后解决（记得之前好像也是用脚本仿真出问题了，设置voptflow = 0才能仿真，但这次又重新设置为1才可以）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>UVM</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA系统设计之AXI总线</title>
    <url>/2024/04/16/FPGA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B9%8BAXI%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<p>本节主要（这块挺重要的，看了一点，但暂时还没时间更新）</p>
<span id="more"></span>]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之数据校验</title>
    <url>/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>本节主要对通信系统中常见的校验模块进行学习，主要包括CRC与ECC校验。由于本人能力有限，暂时只是会用其校验方法，具体推导还没了解清楚，如果今后有时间更深入了解，将及时在此篇文章中补充。</p>
<span id="more"></span>
<h1 id="CRC校验（循环冗余校验）"><a href="#CRC校验（循环冗余校验）" class="headerlink" title="CRC校验（循环冗余校验）"></a>CRC校验（循环冗余校验）</h1><ul>
<li><p>CRC是数据帧传输中常用的一种差错控制编码方式，针对要发送的数据帧，使用一些<strong>特定的多项式可以计算出CRC校验结果</strong></p>
</li>
<li><p>CRC校验结果和原始数据一起传输到接收端，接收端在接收数据的同时按照相同的多项式对接收数据进行校验运算，并将校验结果和接收的结果进行对比：</p>
<ul>
<li>如果二者相同，则认为没有发生传输错误；</li>
<li>如果不同，则认为发生了传输错误</li>
<li>从理论上说，如果接收端计算出的CRC值与接收到的CRC值匹配，数据中仍有出错的可能，但是由于这种可能性极低，在实际应用中可以视为0，即没有错误发生</li>
</ul>
<p><img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413155406109.png" alt="image-20240413155406109" style="zoom: 67%;"></p>
</li>
<li><p>关于CRC计算校验子的规则到底是怎样的（其实就是移位+异或），可以看<a href="https://www.bilibili.com/video/BV1j441117a9?p=25&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">ex_16_1汉明纠错码原理以及一步一步分析实现纠错码；_哔哩哔哩_bilibili</a>视频30mins左右开始的内容（但其实懂了这个，我也还是不明白最终映射到电路上如何成了LFSR那样的结果，不过会就行，聪明的人已经为我们推导完了，不用纠结，虽然我纠结了很久还没弄懂）</p>
</li>
<li><p>CRC校验的硬件实现一般分为串行和并行两种，在串行实现方法中使用到了LFSR寄存器，所以下面从LFSR寄存器的介绍开始，介绍其实现方法。</p>
</li>
</ul>
<h2 id="1-LFSR寄存器"><a href="#1-LFSR寄存器" class="headerlink" title="1.LFSR寄存器"></a>1.LFSR寄存器</h2><ul>
<li><p>LFSR的特征多项式</p>
<script type="math/tex; mode=display">
f(x) = C_nx^n + C_{n-1}x^{n-1} + \cdots + C_3x^3 + C_2x^2+C_1x + 1</script></li>
<li><p>一个$n$级LFSR（寄存器的个数）最多只有$2^n - 1$个状态，即：<strong>一个$n$级的LFSR最多只能遍历$2^n-1$个序列，即最大周期为$2^n-1$</strong>（$n$<strong>bit移位寄存器能存储的数据为$0\sim 2^n-1$，即$2^n$个状态，但是由于LFSR禁止全0状态，因此一个$n$级的LFSR最多只能有$2^n - 1$个状态，</strong>因此一个LFSR的最大周期是$2^n-1$个系统时钟周期）</p>
</li>
<li><p><strong>当使用LFSR产生PRBS（伪随机噪声）时，是存在周期性的</strong>。值得注意的是：不是所有的LFSR都能达到$2^n-1$个周期，这与抽头的设计相关，只要选择合适的反馈函数便可使序列周期达到$2^n-1$，<strong>周期达到最大值的序列称为$m$​序列</strong></p>
</li>
<li><p>LFSR寄存器又分为两类：</p>
<ul>
<li>斐波那契LFSR：多到一型LFSR(many to one)</li>
<li>伽罗瓦LFSR：一到多型LFSR(one to many)</li>
</ul>
</li>
<li><strong>伽罗瓦LFSR具有更高的速度，因为两个触发器之间只有一个异或门</strong>。斐波那契LFSR在首尾两个寄存器之间有多个异或门，组合逻辑延时更大。</li>
</ul>
<h3 id="1-1-斐波那契LFSR"><a href="#1-1-斐波那契LFSR" class="headerlink" title="1.1 斐波那契LFSR"></a>1.1 斐波那契LFSR</h3><ul>
<li><p>斐波那契LFSR：抽头序列对应bit<strong>位置的多个寄存器的输出异或后驱动一个寄存器输入</strong></p>
</li>
<li><p><strong>从左至右依次递增编号：</strong></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413161459879.png" alt="image-20240413161459879" style="zoom:67%;"></p>
</li>
<li><p><strong>从左至右依次递减编号：</strong></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413161539700.png" alt="image-20240413161539700" style="zoom:67%;"></p>
</li>
<li><p>以三级LFSR，反馈函数：$f(x) = x^3+ x^2 + 1$ 为例，<strong>其两种编号的斐波那契电路图如下</strong>：</p>
<ul>
<li><p><strong>从左至右依次递增编号：</strong></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413161714496.png" alt="image-20240413161714496" style="zoom: 50%;"></p>
<p>假设初始状态为001，则该电路的状态跳转为：</p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413161812604.png" alt="image-20240413161812604" style="zoom: 67%;"></p>
</li>
<li><p><strong>从左至右依次递减编号：</strong></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413161847822.png" alt="image-20240413161847822" style="zoom: 50%;"></p>
<p>假设初始状态为001，则该电路的状态跳转为：</p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413161919429.png" alt="image-20240413161919429" style="zoom:67%;"></p>
</li>
</ul>
</li>
<li><p><strong>斐波那契LFSR习惯采用“从左到右依次递增编号”的电路</strong></p>
</li>
</ul>
<h3 id="1-2-伽罗瓦LFSR"><a href="#1-2-伽罗瓦LFSR" class="headerlink" title="1.2 伽罗瓦LFSR"></a>1.2 伽罗瓦LFSR</h3><ul>
<li><p>伽罗瓦LFSR：<strong>最后一个寄存器的输出</strong>通过与<strong>抽头序列对应位置寄存器前一级寄存器的输出异或后</strong>驱动多个抽头序列对应位置的寄存器</p>
</li>
<li><p><strong>从左至右依次递增编号：</strong></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413162218320.png" alt="image-20240413162218320" style="zoom: 67%;"></p>
</li>
<li><p><strong>从左至右依次递减编号：</strong></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413162251820.png" alt="image-20240413162251820" style="zoom:67%;"></p>
</li>
<li><p>同样，以三级LFSR，反馈函数：$f(x) = x^3+ x^2 + 1$​​ 为例，<strong>其两种编号的伽罗瓦电路图如下</strong>：</p>
<ul>
<li><p><strong>从左至右依次递增编号：</strong></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413162457119.png" alt="image-20240413162457119" style="zoom:50%;"></p>
<p>假设初始状态为001，则该电路的状态跳转为：</p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413162551691.png" alt="image-20240413162551691" style="zoom: 67%;"></p>
</li>
<li><p><strong>从左至右依次递减编号：</strong></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413162620602.png" alt="image-20240413162620602" style="zoom: 50%;"></p>
<p>假设初始状态为001，则该电路的状态跳转为：</p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413162645902.png" alt="image-20240413162645902" style="zoom:67%;"></p>
</li>
</ul>
</li>
<li><p><strong>伽罗瓦LFSR习惯采用“从左到右依次递减编号”电路</strong></p>
</li>
</ul>
<h2 id="2-串行CRC的实现"><a href="#2-串行CRC的实现" class="headerlink" title="2.串行CRC的实现"></a>2.串行CRC的实现</h2><ul>
<li><p>串行CRC8（以多项式$x^8+x^2+x+1$为例）硬件实现的原理图如下：</p>
<p><img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240414014027677.png" alt="image-20240414014027677" style="zoom:50%;"></p>
</li>
<li><p>其实这个结构具体是怎么跟CRC计算的底层原理对应上的，我也没弄太懂，但是呢，其实它和前文中一到多的LFSR结构一样，只是在输出寄存器反馈到各级寄存器之前与din异或了。那么在不懂底层原理的情况下，其实根据LFSR的知识，再加个异或，也是能画出来原理图来的，然后再照着原理图写代码就可以了。</p>
</li>
<li><p><strong>值得注意的是，din送数据时是最高bit先进</strong></p>
</li>
</ul>
<h3 id="2-1源代码"><a href="#2-1源代码" class="headerlink" title="2.1源代码"></a>2.1源代码</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> serial_crc8(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rstb,</span><br><span class="line">    <span class="keyword">input</span> din,</span><br><span class="line">    <span class="keyword">input</span> init_crc,     <span class="comment">//初始化crc寄存器</span></span><br><span class="line">    <span class="keyword">input</span> calc_crc,     <span class="comment">//该信号拉高即计算crc</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] crc_out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> CRC_INIT_VALUE = <span class="number">8&#x27;h00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] newcrc;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] crcreg,crcreg_nxt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是下一状态的判断</span></span><br><span class="line">    <span class="keyword">assign</span> newcrc[<span class="number">0</span>] = crcreg[<span class="number">7</span>] ^ din;</span><br><span class="line">    <span class="keyword">assign</span> newcrc[<span class="number">1</span>] = (crcreg[<span class="number">7</span>] ^ din) ^ crcreg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> newcrc[<span class="number">2</span>] = (crcreg[<span class="number">7</span>] ^ din) ^ crcreg[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> newcrc[<span class="number">3</span>] = crcreg[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">assign</span> newcrc[<span class="number">4</span>] = crcreg[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> newcrc[<span class="number">5</span>] = crcreg[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">assign</span> newcrc[<span class="number">6</span>] = crcreg[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">assign</span> newcrc[<span class="number">7</span>] = crcreg[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点类似状态机中下一状态的判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(init_crc) <span class="keyword">begin</span></span><br><span class="line">           crcreg_nxt = CRC_INIT_VALUE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(calc_crc) <span class="keyword">begin</span></span><br><span class="line">                crcreg_nxt = newcrc;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                crcreg_nxt = crcreg;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点类似状态机中的状态跳转的控制</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rstb) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rstb) <span class="keyword">begin</span></span><br><span class="line">            crcreg &lt;= CRC_INIT_VALUE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            crcreg &lt;= crcreg_nxt;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">assign</span> crc_out = crcreg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-testbench"><a href="#2-2-testbench" class="headerlink" title="2.2 testbench"></a>2.2 testbench</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> serial_crc8_tb;</span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rstb;</span><br><span class="line">    <span class="keyword">reg</span> din;</span><br><span class="line">    <span class="keyword">reg</span> init_crc;  </span><br><span class="line">    <span class="keyword">reg</span> calc_crc;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] crc_out;</span><br><span class="line"></span><br><span class="line">    serial_crc8 serial_crc8_u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rstb</span>(rstb),</span><br><span class="line">        <span class="variable">.din</span>(din),</span><br><span class="line">        <span class="variable">.init_crc</span>(init_crc), </span><br><span class="line">        <span class="variable">.calc_crc</span>(calc_crc), </span><br><span class="line">        <span class="variable">.crc_out</span>(crc_out)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rstb = <span class="number">0</span>;</span><br><span class="line">        din = <span class="number">0</span>;            <span class="comment">//1001 0110（从高位开始输入）</span></span><br><span class="line">        init_crc = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">20</span>;</span><br><span class="line">        rstb = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        init_crc = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        init_crc = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span> din &lt;= <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> din &lt;= <span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span> din &lt;= <span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span> din &lt;= <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> din &lt;= <span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span> din &lt;= <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> din &lt;= <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> din &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        calc_crc &lt;= <span class="number">0</span>;</span><br><span class="line">        #<span class="number">50</span> calc_crc &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240413210603025.png" alt="image-20240413210603025"></p>
</li>
</ul>
<h2 id="3-并行CRC的实现"><a href="#3-并行CRC的实现" class="headerlink" title="3.并行CRC的实现"></a>3.并行CRC的实现</h2><ul>
<li>在网上看了很多并行CRC的推导步骤，遗憾的是个人能力有限，没有一个是能完全看懂的，不过其实不懂也没关系，最愚蠢的推导方式就是对串行CRC的公式进行迭代，应该就是能推导出来的</li>
<li>网上有很多并行CRC代码生成的网站及小程序，这里推荐一个目前还能用的：<a href="http://outputlogic.com/?page_id=321">OutputLogic.com » CRC Generator</a></li>
<li><p>可以通过CRC校验码在线计算网站验证：<a href="http://www.ip33.com/crc.html">CRC（循环冗余校验）在线计算_ip33.com</a></p>
</li>
<li><p>仿真仿真着有个重大发现，<strong>原来并行CRC是可以用$m$个小位宽（比如$n$位宽）的数经过$m$个周期的延时求出的CRC等效为$m\times n$​位宽数据对应的校验码</strong></p>
</li>
<li>下面以OutputLogic.com网站上生成的$x^8+x^2+x+1$的初始值为0的CRC代码为例，仿真分析（网站上默认的初始值是ff，我将其改为00了）</li>
</ul>
<h3 id="3-1-源代码"><a href="#3-1-源代码" class="headerlink" title="3.1 源代码"></a>3.1 源代码</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> parallel_crc8(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,        </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data_in,</span><br><span class="line">    <span class="keyword">input</span> crc_en,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] crc_out</span><br><span class="line">  );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] lfsr_q,lfsr_c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> crc_out = lfsr_q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        lfsr_c[<span class="number">0</span>] = lfsr_q[<span class="number">4</span>] ^ lfsr_q[<span class="number">6</span>] ^ lfsr_q[<span class="number">7</span>] ^ data_in[<span class="number">0</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">7</span>] ^ data_in[<span class="number">8</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">19</span>] ^ data_in[<span class="number">21</span>] ^ data_in[<span class="number">23</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">30</span>] ^ data_in[<span class="number">31</span>];</span><br><span class="line">        lfsr_c[<span class="number">1</span>] = lfsr_q[<span class="number">0</span>] ^ lfsr_q[<span class="number">4</span>] ^ lfsr_q[<span class="number">5</span>] ^ lfsr_q[<span class="number">6</span>] ^ data_in[<span class="number">0</span>] ^ data_in[<span class="number">1</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">9</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">20</span>] ^ data_in[<span class="number">21</span>] ^ data_in[<span class="number">22</span>] ^ data_in[<span class="number">23</span>] ^ data_in[<span class="number">24</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">29</span>] ^ data_in[<span class="number">30</span>];</span><br><span class="line">        lfsr_c[<span class="number">2</span>] = lfsr_q[<span class="number">0</span>] ^ lfsr_q[<span class="number">1</span>] ^ lfsr_q[<span class="number">4</span>] ^ lfsr_q[<span class="number">5</span>] ^ data_in[<span class="number">0</span>] ^ data_in[<span class="number">1</span>] ^ data_in[<span class="number">2</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">8</span>] ^ data_in[<span class="number">10</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">22</span>] ^ data_in[<span class="number">24</span>] ^ data_in[<span class="number">25</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">29</span>];</span><br><span class="line">        lfsr_c[<span class="number">3</span>] = lfsr_q[<span class="number">1</span>] ^ lfsr_q[<span class="number">2</span>] ^ lfsr_q[<span class="number">5</span>] ^ lfsr_q[<span class="number">6</span>] ^ data_in[<span class="number">1</span>] ^ data_in[<span class="number">2</span>] ^ data_in[<span class="number">3</span>] ^ data_in[<span class="number">7</span>] ^ data_in[<span class="number">9</span>] ^ data_in[<span class="number">11</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">23</span>] ^ data_in[<span class="number">25</span>] ^ data_in[<span class="number">26</span>] ^ data_in[<span class="number">29</span>] ^ data_in[<span class="number">30</span>];</span><br><span class="line">        lfsr_c[<span class="number">4</span>] = lfsr_q[<span class="number">0</span>] ^ lfsr_q[<span class="number">2</span>] ^ lfsr_q[<span class="number">3</span>] ^ lfsr_q[<span class="number">6</span>] ^ lfsr_q[<span class="number">7</span>] ^ data_in[<span class="number">2</span>] ^ data_in[<span class="number">3</span>] ^ data_in[<span class="number">4</span>] ^ data_in[<span class="number">8</span>] ^ data_in[<span class="number">10</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">19</span>] ^ data_in[<span class="number">24</span>] ^ data_in[<span class="number">26</span>] ^ data_in[<span class="number">27</span>] ^ data_in[<span class="number">30</span>] ^ data_in[<span class="number">31</span>];</span><br><span class="line">        lfsr_c[<span class="number">5</span>] = lfsr_q[<span class="number">1</span>] ^ lfsr_q[<span class="number">3</span>] ^ lfsr_q[<span class="number">4</span>] ^ lfsr_q[<span class="number">7</span>] ^ data_in[<span class="number">3</span>] ^ data_in[<span class="number">4</span>] ^ data_in[<span class="number">5</span>] ^ data_in[<span class="number">9</span>] ^ data_in[<span class="number">11</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">20</span>] ^ data_in[<span class="number">25</span>] ^ data_in[<span class="number">27</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">31</span>];</span><br><span class="line">        lfsr_c[<span class="number">6</span>] = lfsr_q[<span class="number">2</span>] ^ lfsr_q[<span class="number">4</span>] ^ lfsr_q[<span class="number">5</span>] ^ data_in[<span class="number">4</span>] ^ data_in[<span class="number">5</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">10</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">19</span>] ^ data_in[<span class="number">21</span>] ^ data_in[<span class="number">26</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">29</span>];</span><br><span class="line">        lfsr_c[<span class="number">7</span>] = lfsr_q[<span class="number">3</span>] ^ lfsr_q[<span class="number">5</span>] ^ lfsr_q[<span class="number">6</span>] ^ data_in[<span class="number">5</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">7</span>] ^ data_in[<span class="number">11</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">20</span>] ^ data_in[<span class="number">22</span>] ^ data_in[<span class="number">27</span>] ^ data_in[<span class="number">29</span>] ^ data_in[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">end</span> <span class="comment">//always</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            lfsr_q &lt;= &#123;<span class="number">8</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            lfsr_q &lt;= crc_en ? lfsr_c : lfsr_q;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> <span class="comment">//always</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-testbench"><a href="#3-2-testbench" class="headerlink" title="3.2 testbench"></a>3.2 testbench</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> parallel_crc8_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst_n;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] data_in;</span><br><span class="line">    <span class="keyword">reg</span> crc_en;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] crc_out;</span><br><span class="line"></span><br><span class="line">    parallel_crc8 parallel_crc8_u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.data_in</span>(data_in),</span><br><span class="line">        <span class="variable">.crc_en</span>(crc_en),</span><br><span class="line">        <span class="variable">.crc_out</span>(crc_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rst_n = <span class="number">0</span>;</span><br><span class="line">        crc_en &lt;= <span class="number">0</span>;</span><br><span class="line">        data_in &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">        #<span class="number">20</span> rst_n = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> crc_en &lt;= <span class="number">1&#x27;d1</span>;</span><br><span class="line">        data_in &lt;= <span class="number">32&#x27;h00004567</span>;</span><br><span class="line">        #<span class="number">10</span> data_in &lt;= <span class="number">32&#x27;h0000f867</span>;</span><br><span class="line">        #<span class="number">10</span> data_in &lt;= <span class="number">32&#x27;h00004e17</span>;</span><br><span class="line">        #<span class="number">10</span> data_in &lt;= <span class="number">32&#x27;h000095a6</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240414011817089.png" alt="image-20240414011817089"></p>
</li>
<li><p>结果分析：<strong>可以得到最终结果为0h35，其也是00004567_0000f867_00004e17_000095a6对应的校验码</strong>。但每个时钟周期实际上只计算了32bit，经过4个时钟周期后，即可计算出$32\times 4 =128$bit对应的校验码。其实，个人感觉当前每32bit的输出就作为下次32bit的初始值。<strong>值得注意的是，从最高32bit开始送入</strong></p>
<p><img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240414012118881.png" alt="image-20240414012118881" style="zoom: 33%;"></p>
</li>
<li><p>这里还PS一下，一开始我并没有发现可以用小位宽不断迭代生成大位宽对应的校验码，以为只能是每个时钟周期都能计算出一个小位宽的结果，每个周期输出的结果与结果直接并无联系，还愚蠢的将代码改成如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> parallel_crc8(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,        </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data_in,</span><br><span class="line">    <span class="keyword">input</span> crc_en,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] crc_out</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">localparam</span> CRC_INIT_VALUE = <span class="number">8&#x27;h00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] lfsr_q,lfsr_c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> crc_out = lfsr_q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        lfsr_c[<span class="number">0</span>] = CRC_INIT_VALUE[<span class="number">4</span>] ^ CRC_INIT_VALUE[<span class="number">6</span>] ^ CRC_INIT_VALUE[<span class="number">7</span>] ^ data_in[<span class="number">0</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">7</span>] ^ data_in[<span class="number">8</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">19</span>] ^ data_in[<span class="number">21</span>] ^ data_in[<span class="number">23</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">30</span>] ^ data_in[<span class="number">31</span>];</span><br><span class="line">        lfsr_c[<span class="number">1</span>] = CRC_INIT_VALUE[<span class="number">0</span>] ^ CRC_INIT_VALUE[<span class="number">4</span>] ^ CRC_INIT_VALUE[<span class="number">5</span>] ^ CRC_INIT_VALUE[<span class="number">6</span>] ^ data_in[<span class="number">0</span>] ^ data_in[<span class="number">1</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">9</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">20</span>] ^ data_in[<span class="number">21</span>] ^ data_in[<span class="number">22</span>] ^ data_in[<span class="number">23</span>] ^ data_in[<span class="number">24</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">29</span>] ^ data_in[<span class="number">30</span>];</span><br><span class="line">        lfsr_c[<span class="number">2</span>] = CRC_INIT_VALUE[<span class="number">0</span>] ^ CRC_INIT_VALUE[<span class="number">1</span>] ^ CRC_INIT_VALUE[<span class="number">4</span>] ^ CRC_INIT_VALUE[<span class="number">5</span>] ^ data_in[<span class="number">0</span>] ^ data_in[<span class="number">1</span>] ^ data_in[<span class="number">2</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">8</span>] ^ data_in[<span class="number">10</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">22</span>] ^ data_in[<span class="number">24</span>] ^ data_in[<span class="number">25</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">29</span>];</span><br><span class="line">        lfsr_c[<span class="number">3</span>] = CRC_INIT_VALUE[<span class="number">1</span>] ^ CRC_INIT_VALUE[<span class="number">2</span>] ^ CRC_INIT_VALUE[<span class="number">5</span>] ^ CRC_INIT_VALUE[<span class="number">6</span>] ^ data_in[<span class="number">1</span>] ^ data_in[<span class="number">2</span>] ^ data_in[<span class="number">3</span>] ^ data_in[<span class="number">7</span>] ^ data_in[<span class="number">9</span>] ^ data_in[<span class="number">11</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">23</span>] ^ data_in[<span class="number">25</span>] ^ data_in[<span class="number">26</span>] ^ data_in[<span class="number">29</span>] ^ data_in[<span class="number">30</span>];</span><br><span class="line">        lfsr_c[<span class="number">4</span>] = CRC_INIT_VALUE[<span class="number">0</span>] ^ CRC_INIT_VALUE[<span class="number">2</span>] ^ CRC_INIT_VALUE[<span class="number">3</span>] ^ CRC_INIT_VALUE[<span class="number">6</span>] ^ CRC_INIT_VALUE[<span class="number">7</span>] ^ data_in[<span class="number">2</span>] ^ data_in[<span class="number">3</span>] ^ data_in[<span class="number">4</span>] ^ data_in[<span class="number">8</span>] ^ data_in[<span class="number">10</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">19</span>] ^ data_in[<span class="number">24</span>] ^ data_in[<span class="number">26</span>] ^ data_in[<span class="number">27</span>] ^ data_in[<span class="number">30</span>] ^ data_in[<span class="number">31</span>];</span><br><span class="line">        lfsr_c[<span class="number">5</span>] = CRC_INIT_VALUE[<span class="number">1</span>] ^ CRC_INIT_VALUE[<span class="number">3</span>] ^ CRC_INIT_VALUE[<span class="number">4</span>] ^ CRC_INIT_VALUE[<span class="number">7</span>] ^ data_in[<span class="number">3</span>] ^ data_in[<span class="number">4</span>] ^ data_in[<span class="number">5</span>] ^ data_in[<span class="number">9</span>] ^ data_in[<span class="number">11</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">20</span>] ^ data_in[<span class="number">25</span>] ^ data_in[<span class="number">27</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">31</span>];</span><br><span class="line">        lfsr_c[<span class="number">6</span>] = CRC_INIT_VALUE[<span class="number">2</span>] ^ CRC_INIT_VALUE[<span class="number">4</span>] ^ CRC_INIT_VALUE[<span class="number">5</span>] ^ data_in[<span class="number">4</span>] ^ data_in[<span class="number">5</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">10</span>] ^ data_in[<span class="number">12</span>] ^ data_in[<span class="number">14</span>] ^ data_in[<span class="number">16</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">19</span>] ^ data_in[<span class="number">21</span>] ^ data_in[<span class="number">26</span>] ^ data_in[<span class="number">28</span>] ^ data_in[<span class="number">29</span>];</span><br><span class="line">        lfsr_c[<span class="number">7</span>] = CRC_INIT_VALUE[<span class="number">3</span>] ^ CRC_INIT_VALUE[<span class="number">5</span>] ^ CRC_INIT_VALUE[<span class="number">6</span>] ^ data_in[<span class="number">5</span>] ^ data_in[<span class="number">6</span>] ^ data_in[<span class="number">7</span>] ^ data_in[<span class="number">11</span>] ^ data_in[<span class="number">13</span>] ^ data_in[<span class="number">15</span>] ^ data_in[<span class="number">17</span>] ^ data_in[<span class="number">18</span>] ^ data_in[<span class="number">20</span>] ^ data_in[<span class="number">22</span>] ^ data_in[<span class="number">27</span>] ^ data_in[<span class="number">29</span>] ^ data_in[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">end</span> <span class="comment">//always</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            lfsr_q &lt;= &#123;<span class="number">8</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            lfsr_q &lt;= crc_en ? lfsr_c : lfsr_q;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> <span class="comment">//always</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>对应仿真结果：</p>
<p><img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240414013031318.png" alt="image-20240414013031318"></p>
</li>
<li><p>不过感觉其实这个修改适用于：求许多个独立的32bit数据对应的CRC校验码场景</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4.Reference"></a>4.Reference</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/620450000">【Verilog编程】线性反馈移位寄存器（LFSR）原理及Verilog代码实现 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/baozouxiaoluoli/article/details/120321794">Verilog 实现32位并行CRC编解码 可在一个时钟周期出结果_crc32 verilog-CSDN博客</a></p>
</li>
</ul>
<hr>
<h1 id="ECC校验"><a href="#ECC校验" class="headerlink" title="ECC校验"></a>ECC校验</h1><ul>
<li><p>关于ECC校验，其是基于汉明码的，它也有自己特定的计算校验子的规则，此处不再赘述，附上几篇说的比较不错的博客，看完应该能大概弄懂计算的流程了。还是截出博客中的重点吧</p>
</li>
<li><p><a href="https://blog.csdn.net/qq_37708525/article/details/128735265">最详细的“ECC-汉明码”原理讲解_ecc编码-CSDN博客</a></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240414015743270.png" alt="image-20240414015743270" style="zoom: 33%;"></p>
</li>
<li><p><a href="https://blog.csdn.net/deepking18254382067/article/details/85802821?ops_request_misc=%7B%22request%5Fid%22%3A%22171163141316800184165709%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171163141316800184165709&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-85802821-null-null.142^v100^pc_search_result_base6&amp;utm_term=史上最通俗的海明码计算、检错和纠错原理解析&amp;spm=1018.2226.3001.4187">史上最通俗的海明码编码计算、检错和纠错原理解析_求0101按偶校验配置的海明编码-CSDN博客</a></p>
<p> <img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240414015820950.png" alt="image-20240414015820950" style="zoom:33%;"></p>
</li>
<li><p><a href="https://github.com/Jassy930/wx_article/blob/master/汉明码/汉明码.md">wx_article/汉明码/汉明码.md at master · Jassy930/wx_article · GitHub</a>（这篇详细看看，整个ECC校验子的流程大概就明白了）</p>
</li>
<li><p>因为目前在比赛的项目中决定用CRC校验，所以暂时不做ECC的仿真测试，有时间有需求做了ECC的设计的话，再来此补充</p>
</li>
</ul>
<hr>
<h1 id="附加模块编写"><a href="#附加模块编写" class="headerlink" title="附加模块编写"></a>附加模块编写</h1><ul>
<li><p>因为这里提到了LFSR寄存器，这里就补充LFSR计数器的编写</p>
<p><img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240527130219680.png" alt="image-20240527130219680" style="zoom:50%;"></p>
<ul>
<li><p>源文件：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> lfsr_counter_4bit(</span><br><span class="line">    <span class="keyword">input</span>   clk,</span><br><span class="line">    <span class="keyword">input</span>   rst_n,</span><br><span class="line">    <span class="keyword">input</span>   new_cntr_preset,    <span class="comment">//该信号拉高预设初值</span></span><br><span class="line">    <span class="keyword">output</span>  ctr_expired</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span> : <span class="number">0</span>] lfsr_cnt, lfsr_cnt_nxt;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span> : <span class="number">0</span>] lfsr_cnt_xor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> lfsr_cnt_xor[<span class="number">0</span>] = lfsr_cnt[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> lfsr_cnt_xor[<span class="number">1</span>] = lfsr_cnt[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">assign</span> lfsr_cnt_xor[<span class="number">2</span>] = lfsr_cnt[<span class="number">3</span>] ^ lfsr_cnt[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> lfsr_cnt_xor[<span class="number">3</span>] = lfsr_cnt[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(new_cntr_preset) <span class="keyword">begin</span></span><br><span class="line">            lfsr_cnt_nxt = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">        <span class="keyword">end</span>    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            lfsr_cnt_nxt = lfsr_cnt_xor;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            lfsr_cnt &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            lfsr_cnt &lt;= lfsr_cnt_nxt;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> ctr_expired = (lfsr_cnt == <span class="number">4&#x27;b0111</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>testbench</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> lfsr_counter_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk             ;</span><br><span class="line">    <span class="keyword">reg</span> rst_n           ;</span><br><span class="line">    <span class="keyword">reg</span> new_cntr_preset ;</span><br><span class="line">    <span class="keyword">wire</span> ctr_expired    ; </span><br><span class="line"></span><br><span class="line">    lfsr_counter_4bit lfsr_counter_4bit_u1(</span><br><span class="line">        <span class="variable">.clk</span>             (clk             ),</span><br><span class="line">        <span class="variable">.rst_n</span>           (rst_n           ),</span><br><span class="line">        <span class="variable">.new_cntr_preset</span> (new_cntr_preset ),</span><br><span class="line">        <span class="variable">.ctr_expired</span>     (ctr_expired     )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">1</span>;</span><br><span class="line">        rst_n = <span class="number">0</span>;</span><br><span class="line">        new_cntr_preset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">21</span> rst_n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>仿真结果：</p>
<p><img src="/2024/04/13/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/image-20240527130518793.png" alt="image-20240527130518793"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之常用通信接口时序</title>
    <url>/2024/03/15/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F/</url>
    <content><![CDATA[<p>本节包括SPI配置DAC芯片实例、异步并口通信等。</p>
<span id="more"></span>
<h1 id="SPI配置时序"><a href="#SPI配置时序" class="headerlink" title="SPI配置时序"></a>SPI配置时序</h1><h2 id="1-某DAC芯片的SPI配置时序"><a href="#1-某DAC芯片的SPI配置时序" class="headerlink" title="1.某DAC芯片的SPI配置时序"></a>1.某DAC芯片的SPI配置时序</h2><ul>
<li>此时时序的关键是：时钟上升沿主机给从机发数据，时钟下降沿从机给主机发数据</li>
</ul>
<p><img src="/2024/03/15/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F/image-20240315133651049.png" alt="image-20240315133651049" style="zoom:50%;"></p>
<ul>
<li><p>正因如此，利用FPGA的系统时钟产生SPI的分频时钟后，需要进行180°时钟反相，也就是用产生的分频时钟去控制SPI的配置时序，但最终输出的SPI实际时钟是分频时钟的180°反相，这样能使得SPI上要发送的数据正好处于SPI时钟的上升沿</p>
<p><img src="/2024/03/15/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F/image-20240315134559957.png" alt="image-20240315134559957" style="zoom: 67%;"></p>
</li>
<li><p>并且，关于DAC的配置，总共需要发送32个16bit的数据才算完成，此处牵扯到串行处理，故用状态机控制</p>
<p><img src="/2024/03/15/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F/image-20240315134814666.png" alt="image-20240315134814666" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-源代码"><a href="#2-源代码" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> spi_ctrl(</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>		sclk,<span class="comment">//系统时钟50Mhz</span></span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>		rst_n,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>		work_en,<span class="comment">//触发配置操作的使能</span></span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>		    conf_end,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">wire</span>		spi_clk,<span class="comment">//50-60mhz</span></span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">wire</span>		spi_sdi,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">wire</span>		spi_csn,</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>		spi_sdo<span class="comment">//读输入管脚不进行编程</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span>	IDLE = <span class="number">5&#x27;b0_0001</span>;</span><br><span class="line">    <span class="keyword">parameter</span>	WAIT = <span class="number">5&#x27;b0_0010</span>;</span><br><span class="line">    <span class="keyword">parameter</span>	R_MEM= <span class="number">5&#x27;b0_0100</span>;</span><br><span class="line">    <span class="keyword">parameter</span>	W_REG= <span class="number">5&#x27;b0_1000</span>;</span><br><span class="line">    <span class="keyword">parameter</span>	STOP = <span class="number">5&#x27;b1_0000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span>	H_DIV_CYC	=	<span class="number">5&#x27;d25</span>-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">4</span>:<span class="number">0</span>]	state;<span class="comment">//状态机的寄存器变量，编码方式采用独热码</span></span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">4</span>:<span class="number">0</span>]	div_cnt;</span><br><span class="line">    <span class="keyword">reg</span>		    clk_p=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">wire</span>		clk_n;</span><br><span class="line">    <span class="keyword">reg</span>		    pose_flag;</span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">3</span>:<span class="number">0</span>]	wait_cnt;</span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">3</span>:<span class="number">0</span>]	shift_cnt;</span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">4</span>:<span class="number">0</span>]	r_addr;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>]	r_data;</span><br><span class="line">    <span class="keyword">wire</span>		wren;</span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">15</span>:<span class="number">0</span>]	shift_buf;</span><br><span class="line">    <span class="keyword">reg</span>		    data_end;</span><br><span class="line">    <span class="keyword">reg</span>		    sdi;</span><br><span class="line">    <span class="keyword">reg</span>		    csn;</span><br><span class="line">    <span class="keyword">reg</span>		    tck;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分频计数器</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            div_cnt &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( div_cnt == H_DIV_CYC )</span><br><span class="line">            div_cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            div_cnt &lt;= div_cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="comment">//分频时钟不允许做寄存器的触发时钟，也就是不能卸载always块的触发列表中</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            clk_p &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(div_cnt == H_DIV_CYC)</span><br><span class="line">            clk_p &lt;= ~clk_p;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">assign</span>	clk_n=~clk_p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            pose_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(clk_p == <span class="number">1&#x27;b0</span> &amp;&amp; div_cnt == H_DIV_CYC)</span><br><span class="line">            pose_flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span>	pose_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            wait_cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == WAIT &amp;&amp; pose_flag == <span class="number">1&#x27;b1</span>)</span><br><span class="line">            wait_cnt &lt;= wait_cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state != WAIT)</span><br><span class="line">            wait_cnt &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fsm</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">case</span> (state)</span><br><span class="line">            IDLE :<span class="keyword">if</span>(work_en == <span class="number">1&#x27;b1</span>)</span><br><span class="line">                state &lt;= WAIT;</span><br><span class="line">            WAIT :<span class="keyword">if</span>(wait_cnt[<span class="number">3</span>] == <span class="number">1&#x27;b1</span>)</span><br><span class="line">                state &lt;= R_MEM;</span><br><span class="line">            R_MEM:	state &lt;=W_REG;</span><br><span class="line">            W_REG:	<span class="keyword">if</span>(shift_cnt == <span class="number">4&#x27;d15</span> &amp;&amp; pose_flag == <span class="number">1&#x27;b1</span> &amp;&amp; data_end != <span class="number">1&#x27;b1</span>)</span><br><span class="line">                    state &lt;= WAIT;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(shift_cnt == <span class="number">4&#x27;d15</span> &amp;&amp; pose_flag == <span class="number">1&#x27;b1</span> &amp;&amp; data_end == <span class="number">1&#x27;b1</span>)</span><br><span class="line">                    state &lt;= STOP;</span><br><span class="line">            STOP:	state &lt;= STOP;</span><br><span class="line">            <span class="keyword">default</span> : state &lt;= IDLE; </span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            shift_cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == W_REG &amp;&amp; pose_flag == <span class="number">1&#x27;b1</span>)</span><br><span class="line">            shift_cnt &lt;= shift_cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( state != W_REG)</span><br><span class="line">            shift_cnt &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读mem的地址产生</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            r_addr &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == R_MEM)</span><br><span class="line">            r_addr &lt;= r_addr + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//data_end 最后一个需要移位数据</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            data_end &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == R_MEM &amp;&amp; (&amp;r_addr) == <span class="number">1&#x27;b1</span>)<span class="comment">//等效于r_addr == 5&#x27;d31</span></span><br><span class="line">            data_end &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span>	wren =<span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            shift_buf&lt;=<span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == R_MEM)</span><br><span class="line">            shift_buf &lt;= r_data;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == W_REG &amp;&amp; pose_flag == <span class="number">1&#x27;b1</span>)</span><br><span class="line">            shift_buf &lt;= &#123;shift_buf[<span class="number">14</span>:<span class="number">0</span>],<span class="number">1&#x27;b1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据的输出</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            sdi&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == W_REG)</span><br><span class="line">            sdi&lt;=shift_buf[<span class="number">15</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sdi &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            csn &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == W_REG)</span><br><span class="line">            csn &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            csn &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            tck&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == W_REG )</span><br><span class="line">            tck&lt;=clk_n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tck&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> spi_clk = tck;</span><br><span class="line">    <span class="keyword">assign</span> spi_csn = csn;</span><br><span class="line">    <span class="keyword">assign</span> spi_sdi = sdi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> sclk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span>(rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            conf_end &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == STOP)</span><br><span class="line">            conf_end &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">    blk_mem_gen_0	ram_16x32_sr_inst (</span><br><span class="line">        <span class="variable">.addra</span> ( r_addr ),<span class="comment">//读地址</span></span><br><span class="line">        <span class="variable">.clka</span> ( sclk ),</span><br><span class="line">        <span class="variable">.douta</span> ( r_data ) <span class="comment">//读数据</span></span><br><span class="line">        );  </span><br><span class="line">        </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench"><a href="#3-Testbench" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> dac_spi_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>	        sclk,rst_n;</span><br><span class="line">    <span class="keyword">reg</span>	        work_en;</span><br><span class="line">    <span class="keyword">wire</span>	    spi_clk,sclk_csn,spi_sdi;</span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">15</span>:<span class="number">0</span>]	send_mem [<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">15</span>:<span class="number">0</span>]	shift_buf;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span>	<span class="keyword">begin</span></span><br><span class="line">        rst_n =<span class="number">0</span>;</span><br><span class="line">        sclk =<span class="number">0</span>;</span><br><span class="line">        #<span class="number">100</span>;</span><br><span class="line">        rst_n =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span>	<span class="keyword">begin</span></span><br><span class="line">        work_en =<span class="number">0</span>;</span><br><span class="line">        #<span class="number">150</span></span><br><span class="line">        work_en =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemb</span>(<span class="string">&quot;D:\\App_Data_File\\Vivado_data\\Vivado_project\\DSP_design\\DAC_SPI\\dac_ini_16x32.mif&quot;</span>,send_mem);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> sclk = ~sclk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rec_spi();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    spi_ctrl	spi_ctrl_inst(</span><br><span class="line">        <span class="variable">.sclk</span>		(sclk),<span class="comment">//系统时钟50Mhz</span></span><br><span class="line">        <span class="variable">.rst_n</span>		(rst_n),</span><br><span class="line">        <span class="variable">.work_en</span>	(work_en),<span class="comment">//触发配置操作的使能</span></span><br><span class="line">        <span class="variable">.conf_end</span>	(conf_end),</span><br><span class="line">        <span class="variable">.spi_clk</span>	(spi_clk),<span class="comment">//50-60mhz</span></span><br><span class="line">        <span class="variable">.spi_sdi</span>	(spi_sdi),</span><br><span class="line">        <span class="variable">.spi_csn</span>	(spi_csn),</span><br><span class="line">        <span class="variable">.spi_sdo</span>	()<span class="comment">//读输入管脚不进行编程</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> rec_spi();</span><br><span class="line">        <span class="keyword">integer</span> i,j;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i=i+<span class="number">1</span>)<span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j=j+<span class="number">1</span>)<span class="keyword">begin</span></span><br><span class="line">                    @(<span class="keyword">posedge</span> spi_clk);</span><br><span class="line">                        shift_buf = &#123;shift_buf[<span class="number">14</span>:<span class="number">0</span>],spi_sdi&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">15</span> &amp;&amp; shift_buf == send_mem[i])</span><br><span class="line">                        <span class="built_in">$display</span>(<span class="string">&quot;ok data index is %d rec_d=%d send_d=%d&quot;</span>,i,shift_buf,send_mem[i]);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j== <span class="number">15</span>)</span><br><span class="line">                        <span class="built_in">$display</span>(<span class="string">&quot;error&quot;</span>);	</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2024/03/15/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F/image-20240315135211882.png" alt="image-20240315135211882" style="zoom: 70%;"></p>
</li>
<li><p>这里写测试代码的方式值得一学，不然还得人工判断传输的结果是否正确</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> rec_spi();</span><br><span class="line">    <span class="keyword">integer</span> i,j;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i=i+<span class="number">1</span>)<span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j=j+<span class="number">1</span>)<span class="keyword">begin</span></span><br><span class="line">                @(<span class="keyword">posedge</span> spi_clk);</span><br><span class="line">                    shift_buf = &#123;shift_buf[<span class="number">14</span>:<span class="number">0</span>],spi_sdi&#125;;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">15</span> &amp;&amp; shift_buf == send_mem[i])</span><br><span class="line">                    <span class="built_in">$display</span>(<span class="string">&quot;ok data index is %d rec_d=%d send_d=%d&quot;</span>,i,shift_buf,send_mem[i]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j== <span class="number">15</span>)</span><br><span class="line">                    <span class="built_in">$display</span>(<span class="string">&quot;error&quot;</span>);	</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4.Reference"></a>4.Reference</h2><ul>
<li><a href="https://www.bilibili.com/video/BV1j441117a9?p=9&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">ex_7-1DAC3283 寄存器初始化，SPI驱动写法以及技巧；_哔哩哔哩_bilibili</a></li>
</ul>
<hr>
<h1 id="异步并口通信"><a href="#异步并口通信" class="headerlink" title="异步并口通信"></a>异步并口通信</h1><ul>
<li><p>异步并口应用：CPU类的芯片与FPGA的数据交互，数据速率一般在100Mbps以内，数据总线不大于16bit</p>
</li>
<li><p>写操作（外部芯片对FPGA写）的时序图：</p>
<p><img src="/2024/03/15/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F/image-20240322155750268.png" alt="image-20240322155750268" style="zoom: 30%;"></p>
</li>
<li><p>读操作（外部芯片读FPGA内数据）时序图：</p>
</li>
</ul>
<p><img src="/2024/03/15/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F/image-20240322160016934.png" alt="image-20240322160016934" style="zoom:25%;"></p>
<h2 id="1-源代码"><a href="#1-源代码" class="headerlink" title="1.源代码"></a>1.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> asyn_parallel(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">input</span> cs_n,</span><br><span class="line">    <span class="keyword">input</span> we_n,</span><br><span class="line">    <span class="keyword">input</span> rd_n,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr,</span><br><span class="line">    <span class="keyword">inout</span> [<span class="number">15</span>:<span class="number">0</span>] data</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] rom_data[<span class="number">7</span>:<span class="number">0</span>];   <span class="comment">//FPGA内部存储</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//降低亚稳态出现的概率把CS_n rd_n we_n;单比特信号打两拍</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cs_n_2bit, rd_n_2bit, we_n_2bit;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            &#123;cs_n_2bit, rd_n_2bit, we_n_2bit&#125; &lt;= &#123;<span class="number">2&#x27;b11</span>, <span class="number">2&#x27;b11</span>, <span class="number">3&#x27;b11</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            &#123;cs_n_2bit, rd_n_2bit, we_n_2bit&#125; &lt;= &#123;&#123;cs_n_2bit[<span class="number">0</span>], cs_n&#125;, &#123;rd_n_2bit[<span class="number">0</span>], rd_n&#125;, &#123;we_n_2bit[<span class="number">0</span>], we_n&#125;&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//同样，对输入的地址和数据也打两拍</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] addr_2clk;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] data_2clk;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            &#123;addr_2clk, data_2clk&#125; &lt;= &#123;<span class="number">16&#x27;b0</span>, <span class="number">32&#x27;b0</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            &#123;addr_2clk, data_2clk&#125; &lt;= &#123;&#123;addr_2clk[<span class="number">7</span>:<span class="number">0</span>], addr&#125;, &#123;data_2clk[<span class="number">15</span>:<span class="number">0</span>], data&#125;&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//三态门</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] data_r;</span><br><span class="line">    <span class="keyword">assign</span> data = (cs_n_2bit[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; we_n == <span class="number">1&#x27;b1</span> &amp;&amp; rd_n_2bit[<span class="number">1</span>] == <span class="number">1&#x27;b0</span>) ? data_r : <span class="number">16&#x27;hzzzz</span>;  <span class="comment">//当读拉低时，将数据输出给外部设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读时序：外部设备读FPGA</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_r &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cs_n_2bit[<span class="number">1</span>] == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(we_n_2bit[<span class="number">1</span>] == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span>          <span class="comment">//在写拉高时，先把要读的数的地址获得，提前知道要读哪个数</span></span><br><span class="line">                data_r &lt;= rom_data[addr_2clk[<span class="number">15</span>:<span class="number">8</span>]];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写时序：外部设备对FPGA写</span></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                rom_data[i] &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cs_n_2bit[<span class="number">1</span>] == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(rd_n_2bit[<span class="number">1</span>] == <span class="number">1&#x27;b1</span> &amp;&amp; we_n_2bit[<span class="number">1</span>] == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">                rom_data[addr_2clk[<span class="number">15</span>:<span class="number">8</span>]] &lt;= data_2clk[<span class="number">31</span>:<span class="number">16</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="2-Testbench"><a href="#2-Testbench" class="headerlink" title="2.Testbench*"></a>2.Testbench*</h2><ul>
<li>testbench的测试方式值得学习，其实就根据时序图给出每个时序信号就可</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> asyn_parallel_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span>	setup_time=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">parameter</span>	hold_time=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">parameter</span>	data_time=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">parameter</span>	read_wait=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>		sclk,   rst_n;</span><br><span class="line">    <span class="keyword">reg</span>		cs_n,   rd_n,   wr_n;</span><br><span class="line">    <span class="keyword">reg</span>	    [<span class="number">15</span>:<span class="number">0</span>]	data;</span><br><span class="line">    <span class="keyword">reg</span>	    [<span class="number">7</span>:<span class="number">0</span>]	addr;</span><br><span class="line">    <span class="keyword">wire</span>	[<span class="number">15</span>:<span class="number">0</span>]	w_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        sclk =<span class="number">0</span>;</span><br><span class="line">        rst_n =<span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span> </span><br><span class="line">        rst_n =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        cs_n=<span class="number">1</span>;</span><br><span class="line">        rd_n=<span class="number">1</span>;</span><br><span class="line">        wr_n=<span class="number">1</span>;</span><br><span class="line">        data=<span class="number">0</span>;</span><br><span class="line">        addr=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">300</span>;</span><br><span class="line">        write_data(<span class="number">8</span>);</span><br><span class="line">        #<span class="number">100</span>;</span><br><span class="line">        read_data(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> sclk = ~sclk;</span><br><span class="line">    <span class="comment">//测试激励的三态门</span></span><br><span class="line">    <span class="keyword">assign</span>	w_data = (wr_n==<span class="number">1&#x27;b0</span>) ? data : <span class="number">16&#x27;hzzzz</span>; </span><br><span class="line">    <span class="comment">//写数据的任务</span></span><br><span class="line">    <span class="keyword">task</span>	write_data(<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] len);</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i=i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                cs_n=<span class="number">0</span>;</span><br><span class="line">                data=i[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">                addr=i[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">                setup_dly();</span><br><span class="line">                wr_n=<span class="number">0</span>;</span><br><span class="line">                data_dly();</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;write data addr is %d = %d&quot;</span>,i,w_data);</span><br><span class="line">                wr_n=<span class="number">1</span>;</span><br><span class="line">                hold_dly();</span><br><span class="line">                <span class="comment">//cs_n=1;</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            cs_n =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">task</span>	read_data(<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] len);</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i=i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                cs_n=<span class="number">0</span>;</span><br><span class="line">                addr=i[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">                read_dly();</span><br><span class="line">                rd_n=<span class="number">0</span>;</span><br><span class="line">                data_dly();</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;read data addr is %d = %d&quot;</span>,i,w_data);</span><br><span class="line">                rd_n=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            cs_n =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    asyn_parallel parall_interf_inst(</span><br><span class="line">        <span class="variable">.clk</span>		(sclk),<span class="comment">//50mhz</span></span><br><span class="line">        <span class="variable">.rst_n</span>		(rst_n),</span><br><span class="line">        <span class="variable">.cs_n</span>		(cs_n),</span><br><span class="line">        <span class="variable">.rd_n</span>		(rd_n),</span><br><span class="line">        <span class="variable">.we_n</span>		(wr_n),</span><br><span class="line">        <span class="variable">.data</span>		(w_data),<span class="comment">//1Mhz</span></span><br><span class="line">        <span class="variable">.addr</span>		(addr)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本的延时任务</span></span><br><span class="line">    <span class="keyword">task</span>	setup_dly();</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;setup_time;i=i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                @(<span class="keyword">posedge</span> sclk);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span>	hold_dly();</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;hold_time;i=i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                @(<span class="keyword">posedge</span> sclk);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span>	data_dly();</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;data_time;i=i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                @(<span class="keyword">posedge</span> sclk);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">task</span>	read_dly();</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;read_wait;i=i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                @(<span class="keyword">posedge</span> sclk);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>仿真结果：</p>
<p><img src="/2024/03/15/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F/image-20240322161832106.png" alt="image-20240322161832106"></p>
<p><img src="/2024/03/15/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F/image-20240322161921263.png" alt="image-20240322161921263"></p>
</li>
</ul>
<h2 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3.Reference"></a>3.Reference</h2><ul>
<li><a href="https://www.bilibili.com/video/BV1j441117a9?p=11&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">ex_8FPGA与CPU芯片进行并口通信，驱动技巧；_哔哩哔哩_bilibili</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA设计高级技巧之状态机</title>
    <url>/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<p>本节主要介绍了编写状态机时要注意的细节，后续在实际工作中遇到状态机的坑也会在此记录。</p>
<span id="more"></span>
<h1 id="状态机的编码方式"><a href="#状态机的编码方式" class="headerlink" title="状态机的编码方式"></a>状态机的编码方式</h1><ul>
<li><p>具体的编码方式有三种：</p>
<ul>
<li><p><strong>顺序码</strong>：状态编码遵循传统的状态二进制序列</p>
<p> <img src="/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/image-20240411221917212.png" alt="image-20240411221917212" style="zoom: 50%;"></p>
</li>
<li><p><strong>格雷码</strong>：除了相邻状态编码之间只有一个位变化外，其他和顺序码类似</p>
<p> <img src="/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/image-20240411221940827.png" alt="image-20240411221940827" style="zoom:50%;"></p>
</li>
<li><p><strong>独热码</strong>：这种方法是在状态机中为每一种状态分配一个触发器。只有一个触发器当前设置有效，其余均设置为无效，故称为“独热”</p>
<p> <img src="/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/image-20240411221954703.png" alt="image-20240411221954703" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>假设使用的是格雷码，由于相邻两个数据之间只有一位不同，所以可在很大程度上消除由延时引起的过渡状态。使用格雷码虽然可以大大降低产生过渡状态的概率，<strong>但如果当一个状态到下一个状态有多种转换路径时，就不能保证状态跳转时只有一个位变化，这样，将无法发挥格雷码的特点</strong>。</p>
</li>
<li><p>所以，<strong>需要仔细分析状态机的结果，如果状态机中某个状态跳转方向多于一个，此时慎用格雷码，可以采用独热码</strong></p>
</li>
</ul>
<hr>
<h1 id="多进程状态机"><a href="#多进程状态机" class="headerlink" title="多进程状态机"></a>多进程状态机</h1><ul>
<li><p>在状态机的描述中，多进程方式使用较多，双进程和三进程描述方式中，三进程描述方式仅仅比双进程多使用了一个进程对状态的输出进行描述</p>
</li>
<li><p>三进程状态机又分为两种，第一种是输出进程使用组合逻辑进行描述；第二种是使用时序逻辑对输出进行描述，其余两个进程完全相同</p>
</li>
<li><p><strong>一般来说，使用寄存器输出可以改变输出的时序条件，还能避免组合电路的毛刺，所以是推荐的描述方式</strong></p>
<p><img src="/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/image-20240411220452371.png" alt="image-20240411220452371" style="zoom: 33%;"></p>
</li>
<li><p>上述<strong>这种结构可以有效地抑制过渡状态的出现，这是因为输出寄存器只要求状态值在时钟边沿稳定</strong></p>
</li>
<li><p>但是它占用的资源更多，状态机的输出增加了一个时钟周期的延时。但现在逻辑器件的规模越来越大，不在意这一点点资源的消耗，至于输出的延时，对于同步设计来说，都是流水操作，一般不会影响到整个系统的性能</p>
</li>
</ul>
<hr>
<h1 id="设计综合工具能够识别的状态机"><a href="#设计综合工具能够识别的状态机" class="headerlink" title="设计综合工具能够识别的状态机"></a>设计综合工具能够识别的状态机</h1><ul>
<li><p>如果使用的是SystemVerilog，一定要使用<strong>枚举类型</strong>来描述状态机</p>
</li>
<li><p>如果在状态转换逻辑中使用了下例所示的<strong>算术运算</strong>，那么综合工具将不会识别状态机</p>
<p><img src="/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/image-20240411221339251.png" alt="image-20240411221339251" style="zoom:33%;"></p>
</li>
<li><p><strong>如果将状态变量作为输出</strong>，那么综合工具将无法识别状态机</p>
</li>
<li><p><strong>状态机中使用有符号变量</strong>，那么综合工具将无法识别状态机</p>
</li>
</ul>
<hr>
<h1 id="附加知识点"><a href="#附加知识点" class="headerlink" title="附加知识点"></a>附加知识点</h1><h2 id="1-modelsim使用run-do脚本仿真"><a href="#1-modelsim使用run-do脚本仿真" class="headerlink" title="1.modelsim使用run.do脚本仿真"></a>1.modelsim使用run.do脚本仿真</h2><ul>
<li><p>套个模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#run.do文件中#代表注释</span><br><span class="line"></span><br><span class="line">#退出当前仿真功能</span><br><span class="line">quit -sim</span><br><span class="line">#清除命令行显示信息</span><br><span class="line">.main clear</span><br><span class="line"></span><br><span class="line">#vlib为创建库</span><br><span class="line">vlib	./lib/</span><br><span class="line">vlib	./lib/work_a/</span><br><span class="line">vlib	./lib/design/</span><br><span class="line">#映射逻辑库名，将逻辑库名映射库路径</span><br><span class="line">vmap	base_space ./lib/work_a/</span><br><span class="line">vmap	design	./lib/design/</span><br><span class="line"></span><br><span class="line">#vlog -work代表编译</span><br><span class="line">vlog	-work base_space	./tb_mealy.v</span><br><span class="line">vlog	-work design		./../design/*.v</span><br><span class="line">#vsim为启动仿真</span><br><span class="line">#-t 运行仿真的时间精度是ns</span><br><span class="line">#-L 是链接库关键字</span><br><span class="line">vsim	-t ns  -voptargs=+acc -L base_space -L design base_space.tb_mealy</span><br><span class="line"></span><br><span class="line">#用虚拟信号表示状态信息</span><br><span class="line">virtual	type &#123;</span><br><span class="line">&#123;01 S1&#125;</span><br><span class="line">&#123;02 S2&#125;</span><br><span class="line">&#123;04 S3&#125;</span><br><span class="line">&#123;08 S4&#125;</span><br><span class="line">&#123;10 S5&#125;</span><br><span class="line">&#123;20 S6&#125;</span><br><span class="line">&#125; vir_new_signal</span><br><span class="line"></span><br><span class="line">#add wave用来添加波形</span><br><span class="line">#-divider用来分组</span><br><span class="line">add wave	-divider &#123;tb_mealy_1&#125;</span><br><span class="line">add wave	tb_mealy/*</span><br><span class="line">add wave	-divider &#123;mealy&#125;</span><br><span class="line">#顶层/例化的名字/* 其中*号是通配符，匹配所有信号</span><br><span class="line">add wave	tb_mealy/mealy_inst/*</span><br><span class="line">#创建一个vir_new_signal 类型的信号，也就是把Currt_st进行类型转换</span><br><span class="line">virtual	function &#123;(vir_new_signal)tb_mealy/mealy_inst/Curr_st&#125; new_state</span><br><span class="line">add wave  -color red	tb_mealy/mealy_inst/new_state</span><br><span class="line"></span><br><span class="line">run 1us</span><br></pre></td></tr></table></figure>
</li>
<li><p>对应文件夹（在sim文件夹下建一个modelsim工程）：</p>
<p> <img src="/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/image-20240306222959762.png" alt="image-20240306222959762" style="zoom:80%;"></p>
</li>
<li><p>如果因为<code>-voptargs=+acc</code>报错，见<a href="https://blog.csdn.net/Tina_yaoyao/article/details/45127259">关于 modelsim仿真时出现No objects found matching ‘/*’问题-CSDN博客</a>第一种解决办法即可</p>
</li>
<li><p>浅粘一个仿真结果：</p>
<p><img src="/2024/02/25/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA/image-20240306223312601.png" alt="image-20240306223312601"></p>
</li>
</ul>
<h2 id="2-testbench运用task的某写法"><a href="#2-testbench运用task的某写法" class="headerlink" title="2.testbench运用task的某写法"></a>2.testbench运用task的某写法</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> in_data();</span><br><span class="line">	<span class="keyword">integer</span> i;</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">1024</span>;i=i+<span class="number">1</span>)	</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">			@(<span class="keyword">posedge</span> sclk);	<span class="comment">/****for循环里面包含@(clk)，这写法有点意思******/</span></span><br><span class="line">			<span class="keyword">if</span>(i&lt;<span class="number">50</span>)</span><br><span class="line">				in_A=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">200</span>)</span><br><span class="line">				in_A=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">700</span>)</span><br><span class="line">				in_A=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">800</span>)</span><br><span class="line">				in_A=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">900</span>)</span><br><span class="line">				in_A=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA设计高级技巧之时钟域</title>
    <url>/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/</url>
    <content><![CDATA[<p>本节主要介绍了单比特与多比特信号跨时钟域的常见解决办法。</p>
<span id="more"></span>
<h1 id="时钟域"><a href="#时钟域" class="headerlink" title="时钟域"></a>时钟域</h1><ul>
<li><p>单一时钟域：所谓单一时钟域，是指只有一个独立的网络可以驱动整个设计中所有触发器的时钟端口。</p>
</li>
<li><p>时钟域：是指一组逻辑，这组逻辑中的所有同步单元（触发器、同步RAM块以及流水乘法器等）都使用同一网络作为时钟。</p>
</li>
<li><p>并不一定是FPGA只有一个外部时钟输入就是单时钟域了。例如<strong>逻辑门控可以产生时钟</strong>，同样PLL也可以产生多个时钟输出供内部逻辑使用，只不过PLL的输出时钟之间一般具有相关性。<strong>由于PLL产生了多个时钟输出，所以这样的设计也属于多时钟域设计</strong>。</p>
</li>
<li><p>上句话想表达的应该是输入给FPGA内部使用的时钟（由外部时钟分频或者门控等产生），如果是不同的时钟，那么就是多时钟域，如果只有一个时钟，那么就是单时钟域。</p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120185417972.png" alt="image-20240120185417972" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h1 id="单比特信号跨时钟域的同步处理"><a href="#单比特信号跨时钟域的同步处理" class="headerlink" title="单比特信号跨时钟域的同步处理"></a>单比特信号跨时钟域的同步处理</h1><ul>
<li>跨时钟域是指设计中存在两个或两个以上异步时钟域。（我目前对异步时钟域的理解是，由不同外部时钟源产生的时钟，但好像大家分析问题的时候往往把它当成不同频率或者不同相位的时钟了）</li>
</ul>
<h2 id="1-亚稳态及其危害"><a href="#1-亚稳态及其危害" class="headerlink" title="1.亚稳态及其危害"></a>1.亚稳态及其危害</h2><ul>
<li><p>对于沿触发的触发器来说，其输出存在“1”或“0”两个有效状态。</p>
</li>
<li><p>触发器的建立时间和保持时间在时钟上升沿左右定义了一个时间窗口，如果触发器数据输入端口上的数据在这个时间窗口内发生变化，那么就会产生时序违规。</p>
</li>
<li><p>此时触发器内部的某个节点可能会在一个电压范围内浮动，无法稳定在逻辑0或逻辑1状态。</p>
</li>
<li><p><strong>从时序收敛的角度来说，两个触发器之间的组合逻辑延时要求小于最小的时钟周期，但这种亚稳态信号保持亚稳态的时间，本身就是变相增加了逻辑延时。</strong></p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120191136421.png" alt="image-20240120191136421" style="zoom:33%;"></p>
</li>
</ul>
<h2 id="2-处理亚稳态的经典方法：双触发"><a href="#2-处理亚稳态的经典方法：双触发" class="headerlink" title="2.处理亚稳态的经典方法：双触发"></a>2.处理亚稳态的经典方法：双触发</h2><ul>
<li><p>常见的同步器是使用两级寄存器，即使用<strong>寄存器打两拍的方式</strong>进行同步。<strong>所谓的同步器就是采样一个异步信号，采样输出能够同步到到采样时钟的模块。</strong></p>
</li>
<li><p>该方法一般用于同步慢速信号到快速时钟域，因为快时钟域是肯定可以采集到慢时钟域的数据的（<strong>如果快速时钟域的时钟频率是慢速时钟域的1.5倍以上，那么同步较慢的控制信号到一个快速时钟域通常来说不会有问题</strong>），所以需要解决的就是亚稳态的问题</p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120191713706.png" alt="image-20240120191713706" style="zoom:33%;"></p>
</li>
<li><p>当然，仍然有可能级联的第二个寄存器输出还会表现为非稳定状态，但是这种双寄存同步器已经可以解决大部分亚稳态问题。在设计这种同步器的时候应当注意遵循以下原则：</p>
<ul>
<li><p><strong>级联的寄存器必须使用同一个采样时钟</strong></p>
</li>
<li><p><strong>发送端时钟域寄存器输出和接收端异步时钟域级联寄存器输入之间不能有任何其他组合逻辑。因为由于组合逻辑会产生毛刺，这样同步器很有可能采样到不需要的数据。</strong></p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120192032537.png" alt="image-20240120192032537" style="zoom:33%;"></p>
</li>
<li><p><strong>同步器中级联的寄存器除了最后一个寄存器外所有的寄存器只能有一个扇出，即其只能驱动下一级寄存器的输入</strong></p>
</li>
</ul>
</li>
<li><p>另外，只要同步器中寄存器链处于同一时钟域，那么寄存器链中寄存器路径之间是可以存在组合逻辑的。</p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120192351712.png" alt="image-20240120192351712" style="zoom:33%;"></p>
</li>
<li><p>一些高速设计中需要再额外加入一级寄存器来增加MTBF（平均故障间隔时间），也即同步器中两级寄存器的MTBF太短。</p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120192659688.png" alt="image-20240120192659688" style="zoom: 25%;"></p>
</li>
</ul>
<h2 id="3-同步快速信号到慢速时钟域"><a href="#3-同步快速信号到慢速时钟域" class="headerlink" title="3.同步快速信号到慢速时钟域"></a>3.同步快速信号到慢速时钟域</h2><ul>
<li><p>如果丢失信号采样值对于设计来说是不允许的，那么有两种通用的应用方法可以解决这个问题：</p>
<ul>
<li>一个是<strong>开环</strong>解决方案，确保信号在无须确认的情况下可以被采集</li>
<li>另一个是<strong>闭环</strong>解决方案，即在跨时钟域边界时，信号需要接收端的反馈确认。</li>
</ul>
</li>
<li><p><strong>开环解决方案是</strong>：仍然采取之前介绍的打两拍同步器来采样跨时钟域信号，但是<strong>前提是需要先将目标展宽，最佳的脉宽是至少为采样时钟周期的1.5倍，这样跨时钟域信号将会被接收时钟域的时钟至少稳定地采样一次。</strong></p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120194307407.png" alt="image-20240120194307407" style="zoom: 33%;"><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120194326051.png" alt="image-20240120194326051" style="zoom: 33%;"></p>
<p> <img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120194557613.png" alt="image-20240120194557613" style="zoom: 33%;"></p>
</li>
<li><p><strong>闭环解决方案是</strong>：在发送时钟域将数据同步到接收时钟域，再通过反馈回发送时钟域，通过一定逻辑判断，只有当接收数据与发送数据相等时，才传输第下一个数据</p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120202038949.png" alt="image-20240120202038949" style="zoom:33%;"></p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120202304216.png" alt="image-20240120202304216" style="zoom: 50%;"></p>
</li>
</ul>
<hr>
<h1 id="多比特信号跨时钟域同步处理"><a href="#多比特信号跨时钟域同步处理" class="headerlink" title="多比特信号跨时钟域同步处理"></a>多比特信号跨时钟域同步处理</h1><ul>
<li><p>为什么多比特数据跨时钟域时不能采用打两拍的方式处理？如下图所示，<strong>每个寄存器的位置不同，布局布线和逻辑的不同会导致每比特数据到达下一级寄存器的延时不同</strong>，而且延时会随着打拍数的增加、数据位宽的增加、时钟频率的增大而变得更加恶劣</p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120202805830.png" alt="image-20240120202805830" style="zoom: 50%;"></p>
</li>
<li><p>多比特信号跨时钟域同步处理通常采用以下三种方式：</p>
<ul>
<li><strong>多比特信号融合策略</strong>：即在可能的情况下，将多比特跨时钟信号融合成单比特跨时钟域信号</li>
<li><strong>多周期路径规划策略</strong>：即使用同步加载信号来安全地传递多比特跨时钟域信号</li>
<li><strong>使用格雷码传递多比特跨时钟域信号</strong></li>
</ul>
</li>
</ul>
<h2 id="1-多比特信号融合"><a href="#1-多比特信号融合" class="headerlink" title="1.多比特信号融合"></a>1.多比特信号融合</h2><ul>
<li><p>将加载和使能两个控制信号融合成一个单比特信号（这两个控制信号本身相同，且同时有效）</p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120203400280.png" alt="image-20240120203400280" style="zoom: 33%;"><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120203425444.png" alt="image-20240120203425444" style="zoom:33%;"></p>
</li>
<li><p>当两个控制信号需要流水间隔一个时钟周期时，要增加一个额外的寄存器将同步后的使能控制信号寄存一拍，这样数据和控制信号形成匹配的流水。</p>
<p><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120203715571.png" alt="image-20240120203715571" style="zoom: 33%;"><img src="/2024/01/20/FPGA%E8%AE%BE%E8%AE%A1%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%97%B6%E9%92%9F%E5%9F%9F/image-20240120203740266.png" alt="image-20240120203740266" style="zoom: 33%;"></p>
</li>
</ul>
<h2 id="2-多周期路径规划"><a href="#2-多周期路径规划" class="headerlink" title="2.多周期路径规划"></a>2.多周期路径规划</h2><ul>
<li>暂时没懂？有一个边沿检测作为同步？？？</li>
</ul>
<h2 id="3-使用FIFO结构处理多比特跨时钟域信号"><a href="#3-使用FIFO结构处理多比特跨时钟域信号" class="headerlink" title="3.使用FIFO结构处理多比特跨时钟域信号"></a>3.使用FIFO结构处理多比特跨时钟域信号</h2><ul>
<li>跨时钟域传输数据用得最多的方法就是使用先入先出结构。FIFO可以用于在两个异步时钟域之间传输多比特信号。格雷码常用于在异步时钟域之间传递多比特计数值，且多用于FIFO内。</li>
<li>有关FIFO的详细内容具体见我的另一篇文章：<a href="https://ssy1938010014.github.io/2023/12/24/FPGA数字信号处理之FIFO/">FPGA数字信号处理之FIFO | ssy的小天地 (ssy1938010014.github.io)</a></li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><p><a href="https://www.cnblogs.com/superego-zhang/p/17499419.html">快时钟域到慢时钟域 - superego_zhang - 博客园 (cnblogs.com)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/luoai_2666/article/details/119653178">跨时钟域信号如何处理（二、多bit信号）_跨时钟域处理 多位不相关信号-CSDN博客</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA实现CNN之卷积神经网络理论基础</title>
    <url>/2024/01/18/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本节主要介绍了卷积神经网络最基础的知识。</p>
<span id="more"></span>
<h1 id="单层神经网络"><a href="#单层神经网络" class="headerlink" title="单层神经网络"></a>单层神经网络</h1><p><img src="/2024/01/18/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/image-20240118183520659.png" alt="image-20240118183520659" style="zoom: 67%;"></p>
<h2 id="1-NN反向传播的推导"><a href="#1-NN反向传播的推导" class="headerlink" title="1.NN反向传播的推导"></a>1.NN反向传播的推导</h2><ul>
<li><p>梯度下降的公式为：</p>
<script type="math/tex; mode=display">
w=w-\alpha\cdot \frac{\partial L(w,b)}{\partial w}\\
b = b-\alpha\cdot \frac{\partial L(w,b)}{\partial b}</script></li>
<li><p>激活函数Sigmoid(x)：</p>
<script type="math/tex; mode=display">
Sigmoid(x) = \frac{1}{1+e^{-x}}\\
Sigmoid'(x)= S\cdot (1-S)</script></li>
<li><p>损失函数Loss：</p>
<script type="math/tex; mode=display">
L (w,b)= \frac12(Z_{out}-Z_{gold})^2\\
L' (w,b)= (Z_{out}-Z_{gold})</script><ul>
<li>其中，$Zout$为神经网络的输出结果，$Z_{gold}$为神经网络的标签</li>
</ul>
</li>
<li><p>以求$w_5$的反向传播为例（先假设学习率为1）：</p>
<ul>
<li><p>首先，$w_5$梯度下降公式为：</p>
<script type="math/tex; mode=display">
w_5 = w_5 -\frac{\partial L(w,b)}{\partial w_5}</script></li>
<li><p>那么，主要就是求解$\frac{\part L(w.b)}{\part w_5}$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\part L(w,b)}{\part w_5} &=\frac{\part L(w,b)}{\part Z_{out}}\cdot \frac{\part Z_{out}}{\part w_5}\\
&=(Z_{out}-Z_{gold})\frac{\part Z_{out}}{\part w_5}\\
&=(Z_{out}-Z_{gold})\cdot Z_{out}\cdot(1-Z_{out})\cdot z_1
\end{aligned}</script><ul>
<li>其中，$Z_{out} = S(z_1w_5+z_2w_6+b_3),\frac{\part Z_{out}}{\part w_5}=S’(z_1w_5+z_2w_6+b_3)\cdot z_1$</li>
</ul>
</li>
</ul>
</li>
<li><p>以求$w_1$的反向传播为例（先假设学习率为1）：</p>
<ul>
<li><p>首先，$w_1$的梯度下降公式为：</p>
<script type="math/tex; mode=display">
w_1 = w_1-\frac{\part L(w,b)}{\part w_1}</script></li>
<li><p>那么，主要就是求解$\frac{\part L(w,b)}{\part w_1}$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\part L(w,b)}{\part w_1} &= \frac{\part L(w,b)}{\part Z_{out}}\frac{\part Z_{out}}{\part z_1}\frac{\part z_1}{\part w_1}\\
& = (Z_{out}-Z_{gold})\frac{\part z_{out}}{\part z_1}\frac{\part z_1}{\part w_1}\\
& = (Z_{out}-Z_{gold})\cdot (Z_{out}(1-Z_{out}))w_5\cdot\frac{\part z_1}{\part w_1}\\
& = (Z_{out}-Z_{gold})\cdot (Z_{out}(1-Z_{out}))w_5\cdot(z_1(1-z_1))x_0
\end{aligned}</script><ul>
<li>其中，$z_1 = Sigmoid(w_1x_0+w_2x_1+b_1)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-MATLAB仿真实现"><a href="#2-MATLAB仿真实现" class="headerlink" title="2.MATLAB仿真实现"></a>2.MATLAB仿真实现</h2><ul>
<li><p>LNN.m</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line"><span class="comment">%//////// 训练集 ///////// WX - B</span></span><br><span class="line">data_set = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">            <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">            <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;</span><br><span class="line">            <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">[data_set_len,~]=<span class="built_in">size</span>(data_set);</span><br><span class="line"><span class="comment">%/////// 常量定义 ///////</span></span><br><span class="line">PERCISION = <span class="number">0.0001</span>;</span><br><span class="line">ALPHA = <span class="number">0.5</span>;</span><br><span class="line">INPUT_LAYER_CNUM = <span class="number">2</span>;</span><br><span class="line">HIDDEN_LAYER_CNUM = <span class="number">2</span>;</span><br><span class="line">OUTPUT_LAYER_CNUM = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">hidden_weights = <span class="built_in">rand</span>(HIDDEN_LAYER_CNUM,INPUT_LAYER_CNUM + <span class="number">1</span> );</span><br><span class="line">output_weights = <span class="built_in">rand</span>(OUTPUT_LAYER_CNUM,HIDDEN_LAYER_CNUM + <span class="number">1</span> );</span><br><span class="line">hidden_out=<span class="built_in">zeros</span>(<span class="number">1</span>,HIDDEN_LAYER_CNUM);</span><br><span class="line">loss = <span class="number">1</span>;</span><br><span class="line"><span class="comment">%/////// 训练 [调整参数的过程] //////////</span></span><br><span class="line"><span class="keyword">while</span>(loss &gt; PERCISION )</span><br><span class="line">    loss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:data_set_len</span><br><span class="line">        <span class="comment">%///// 正向传播 //////</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:HIDDEN_LAYER_CNUM</span><br><span class="line">            tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> k=<span class="number">1</span>:INPUT_LAYER_CNUM</span><br><span class="line">                tmp = tmp + hidden_weights(<span class="built_in">i</span>,k)*data_set(<span class="built_in">j</span>,k);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            tmp = tmp - hidden_weights(<span class="built_in">i</span>,INPUT_LAYER_CNUM+<span class="number">1</span>) ;</span><br><span class="line">            hidden_out(<span class="number">1</span>,<span class="built_in">i</span>) = f_sigmoid(tmp);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        zout = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:HIDDEN_LAYER_CNUM</span><br><span class="line">            zout = zout + output_weights(<span class="number">1</span>,<span class="built_in">i</span>)*hidden_out(<span class="number">1</span>,<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        zout = zout - output_weights(<span class="number">1</span>,HIDDEN_LAYER_CNUM+<span class="number">1</span>);</span><br><span class="line">        zout = f_sigmoid(zout);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%///// 反向传播 //////</span></span><br><span class="line">        <span class="comment">%---- 输出层反向传播 -------</span></span><br><span class="line">        d = (zout - data_set(<span class="built_in">j</span>,INPUT_LAYER_CNUM+<span class="number">1</span>))*zout*(<span class="number">1</span>-zout)*ALPHA;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:HIDDEN_LAYER_CNUM</span><br><span class="line">            output_weights(<span class="number">1</span>,<span class="built_in">i</span>) = output_weights(<span class="number">1</span>,<span class="built_in">i</span>) - d * hidden_out(<span class="number">1</span>,<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        output_weights(<span class="number">1</span>,HIDDEN_LAYER_CNUM+<span class="number">1</span>)=output_weights(<span class="number">1</span>,HIDDEN_LAYER_CNUM+<span class="number">1</span>)-(-d);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%---- 隐藏层反向传播 -------</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span>:HIDDEN_LAYER_CNUM</span><br><span class="line">            dd = d*output_weights(<span class="number">1</span>,<span class="built_in">i</span>)*hidden_out(<span class="number">1</span>,<span class="built_in">i</span>)*(<span class="number">1</span>-hidden_out(<span class="number">1</span>,<span class="built_in">i</span>))*ALPHA;</span><br><span class="line">             <span class="keyword">for</span> k = <span class="number">1</span>:INPUT_LAYER_CNUM</span><br><span class="line">                hidden_weights(<span class="built_in">i</span>,k) = hidden_weights(<span class="built_in">i</span>,k) - dd*data_set(<span class="built_in">j</span>,k);</span><br><span class="line">             <span class="keyword">end</span></span><br><span class="line">            hidden_weights(<span class="built_in">i</span>,INPUT_LAYER_CNUM+<span class="number">1</span>) = hidden_weights(<span class="built_in">i</span>,INPUT_LAYER_CNUM+<span class="number">1</span>)-(-dd);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">%///// 更新损失值loss //////</span></span><br><span class="line">        loss = loss + (zout -data_set(<span class="built_in">j</span>,INPUT_LAYER_CNUM+<span class="number">1</span>))^<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(loss)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% /////// 预测 [检验参数的过程] //////////</span></span><br><span class="line">x=[<span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">z1 = x(<span class="number">1</span>,<span class="number">1</span>)*hidden_weights(<span class="number">1</span>,<span class="number">1</span>)+x(<span class="number">1</span>,<span class="number">2</span>)*hidden_weights(<span class="number">1</span>,<span class="number">2</span>)-hidden_weights(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">z1 = f_sigmoid(z1);</span><br><span class="line"></span><br><span class="line">z2 = x(<span class="number">1</span>,<span class="number">1</span>)*hidden_weights(<span class="number">2</span>,<span class="number">1</span>)+x(<span class="number">1</span>,<span class="number">2</span>)*hidden_weights(<span class="number">2</span>,<span class="number">2</span>)-hidden_weights(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">z2 = f_sigmoid(z2);</span><br><span class="line"></span><br><span class="line">zout_ = z1 * output_weights(<span class="number">1</span>,<span class="number">1</span>) + z2 * output_weights(<span class="number">1</span>,<span class="number">2</span>) - output_weights(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">zout_ = f_sigmoid(zout_);</span><br><span class="line"><span class="built_in">disp</span>(zout_)</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">round</span>(zout_))</span><br></pre></td></tr></table></figure>
</li>
<li><p>f_sigmoid.m</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span> = <span class="title">f_sigmoid</span><span class="params">( x )</span></span></span><br><span class="line">    result = <span class="number">1</span>/(<span class="number">1</span>+<span class="built_in">exp</span>(-x));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="1-卷积层"><a href="#1-卷积层" class="headerlink" title="1.卷积层"></a>1.卷积层</h2><p><img src="/2024/01/18/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/image-20240122150347941.png" alt="image-20240122150347941" style="zoom: 33%;"></p>
<p><img src="/2024/01/18/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/image-20240122150454168.png" alt="image-20240122150454168" style="zoom:33%;"></p>
<ul>
<li><p><strong>存在权值共享</strong></p>
<p><img src="/2024/01/18/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/image-20240122150540306.png" alt="image-20240122150540306" style="zoom:33%;"></p>
</li>
<li><p><strong>卷积核大小</strong>决定感受野大小</p>
</li>
<li><p><strong>卷积核的数量</strong>决定所能提取特征的多少</p>
</li>
<li><p><strong>卷积核的步长</strong>影响计算量以及特征提取的质量</p>
</li>
<li><p><strong>卷积前后图像尺寸</strong>：</p>
<ul>
<li><p>设步长为s，填充为p，输入图像I的尺寸为$I_H\times I_W$，卷积核K的尺寸为$K_H\times K_W$</p>
<script type="math/tex; mode=display">
W_{out} = floor(\frac{I_W+2p-K_W}{s}+1)\\
H_{out} = floor(\frac{I_H+2p-K_H}{s}+1)</script><ul>
<li>其中，$floor$表示向下取整</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-激活层"><a href="#2-激活层" class="headerlink" title="2.激活层"></a>2.激活层</h2><ul>
<li><p>为什么需要激活层？</p>
<ul>
<li>卷积层都是线性运算，缺少非线性运算的能力</li>
<li>并不是所有非线性函数都可以用CNN中激活的操作</li>
</ul>
</li>
<li><p>考虑梯度消失/梯度爆炸问题</p>
<p><img src="/2024/01/18/FPGA%E5%AE%9E%E7%8E%B0CNN%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/image-20240122200530083.png" alt="image-20240122200530083" style="zoom:50%;"></p>
<ul>
<li>考虑对$b_1$的反向传播，重点在于求解$\frac{\part F}{\part b_1}$</li>
<li><p>$y_i = \sigma(z_i) = \sigma(w_ix_i+b_i)$、$x_i = y_{i-1}$、$L$是损失函数</p>
</li>
<li><p>那么，有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\part L}{\part b_1}&=\frac{\part L}{\part y_n}\frac{\part y_n}{\part z_n}\frac{\part z_n}{\part x_n}\frac{\part x_n}{\part z_{n-1}}\cdots \frac{\part z_2}{\part x_2}\frac{\part x_2}{\part z_1}\frac{\part z_1}{\part b_1}\\
&=\frac{\part L}{\part y_n}\sigma'(z_n)w_n\cdots\sigma'(z_3)w_3\sigma'(z_2)w_2\sigma'(z_1)1
\end{aligned}</script></li>
<li><p><strong>梯度消失</strong>：指激活函数导数乘权重小于1时，在多层链式求导中，出现梯度快速接近0的现象</p>
</li>
<li><p><strong>梯度爆炸</strong>：指激活函数导数乘权重大于1时，在多层链式求导中，出现梯度快速增大的现象（甚至溢出）</p>
</li>
</ul>
</li>
<li><p>激活函数选取要求：</p>
<ul>
<li>是一个非线性函数</li>
<li>计算简单</li>
<li>单调性</li>
<li>可导性</li>
<li>非饱和性：当激活函数的导数在自变量趋近于无穷大时，导数结果趋近于0，那么则称存在饱和性</li>
</ul>
</li>
<li><p>常见的激活函数：</p>
<ul>
<li>Sigmoid函数$Sigmoid(x) = \frac1{1+e^{-x}}$：<ul>
<li>Sigmoid函数容易产生梯度消失</li>
<li>Sigmoid函数中有幂运算，增加计算时间</li>
</ul>
</li>
<li>Tanh双曲正切函数$tanh(x) = \frac{e^x-e^{-x }}{e^x+e^{-x}}$：<ul>
<li>Tanh存在梯度消失问题</li>
<li>Tanh存在计算量较大问题</li>
</ul>
</li>
<li>ReLU函数：<ul>
<li>ReLU函数在$x\ge 0$时，不存在梯度消失问题</li>
<li>ReLU函数计算简单</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-池化层"><a href="#3-池化层" class="headerlink" title="3.池化层"></a>3.池化层</h2><ul>
<li><p>池化缩小了数据尺寸，尽可能保留原数据特征信息，数据压缩</p>
</li>
<li><p>抑制噪声</p>
</li>
<li><p>减少了所需要的训练参数，降低网络规模与复杂量</p>
</li>
<li><p>在空间上实现了感受野的增大，有利于提高小卷积核在大尺度特征上的提取能力</p>
</li>
<li><p><strong>池化层前后图像尺寸</strong>：</p>
<ul>
<li>设步长为s，输入图像I的尺寸为$I_H\times I_W$，池化尺寸为K<script type="math/tex; mode=display">
W_{out} = floor(\frac{I_W-K}{s}+1)\\
H_{out} = floor(\frac{I_H-K}{s}+1)</script></li>
</ul>
</li>
</ul>
<h2 id="4-CNN的反向传播推导"><a href="#4-CNN的反向传播推导" class="headerlink" title="4.CNN的反向传播推导"></a>4.CNN的反向传播推导</h2>]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog之进阶级刷题</title>
    <url>/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>本文主要对牛客网Verilog刷题中的进阶习题进行记录。</p>
<span id="more"></span>
<h1 id="输入序列连续的序列检测"><a href="#输入序列连续的序列检测" class="headerlink" title="输入序列连续的序列检测"></a>输入序列连续的序列检测</h1><ul>
<li><p>请编写一个序列检测模块，检测输入信号a是否满足01110001序列，当信号满足该序列，给出指示信号match。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240113174445243.png" alt="image-20240113174445243"></p>
</li>
<li><p>sequence_detect_easy.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> sequence_detect_easy(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> a,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">parameter</span> IDLE = <span class="number">4&#x27;d0</span>,  <span class="comment">//初始状态</span></span><br><span class="line">              S1 = <span class="number">4&#x27;d1</span>,    <span class="comment">//&quot;0&quot;</span></span><br><span class="line">              S2 = <span class="number">4&#x27;d2</span>,    <span class="comment">//&quot;01&quot;</span></span><br><span class="line">              S3 = <span class="number">4&#x27;d3</span>,    <span class="comment">//&quot;011&quot;</span></span><br><span class="line">              S4 = <span class="number">4&#x27;d4</span>,    <span class="comment">//&quot;0111&quot;</span></span><br><span class="line">              S5 = <span class="number">4&#x27;d5</span>,    <span class="comment">//&quot;01110&quot;</span></span><br><span class="line">              S6 = <span class="number">4&#x27;d6</span>,    <span class="comment">//&quot;011100&quot;</span></span><br><span class="line">              S7 = <span class="number">4&#x27;d7</span>,    <span class="comment">//&quot;0111000&quot;</span></span><br><span class="line">              S8 = <span class="number">4&#x27;d8</span>;    <span class="comment">//&quot;01110001&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] state,next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (state)</span><br><span class="line">            IDLE: next_state = a ? IDLE : S1;</span><br><span class="line">            S1: next_state = a ? S2 : S1;</span><br><span class="line">            S2: next_state = a ? S3 : S1;</span><br><span class="line">            S3: next_state = a ? S4 : S1;</span><br><span class="line">            S4: next_state = a ? IDLE : S5;</span><br><span class="line">            S5: next_state = a ? S2 : S6;</span><br><span class="line">            S6: next_state = a ? S2 : S7;</span><br><span class="line">            S7: next_state = a ? S8 : S1;</span><br><span class="line">            S8: next_state = a ? S3 : S1;   <span class="comment">//这里实际上重复检测了，重复的是“011”</span></span><br><span class="line">            <span class="keyword">default</span>: next_state = IDLE;     <span class="comment">//本来想省略一个状态的，但若省略S8，那么输出会提前一个clk输出，且不能重复检测</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出时序</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            match &lt;= (state == S8) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用移位寄存器实现序列检测器会更简单</span></span><br><span class="line"><span class="comment">`timescale 1ns/1ns</span></span><br><span class="line"><span class="comment">module sequence_detect(</span></span><br><span class="line"><span class="comment">	input clk,</span></span><br><span class="line"><span class="comment">	input rst_n,</span></span><br><span class="line"><span class="comment">	input a,</span></span><br><span class="line"><span class="comment">	output reg match</span></span><br><span class="line"><span class="comment">	);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	reg [7:0] a_tem;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	always @(posedge clk or negedge rst_n)</span></span><br><span class="line"><span class="comment">		if (!rst_n)</span></span><br><span class="line"><span class="comment">			begin </span></span><br><span class="line"><span class="comment">				match &lt;= 1&#x27;b0;</span></span><br><span class="line"><span class="comment">			end</span></span><br><span class="line"><span class="comment">		else if (a_tem == 8&#x27;b0111_0001)</span></span><br><span class="line"><span class="comment">			begin</span></span><br><span class="line"><span class="comment">				match &lt;= 1&#x27;b1;</span></span><br><span class="line"><span class="comment">			end</span></span><br><span class="line"><span class="comment">		else </span></span><br><span class="line"><span class="comment">			begin	</span></span><br><span class="line"><span class="comment">				match &lt;= 1&#x27;b0;</span></span><br><span class="line"><span class="comment">			end</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	always @(posedge clk or negedge rst_n)</span></span><br><span class="line"><span class="comment">		if (!rst_n)</span></span><br><span class="line"><span class="comment">			begin </span></span><br><span class="line"><span class="comment">				a_tem &lt;= 8&#x27;b0;</span></span><br><span class="line"><span class="comment">			end</span></span><br><span class="line"><span class="comment">		else </span></span><br><span class="line"><span class="comment">			begin</span></span><br><span class="line"><span class="comment">				a_tem &lt;= &#123;a_tem[6:0],a&#125;;</span></span><br><span class="line"><span class="comment">			end</span></span><br><span class="line"><span class="comment">endmodule</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="含有无关项的序列检测"><a href="#含有无关项的序列检测" class="headerlink" title="含有无关项的序列检测*"></a>含有无关项的序列检测*</h1><ul>
<li><p>请编写一个序列检测模块，检测输入信号a是否满足011XXX110序列（长度为9位数据，前三位是011，后三位是110，中间三位不做要求），当信号满足该序列，给出指示信号match。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240916123454507.png" alt="image-20240916123454507" style="zoom: 33%;"></p>
</li>
<li><p><strong>该题使用移位寄存器可以很好的实现</strong></p>
</li>
<li><p>源代码</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> sequence_detect(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> a,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">8</span> : <span class="number">0</span>]	 a_shift_reg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移位寄存器</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">			a_shift_reg &lt;= <span class="number">9&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			a_shift_reg &lt;= &#123;a_shift_reg[<span class="number">7</span> : <span class="number">0</span>], a&#125;;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//match判断</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">			match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(a_shift_reg[<span class="number">8</span> -: <span class="number">3</span>] == <span class="number">3&#x27;b011</span> &amp;&amp; a_shift_reg[<span class="number">0</span> +: <span class="number">3</span>] == <span class="number">3&#x27;b110</span>) <span class="keyword">begin</span></span><br><span class="line">				match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">				match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="不重复序列检测"><a href="#不重复序列检测" class="headerlink" title="不重复序列检测*"></a>不重复序列检测*</h1><ul>
<li><p>请编写一个序列检测模块，检测输入信号（a）是否满足011100序列， 要求以每六个输入为一组，不检测重复序列，例如第一位数据不符合，则不考虑后五位。一直到第七位数据即下一组信号的第一位开始检测。当信号满足该序列，给出指示信号match。当不满足时给出指示信号not_match。</p>
<p>模块的接口信号图如下：（要求必须用状态机实现）</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240916134936207.png" alt="image-20240916134936207" style="zoom:50%;"></p>
</li>
<li><p><strong>添加一个ERROR状态，当出现某位出现错误是，不再检测后面的位，只是等待这组数据的结束</strong></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Sequence_detect_no_repeat(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> data,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> not_match</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===============================参数定义=========================</span></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">localparam</span>  IDLE = <span class="number">4&#x27;d0</span>,</span><br><span class="line">                S1 = <span class="number">4&#x27;d1</span>,</span><br><span class="line">                S2 = <span class="number">4&#x27;d2</span>,</span><br><span class="line">                S3 = <span class="number">4&#x27;d3</span>,</span><br><span class="line">                S4 = <span class="number">4&#x27;d4</span>,</span><br><span class="line">                S5 = <span class="number">4&#x27;d5</span>,</span><br><span class="line">                ERROR = <span class="number">4&#x27;d7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现态与次态的定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span> : <span class="number">0</span>] cur_state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] counter; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//===============================状态机逻辑=========================</span></span><br><span class="line">    <span class="comment">//计数器逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            counter &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(counter == <span class="number">5</span>) <span class="keyword">begin</span></span><br><span class="line">                counter &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.状态转移</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        next_state = IDLE;</span><br><span class="line">        <span class="keyword">case</span>(cur_state) </span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = S1;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S1: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = S2;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S2: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = S3;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S3: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = S4;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = ERROR;</span><br><span class="line">                <span class="keyword">end</span>                </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S4: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = S5;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = ERROR;</span><br><span class="line">                <span class="keyword">end</span>                </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S5: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = ERROR;</span><br><span class="line">                <span class="keyword">end</span>                </span><br><span class="line">            <span class="keyword">end</span>        </span><br><span class="line">            ERROR: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(counter == <span class="number">5</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = IDLE;</span><br><span class="line">                <span class="keyword">end</span> </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出逻辑</span></span><br><span class="line">   <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cur_state == S5 &amp;&amp; data == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">                match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cur_state == ERROR &amp;&amp; counter == <span class="number">&#x27;d5</span>) <span class="keyword">begin</span></span><br><span class="line">                not_match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                not_match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="输入序列不连续的序列检测"><a href="#输入序列不连续的序列检测" class="headerlink" title="输入序列不连续的序列检测*"></a>输入序列不连续的序列检测*</h1><ul>
<li><p>请编写一个序列检测模块，输入信号端口为data，表示数据有效的指示信号端口为data_valid。当data_valid信号为高时，表示此刻的输入信号data有效，参与序列检测；当data_valid为低时，data无效，抛弃该时刻的输入。当输入序列的有效信号满足0110时，拉高序列匹配信号match。（要求用状态机实现）</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240916142134289.png" alt="image-20240916142134289" style="zoom:50%;"></p>
</li>
<li><p><strong>注意判断输出时，由于S3只是011，所以还需对此时输入data（且有效）判断</strong>：<code>cur_state == S3 &amp;&amp; data == 1&#39;b0 &amp;&amp; data_valid == 1&#39;b1</code></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Sequence_detect_Discontinuous(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> data,</span><br><span class="line">	<span class="keyword">input</span> data_valid,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> match</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===============================参数定义=========================</span></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">localparam</span>  IDLE = <span class="number">2&#x27;d0</span>,</span><br><span class="line">                S1 = <span class="number">2&#x27;d1</span>,</span><br><span class="line">                S2 = <span class="number">2&#x27;d2</span>,</span><br><span class="line">                S3 = <span class="number">2&#x27;d3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现态与次态定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span> : <span class="number">0</span>] cur_state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===============================状态机逻辑=========================</span></span><br><span class="line">    <span class="comment">//1.状态转移</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        next_state = IDLE;</span><br><span class="line">        <span class="keyword">case</span>(cur_state)</span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid &amp;&amp; data == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = S1;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S1: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid &amp;&amp; data == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = S2;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = S1;</span><br><span class="line">                <span class="keyword">end</span>                </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S2: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid &amp;&amp; data == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = S3;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = S2;</span><br><span class="line">                <span class="keyword">end</span>                </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S3: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(data_valid &amp;&amp; data == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">                    next_state = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    next_state = S3;</span><br><span class="line">                <span class="keyword">end</span>                </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cur_state == S3 &amp;&amp; data == <span class="number">1&#x27;b0</span> &amp;&amp; data_valid == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">                match &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                match &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="信号发生器"><a href="#信号发生器" class="headerlink" title="信号发生器*"></a>信号发生器*</h1><ul>
<li><p>请编写一个信号发生器模块，根据波形选择信号wave_choise发出相应的波形：wave_choice=0时，发出方波信号；wave_choice=1时，发出锯齿波信号；wave_choice=2时，发出三角波信号。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240917163116780.png" alt="image-20240917163116780" style="zoom: 67%;"></p>
</li>
<li><p>注意<code>square_wave_cnt &lt; &#39;d10</code>（<code>1~10、11~19~0</code>）与<code>square_wave_cnt &lt; &#39;d9 || square_wave_cnt == &#39;d19</code>（<code>0~9、9~19</code>）的区别。正常来说都是50%占空比的方波，不知为何不加就会牛客网编译器就会报错</p>
<ul>
<li><p>square_wave_cnt &lt; ‘d10：</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240917163750125.png" alt="image-20240917163750125"></p>
</li>
<li><p>square_wave_cnt &lt; ‘d9 || square_wave_cnt == ‘d19</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240917163520227.png" alt="image-20240917163520227"></p>
</li>
</ul>
</li>
<li><p>源代码</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> signal_generator(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] wave_choise,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]wave</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方波计数器</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span> : <span class="number">0</span>] square_wave_cnt;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            square_wave_cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(wave_choise == <span class="number">&#x27;d0</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(square_wave_cnt == <span class="number">&#x27;d19</span>) <span class="keyword">begin</span></span><br><span class="line">                    square_wave_cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    square_wave_cnt &lt;= square_wave_cnt + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                square_wave_cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//三角波控制器</span></span><br><span class="line">    <span class="keyword">reg</span> triangle_wave_flag; <span class="comment">//其中flag=0代表下降，=1代表上升</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            triangle_wave_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(wave_choise == <span class="number">&#x27;d2</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(wave == <span class="number">&#x27;d1</span>) <span class="keyword">begin</span></span><br><span class="line">                    triangle_wave_flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(wave == <span class="number">&#x27;d19</span>) <span class="keyword">begin</span>      <span class="comment">//其实此时是1~20的wave为上升，21~0的wave为下降</span></span><br><span class="line">                        triangle_wave_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                triangle_wave_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出选择控制</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            wave &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(wave_choise)</span><br><span class="line">                <span class="number">2&#x27;d0</span>: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(square_wave_cnt &lt; <span class="number">&#x27;d9</span> || square_wave_cnt == <span class="number">&#x27;d19</span>) <span class="keyword">begin</span></span><br><span class="line">                        wave &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        wave &lt;= <span class="number">&#x27;d20</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2&#x27;d1</span>: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(wave == <span class="number">&#x27;d20</span>) <span class="keyword">begin</span></span><br><span class="line">                        wave &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        wave &lt;= wave + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2&#x27;d2</span>: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(triangle_wave_flag == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">                        wave &lt;= wave - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        wave &lt;= wave + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: wave &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="数据串转并电路"><a href="#数据串转并电路" class="headerlink" title="数据串转并电路"></a>数据串转并电路</h1><ul>
<li><p>实现串并转换电路，输入端输入单bit数据，每当本模块接收到6个输入数据后，输出端输出拼接后的6bit数据。本模块输入端与上游的采用valid-ready双向握手机制，输出端与下游采用valid-only握手机制。数据拼接时先接收到的数据放到data_b的低位。电路的接口如下图所示。valid_a用来指示数据输入data_a的有效性，valid_b用来指示数据输出data_b的有效性；ready_a用来指示本模块是否准备好接收上游数据，本模块中一直拉高；clk是时钟信号；rst_n是异步复位信号。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240917172628400.png" alt="image-20240917172628400" style="zoom: 33%;"></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> s_to_p(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				valid_a		,</span><br><span class="line">	<span class="keyword">input</span>	 			data_a		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span> 		ready_a		,</span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_b		,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] 	data_b</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span> : <span class="number">0</span>] data_out_r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_a &amp;&amp; ready_a) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">&#x27;d5</span>) <span class="keyword">begin</span></span><br><span class="line">                    cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_out_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_a) <span class="keyword">begin</span></span><br><span class="line">                data_out_r &lt;= &#123;data_a, data_out_r[<span class="number">5</span> : <span class="number">1</span>]&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_b &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">&#x27;d5</span>) <span class="keyword">begin</span></span><br><span class="line">                data_b &lt;= &#123;data_a, data_out_r[<span class="number">5</span> : <span class="number">1</span>]&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            ready_a &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            ready_a &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">&#x27;d5</span>) <span class="keyword">begin</span></span><br><span class="line">                valid_b &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                valid_b &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="数据累加输出"><a href="#数据累加输出" class="headerlink" title="数据累加输出*"></a>数据累加输出<em>*</em></h1><ul>
<li><p>实现串行输入数据累加输出，输入端输入8bit数据，每当模块接收到4个输入数据后，输出端输出4个接收到数据的累加结果。输入端和输出端与上下游的交互采用valid-ready双向握手机制。要求上下游均能满速传输时，数据传输无气泡，不能由于本模块的设计原因产生额外的性能损失。</p>
</li>
<li><p>电路的接口如下图所示。valid_a用来指示数据输入data_in的有效性，valid_b用来指示数据输出data_out的有效性；ready_a用来指示本模块是否准备好接收上游数据，ready_b表示下游是否准备好接收本模块的输出数据；clk是时钟信号；rst_n是异步复位信号。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240917220618909.png" alt="image-20240917220618909" style="zoom:50%;"></p>
</li>
<li><p><strong>好好理解ready_a和ready_b信号对正常只有valid逻辑的影响，重点看代码里面的注释！</strong></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> valid_ready(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>		[<span class="number">7</span>:<span class="number">0</span>]	data_in		,</span><br><span class="line">	<span class="keyword">input</span>				valid_a		,</span><br><span class="line">	<span class="keyword">input</span>	 			ready_b		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>		 		ready_a		,</span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_b		,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">9</span>:<span class="number">0</span>] 	data_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span> : <span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_a &amp;&amp; ready_a) <span class="keyword">begin</span>                            <span class="comment">//与输出相关的信号时，都带上ready_a就行，因为当本级准备好时，才能正常工作</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">&#x27;d3</span>) <span class="keyword">begin</span></span><br><span class="line">                    cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据输出</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_out &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">&#x27;d0</span> &amp;&amp; valid_a &amp;&amp; ready_a &amp;&amp; ready_b) <span class="keyword">begin</span>   <span class="comment">//这里其实不太好理解，就是当cnt == 0的时候是要开启下一次计算（正常来说），重新加载第一个数据</span></span><br><span class="line">                data_out &lt;= data_in;                                <span class="comment">//如果下一级准备好了，就正常加载，如果没有准备好，数据应该保持，</span></span><br><span class="line">            <span class="keyword">end</span>                                                     </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(valid_a &amp;&amp; ready_a) <span class="keyword">begin</span>                       <span class="comment">//其实~ready_b成立时，ready_a == 0（根据ready_a的组合逻辑）,那么就肯定是data_out保持了</span></span><br><span class="line">                data_out &lt;= data_out + data_in;                     <span class="comment">//所以这里写法可以这样简化，没有单独写出~ready_b的情况</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据有效信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            valid_b &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">&#x27;d3</span> &amp;&amp; valid_a &amp;&amp; ready_a) <span class="keyword">begin</span>  <span class="comment">//这里很容易出错，注意当cnt==&#x27;d3时，可不一定是valid_a==1</span></span><br><span class="line">                valid_b &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(~ready_b) <span class="keyword">begin</span>          <span class="comment">//可以等效成代码：else if(valid_b &amp;&amp; ready_b)</span></span><br><span class="line">                    valid_b &lt;= valid_b;     <span class="comment">//                  valid_b &lt;= 1&#x27;d0;</span></span><br><span class="line">                <span class="keyword">end</span>                         <span class="comment">//该等效代码的理解是：运算完成后需置高1clk，在下一个时钟周期就要归0了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span>                  <span class="comment">//如果此时下一级准备好了，说明下一级已经读到数据运算有效信号了，就拉低valid_b（就跟没有这个ready信号的正常操作一样）</span></span><br><span class="line">                    valid_b &lt;= <span class="number">1&#x27;b0</span>;        <span class="comment">//如果此时下一级还没有准备好，那么就要继续保持这个valid_b信号，直到下一级在准备好的时候能读到这个信号，知道数据已经运算有效了</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span>         <span class="comment">//这个我自己写的分支的理解是：运算有效后如果下一级模块还没有准备好(~ready)，那么该valid_b信号就要继续保持（因为如果没有准备好，所有输出数据都是要保持的）</span></span><br><span class="line">        <span class="keyword">end</span>             <span class="comment">//如果准备好了，那就正常归0（因为正常情况下valid就只会拉高1clk）</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出给上一级的ready</span></span><br><span class="line">    <span class="keyword">assign</span> ready_a = (valid_b &amp;&amp; ~ready_b) ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">//数据有效且下一级未准备好时 输出给上一级的ready拉高</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="非整数倍数据位宽转换24to128"><a href="#非整数倍数据位宽转换24to128" class="headerlink" title="非整数倍数据位宽转换24to128*"></a>非整数倍数据位宽转换24to128*</h1><ul>
<li><p>实现数据位宽转换电路，实现24bit数据输入转换为128bit数据输出。其中，先到的数据应置于输出的高bit位。电路的接口如下图所示。valid_in用来指示数据输入data_in的有效性，valid_out用来指示数据输出data_out的有效性；clk是时钟信号；rst_n是异步复位信号。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240918145814104.png" alt="image-20240918145814104" style="zoom:33%;"></p>
</li>
<li><p>这里的解题思路很巧妙，输入数据是24bit，输出数据是128bit。因为128×3=24×16128×3=24×16，<strong>所以每输入16个有效数据，就可以产生三个完整的输出</strong>。<strong>因此设置一个仅在输入数据有效时工作的计数器<code>cnt</code>，计数范围是0-15。</strong></p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240919150515791.png" alt="image-20240919150515791" style="zoom: 67%;"></p>
</li>
<li><p><strong>设置一个数据暂存器<code>data_lock</code>（128bit），每当输入有效时，将数据从低位移入。</strong></p>
</li>
<li><p><strong>每当计数器<code>cnt</code>计数到5、10、15时，<code>data_out</code>要进行更新，并拉高<code>valid_out</code>一个周期。</strong></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> width_24to128(</span><br><span class="line">	<span class="keyword">input</span> 				clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">23</span>:<span class="number">0</span>]		data_in		,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>	<span class="keyword">reg</span>			valid_out	,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">127</span>:<span class="number">0</span>]	data_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span> : <span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">127</span> : <span class="number">0</span>] data_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数器逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">&#x27;d15</span>) <span class="keyword">begin</span></span><br><span class="line">                    cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//移位拼接</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_lock &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">                data_lock &lt;= &#123;data_lock[<span class="number">103</span> : <span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_out &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">&#x27;d5</span> &amp;&amp; valid_in) <span class="keyword">begin</span></span><br><span class="line">                data_out &lt;= &#123;data_lock[<span class="number">119</span> : <span class="number">0</span>], data_in[<span class="number">23</span> : <span class="number">16</span>]&#125;;		<span class="comment">//在输出这组数据最后一个数的同时，这个数将被存到data_lock中，以便下次使用</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">&#x27;d10</span> &amp;&amp; valid_in) <span class="keyword">begin</span></span><br><span class="line">                data_out &lt;= &#123;data_lock[<span class="number">111</span> : <span class="number">0</span>], data_in[<span class="number">23</span> : <span class="number">8</span>]&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">&#x27;d15</span> &amp;&amp; valid_in) <span class="keyword">begin</span></span><br><span class="line">                data_out &lt;= &#123;data_lock[<span class="number">103</span> : <span class="number">0</span>], data_in[<span class="number">23</span> : <span class="number">0</span>]&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出有效信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in &amp;&amp; (cnt == <span class="number">&#x27;d5</span> || cnt == <span class="number">&#x27;d10</span> || cnt == <span class="number">&#x27;d15</span>)) <span class="keyword">begin</span></span><br><span class="line">                valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="非整数倍数据位宽转换8to12"><a href="#非整数倍数据位宽转换8to12" class="headerlink" title="非整数倍数据位宽转换8to12"></a>非整数倍数据位宽转换8to12</h1><ul>
<li><p>实现数据位宽转换电路，实现8bit数据输入转换为12bit数据输出。其中，先到的数据应置于输出的高bit位。电路的接口如下图所示。valid_in用来指示数据输入data_in的有效性，valid_out用来指示数据输出data_out的有效性；clk是时钟信号；rst_n是异步复位信号。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240919151229197.png" alt="image-20240919151229197" style="zoom:50%;"></p>
</li>
<li><p>本题解法与上题一致</p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> width_8to12(</span><br><span class="line">	<span class="keyword">input</span> 				   clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 			      rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				      valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	[<span class="number">7</span>:<span class="number">0</span>]			   data_in	,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>  <span class="keyword">reg</span>			   valid_out,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">11</span>:<span class="number">0</span>]   data_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8 * 3 = 12 * 2</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span> : <span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">11</span> : <span class="number">0</span>] data_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数器逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">&#x27;d2</span>) <span class="keyword">begin</span></span><br><span class="line">                    cnt &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//移位锁存</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_lock &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">                data_lock &lt;= &#123;data_lock[<span class="number">3</span> : <span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_out &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in &amp;&amp; cnt == <span class="number">&#x27;d1</span>) <span class="keyword">begin</span></span><br><span class="line">                data_out &lt;= &#123;data_lock[<span class="number">7</span> : <span class="number">0</span>], data_in[<span class="number">7</span> : <span class="number">4</span>]&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(valid_in &amp;&amp; cnt == <span class="number">&#x27;d2</span>) <span class="keyword">begin</span></span><br><span class="line">                data_out &lt;= &#123;data_lock[<span class="number">3</span> : <span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据有效信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in &amp;&amp; (cnt == <span class="number">&#x27;d1</span> || cnt == <span class="number">&#x27;d2</span>)) <span class="keyword">begin</span></span><br><span class="line">                valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="整数倍数据位宽转换8to16"><a href="#整数倍数据位宽转换8to16" class="headerlink" title="整数倍数据位宽转换8to16"></a>整数倍数据位宽转换8to16</h1><ul>
<li><p>实现数据位宽转换电路，实现8bit数据输入转换为16bit数据输出。其中，先到的8bit数据应置于输出16bit的高8位。电路的接口如下图所示。valid_in用来指示数据输入data_in的有效性，valid_out用来指示数据输出data_out的有效性；clk是时钟信号；rst_n是异步复位信号。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240919154353458.png" alt="image-20240919154353458" style="zoom:50%;"></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> width_8to16_integer(</span><br><span class="line">	<span class="keyword">input</span> 				    clk 		,   </span><br><span class="line">	<span class="keyword">input</span> 				    rst_n		,</span><br><span class="line">	<span class="keyword">input</span>				    valid_in	,</span><br><span class="line">	<span class="keyword">input</span>	    [<span class="number">7</span>:<span class="number">0</span>]	    data_in	    ,</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">output</span>  <span class="keyword">reg</span>			    valid_out   ,</span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>]	    data_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span> : <span class="number">0</span>] data_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8 * 2 = 16</span></span><br><span class="line">    <span class="keyword">reg</span> cnt;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= ~cnt;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//移位输出</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_lock &lt;=<span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in) <span class="keyword">begin</span></span><br><span class="line">                data_lock &lt;= &#123;data_lock[<span class="number">7</span> : <span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_out &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in &amp;&amp; cnt == <span class="number">&#x27;d1</span>) <span class="keyword">begin</span></span><br><span class="line">                data_out &lt;= &#123;data_lock[<span class="number">7</span> : <span class="number">0</span>], data_in&#125;;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据输出有效</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(valid_in &amp;&amp; cnt == <span class="number">&#x27;d1</span>) <span class="keyword">begin</span></span><br><span class="line">                valid_out &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                valid_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="状态机-非重叠的序列检测"><a href="#状态机-非重叠的序列检测" class="headerlink" title="状态机-非重叠的序列检测"></a>状态机-非重叠的序列检测</h1><ul>
<li><p>设计一个状态机，用来检测序列 10111，要求：</p>
<p>1、进行非重叠检测  即101110111 只会被检测通过一次</p>
<p>2、寄存器输出且同步输出结果（注意rst为<strong>低电平复位</strong>）</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240920140736362.png" alt="image-20240920140736362" style="zoom:33%;"></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> sequence_test1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">localparam</span>  IDLE = <span class="number">3&#x27;d0</span>,</span><br><span class="line">                S1  = <span class="number">3&#x27;d1</span>,</span><br><span class="line">                S2  = <span class="number">3&#x27;d2</span>,</span><br><span class="line">                S3  = <span class="number">3&#x27;d3</span>,</span><br><span class="line">                S4  = <span class="number">3&#x27;d4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现态与次态定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] cur_state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(cur_state)</span><br><span class="line">            IDLE: next_state = data == <span class="number">1</span> ? S1 : IDLE;</span><br><span class="line">            S1: next_state = data == <span class="number">0</span> ? S2 : S1;</span><br><span class="line">            S2: next_state = data == <span class="number">1</span> ? S3 : S2;</span><br><span class="line">            S3: next_state = data == <span class="number">1</span> ? S4 : S3;</span><br><span class="line">            S4: next_state = data == <span class="number">1</span> ? IDLE : S4;</span><br><span class="line">            <span class="keyword">default</span>: next_state = IDLE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出判断</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cur_state == S4 &amp;&amp; data == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="状态机-重叠序列检测"><a href="#状态机-重叠序列检测" class="headerlink" title="状态机-重叠序列检测"></a>状态机-重叠序列检测</h1><ul>
<li><p>设计一个状态机，用来检测序列 1011，要求：</p>
<p>1、进行重叠检测  即10110111 会被检测通过2次</p>
<p>2、寄存器输出，在序列检测完成下一拍输出检测有效（注意rst为<strong>低电平复位</strong>）</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240920160548636.png" alt="image-20240920160548636" style="zoom: 33%;"></p>
</li>
<li><p>源文件：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> sequence_test2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">localparam</span>  IDLE = <span class="number">3&#x27;d0</span>,</span><br><span class="line">                S1  = <span class="number">3&#x27;d1</span>,</span><br><span class="line">                S2  = <span class="number">3&#x27;d2</span>,</span><br><span class="line">                S3  = <span class="number">3&#x27;d3</span>,</span><br><span class="line">                S4  = <span class="number">3&#x27;d4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现态与次态定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] cur_state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(cur_state)</span><br><span class="line">            IDLE: next_state = data == <span class="number">1</span> ? S1 : IDLE;</span><br><span class="line">            S1: next_state = data == <span class="number">0</span> ? S2 : S1;</span><br><span class="line">            S2: next_state = data == <span class="number">1</span> ? S3 : S2;</span><br><span class="line">            S3: next_state = data == <span class="number">1</span> ? S4 : S3;</span><br><span class="line">            S4: next_state = data == <span class="number">1</span> ? S1 : S2;</span><br><span class="line">            <span class="keyword">default</span>: next_state = IDLE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出判断</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cur_state == S4) <span class="keyword">begin</span></span><br><span class="line">                flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="时钟分频（偶数）"><a href="#时钟分频（偶数）" class="headerlink" title="时钟分频（偶数）*"></a>时钟分频（偶数）*</h1><ul>
<li><p>请使用D触发器设计一个同时输出2/4/8分频的50%占空比的时钟分频。注意rst为<strong>低电平复位</strong></p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240920162131517.png" alt="image-20240920162131517" style="zoom: 33%;"></p>
</li>
<li><p>其实偶数分频是有些小技巧的，即利用计数器，不过之前已经会啦</p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> even_div</span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> rst ,</span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> clk_in,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">wire</span> clk_out2,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">wire</span> clk_out4,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">wire</span> clk_out8</span><br><span class="line">    );</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] clk_reg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk_out2_r;</span><br><span class="line">    <span class="keyword">reg</span> clk_out4_r;</span><br><span class="line">    <span class="keyword">reg</span> clk_out8_r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            clk_reg &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            clk_reg &lt;= clk_reg + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            clk_out2_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            clk_out4_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            clk_out8_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            clk_out2_r &lt;= clk_reg[<span class="number">0</span>];</span><br><span class="line">            clk_out4_r &lt;= clk_reg[<span class="number">1</span>];</span><br><span class="line">            clk_out8_r &lt;= clk_reg[<span class="number">2</span>];            </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> clk_out2 = ~clk_out2_r;</span><br><span class="line">    <span class="keyword">assign</span> clk_out4 = ~clk_out4_r;</span><br><span class="line">    <span class="keyword">assign</span> clk_out8 = ~clk_out8_r;</span><br><span class="line"><span class="comment">//*************code***********//</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="自动贩售机1"><a href="#自动贩售机1" class="headerlink" title="自动贩售机1**"></a>自动贩售机1**</h1><ul>
<li><p>设计一个自动贩售机，输入货币有三种，为0.5/1/2元，饮料价格是1.5元，要求进行找零，找零只会支付0.5元。</p>
<p>ps:投入的货币会自动经过边沿检测并输出一个在时钟上升沿到1，在下降沿到0的脉冲信号</p>
<p>（d1  0.5元；d2  1元；d3  2元；out1 饮料；out2 零钱）</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240923142613137.png" alt="image-20240923142613137" style="zoom:80%;"></p>
</li>
<li><p>可以借助该题好好理解<strong>米粒（输出取决于当前状态+输入）和摩尔型（输出只取决于当前状态）的区别</strong></p>
<ul>
<li>米粒型由于当前状态与输入有关，可以放在输出逻辑里面判断输出，从而减小状态机数量，但增加输出逻辑的复杂度</li>
<li>摩尔型由于当前状态与输出无关，那么其实有很多状态只是为了指示输出，这无形中增加了状态机的数量</li>
</ul>
</li>
<li><p>米粒型版本：（状态仅表示空闲、累计0.5元、累计1元）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> seller1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d1 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d2 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d3 ,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out1,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]out2</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">parameter</span>  IDLE = <span class="number">&#x27;d0</span>,</span><br><span class="line">                S1 = <span class="number">&#x27;d1</span>,   <span class="comment">//0.5</span></span><br><span class="line">                S2 = <span class="number">&#x27;d2</span>;   <span class="comment">//1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//现态与次态定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] cur_state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//next_state = IDLE; 因为次态判断中存在next_state = next_state;这样的写法，那么就不能把该语句放在前面，不然每次判断后next_state都只会等于IDLE</span></span><br><span class="line">        <span class="keyword">case</span>(cur_state)         <span class="comment">//主要原因在于d1，d2，d3都只拉高半个时钟周期</span></span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2,d3&#125;)</span><br><span class="line">                    <span class="number">3&#x27;b100</span>: next_state = S1;</span><br><span class="line">                    <span class="number">3&#x27;b010</span>: next_state = S2;</span><br><span class="line">                    <span class="number">3&#x27;b001</span>: next_state = IDLE;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S1: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2,d3&#125;)</span><br><span class="line">                    <span class="number">3&#x27;b100</span>: next_state = S2;</span><br><span class="line">                    <span class="number">3&#x27;b010</span>: next_state = IDLE;</span><br><span class="line">                    <span class="number">3&#x27;b001</span>: next_state = IDLE;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span>                </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S2: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2,d3&#125;)</span><br><span class="line">                    <span class="number">3&#x27;b100</span>: next_state = IDLE;</span><br><span class="line">                    <span class="number">3&#x27;b010</span>: next_state = IDLE;</span><br><span class="line">                    <span class="number">3&#x27;b001</span>: next_state = IDLE;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span>                     </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: next_state = IDLE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出逻辑</span></span><br><span class="line">    <span class="keyword">reg</span> out1_r;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span> : <span class="number">0</span>] out2_r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(cur_state) </span><br><span class="line">                IDLE: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(&#123;d1,d2,d3&#125; == <span class="number">3&#x27;b001</span>) <span class="keyword">begin</span>	<span class="comment">//这里&#123;d1,d2,d3&#125;能被捕获到也是挺神奇的</span></span><br><span class="line">                        out1_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        out2_r &lt;= <span class="number">&#x27;d1</span>;</span><br><span class="line">                    <span class="keyword">end</span>   </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        out1_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        out2_r &lt;= <span class="number">&#x27;d0</span>;                      </span><br><span class="line">                    <span class="keyword">end</span>                 </span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S1: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">case</span>(&#123;d1,d2,d3&#125;)</span><br><span class="line">                        <span class="number">3&#x27;b010</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>:  <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d2</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span>                       </span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S2: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">case</span>(&#123;d1,d2,d3&#125;)</span><br><span class="line">                        <span class="number">3&#x27;b100</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b010</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d1</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d3</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span>                       </span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                    out1_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    out2_r &lt;= <span class="number">&#x27;d0</span>; </span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            out2 &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= out1_r;</span><br><span class="line">            out2 &lt;= out2_r;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>摩尔型版本（<strong>状态表示可能出现的所有累积钱数</strong>）：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> seller1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d1 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d2 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d3 ,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out1,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]out2</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">parameter</span>  IDLE = <span class="number">&#x27;d0</span>,</span><br><span class="line">                S1 = <span class="number">&#x27;d1</span>,   <span class="comment">//0.5</span></span><br><span class="line">                S2 = <span class="number">&#x27;d2</span>,   <span class="comment">//1</span></span><br><span class="line">                S3 = <span class="number">&#x27;d3</span>,   <span class="comment">//1.5</span></span><br><span class="line">                S4 = <span class="number">&#x27;d4</span>,   <span class="comment">//2</span></span><br><span class="line">                S5 = <span class="number">&#x27;d5</span>,   <span class="comment">//2.5</span></span><br><span class="line">                S6 = <span class="number">&#x27;d6</span>;   <span class="comment">//3</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//现态与次态定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] cur_state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//next_state = IDLE; 因为次态判断中存在next_state = next_state;这样的写法，那么就不能把该语句放在前面，不然每次判断后next_state都只会等于IDLE</span></span><br><span class="line">        <span class="keyword">case</span>(cur_state)         <span class="comment">//主要原因在于d1，d2，d3都只拉高半个时钟周期</span></span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2,d3&#125;)</span><br><span class="line">                    <span class="number">3&#x27;b100</span>: next_state = S1;</span><br><span class="line">                    <span class="number">3&#x27;b010</span>: next_state = S2;</span><br><span class="line">                    <span class="number">3&#x27;b001</span>: next_state = S4;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S1: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2,d3&#125;)</span><br><span class="line">                    <span class="number">3&#x27;b100</span>: next_state = S2;</span><br><span class="line">                    <span class="number">3&#x27;b010</span>: next_state = S3;</span><br><span class="line">                    <span class="number">3&#x27;b001</span>: next_state = S5;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span>                </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S2: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2,d3&#125;)</span><br><span class="line">                    <span class="number">3&#x27;b100</span>: next_state = S3;</span><br><span class="line">                    <span class="number">3&#x27;b010</span>: next_state = S4;</span><br><span class="line">                    <span class="number">3&#x27;b001</span>: next_state = S6;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span>                     </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: next_state = IDLE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(next_state == S3 || next_state == S4 || next_state == S5 || next_state == S6) <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">&#x27;d1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                out1 &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out2 &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(next_state) </span><br><span class="line">                S4: out2 &lt;= <span class="number">&#x27;d1</span>;</span><br><span class="line">                S5: out2 &lt;= <span class="number">&#x27;d2</span>;</span><br><span class="line">                S6: out2 &lt;= <span class="number">&#x27;d3</span>;</span><br><span class="line">                <span class="keyword">default</span>: out2 &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="自动贩售机2"><a href="#自动贩售机2" class="headerlink" title="自动贩售机2*"></a>自动贩售机2*</h1><ul>
<li><p>设计一个自动贩售机，输入货币有两种，为0.5/1元，饮料价格是1.5/2.5元，要求进行找零，找零只会支付0.5元。</p>
<p>ps：1、投入的货币会自动经过边沿检测并输出一个在时钟上升沿到1，在下降沿到0的脉冲信号</p>
<p>2、此题忽略出饮料后才能切换饮料的问题</p>
<p>（d1 0.5 d2 1 sel 选择饮料 out1 饮料1 out2 饮料2 out3 零钱）</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240923162758494.png" alt="image-20240923162758494" style="zoom:80%;"></p>
</li>
<li><p>与上一题类似，次态判断时加上sel判断就行</p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> seller2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d1 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> d2 ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> sel ,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out1,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out2,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> out3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">localparam</span>  IDLE = <span class="number">&#x27;d0</span>,</span><br><span class="line">                S0_5 = <span class="number">&#x27;d1</span>,</span><br><span class="line">                S1   = <span class="number">&#x27;d2</span>,</span><br><span class="line">                S1_5 = <span class="number">&#x27;d3</span>,</span><br><span class="line">                S2   = <span class="number">&#x27;d4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现态与次态定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] cur_state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(cur_state) </span><br><span class="line">            IDLE: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2&#125;) </span><br><span class="line">                    <span class="number">2&#x27;b10</span>: next_state = S0_5;</span><br><span class="line">                    <span class="number">2&#x27;b01</span>: next_state = S1;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S0_5: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2&#125;) </span><br><span class="line">                    <span class="number">2&#x27;b10</span>: next_state = S1;</span><br><span class="line">                    <span class="number">2&#x27;b01</span>: next_state = ~sel ? IDLE : S1_5;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S1: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2&#125;) </span><br><span class="line">                    <span class="number">2&#x27;b10</span>: next_state = ~sel ? IDLE : S1_5;</span><br><span class="line">                    <span class="number">2&#x27;b01</span>: next_state = ~sel ? IDLE : S2;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S1_5: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2&#125;) </span><br><span class="line">                    <span class="number">2&#x27;b10</span>: next_state = S2;</span><br><span class="line">                    <span class="number">2&#x27;b01</span>: next_state = IDLE;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S2: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(&#123;d1,d2&#125;) </span><br><span class="line">                    <span class="number">2&#x27;b10</span>: next_state = IDLE;</span><br><span class="line">                    <span class="number">2&#x27;b01</span>: next_state = IDLE;</span><br><span class="line">                    <span class="keyword">default</span>: next_state = next_state;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                next_state = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出逻辑</span></span><br><span class="line">    <span class="keyword">reg</span> out1_r;</span><br><span class="line">    <span class="keyword">reg</span> out2_r;</span><br><span class="line">    <span class="keyword">reg</span> out3_r;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            out3_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(cur_state) </span><br><span class="line">                S0_5: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">case</span>(&#123;d1,d2&#125;)</span><br><span class="line">                        <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                            </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= ~sel ? <span class="number">&#x27;d1</span> : <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                             </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S1: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">case</span>(&#123;d1,d2&#125;)</span><br><span class="line">                        <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= ~sel ? <span class="number">&#x27;d1</span> : <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                            </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= ~sel ? <span class="number">&#x27;d1</span> : <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= ~sel ? <span class="number">&#x27;d1</span> : <span class="number">&#x27;d0</span>;                             </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S1_5: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">case</span>(&#123;d1,d2&#125;)</span><br><span class="line">                        <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                            </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= sel ? <span class="number">&#x27;d1</span> : <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                             </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span>     </span><br><span class="line">                S2: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">case</span>(&#123;d1,d2&#125;)</span><br><span class="line">                        <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= sel ? <span class="number">&#x27;d1</span> : <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                            </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= sel ? <span class="number">&#x27;d1</span> : <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d1</span>;                             </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                            out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                            out3_r &lt;= <span class="number">&#x27;d0</span>;                               </span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span>  </span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                    out1_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                    out2_r &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                    out3_r &lt;= <span class="number">&#x27;d0</span>;                    </span><br><span class="line">                <span class="keyword">end</span>               </span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            out2 &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            out3 &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            out1 &lt;= out1_r;</span><br><span class="line">            out2 &lt;= out2_r;</span><br><span class="line">            out3 &lt;= out3_r;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<hr>
</li>
</ul>
<h1 id="占空比50-的奇数分频"><a href="#占空比50-的奇数分频" class="headerlink" title="占空比50%的奇数分频*"></a>占空比50%的奇数分频*</h1><ul>
<li><p>设计一个同时输出7分频的时钟分频器，占空比要求为50%。注意rst为<strong>低电平复位</strong></p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240925142052058.png" alt="image-20240925142052058"></p>
</li>
<li><p><strong>分别利用上升沿和下降沿对计数器进行判断，最后对结果取或</strong></p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240925142232868.png" alt="image-20240925142232868"></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> odo_div_or(</span><br><span class="line">    <span class="keyword">input</span>    <span class="keyword">wire</span>  rst ,</span><br><span class="line">    <span class="keyword">input</span>    <span class="keyword">wire</span>  clk_in,</span><br><span class="line">    <span class="keyword">output</span>   <span class="keyword">wire</span>  clk_out7</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">7</span> - <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上升沿判断</span></span><br><span class="line">    <span class="keyword">reg</span> clk_up;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            clk_up &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">7</span> / <span class="number">2</span>) <span class="keyword">begin</span></span><br><span class="line">                clk_up &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">6</span>) <span class="keyword">begin</span></span><br><span class="line">                    clk_up &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    clk_up &lt;= clk_up;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下升沿判断</span></span><br><span class="line">    <span class="keyword">reg</span> clk_down;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            clk_down &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">7</span> / <span class="number">2</span>) <span class="keyword">begin</span></span><br><span class="line">                clk_down &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">6</span>) <span class="keyword">begin</span></span><br><span class="line">                    clk_down &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    clk_down &lt;= clk_down;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> clk_out7 = clk_up | clk_down;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="任意小数分频"><a href="#任意小数分频" class="headerlink" title="任意小数分频*"></a>任意小数分频*</h1><ul>
<li><p>请设计一个可以实现任意小数分频的时钟分频器，比如说8.7分频的时钟信号，注意rst为<strong>低电平复位</strong>。</p>
</li>
<li><p>假设输出<code>clk_out</code>是输入<code>clk_in</code>的N<em>N</em>分频。首先要将分频系数N<em>N</em>化为分数形式，比如4.75→$\frac{19}{4}$，3.4→$\frac{34}{10}$。本题中，8.7可以化为$\frac{87}{10}$。这意味着在87个<code>clk_in</code>周期内输出10个<code>clk_out</code>周期就可以实现分频。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240925154025505.png" alt="image-20240925154025505" style="zoom: 67%;"></p>
</li>
<li><p>然后采用若干种（一般是两种）整数分频在87个原周期<code>clk_in</code>内产生10个新时钟周期<code>clk_out</code>。整数分频的分频系数有很多种选择，但要尽可能接近，提高<code>clk_out</code>的均匀度。一般推荐在小数分频系数N<em>N</em>的附近选取。因为8&lt;N&lt;9，所以两个整数分频系数是8和9。接着要计算87个<code>clk_out</code>周期分别有多少个是8分频和9分频的。设每10个<code>clk_out</code>中有<em>x</em>个8分频输出和<em>y</em>个9分频输出，则可列出如下方程：</p>
<script type="math/tex; mode=display">
x+y=10 \\
8x+9y = 87</script></li>
<li><p>可得x=3，y=7。也就是3个8分频和7个9分频一组，循环输出，就等效于8.7分频。 最后安排组内8分频和9分频的位置。这里的方法也不固定，不过本题要求3个8分频先输出，再输出7个9分频，如下图。</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240925154456206.png" alt="image-20240925154456206"></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> div_M_N(</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">wire</span> clk_in,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">wire</span> rst,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> clk_out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">parameter</span> M_N = <span class="number">8&#x27;d87</span>; </span><br><span class="line">    <span class="keyword">parameter</span> c89 = <span class="number">8&#x27;d24</span>; <span class="comment">// 8/9时钟切换点</span></span><br><span class="line">    <span class="keyword">parameter</span> div_e = <span class="number">5&#x27;d8</span>; <span class="comment">//偶数周期</span></span><br><span class="line">    <span class="keyword">parameter</span> div_o = <span class="number">5&#x27;d9</span>; <span class="comment">//奇数周期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分频器内部计数器</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span> : <span class="number">0</span>] cnt_in;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分频转换标志</span></span><br><span class="line">    <span class="keyword">reg</span> div_flag;       <span class="comment">//0表示偶数分配，1表示奇数分频</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//外部总计数器</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span> : <span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.分频器内部计数器逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cnt_in &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(~div_flag) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt_in == div_e - <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                    cnt_in &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    cnt_in &lt;= cnt_in + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt_in == div_o - <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                    cnt_in &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    cnt_in &lt;= cnt_in + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span>                </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.外部计数器逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cnt_out &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt_out == M_N - <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                cnt_out &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                cnt_out &lt;= cnt_out + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.分频转化器逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            div_flag &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt_out == M_N - <span class="number">1</span> || cnt_out == c89 - <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                div_flag &lt;= ~div_flag;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                div_flag &lt;= div_flag;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.时钟输出</span></span><br><span class="line">    <span class="keyword">reg</span> clk_out_r;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            clk_out_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// if(~div_flag) begin      //这种是在先低后高的情况下</span></span><br><span class="line">            <span class="comment">//     if(cnt_in == (div_e / 2 - 1 ) || cnt_in == div_e - 1) begin</span></span><br><span class="line">            <span class="comment">//         clk_out_r &lt;= ~clk_out_r;</span></span><br><span class="line">            <span class="comment">//     end</span></span><br><span class="line">            <span class="comment">// end</span></span><br><span class="line">            <span class="comment">// else begin</span></span><br><span class="line">            <span class="comment">//     if(cnt_in == div_o / 2 || cnt_in == div_o - 1) begin</span></span><br><span class="line">            <span class="comment">//         clk_out_r &lt;= ~clk_out_r;</span></span><br><span class="line">            <span class="comment">//     end                </span></span><br><span class="line">            <span class="comment">// end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(~div_flag) <span class="keyword">begin</span>         <span class="comment">//题目要求是先高后低</span></span><br><span class="line">                <span class="keyword">if</span>(cnt_in &lt;= (div_e / <span class="number">2</span> - <span class="number">1</span> )) <span class="keyword">begin</span></span><br><span class="line">                    clk_out_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    clk_out_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(cnt_in &lt;= div_o /<span class="number">4</span> + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                    clk_out_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span>               </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    clk_out_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span> </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> clk_out = clk_out_r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="无占空比要去的奇数分频"><a href="#无占空比要去的奇数分频" class="headerlink" title="无占空比要去的奇数分频"></a>无占空比要去的奇数分频</h1><ul>
<li><p>请设计一个同时输出5分频的时钟分频器，本题对占空比没有要求</p>
</li>
<li><p>对占空比没有要求的话，仅在上升沿计数就好</p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> odd_div(</span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> rst ,</span><br><span class="line">    <span class="keyword">input</span>     <span class="keyword">wire</span> clk_in,</span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">wire</span> clk_out5</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">&#x27;d4</span>) <span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上升沿判断</span></span><br><span class="line">    <span class="keyword">reg</span> clk_up;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_in <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            clk_up &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">2</span>) <span class="keyword">begin</span></span><br><span class="line">                clk_up &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                clk_up &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> clk_out5 = clk_up;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="根据状态转移写状态机-三段式"><a href="#根据状态转移写状态机-三段式" class="headerlink" title="根据状态转移写状态机-三段式"></a>根据状态转移写状态机-三段式</h1><ul>
<li><p>如图所示为两种状态机中的一种，请根据状态转移图写出代码，状态转移线上的0/0等表示的意思是过程中data/flag的值。</p>
<p>要求：</p>
<p>1、 必须使用对应类型的状态机</p>
<p>2、 使用三段式描述方法，输出判断要求要用到对现态的判断</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240926132356818.png" alt="image-20240926132356818" style="zoom:80%;"></p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240926132428378.png" alt="image-20240926132428378" style="zoom:80%;"></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fsm1(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">parameter</span>   S0 = <span class="number">2&#x27;d0</span>,</span><br><span class="line">                S1 = <span class="number">2&#x27;d1</span>,</span><br><span class="line">                S2 = <span class="number">2&#x27;d2</span>,</span><br><span class="line">                S3 = <span class="number">2&#x27;d3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现态与次态定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span> : <span class="number">0</span>] cur_state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= S0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        next_state = cur_state;</span><br><span class="line">        <span class="keyword">case</span>(cur_state)</span><br><span class="line">            S0: next_state = data ? S1 : S0;</span><br><span class="line">            S1: next_state = data ? S2 : S1;</span><br><span class="line">            S2: next_state = data ? S3 : S2;</span><br><span class="line">            S3: next_state = data ? S0 : S3;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出判断</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cur_state == S3 &amp;&amp; data == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">                flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="根据状态转移写状态机-二段式"><a href="#根据状态转移写状态机-二段式" class="headerlink" title="根据状态转移写状态机-二段式"></a>根据状态转移写状态机-二段式</h1><ul>
<li><p>如图所示为两种状态机中的一种，请根据状态转移图写出代码，状态转移线上的0/0等表示的意思是过程中data/flag的值。</p>
<p>要求：</p>
<p>1、 必须使用对应类型的状态机</p>
<p>2、 使用二段式描述方法</p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240926133500919.png" alt="image-20240926133500919" style="zoom:80%;"></p>
<p><img src="/2024/01/10/Verilog%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240926133518169.png" alt="image-20240926133518169" style="zoom:80%;"></p>
</li>
<li><p>源代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fsm2(</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> clk  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> rst  ,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> data ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> flag</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">parameter</span>   S0 = <span class="number">3&#x27;d0</span>,</span><br><span class="line">                S1 = <span class="number">3&#x27;d1</span>,</span><br><span class="line">                S2 = <span class="number">3&#x27;d2</span>,</span><br><span class="line">                S3 = <span class="number">3&#x27;d3</span>,</span><br><span class="line">                S4 = <span class="number">3&#x27;d4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现态与次态定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span> : <span class="number">0</span>] cur_state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= S0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cur_state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.次态判断与输出判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        next_state = cur_state;</span><br><span class="line">        flag = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">case</span>(cur_state)</span><br><span class="line">            S0: <span class="keyword">begin</span></span><br><span class="line">                next_state = data ? S1 : S0;</span><br><span class="line">                flag = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S1: <span class="keyword">begin</span></span><br><span class="line">                next_state = data ? S2 : S1;</span><br><span class="line">                flag = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S2: <span class="keyword">begin</span></span><br><span class="line">                next_state = data ? S3 : S2;</span><br><span class="line">                flag = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S3: <span class="keyword">begin</span></span><br><span class="line">                next_state = data ? S4 : S3;</span><br><span class="line">                flag = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S4: <span class="keyword">begin</span></span><br><span class="line">                next_state = data ? S1 : S0;</span><br><span class="line">                flag = <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之FIFO</title>
    <url>/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/</url>
    <content><![CDATA[<p>本节主要介绍了同步FIFO与异步FIFO的工作原理与硬件设计的关键，并列举了示例代码。</p>
<span id="more"></span>
<h1 id="FIFO概述"><a href="#FIFO概述" class="headerlink" title="FIFO概述"></a>FIFO概述</h1><ul>
<li><p>FIFO（First In First Out），是一种<strong>先进先出的数据缓存器</strong>。其<strong>不可寻址</strong>，只能顺序写入、顺序读出，数据地址由内部读写地址自动加1完成（这里注意与RAM的区分：RAM支持外部给定地址读写数据），通常硬件上<strong>实现的是循环队列</strong></p>
</li>
<li><p><strong>FIFO的功能</strong>：FIFO是速率匹配中的一个<strong>缓冲环节</strong>，一般用于连接两个速率不同的数据通路</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231224020051443.png" alt="image-20231224020051443" style="zoom: 67%;"></p>
</li>
<li><p><strong>FIFO分类</strong>：</p>
<ul>
<li><strong>同步FIFO</strong>：<ul>
<li><strong>特点</strong>：数据写入FIFO的时钟和数据读出FIFO的时钟是<strong>同步</strong>的</li>
<li><strong>作用</strong>：作为交互数据的缓冲，相当于一个buffer</li>
</ul>
</li>
<li><strong>异步FIFO</strong>：<ul>
<li><strong>特点</strong>：数据写入FIFO的时钟和数据读出FIFO的时钟是<strong>异步</strong>的</li>
<li><strong>作用</strong>：实现数据在不同时钟域之间进行传递，或作为不同数据宽度的数据接口（比如写的数据是8个bit，读出的数据是16bit，或者写的是16个bit，读出的数据是8个bit）</li>
</ul>
</li>
</ul>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231224020354679.png" alt="image-20231224020354679" style="zoom:50%;"></p>
</li>
<li><p><strong>FIFO深度与宽度</strong>：</p>
<ul>
<li>FIFO宽度：用fifo_data_size表示，也就是<strong>FIFO存储的每个数据宽度</strong></li>
<li>FIFO深度：用fifo_addr_size表示，也就是<strong>能存储多少个数据</strong></li>
</ul>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231224020607825.png" alt="image-20231224020607825" style="zoom:50%;"></p>
</li>
<li><p><strong>FIFO中相关信号</strong>：</p>
<ul>
<li>时钟、复位：clk，rst_n_i</li>
<li>读使能（读控制）：rd_en_i</li>
<li>写使能（写控制）：wr_en_i</li>
<li>满信号（满标志）：full，当FIFO中的数据满（或接近满），不再能进行数据的写入</li>
<li>空信号（空标志）：empty，当FIFO为空（或接近空），不再能进行数据的读出</li>
</ul>
</li>
</ul>
<hr>
<h1 id="同步FIFO"><a href="#同步FIFO" class="headerlink" title="同步FIFO"></a>同步FIFO</h1><h2 id="1-设计关键"><a href="#1-设计关键" class="headerlink" title="1.设计关键"></a>1.设计关键</h2><ul>
<li><p><strong>“空”和“满”信号的判断</strong>：</p>
<ul>
<li><p>首先来看一个正常循环FIFO的空满信号判断流程：</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231227105716607.png" alt="image-20231227105716607"></p>
</li>
<li><p>由上图可以总结出：</p>
<ul>
<li><strong>当读指针追上写指针时，FIFO为空</strong></li>
<li><strong>当写指针追上读指针时，FIFO为满</strong></li>
</ul>
</li>
<li><p>由于FIFO空和满状态时，读写指针都指向相同位置，那么如何较好的判断究竟是空还是满呢？<strong>答案是：将地址指针扩展1bit</strong></p>
<ul>
<li>在深度为8的FIFO中，需要3bit的读写指针来分别指示读写地址3’b000-3’b111这8个地址。若将地址指针扩展1bit，则变成4bit的地址，而地址表示区间则变成了4’b0000-4’b1111。假设不看最高位的话，后面3位的表示区间仍然是3’b000-3’b111，也就意味着最高位可以拿来作为指示位。<br><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231227111508593.png" alt="image-20231227111508593"></li>
<li>由上图可以总结出：<ul>
<li><strong>读写指针相同，FIFO为空状态</strong></li>
<li><strong>读写指针最高位相反，其他位相同，FIFO为满状态</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-源代码"><a href="#2-源代码" class="headerlink" title="2.源代码"></a>2.源代码</h2><ul>
<li><p>sync_fifo.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> sync_fifo #(</span><br><span class="line">    <span class="keyword">parameter</span> DEPTH = <span class="number">8</span>,</span><br><span class="line">    <span class="keyword">parameter</span> WIDTH = <span class="number">8</span></span><br><span class="line">) (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst_n,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span>             i_wen,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] i_wdata,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">wire</span>             i_ren,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] o_rdata,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o_empty,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o_full</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> ADDR_WIDTH = <span class="built_in">$clog2</span>(DEPTH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] mem[DEPTH-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [ADDR_WIDTH:<span class="number">0</span>] wptr, wptr_next;</span><br><span class="line">    <span class="keyword">reg</span> [ADDR_WIDTH:<span class="number">0</span>] rptr, rptr_next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">            wptr &lt;= &#123;ADDR_WIDTH&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">            rptr &lt;= &#123;ADDR_WIDTH&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            wptr &lt;= wptr_next;</span><br><span class="line">            rptr &lt;= rptr_next;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        wptr_next = wptr;</span><br><span class="line">        rptr_next = rptr;</span><br><span class="line">        <span class="keyword">if</span> (i_wen &amp;&amp; !o_full) <span class="keyword">begin</span></span><br><span class="line">            wptr_next = wptr + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (i_ren &amp;&amp; !o_empty) <span class="keyword">begin</span></span><br><span class="line">            rptr_next = rptr + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DEPTH; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                mem[i] &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (i_wen &amp;&amp; !o_full) <span class="keyword">begin</span></span><br><span class="line">            mem[wptr[ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]] &lt;= i_wdata;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">            o_rdata &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (i_ren &amp;&amp; !o_empty) <span class="keyword">begin</span></span><br><span class="line">            o_rdata &lt;= mem[rptr[ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_empty = wptr == rptr;</span><br><span class="line">    <span class="keyword">assign</span> o_full  = wptr == &#123;~rptr[ADDR_WIDTH], rptr[ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Testbench"><a href="#3-Testbench" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><ul>
<li><p>sync_fifo_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns	</span><span class="comment">//时间单位/精度</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//------------&lt;模块及端口声明&gt;----------------------------------------</span></span><br><span class="line"><span class="keyword">module</span> sync_fifo_tb();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">parameter</span>   DATA_WIDTH = <span class="number">8</span>  ;		<span class="comment">//FIFO位宽</span></span><br><span class="line">    <span class="keyword">parameter</span>   DATA_DEPTH = <span class="number">8</span> ;		<span class="comment">//FIFO深度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span>									clk		;</span><br><span class="line">    <span class="keyword">reg</span>									rst_n	;</span><br><span class="line">    <span class="keyword">reg</span>		[DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]			data_in	;</span><br><span class="line">    <span class="keyword">reg</span>									rd_en	;</span><br><span class="line">    <span class="keyword">reg</span>									wr_en	;</span><br><span class="line">                            </span><br><span class="line">    <span class="keyword">wire</span>	[DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]			data_out;	</span><br><span class="line">    <span class="keyword">wire</span>								empty	;	</span><br><span class="line">    <span class="keyword">wire</span>								full	;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//------------&lt;例化被测试模块&gt;----------------------------------------</span></span><br><span class="line">    sync_fifo</span><br><span class="line">    #(</span><br><span class="line">        <span class="variable">.DEPTH</span>	(DATA_WIDTH),			<span class="comment">//FIFO位宽</span></span><br><span class="line">        <span class="variable">.WIDTH</span>	(DATA_DEPTH)			<span class="comment">//FIFO深度</span></span><br><span class="line">    )</span><br><span class="line">    sync_fifo_ptr_inst(</span><br><span class="line">        <span class="variable">.clk</span>		(clk		),</span><br><span class="line">        <span class="variable">.rst_n</span>		(rst_n		),</span><br><span class="line">        <span class="variable">.i_wdata</span>	(data_in	),</span><br><span class="line">        <span class="variable">.i_ren</span>		(rd_en		),</span><br><span class="line">        <span class="variable">.i_wen</span>		(wr_en		),</span><br><span class="line">                    </span><br><span class="line">        <span class="variable">.o_rdata</span>	(data_out	),	</span><br><span class="line">        <span class="variable">.o_empty</span>	(empty		),	</span><br><span class="line">        <span class="variable">.o_full</span>		(full		)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//------------&lt;设置初始测试条件&gt;----------------------------------------</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">1&#x27;b0</span>;					<span class="comment">//初始时钟为0</span></span><br><span class="line">        rst_n &lt;= <span class="number">1&#x27;b0</span>;				<span class="comment">//初始复位</span></span><br><span class="line">        data_in &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        wr_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        rd_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="comment">//重复8次写操作，让FIFO写满 	</span></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">8</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">negedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">                rst_n &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">                wr_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                data_in &lt;= <span class="built_in">$random</span>;	<span class="comment">//生成8位随机数</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//重复8次读操作，让FIFO读空 	</span></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">8</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">negedge</span> clk)<span class="keyword">begin</span>		</span><br><span class="line">                wr_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                rd_en &lt;= <span class="number">1&#x27;d1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//重复4次写操作，写入4个随机数据	</span></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">4</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">negedge</span> clk)<span class="keyword">begin</span>		</span><br><span class="line">                wr_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                data_in &lt;= <span class="built_in">$random</span>;	<span class="comment">//生成8位随机数</span></span><br><span class="line">                rd_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//持续同时对FIFO读写，写入数据为随机数据	</span></span><br><span class="line">        <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">negedge</span> clk)<span class="keyword">begin</span>		</span><br><span class="line">                wr_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                data_in &lt;= <span class="built_in">$random</span>;	<span class="comment">//生成8位随机数</span></span><br><span class="line">                rd_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//------------&lt;设置时钟&gt;----------------------------------------------</span></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;			<span class="comment">//系统时钟周期20ns</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231226145844212.png" alt="image-20231226145844212">    </p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="异步FIFO"><a href="#异步FIFO" class="headerlink" title="异步FIFO"></a>异步FIFO</h1><h2 id="1-设计关键-1"><a href="#1-设计关键-1" class="headerlink" title="1.设计关键"></a>1.设计关键</h2><ul>
<li><p><strong>“空”和“满”信号的判断：</strong></p>
<ul>
<li><p>异步FIFO也可以用同步FIFO的方式去判断空满状态，但是！！！，异步FIFO存在跨时钟域的问题，它存在亚阈值问题，如果仍然使用二进制编码方式的话，会大大增加出现亚阈值状态的概率</p>
</li>
<li><p>首先，先解释为什么跨时钟域容易出现亚阈值问题（亚阈值问题就是数据不满足触发器的建立时间和保持时间，在时钟跳变沿时采集到了一个不稳定的状态，详情见Reference）</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231227115142508.png" alt="image-20231227115142508"></p>
</li>
<li><p>二进制的7（0111）跳转到8（1000），4位都会发生变化，所以发生亚稳态的概率就比较大，那么我们如何减少发生亚稳态的概率呢？<strong>答案是：用格雷码</strong></p>
<ul>
<li><p>格雷码是相邻数字之间只有1个bit的变化，那么就会大大减少亚稳态发生的概率</p>
</li>
<li><p>二进制与格雷码的转化：<strong>二进制码右移一位^二进制码=格雷码</strong>（^代表异或）</p>
</li>
<li><p>如何用格雷码判断空满：</p>
<ul>
<li><p><strong>当最高位和次高位相同，其余位相同认为是读空</strong></p>
</li>
<li><p><strong>当最高位和次高位不同，其余位相同认为是写满</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>跨时钟域的同步问题</strong>：因为读指针与写指针是受不同时钟控制的，所以它们之间的比较，需要先同步到一个时钟下（<strong>这里的同步都是指使用2个（或者3个，但此类情况不多）FF（触发器）来进行同步（俗称“打两拍”）</strong>，我的理解是用这两拍的时间先锁存一个指针，然后再将这个指针与经过了2拍之后的另一个指针比较）</p>
<ul>
<li><p><strong>“写满”的判断：需要将读指针同步到写时钟域，再与写指针判断</strong></p>
<ul>
<li><p>假设本来是这样的：</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231227122308994.png" alt="image-20231227122308994"></p>
</li>
<li><p>如果在2拍（<strong>写时钟下</strong>）时间内，写指针从0010写到0111，此时写指针和读指针（延时两拍后的，并非真实读指针）指向同一地址，FIFO为满</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231227122645638.png" alt="image-20231227122645638"></p>
</li>
<li><p>但其实在这段时间内，可能真实读指针已经读出了数据，所以此时存在“<strong>虚满</strong>”状态</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231227122919471.png" alt="image-20231227122919471"></p>
</li>
</ul>
</li>
<li><p><strong>“读空”的判断：需要将写指针同步到读时钟域，再与读指针判断</strong></p>
<ul>
<li><p>假设本来是这样的：</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231227123629433.png" alt="image-20231227123629433"></p>
</li>
<li><p>如果在2拍（<strong>读时钟下</strong>）时间内，读指针从0010读到0111再到1000，此时写指针和读指针（延时两拍后的，并非真实写指针）指向同一地址，FIFO为空</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231227123723989.png" alt="image-20231227123723989"></p>
</li>
<li><p>但其实在这段时间内，可能真实写指针已经写入了数据，所以此时存在“<strong>虚空</strong>”状态</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231227124012465.png" alt="image-20231227124012465"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-源代码-1"><a href="#2-源代码-1" class="headerlink" title="2.源代码"></a>2.源代码</h2><ul>
<li><p>async_fifo.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异步FIFO</span></span><br><span class="line"><span class="keyword">module</span>	async_fifo</span><br><span class="line">    #(</span><br><span class="line">        <span class="keyword">parameter</span>   DATA_WIDTH = <span class="number">&#x27;d8</span>  ,								<span class="comment">//FIFO位宽</span></span><br><span class="line">        <span class="keyword">parameter</span>   DATA_DEPTH = <span class="number">&#x27;d16</span> 								<span class="comment">//FIFO深度</span></span><br><span class="line">    )		</span><br><span class="line">    (		</span><br><span class="line">    <span class="comment">//写数据		</span></span><br><span class="line">        <span class="keyword">input</span>							wr_clk		,				<span class="comment">//写时钟</span></span><br><span class="line">        <span class="keyword">input</span>							wr_rst_n	,       		<span class="comment">//低电平有效的写复位信号</span></span><br><span class="line">        <span class="keyword">input</span>							wr_en		,       		<span class="comment">//写使能信号，高电平有效	</span></span><br><span class="line">        <span class="keyword">input</span>	[DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]		data_in		,       		<span class="comment">//写入的数据</span></span><br><span class="line">    <span class="comment">//读数据			</span></span><br><span class="line">        <span class="keyword">input</span>							rd_clk		,				<span class="comment">//读时钟</span></span><br><span class="line">        <span class="keyword">input</span>							rd_rst_n	,       		<span class="comment">//低电平有效的读复位信号</span></span><br><span class="line">        <span class="keyword">input</span>							rd_en		,				<span class="comment">//读使能信号，高电平有效						                                        </span></span><br><span class="line">        <span class="keyword">output</span>	<span class="keyword">reg</span>	[DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	data_out	,				<span class="comment">//输出的数据</span></span><br><span class="line">    <span class="comment">//状态标志					</span></span><br><span class="line">        <span class="keyword">output</span>							empty		,				<span class="comment">//空标志，高电平表示当前FIFO已被写满</span></span><br><span class="line">        <span class="keyword">output</span>							full		    			<span class="comment">//满标志，高电平表示当前FIFO已被读空</span></span><br><span class="line">    );                                                              </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//reg define</span></span><br><span class="line">    <span class="comment">//用二维数组实现RAM</span></span><br><span class="line">    <span class="keyword">reg</span> [DATA_WIDTH - <span class="number">1</span> : <span class="number">0</span>]			fifo_buffer[DATA_DEPTH - <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">reg</span> [<span class="built_in">$clog2</span>(DATA_DEPTH) : <span class="number">0</span>]		wr_ptr;						<span class="comment">//写地址指针，二进制</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="built_in">$clog2</span>(DATA_DEPTH) : <span class="number">0</span>]		rd_ptr;						<span class="comment">//读地址指针，二进制</span></span><br><span class="line">    <span class="keyword">reg</span>	[<span class="built_in">$clog2</span>(DATA_DEPTH) : <span class="number">0</span>]		rd_ptr_g_d1;				<span class="comment">//读指针格雷码在写时钟域下同步1拍</span></span><br><span class="line">    <span class="keyword">reg</span>	[<span class="built_in">$clog2</span>(DATA_DEPTH) : <span class="number">0</span>]		rd_ptr_g_d2;				<span class="comment">//读指针格雷码在写时钟域下同步2拍</span></span><br><span class="line">    <span class="keyword">reg</span>	[<span class="built_in">$clog2</span>(DATA_DEPTH) : <span class="number">0</span>]		wr_ptr_g_d1;				<span class="comment">//写指针格雷码在读时钟域下同步1拍</span></span><br><span class="line">    <span class="keyword">reg</span>	[<span class="built_in">$clog2</span>(DATA_DEPTH) : <span class="number">0</span>]		wr_ptr_g_d2;				<span class="comment">//写指针格雷码在读时钟域下同步2拍</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//wire define</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="built_in">$clog2</span>(DATA_DEPTH) : <span class="number">0</span>]		wr_ptr_g;					<span class="comment">//写地址指针，格雷码</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="built_in">$clog2</span>(DATA_DEPTH) : <span class="number">0</span>]		rd_ptr_g;					<span class="comment">//读地址指针，格雷码</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="built_in">$clog2</span>(DATA_DEPTH) - <span class="number">1</span> : <span class="number">0</span>]	wr_ptr_true;				<span class="comment">//真实写地址指针，作为写ram的地址</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="built_in">$clog2</span>(DATA_DEPTH) - <span class="number">1</span> : <span class="number">0</span>]	rd_ptr_true;				<span class="comment">//真实读地址指针，作为读ram的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//地址指针从二进制转换成格雷码</span></span><br><span class="line">    <span class="keyword">assign</span> 	wr_ptr_g = wr_ptr ^ (wr_ptr &gt;&gt; <span class="number">1</span>);					</span><br><span class="line">    <span class="keyword">assign</span> 	rd_ptr_g = rd_ptr ^ (rd_ptr &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//读写RAM地址赋值</span></span><br><span class="line">    <span class="keyword">assign</span>	wr_ptr_true = wr_ptr [<span class="built_in">$clog2</span>(DATA_DEPTH) - <span class="number">1</span> : <span class="number">0</span>];		<span class="comment">//写RAM地址等于写指针的低DATA_DEPTH位(去除最高位)</span></span><br><span class="line">    <span class="keyword">assign</span>	rd_ptr_true = rd_ptr [<span class="built_in">$clog2</span>(DATA_DEPTH) - <span class="number">1</span> : <span class="number">0</span>];		<span class="comment">//读RAM地址等于读指针的低DATA_DEPTH位(去除最高位)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写操作,更新写地址</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> wr_clk <span class="keyword">or</span> <span class="keyword">negedge</span> wr_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!wr_rst_n)</span><br><span class="line">            wr_ptr &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!full &amp;&amp; wr_en)<span class="keyword">begin</span>								<span class="comment">//写使能有效且非满</span></span><br><span class="line">            wr_ptr &lt;= wr_ptr + <span class="number">1&#x27;d1</span>;</span><br><span class="line">            fifo_buffer[wr_ptr_true] &lt;= data_in;</span><br><span class="line">        <span class="keyword">end</span>	</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//将读指针的格雷码同步到写时钟域，来判断是否写满</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> wr_clk <span class="keyword">or</span> <span class="keyword">negedge</span> wr_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!wr_rst_n)<span class="keyword">begin</span></span><br><span class="line">            rd_ptr_g_d1 &lt;= <span class="number">0</span>;										<span class="comment">//寄存1拍</span></span><br><span class="line">            rd_ptr_g_d2 &lt;= <span class="number">0</span>;										<span class="comment">//寄存2拍</span></span><br><span class="line">        <span class="keyword">end</span>				</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span>												</span><br><span class="line">            rd_ptr_g_d1 &lt;= rd_ptr_g;								<span class="comment">//寄存1拍</span></span><br><span class="line">            rd_ptr_g_d2 &lt;= rd_ptr_g_d1;								<span class="comment">//寄存2拍</span></span><br><span class="line">        <span class="keyword">end</span>	</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//读操作,更新读地址</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> rd_clk <span class="keyword">or</span> <span class="keyword">negedge</span> rd_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rd_rst_n)</span><br><span class="line">            rd_ptr &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rd_en &amp;&amp; !empty)<span class="keyword">begin</span>								<span class="comment">//读使能有效且非空</span></span><br><span class="line">            data_out &lt;= fifo_buffer[rd_ptr_true];</span><br><span class="line">            rd_ptr &lt;= rd_ptr + <span class="number">1&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//将写指针的格雷码同步到读时钟域，来判断是否读空</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> rd_clk <span class="keyword">or</span> <span class="keyword">negedge</span> rd_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rd_rst_n)<span class="keyword">begin</span></span><br><span class="line">            wr_ptr_g_d1 &lt;= <span class="number">0</span>;										<span class="comment">//寄存1拍</span></span><br><span class="line">            wr_ptr_g_d2 &lt;= <span class="number">0</span>;										<span class="comment">//寄存2拍</span></span><br><span class="line">        <span class="keyword">end</span>				</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span>												</span><br><span class="line">            wr_ptr_g_d1 &lt;= wr_ptr_g;								<span class="comment">//寄存1拍</span></span><br><span class="line">            wr_ptr_g_d2 &lt;= wr_ptr_g_d1;								<span class="comment">//寄存2拍		</span></span><br><span class="line">        <span class="keyword">end</span>	</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//更新指示信号</span></span><br><span class="line">    <span class="comment">//当所有位相等时，读指针追到到了写指针，FIFO被读空</span></span><br><span class="line">    <span class="keyword">assign</span>	empty = ( wr_ptr_g_d2 == rd_ptr_g ) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="comment">//当高位相反且其他位相等时，写指针超过读指针一圈，FIFO被写满</span></span><br><span class="line">    <span class="comment">//同步后的读指针格雷码高两位取反，再拼接上余下位</span></span><br><span class="line">    <span class="keyword">assign</span>	full  = ( wr_ptr_g == &#123; ~(rd_ptr_g_d2[<span class="built_in">$clog2</span>(DATA_DEPTH) : <span class="built_in">$clog2</span>(DATA_DEPTH) - <span class="number">1</span>])</span><br><span class="line">                    ,rd_ptr_g_d2[<span class="built_in">$clog2</span>(DATA_DEPTH) - <span class="number">2</span> : <span class="number">0</span>]&#125;)? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Testbench-1"><a href="#3-Testbench-1" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><ul>
<li><p>async_fifo_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> async_fifo_tb;</span><br><span class="line">    <span class="keyword">parameter</span>   DATA_WIDTH = <span class="number">8</span>  ;		<span class="comment">//FIFO位宽</span></span><br><span class="line">    <span class="keyword">parameter</span>   DATA_DEPTH = <span class="number">8</span> ;		<span class="comment">//FIFO深度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span>							wr_clk		;				<span class="comment">//写时钟</span></span><br><span class="line">    <span class="keyword">reg</span>							wr_rst_n	;       		<span class="comment">//低电平有效的写复位信号</span></span><br><span class="line">    <span class="keyword">reg</span>							wr_en		;       		<span class="comment">//写使能信号，高电平有效	</span></span><br><span class="line">    <span class="keyword">reg</span>	[DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]		data_in		;       		<span class="comment">//写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span>							rd_clk		;				<span class="comment">//读时钟</span></span><br><span class="line">    <span class="keyword">reg</span>							rd_rst_n	;       		<span class="comment">//低电平有效的读复位信号</span></span><br><span class="line">    <span class="keyword">reg</span>							rd_en		;				<span class="comment">//读使能信号，高电平有效						                                        </span></span><br><span class="line">    <span class="keyword">wire</span>[DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]		data_out	;				<span class="comment">//输出的数据					</span></span><br><span class="line">    <span class="keyword">wire</span>						empty		;				<span class="comment">//空标志，高电平表示当前FIFO已被写满</span></span><br><span class="line">    <span class="keyword">wire</span>						full		;               <span class="comment">//满标志，高电平表示当前FIFO已被读空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//------------&lt;例化被测试模块&gt;----------------------------------------</span></span><br><span class="line">    async_fifo</span><br><span class="line">    #(</span><br><span class="line">        <span class="variable">.DATA_WIDTH</span>	(DATA_WIDTH),			<span class="comment">//FIFO位宽</span></span><br><span class="line">        <span class="variable">.DATA_DEPTH</span>	(DATA_DEPTH)			<span class="comment">//FIFO深度</span></span><br><span class="line">    )</span><br><span class="line">    async_fifo_inst(</span><br><span class="line">        <span class="variable">.wr_clk</span>		(wr_clk		),</span><br><span class="line">        <span class="variable">.wr_rst_n</span>	(wr_rst_n	),</span><br><span class="line">        <span class="variable">.wr_en</span>		(wr_en		),</span><br><span class="line">        <span class="variable">.data_in</span>	(data_in	),	</span><br><span class="line">        <span class="variable">.rd_clk</span>		(rd_clk		),               </span><br><span class="line">        <span class="variable">.rd_rst_n</span>	(rd_rst_n	),	</span><br><span class="line">        <span class="variable">.rd_en</span>		(rd_en		),	</span><br><span class="line">        <span class="variable">.data_out</span>	(data_out	),</span><br><span class="line">        </span><br><span class="line">        <span class="variable">.empty</span>		(empty		),		</span><br><span class="line">        <span class="variable">.full</span>		(full		)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//------------&lt;设置初始测试条件&gt;----------------------------------------</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rd_clk = <span class="number">1&#x27;b0</span>;					<span class="comment">//初始时钟为0</span></span><br><span class="line">        wr_clk = <span class="number">1&#x27;b0</span>;					<span class="comment">//初始时钟为0</span></span><br><span class="line">        wr_rst_n &lt;= <span class="number">1&#x27;b0</span>;				<span class="comment">//初始复位</span></span><br><span class="line">        rd_rst_n &lt;= <span class="number">1&#x27;b0</span>;				<span class="comment">//初始复位</span></span><br><span class="line">        wr_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        rd_en &lt;= <span class="number">1&#x27;b0</span>;	</span><br><span class="line">        data_in &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        #<span class="number">5</span></span><br><span class="line">        wr_rst_n &lt;= <span class="number">1&#x27;b1</span>;				</span><br><span class="line">        rd_rst_n &lt;= <span class="number">1&#x27;b1</span>;					</span><br><span class="line">    <span class="comment">//重复8次写操作，让FIFO写满 	</span></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">8</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">negedge</span> wr_clk)<span class="keyword">begin</span>		</span><br><span class="line">                wr_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                data_in &lt;= <span class="built_in">$random</span>;	<span class="comment">//生成8位随机数</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//拉低写使能	</span></span><br><span class="line">        @(<span class="keyword">negedge</span> wr_clk)	wr_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//重复8次读操作，让FIFO读空 	</span></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">8</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">negedge</span> rd_clk)rd_en &lt;= <span class="number">1&#x27;d1</span>;		</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//拉低读使能</span></span><br><span class="line">        @(<span class="keyword">negedge</span> rd_clk)rd_en &lt;= <span class="number">1&#x27;d0</span>;		</span><br><span class="line">    <span class="comment">//重复4次写操作，写入4个随机数据	</span></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">4</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">negedge</span> wr_clk)<span class="keyword">begin</span>		</span><br><span class="line">                wr_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                data_in &lt;= <span class="built_in">$random</span>;	<span class="comment">//生成8位随机数</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//持续同时对FIFO读</span></span><br><span class="line">        @(<span class="keyword">negedge</span> rd_clk)rd_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="comment">//持续同时对FIFO写，写入数据为随机数据	</span></span><br><span class="line">        <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">negedge</span> wr_clk)<span class="keyword">begin</span>		</span><br><span class="line">                wr_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                data_in &lt;= <span class="built_in">$random</span>;	<span class="comment">//生成8位随机数</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//------------&lt;设置时钟&gt;----------------------------------------------</span></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> rd_clk = ~rd_clk;			<span class="comment">//读时钟周期20ns</span></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">20</span> wr_clk = ~wr_clk;			<span class="comment">//写时钟周期40ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<ul>
<li><p>整体结果：</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231226163350937.png" alt="image-20231226163350937"></p>
</li>
<li><p>细节展示：</p>
<p><img src="/2023/12/24/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIFO/image-20231226163304427.png" alt="image-20231226163304427"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1n841177Z7/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">FIFO概述_哔哩哔哩_bilibili</a>（FIFO的基本概念）</li>
<li><a href="https://www.bilibili.com/video/BV12Y4y1T7xn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">新新新手Icer练习（五）：同步+异步FIFO的实现_哔哩哔哩_bilibili</a>（同步与异步FIFO原理性的介绍）</li>
<li><a href="https://blog.csdn.net/wuzhikaidetb/article/details/121136040?ops_request_misc=%7B%22request%5Fid%22%3A%22170356087316800184160647%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=170356087316800184160647&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-121136040-null-null.nonecase&amp;utm_term=FIFO&amp;spm=1018.2226.3001.4450">同步FIFO的两种Verilog设计方法（计数器法、高位扩展法）_fifo同时读写计数器-CSDN博客</a>（同步FIFO解释得很清楚）</li>
<li><a href="https://blog.csdn.net/wuzhikaidetb/article/details/121152844?ops_request_misc=%7B%22request%5Fid%22%3A%22170357118716800211598390%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=170357118716800211598390&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-121152844-null-null.nonecase&amp;utm_term=FIFO&amp;spm=1018.2226.3001.4450">＜FPGA＞异步FIFO的Verilg实现方法_fpga fifo verilog-CSDN博客</a>（异步FIFO也解释得比较清楚，但跨时钟域那可能会难以理解，得自己边画图或者和仿真结果理解）</li>
<li><a href="https://blog.csdn.net/wuzhikaidetb/article/details/119619162#:~:text=单比特信号从慢速时钟域同步到快速时钟域需要使用打两拍的方式消除亚稳态。 第一级寄存器产生亚稳态并经过自身后可以稳定输出的概率为 70%~80%左右，第二级寄存,器可以稳定输出的概率为 99%左右，后面再多加寄存器的级数改善效果就不明显了，所以 数据进来后一般选择打两拍即可。">FPGA设计的“打拍（寄存）”和“亚稳态” 到底是什么？_fpga打拍的作用-CSDN博客</a>（亚稳态问题的解释）</li>
<li><a href="https://blog.csdn.net/wuzhikaidetb/article/details/123570799?ops_request_misc=%7B%22request%5Fid%22%3A%22170364997616800222874540%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=170364997616800222874540&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-3-123570799-null-null.nonecase&amp;utm_term=FIFO&amp;spm=1018.2226.3001.4450">关于异步FIFO设计，这7点你必须要搞清楚_异步fifo设计要素-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之脉动阵列</title>
    <url>/2023/12/18/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/</url>
    <content><![CDATA[<p>本节主要介绍了脉冲阵列的基本结构以及其实现矩阵乘法和卷积操作的原理。</p>
<span id="more"></span>
<h1 id="脉动阵列的基本原理"><a href="#脉动阵列的基本原理" class="headerlink" title="脉动阵列的基本原理"></a>脉动阵列的基本原理</h1><ul>
<li><p>脉动阵列本质是结构简单的流水线，其工作过程可看作是数据在时钟的驱动下像脉搏一般在阵列中向前跳动</p>
<p><img src="/2023/12/18/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20231219162318922.png" alt="image-20231219162318922" style="zoom: 67%;"></p>
</li>
</ul>
<h1 id="脉动阵列实现矩阵乘法"><a href="#脉动阵列实现矩阵乘法" class="headerlink" title="脉动阵列实现矩阵乘法"></a>脉动阵列实现矩阵乘法</h1><h2 id="1-模式一：中间结果存储在脉动阵列单元中"><a href="#1-模式一：中间结果存储在脉动阵列单元中" class="headerlink" title="1.模式一：中间结果存储在脉动阵列单元中"></a>1.模式一：中间结果存储在脉动阵列单元中</h2><ul>
<li>在脉动阵列流动的是输入和权重，而每一步的结果保存在脉动计算单元中</li>
</ul>
<h3 id="1-1-实现思路"><a href="#1-1-实现思路" class="headerlink" title="1.1 实现思路"></a>1.1 实现思路</h3><ul>
<li><p>模式一：脉动阵列计算矩阵乘法的初始状态</p>
<p><img src="/2023/12/18/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20231219162427269.png" alt="image-20231219162427269" style="zoom: 67%;"></p>
</li>
<li><p>实现架构</p>
<p><img src="/2023/12/18/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20231219161148576.png" alt="image-20231219161148576"></p>
<ul>
<li>其中*表示延时一拍</li>
</ul>
</li>
<li><p>每个PE单元其实就是一个MAC，通过脉动阵列可以实现在计算的同时将数据同时传导到后面的PE单元</p>
</li>
</ul>
<h3 id="1-2-源文件"><a href="#1-2-源文件" class="headerlink" title="1.2 源文件"></a>1.2 源文件</h3><ul>
<li><p>top.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> en,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>*<span class="number">9</span>-<span class="number">1</span>:<span class="number">0</span>] in1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>*<span class="number">9</span>-<span class="number">1</span>:<span class="number">0</span>] in2,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">9</span>*<span class="number">9</span>-<span class="number">1</span>:<span class="number">0</span>] out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] hang1 [<span class="number">0</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] hang2 [<span class="number">0</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] hang3 [<span class="number">0</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] lie1 [<span class="number">0</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] lie2 [<span class="number">0</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] lie3 [<span class="number">0</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] flag;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] down00,down01,down02,down10,down11,down12,down20,down21,down22;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] right00,right01,right02,right10,right11,right12,right20,right21,right22;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] sum00,sum01,sum02,sum10,sum11,sum12,sum20,sum21,sum22;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] left00;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] left10;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] left20;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] up00;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] up01;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] up02;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst)<span class="keyword">begin</span></span><br><span class="line">            out &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            hang1[<span class="number">0</span>] &lt;= in1[<span class="number">3</span>-:<span class="number">4</span>];            <span class="comment">//从in1[3]开始向下取4位，即in1[3],in1[2],in1[1],in1[0]，即将in[3:0]赋值给hang1[0]</span></span><br><span class="line">            hang1[<span class="number">1</span>] &lt;= in1[<span class="number">7</span>-:<span class="number">4</span>];</span><br><span class="line">            hang1[<span class="number">2</span>] &lt;= in1[<span class="number">11</span>-:<span class="number">4</span>];</span><br><span class="line">            hang1[<span class="number">3</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            hang1[<span class="number">4</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            hang2[<span class="number">0</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            hang2[<span class="number">1</span>] &lt;= in1[<span class="number">15</span>-:<span class="number">4</span>];</span><br><span class="line">            hang2[<span class="number">2</span>] &lt;= in1[<span class="number">19</span>-:<span class="number">4</span>];</span><br><span class="line">            hang2[<span class="number">3</span>] &lt;= in1[<span class="number">23</span>-:<span class="number">4</span>];</span><br><span class="line">            hang2[<span class="number">4</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            hang3[<span class="number">0</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            hang3[<span class="number">1</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            hang3[<span class="number">2</span>] &lt;= in1[<span class="number">27</span>-:<span class="number">4</span>];</span><br><span class="line">            hang3[<span class="number">3</span>] &lt;= in1[<span class="number">31</span>-:<span class="number">4</span>];</span><br><span class="line">            hang3[<span class="number">4</span>] &lt;= in1[<span class="number">35</span>-:<span class="number">4</span>];</span><br><span class="line">            lie1[<span class="number">0</span>] &lt;= in2[<span class="number">3</span>-:<span class="number">4</span>];</span><br><span class="line">            lie1[<span class="number">1</span>] &lt;= in2[<span class="number">15</span>-:<span class="number">4</span>];</span><br><span class="line">            lie1[<span class="number">2</span>] &lt;= in2[<span class="number">27</span>-:<span class="number">4</span>];</span><br><span class="line">            lie1[<span class="number">3</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            lie1[<span class="number">4</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            lie2[<span class="number">0</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            lie2[<span class="number">1</span>] &lt;= in2[<span class="number">7</span>-:<span class="number">4</span>];</span><br><span class="line">            lie2[<span class="number">2</span>] &lt;= in2[<span class="number">19</span>-:<span class="number">4</span>];</span><br><span class="line">            lie2[<span class="number">3</span>] &lt;= in2[<span class="number">31</span>-:<span class="number">4</span>];</span><br><span class="line">            lie2[<span class="number">4</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            lie3[<span class="number">0</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            lie3[<span class="number">1</span>] &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">            lie3[<span class="number">2</span>] &lt;= in2[<span class="number">11</span>-:<span class="number">4</span>];</span><br><span class="line">            lie3[<span class="number">3</span>] &lt;= in2[<span class="number">23</span>-:<span class="number">4</span>];</span><br><span class="line">            lie3[<span class="number">4</span>] &lt;= in2[<span class="number">35</span>-:<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst)<span class="keyword">begin</span></span><br><span class="line">            flag &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(en) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//if(flag==4&#x27;d5)</span></span><br><span class="line">                <span class="comment">//flag&lt;=0;</span></span><br><span class="line">                <span class="comment">//else</span></span><br><span class="line">            flag &lt;= flag + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(flag)</span><br><span class="line">            <span class="number">0</span> : <span class="keyword">begin</span></span><br><span class="line">                left00 &lt;= hang1[<span class="number">0</span>];</span><br><span class="line">                left10 &lt;= hang2[<span class="number">0</span>];</span><br><span class="line">                left20 &lt;= hang3[<span class="number">0</span>];</span><br><span class="line">                up00 &lt;= lie1[<span class="number">0</span>];</span><br><span class="line">                up01 &lt;= lie2[<span class="number">0</span>];</span><br><span class="line">                up02 &lt;= lie3[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="number">1</span> : <span class="keyword">begin</span></span><br><span class="line">                left00 &lt;= hang1[<span class="number">1</span>];</span><br><span class="line">                left10 &lt;= hang2[<span class="number">1</span>];</span><br><span class="line">                left20 &lt;= hang3[<span class="number">1</span>];</span><br><span class="line">                up00 &lt;= lie1[<span class="number">1</span>];</span><br><span class="line">                up01 &lt;= lie2[<span class="number">1</span>];</span><br><span class="line">                up02 &lt;= lie3[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="number">2</span> : <span class="keyword">begin</span></span><br><span class="line">                left00 &lt;= hang1[<span class="number">2</span>];</span><br><span class="line">                left10 &lt;= hang2[<span class="number">2</span>];</span><br><span class="line">                left20 &lt;= hang3[<span class="number">2</span>];</span><br><span class="line">                up00 &lt;= lie1[<span class="number">2</span>];</span><br><span class="line">                up01 &lt;= lie2[<span class="number">2</span>];</span><br><span class="line">                up02 &lt;= lie3[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="number">3</span> : <span class="keyword">begin</span></span><br><span class="line">                left00 &lt;= hang1[<span class="number">3</span>];</span><br><span class="line">                left10 &lt;= hang2[<span class="number">3</span>];</span><br><span class="line">                left20 &lt;= hang3[<span class="number">3</span>];</span><br><span class="line">                up00 &lt;= lie1[<span class="number">3</span>];</span><br><span class="line">                up01 &lt;= lie2[<span class="number">3</span>];</span><br><span class="line">                up02 &lt;= lie3[<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="number">4</span> : <span class="keyword">begin</span></span><br><span class="line">                left00 &lt;= hang1[<span class="number">4</span>];</span><br><span class="line">                left10 &lt;= hang2[<span class="number">4</span>];</span><br><span class="line">                left20 &lt;= hang3[<span class="number">4</span>];</span><br><span class="line">                up00 &lt;= lie1[<span class="number">4</span>];</span><br><span class="line">                up01 &lt;= lie2[<span class="number">4</span>];</span><br><span class="line">                up02 &lt;= lie3[<span class="number">4</span>];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">begin</span></span><br><span class="line">                left00 &lt;= <span class="number">0</span>;</span><br><span class="line">                left10 &lt;= <span class="number">0</span>;</span><br><span class="line">                left20 &lt;= <span class="number">0</span>;</span><br><span class="line">                up00 &lt;= <span class="number">0</span>;</span><br><span class="line">                up01 &lt;= <span class="number">0</span>;</span><br><span class="line">                up02 &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    pe pe00(</span><br><span class="line">        <span class="variable">.clk</span>(clk),<span class="variable">.rst</span>(rst),<span class="variable">.left</span>(left00),<span class="variable">.up</span>(up00),<span class="variable">.down</span>(down00),<span class="variable">.right</span>(right00),<span class="variable">.sum_out</span>(sum00)</span><br><span class="line">    );</span><br><span class="line">    pe pe01(</span><br><span class="line">        <span class="variable">.clk</span>(clk),<span class="variable">.rst</span>(rst),<span class="variable">.left</span>(right00),<span class="variable">.up</span>(up01),<span class="variable">.down</span>(down01),<span class="variable">.right</span>(right01),<span class="variable">.sum_out</span>(sum01)</span><br><span class="line">    );</span><br><span class="line">    pe pe02(</span><br><span class="line">        <span class="variable">.clk</span>(clk),<span class="variable">.rst</span>(rst),<span class="variable">.left</span>(right01),<span class="variable">.up</span>(up02),<span class="variable">.down</span>(down02),<span class="variable">.right</span>(right02),<span class="variable">.sum_out</span>(sum02)</span><br><span class="line">    );</span><br><span class="line">    pe pe10(</span><br><span class="line">        <span class="variable">.clk</span>(clk),<span class="variable">.rst</span>(rst),<span class="variable">.left</span>(left10),<span class="variable">.up</span>(down00),<span class="variable">.down</span>(down10),<span class="variable">.right</span>(right10),<span class="variable">.sum_out</span>(sum10)</span><br><span class="line">    );</span><br><span class="line">    pe pe11(</span><br><span class="line">        <span class="variable">.clk</span>(clk),<span class="variable">.rst</span>(rst),<span class="variable">.left</span>(right10),<span class="variable">.up</span>(down01),<span class="variable">.down</span>(down11),<span class="variable">.right</span>(right11),<span class="variable">.sum_out</span>(sum11)</span><br><span class="line">    );</span><br><span class="line">    pe pe12(</span><br><span class="line">        <span class="variable">.clk</span>(clk),<span class="variable">.rst</span>(rst),<span class="variable">.left</span>(right11),<span class="variable">.up</span>(down02),<span class="variable">.down</span>(down12),<span class="variable">.right</span>(right12),<span class="variable">.sum_out</span>(sum12)</span><br><span class="line">    );</span><br><span class="line">    pe pe20(</span><br><span class="line">        <span class="variable">.clk</span>(clk),<span class="variable">.rst</span>(rst),<span class="variable">.left</span>(left20),<span class="variable">.up</span>(down10),<span class="variable">.down</span>(down20),<span class="variable">.right</span>(right20),<span class="variable">.sum_out</span>(sum20)</span><br><span class="line">    );</span><br><span class="line">    pe pe21(</span><br><span class="line">        <span class="variable">.clk</span>(clk),<span class="variable">.rst</span>(rst),<span class="variable">.left</span>(right20),<span class="variable">.up</span>(down11),<span class="variable">.down</span>(down21),<span class="variable">.right</span>(right21),<span class="variable">.sum_out</span>(sum21)</span><br><span class="line">    );</span><br><span class="line">    pe pe22(</span><br><span class="line">        <span class="variable">.clk</span>(clk),<span class="variable">.rst</span>(rst),<span class="variable">.left</span>(right21),<span class="variable">.up</span>(down12),<span class="variable">.down</span>(down22),<span class="variable">.right</span>(right22),<span class="variable">.sum_out</span>(sum22)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pe.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pe(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] left,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] up,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] down,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] right,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] sum_out,</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] mult_out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) <span class="keyword">begin</span></span><br><span class="line">            right &lt;= <span class="number">0</span>;</span><br><span class="line">            down &lt;=<span class="number">0</span>;</span><br><span class="line">            sum_out &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            down &lt;= up;</span><br><span class="line">            right &lt;= left;</span><br><span class="line">            sum_out &lt;= sum_out + mult_out;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    multiply u_mult(</span><br><span class="line">        <span class="variable">.a</span>(left),</span><br><span class="line">        <span class="variable">.b</span>(up),</span><br><span class="line">        <span class="variable">.out</span>(mult_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>multiply.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> multiply(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]b,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> out = a * b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3-Testbench"><a href="#1-3-Testbench" class="headerlink" title="1.3 Testbench"></a>1.3 Testbench</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_tb();</span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst;</span><br><span class="line">    <span class="keyword">reg</span> en;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>*<span class="number">9</span>-<span class="number">1</span>:<span class="number">0</span>] in1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>*<span class="number">9</span>-<span class="number">1</span>:<span class="number">0</span>] in2;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">9</span>*<span class="number">9</span>-<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        rst=<span class="number">0</span>;</span><br><span class="line">        in1=<span class="number">0</span>;</span><br><span class="line">        in2=<span class="number">0</span>;</span><br><span class="line">        en=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        rst=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        rst=<span class="number">0</span>;</span><br><span class="line">        in1=<span class="number">36&#x27;b0101_0010_0011_0011_0101_0010_0010_0100_0011</span>;</span><br><span class="line">        in2=<span class="number">36&#x27;b0101_0010_0011_0011_0101_0010_0010_0100_0011</span>;</span><br><span class="line">        #<span class="number">10</span></span><br><span class="line">        en=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">100</span></span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk=~clk;</span><br><span class="line"></span><br><span class="line">    top u_top(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst</span>(rst),</span><br><span class="line">        <span class="variable">.in1</span>(in1),</span><br><span class="line">        <span class="variable">.in2</span>(in2),</span><br><span class="line">        <span class="variable">.out</span>(out),</span><br><span class="line">        <span class="variable">.en</span>(en)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/12/18/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20231218195742146.png" alt="image-20231218195742146"></p>
</li>
</ul>
<h2 id="2-模式二：权重存储在脉动阵列单元中"><a href="#2-模式二：权重存储在脉动阵列单元中" class="headerlink" title="2.模式二：权重存储在脉动阵列单元中"></a>2.模式二：权重存储在脉动阵列单元中</h2><ul>
<li>在脉动阵列中流动的是输入和权重乘的中间结果，权重存储在脉动计算单元中</li>
</ul>
<h3 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h3><ul>
<li><p>模式二：脉动阵列计算矩阵乘法的初始状态</p>
<p><img src="/2023/12/18/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20231219162523972.png" alt="image-20231219162523972" style="zoom: 67%;"></p>
</li>
<li><p>实现框架</p>
<p><img src="/2023/12/18/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20231219143543113.png" alt="image-20231219143543113" style="zoom:50%;"></p>
</li>
<li><p><strong>这里的话实现的是权重$\times$输入</strong>，详情见reference中的参考</p>
<p><img src="/2023/12/18/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20231219153826503.png" alt="image-20231219153826503" style="zoom:50%;"></p>
<ul>
<li>当第一列固定不动的时候，其均只需要分别与$a_{11},a_{12},a_{13}$相乘，故第一列数据$w_{11},w_{21},w_{31}$是作为脉动阵列的第一行的</li>
</ul>
</li>
</ul>
<hr>
<h1 id="脉动阵列实现卷积操作"><a href="#脉动阵列实现卷积操作" class="headerlink" title="脉动阵列实现卷积操作"></a>脉动阵列实现卷积操作</h1><ul>
<li><p>原理参考：<a href="https://hitsz-cslab.gitee.io/dla/lab4/theory/">https://hitsz-cslab.gitee.io/dla/lab4/theory/</a></p>
<p><img src="/2023/12/18/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20231219144232798.png" alt="image-20231219144232798" style="zoom: 67%;"></p>
</li>
<li><p>将卷积计算进行如上图的转换后即可将卷积计算转化为求矩阵乘法</p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><p><a href="https://www.bilibili.com/video/BV1qX4y147it/?vd_source=221b76534ba13cfad544149d75ce9b6c">脉动阵列：高性能矩阵乘法器_哔哩哔哩_bilibili</a></p>
</li>
<li><p><a href="https://hitsz-cslab.gitee.io/dla/lab4/theory/">实验原理 - 深度学习体系结构（2021秋季） | 哈工大（深圳） (gitee.io)</a>（矩阵乘法模式一和卷积实现看这个就可以理解）</p>
</li>
<li><a href="https://zhuanlan.zhihu.com/p/421737378">Google AI芯片TPU核心架构—脉动阵列Systolic Array - 知乎 (zhihu.com)</a>（矩阵乘法模式二的详细解释看这个）</li>
<li><p><a href="https://blog.csdn.net/w_x_yhao/article/details/126979056">脉动阵列实现卷积计算_脉动阵列 卷积-CSDN博客</a>（矩阵乘法模式二看这个，里面有作者手画的图，一看就懂）</p>
</li>
<li><p><a href="https://github.com/SuperLiaoXH/SystolicArray-2D-FP16/blob/main/0 Source/PE_Array_2D.sv">SystolicArray-2D-FP16/0 Source/PE_Array_2D.sv at main · SuperLiaoXH/SystolicArray-2D-FP16 · GitHub</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/kongchung/p/13227256.html">https://www.cnblogs.com/kongchung/p/13227256.html</a></p>
</li>
<li><p><a href="https://github.com/wzc810049078/systolic-array-matrix-multiplier/blob/master/scr/matrix_mul_sa_pipe.v">systolic-array-matrix-multiplier/scr/matrix_mul_sa_pipe.v at master · wzc810049078/systolic-array-matrix-multiplier · GitHub</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI DSP</tag>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之FIR滤波器</title>
    <url>/2023/11/20/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIR%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    <content><![CDATA[<p>本节主要介绍了FIR滤波器的并行与串行verilog实现，及其量化方法。</p>
<span id="more"></span>
<h1 id="FIR滤波器设计原理"><a href="#FIR滤波器设计原理" class="headerlink" title="FIR滤波器设计原理"></a>FIR滤波器设计原理</h1><ul>
<li>详情见：(<a href="https://www.bilibili.com/video/BV1se411V7Ek/?spm_id_from=333.999.0.0&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">https://www.bilibili.com/video/BV1se411V7Ek/?spm_id_from=333.999.0.0&amp;vd_source=221b76534ba13cfad544149d75ce9b6c</a>)</li>
<li>线性相位造成延时的解释：<a href="https://blog.csdn.net/yhy0428/article/details/123308149">MATLAB中FIR滤波器的时延溢出问题详解：线性相位对信号造成的时延溢出及其消除方法，以及fir1等函数的使用_fir函数是怎么用_TechYin的博客-CSDN博客</a></li>
<li>关于相位与延时的关系这里解释的很好：<a href="https://www.bilibili.com/video/BV1Wg411e7Dg/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">【数字信号处理】15.2 线性相位FIR数字滤波器的特性_哔哩哔哩_bilibili</a></li>
</ul>
<hr>
<h1 id="FIR滤波器的硬件实现"><a href="#FIR滤波器的硬件实现" class="headerlink" title="FIR滤波器的硬件实现"></a>FIR滤波器的硬件实现</h1><h2 id="1-基于累加器的FIR滤波器设计"><a href="#1-基于累加器的FIR滤波器设计" class="headerlink" title="1.基于累加器的FIR滤波器设计"></a>1.基于累加器的FIR滤波器设计</h2><ul>
<li><p>以4阶FIR滤波器为例，采用FPGA实现累加器组成的FIR滤波器电路，有：</p>
<script type="math/tex; mode=display">
y(n) = x(n) + x(n-1) + x(n-2) + x(n-3) + x(n-4)\\
h(n) = \{1,1,1,1,1\}</script></li>
<li><p>其中，$x(n)=sin(40\pi t) + sin(4\pi t)$，其分别对应$20Hz$和$2Hz$，设采样频率为$f_s = 100Hz$，其也就是FPGA的系统时钟</p>
</li>
<li><p>FPGA设计的系统框图如下：</p>
<p><img src="/2023/11/20/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIR%E6%BB%A4%E6%B3%A2%E5%99%A8/image-20231120181039172.png" alt="image-20231120181039172" style="zoom: 67%;"></p>
</li>
</ul>
<h2 id="2-源文件"><a href="#2-源文件" class="headerlink" title="2.源文件"></a>2.源文件</h2><ul>
<li><p>accumulator_fir.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> accumulator_fir(</span><br><span class="line">    <span class="keyword">input</span> clk,                  <span class="comment">//系统时钟，100Hz</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] xin,     <span class="comment">//输入数据</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">signed</span> [<span class="number">11</span>:<span class="number">0</span>] yout   <span class="comment">//滤波输出数据</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//产生4级触发器输出信号，相当于4级延时后的信号</span></span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] x1,x2,x3,x4;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">		 x1 &lt;= xin;</span><br><span class="line">		 x2 &lt;= x1;</span><br><span class="line">		 x3 &lt;= x2;</span><br><span class="line">		 x4 &lt;= x3;</span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对连续5个输入数据进行累加，完成滤波输出	 </span></span><br><span class="line">	<span class="keyword">assign</span> yout = xin + x1 + x2 + x3 + x4; </span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>fir_test_data.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fir_test_data(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> out_valid_sin2Hz,</span><br><span class="line">    <span class="keyword">output</span> out_valid_sin20Hz,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] dout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] sin_data_2Hz;</span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] sin_data_20Hz; <span class="comment">//注意这边一定要定义成有符号数，或者手动补充最高位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生2Hz的正弦信号</span></span><br><span class="line">    dds_compiler_0 u1(</span><br><span class="line">        <span class="variable">.aclk</span>(clk),</span><br><span class="line">        <span class="variable">.s_axis_config_tvalid</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">        <span class="variable">.s_axis_config_tdata</span>(<span class="number">16&#x27;d1311</span>),</span><br><span class="line">        <span class="variable">.m_axis_data_tvalid</span>(out_valid_sin2Hz),</span><br><span class="line">        <span class="variable">.m_axis_data_tdata</span>(sin_data_2Hz)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生20Hz的正弦信号</span></span><br><span class="line">    dds_compiler_0 u2(</span><br><span class="line">        <span class="variable">.aclk</span>(clk),</span><br><span class="line">        <span class="variable">.s_axis_config_tvalid</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">        <span class="variable">.s_axis_config_tdata</span>(<span class="number">16&#x27;d13107</span>),</span><br><span class="line">        <span class="variable">.m_axis_data_tvalid</span>(out_valid_sin20Hz),</span><br><span class="line">        <span class="variable">.m_axis_data_tdata</span>(sin_data_20Hz)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        dout &lt;= sin_data_2Hz + sin_data_20Hz;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FIR_accumulator_design.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FIR_accumulator_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> out_valid_sin2Hz,</span><br><span class="line">    <span class="keyword">output</span> out_valid_sin20Hz,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">signed</span> [<span class="number">11</span>:<span class="number">0</span>] yout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] xin;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//频率叠加信号生成模块</span></span><br><span class="line">    fir_test_data u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.out_valid_sin2Hz</span>(out_valid_sin2Hz),</span><br><span class="line">        <span class="variable">.out_valid_sin20Hz</span>(out_valid_sin20Hz),</span><br><span class="line">        <span class="variable">.dout</span>(xin)</span><br><span class="line">    );</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//叠加器构成的FIR滤波模块</span></span><br><span class="line">    accumulator_fir u2(</span><br><span class="line">        <span class="variable">.clk</span>(clk), </span><br><span class="line">        <span class="variable">.xin</span>(xin), </span><br><span class="line">        <span class="variable">.yout</span>(yout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Testbench"><a href="#3-Testbench" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ms / 1ms</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FIR_accumulator_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk_100Hz;</span><br><span class="line">    <span class="keyword">wire</span> out_valid_sin2Hz;</span><br><span class="line">    <span class="keyword">wire</span> out_valid_sin20Hz;</span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">11</span>:<span class="number">0</span>] yout;</span><br><span class="line"></span><br><span class="line">    FIR_accumulator_design u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk_100Hz),</span><br><span class="line">        <span class="variable">.out_valid_sin2Hz</span>(out_valid_sin2Hz),</span><br><span class="line">        <span class="variable">.out_valid_sin20Hz</span>(out_valid_sin20Hz),</span><br><span class="line">        <span class="variable">.yout</span>(yout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		clk_100Hz = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk_100Hz &lt;= ~clk_100Hz;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>仿真结果：</p>
<p><img src="/2023/11/20/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIR%E6%BB%A4%E6%B3%A2%E5%99%A8/Snipaste_2023-11-20_17-51-29.png" alt="Snipaste_2023-11-20_17-51-29"></p>
</li>
</ul>
<hr>
<h1 id="FIR系数的量化方法"><a href="#FIR系数的量化方法" class="headerlink" title="FIR系数的量化方法"></a>FIR系数的量化方法</h1><h2 id="1-量化原则"><a href="#1-量化原则" class="headerlink" title="1.量化原则"></a>1.量化原则</h2><ul>
<li>归一化处理$\rightarrow $乘以$2^{B-1}-1$$\rightarrow$四舍五入取整（实际设计可能稍有出入，不除以绝对值，方便后期还原，详情见IP核那一节）<ul>
<li>若量化位宽为$B$bit，那么乘以$2^{B-1}-1$的原因是有符号数的范围是-$2^{B-1}\sim 2^{B-1}-1$</li>
</ul>
</li>
<li><strong>输出与输入相比，需要增加的位宽：所有系数的绝对值之和$&lt;2^{B_{pad}}$，$B_{pad}$为增加的位宽</strong></li>
</ul>
<h2 id="2-MATLAB代码"><a href="#2-MATLAB代码" class="headerlink" title="2.MATLAB代码"></a>2.MATLAB代码</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N=<span class="number">16</span>;      <span class="comment">%滤波器长度</span></span><br><span class="line">fs=<span class="number">2000</span>;   <span class="comment">%采样频率</span></span><br><span class="line">fc=<span class="number">200</span>;    <span class="comment">%低通滤波器的3dB截止频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%生成窗函数</span></span><br><span class="line">window=blackman(N)&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="comment">%采用fir1函数设计FIR滤波器</span></span><br><span class="line">b=fir1(N<span class="number">-1</span>,fc*<span class="number">2</span>/fs,window);</span><br><span class="line"></span><br><span class="line"><span class="comment">%对滤波器系数进行量化</span></span><br><span class="line">B=<span class="number">8</span>;                   <span class="comment">%量化位宽为8比特</span></span><br><span class="line">Q_h=b/<span class="built_in">max</span>(<span class="built_in">abs</span>(b));     <span class="comment">%系数归一化处理</span></span><br><span class="line">Q_h=Q_h*(<span class="number">2</span>^(B<span class="number">-1</span>)<span class="number">-1</span>);   <span class="comment">%乘以B比特位宽的最大正整数</span></span><br><span class="line">Q_h8=<span class="built_in">round</span>(Q_h);       <span class="comment">%四舍五入</span></span><br><span class="line"></span><br><span class="line">B=<span class="number">12</span>;                  <span class="comment">%量化位宽为12比特</span></span><br><span class="line">Q_h=b/<span class="built_in">max</span>(<span class="built_in">abs</span>(b));     <span class="comment">%系数归一化处理</span></span><br><span class="line">Q_h=Q_h*(<span class="number">2</span>^(B<span class="number">-1</span>)<span class="number">-1</span>);   <span class="comment">%乘以B比特位宽的最大正整数</span></span><br><span class="line">Q_h12=<span class="built_in">round</span>(Q_h)       <span class="comment">%四舍五入</span></span><br><span class="line"></span><br><span class="line">abs_sum=sum(<span class="built_in">abs</span>(Q_h12))</span><br><span class="line"></span><br><span class="line"><span class="comment">%求滤波器的幅频响应</span></span><br><span class="line">m_b=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(fft(b,<span class="number">1024</span>)));</span><br><span class="line">m_8=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(fft(Q_h8,<span class="number">1024</span>)));</span><br><span class="line">m_12=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(fft(Q_h12,<span class="number">1024</span>)));</span><br><span class="line"><span class="comment">%对幅频响应归一化处理</span></span><br><span class="line">m_b=m_b-<span class="built_in">max</span>(m_b);</span><br><span class="line">m_8=m_8-<span class="built_in">max</span>(m_8);      </span><br><span class="line">m_12=m_12-<span class="built_in">max</span>(m_12);</span><br><span class="line"></span><br><span class="line"><span class="comment">%设置幅频响应的横坐标单位为Hz</span></span><br><span class="line">x_f=[<span class="number">0</span>:(fs/<span class="built_in">length</span>(m_b)):fs/<span class="number">2</span>];</span><br><span class="line"><span class="comment">%只显示正频率部分的幅频响应</span></span><br><span class="line">mb=m_b(<span class="number">1</span>:<span class="built_in">length</span>(x_f));</span><br><span class="line">m8=m_8(<span class="number">1</span>:<span class="built_in">length</span>(x_f));</span><br><span class="line">m12=m_12(<span class="number">1</span>:<span class="built_in">length</span>(x_f));</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘制幅频响应曲线</span></span><br><span class="line"><span class="built_in">plot</span>(x_f,mb,<span class="string">&#x27;-&#x27;</span>,x_f,m8,<span class="string">&#x27;--&#x27;</span>,x_f,m12,<span class="string">&#x27;-.&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;频率(Hz)&#x27;</span>);ylabel(<span class="string">&#x27;幅度(dB)&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;未量化&#x27;</span>,<span class="string">&#x27;8bit量化&#x27;</span>,<span class="string">&#x27;12bit量化&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不同量化位宽对应$h(n)$幅频特性的比较：</p>
<p><img src="/2023/11/20/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIR%E6%BB%A4%E6%B3%A2%E5%99%A8/untitled.bmp" alt="untitled"></p>
</li>
</ul>
<hr>
<h1 id="并行FIR滤波的硬件实现"><a href="#并行FIR滤波的硬件实现" class="headerlink" title="并行FIR滤波的硬件实现"></a>并行FIR滤波的硬件实现</h1><h2 id="1-基于并行FIR滤波器的设计"><a href="#1-基于并行FIR滤波器的设计" class="headerlink" title="1.基于并行FIR滤波器的设计"></a>1.基于并行FIR滤波器的设计</h2><ul>
<li><p>由于经matlab中fir1函数设计的滤波器，都具有线性相位，且$h(n)$的系数是对称的，即$h(k)=h(n-k)$，那么对于此对称结构，有如下实现框图：</p>
<p><img src="/2023/11/20/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIR%E6%BB%A4%E6%B3%A2%E5%99%A8/image-20231120213503803.png" alt="image-20231120213503803" style="zoom:50%;"></p>
</li>
<li><p>全并行处理：<strong>时钟频率与数据速率相同</strong></p>
</li>
</ul>
<h2 id="2-源文件-1"><a href="#2-源文件-1" class="headerlink" title="2.源文件"></a>2.源文件</h2><ul>
<li><p>FirParallel.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FirParallel(</span><br><span class="line">    <span class="keyword">input</span> clk,                      <span class="comment">//系统时钟：2 000 Hz</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] Xin,         <span class="comment">//输入数据</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">21</span>:<span class="number">0</span>] Yout   <span class="comment">//输出数据</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将数据存入移位寄存器Xin_Reg中</span></span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] Xin_Reg[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">	   <span class="keyword">begin</span></span><br><span class="line">		   Xin_Reg[<span class="number">0</span>]  &lt;= Xin;</span><br><span class="line"> 		   Xin_Reg[<span class="number">1</span>]  &lt;= Xin_Reg[<span class="number">0</span>];</span><br><span class="line">		   Xin_Reg[<span class="number">2</span>]  &lt;= Xin_Reg[<span class="number">1</span>];</span><br><span class="line"> 		   Xin_Reg[<span class="number">3</span>]  &lt;= Xin_Reg[<span class="number">2</span>];</span><br><span class="line">		   Xin_Reg[<span class="number">4</span>]  &lt;= Xin_Reg[<span class="number">3</span>];</span><br><span class="line"> 		   Xin_Reg[<span class="number">5</span>]  &lt;= Xin_Reg[<span class="number">4</span>];</span><br><span class="line">		   Xin_Reg[<span class="number">6</span>]  &lt;= Xin_Reg[<span class="number">5</span>];</span><br><span class="line"> 		   Xin_Reg[<span class="number">7</span>]  &lt;= Xin_Reg[<span class="number">6</span>];</span><br><span class="line"> 		   Xin_Reg[<span class="number">8</span>]  &lt;= Xin_Reg[<span class="number">7</span>];</span><br><span class="line">		   Xin_Reg[<span class="number">9</span>]  &lt;= Xin_Reg[<span class="number">8</span>];</span><br><span class="line"> 		   Xin_Reg[<span class="number">10</span>] &lt;= Xin_Reg[<span class="number">9</span>];</span><br><span class="line">		   Xin_Reg[<span class="number">11</span>] &lt;= Xin_Reg[<span class="number">10</span>];</span><br><span class="line"> 		   Xin_Reg[<span class="number">12</span>] &lt;= Xin_Reg[<span class="number">11</span>];</span><br><span class="line">		   Xin_Reg[<span class="number">13</span>] &lt;= Xin_Reg[<span class="number">12</span>];</span><br><span class="line"> 		   Xin_Reg[<span class="number">14</span>] &lt;= Xin_Reg[<span class="number">13</span>];</span><br><span class="line"> 		   Xin_Reg[<span class="number">15</span>] &lt;= Xin_Reg[<span class="number">14</span>];</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//采用8个双输入加法器，完成对称系数相加</span></span><br><span class="line">	<span class="comment">//两个8比特数据相加，需要用9比特数据存储数据</span></span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] Xin_Add [<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">	   <span class="keyword">begin</span></span><br><span class="line">         Xin_Add[<span class="number">0</span>] = Xin_Reg[<span class="number">0</span>] + Xin_Reg[<span class="number">15</span>];</span><br><span class="line">         Xin_Add[<span class="number">1</span>] = Xin_Reg[<span class="number">1</span>] + Xin_Reg[<span class="number">14</span>];</span><br><span class="line">         Xin_Add[<span class="number">2</span>] = Xin_Reg[<span class="number">2</span>] + Xin_Reg[<span class="number">13</span>];</span><br><span class="line">         Xin_Add[<span class="number">3</span>] = Xin_Reg[<span class="number">3</span>] + Xin_Reg[<span class="number">12</span>];</span><br><span class="line">         Xin_Add[<span class="number">4</span>] = Xin_Reg[<span class="number">4</span>] + Xin_Reg[<span class="number">11</span>];</span><br><span class="line">         Xin_Add[<span class="number">5</span>] = Xin_Reg[<span class="number">5</span>] + Xin_Reg[<span class="number">10</span>];</span><br><span class="line">         Xin_Add[<span class="number">6</span>] = Xin_Reg[<span class="number">6</span>] + Xin_Reg[<span class="number">9</span>];</span><br><span class="line">         Xin_Add[<span class="number">7</span>] = Xin_Reg[<span class="number">7</span>] + Xin_Reg[<span class="number">8</span>];</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//实例化8个有符号数乘法器IP核mult</span></span><br><span class="line">	<span class="comment">//2级流水线延时输出</span></span><br><span class="line">	<span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">20</span>:<span class="number">0</span>] Mout [<span class="number">7</span>:<span class="number">0</span>];  </span><br><span class="line">	mult	u0 (</span><br><span class="line">		<span class="variable">.CLK</span> (clk),</span><br><span class="line">		<span class="variable">.A</span> (Xin_Add[<span class="number">0</span>]),       </span><br><span class="line">		<span class="variable">.B</span> (<span class="number">12&#x27;d0</span>),       </span><br><span class="line">		<span class="variable">.P</span> (Mout[<span class="number">0</span>]));    </span><br><span class="line"></span><br><span class="line">	mult	u1 (</span><br><span class="line">		<span class="variable">.CLK</span> (clk),</span><br><span class="line">		<span class="variable">.A</span> (Xin_Add[<span class="number">1</span>]),       </span><br><span class="line">		<span class="variable">.B</span> (-<span class="number">12&#x27;d7</span>),       </span><br><span class="line">		<span class="variable">.P</span> (Mout[<span class="number">1</span>]));  </span><br><span class="line"></span><br><span class="line">	mult	u2 (</span><br><span class="line">		<span class="variable">.CLK</span> (clk),</span><br><span class="line">		<span class="variable">.A</span> (Xin_Add[<span class="number">2</span>]),       </span><br><span class="line">		<span class="variable">.B</span> (-<span class="number">12&#x27;d15</span>),       </span><br><span class="line">		<span class="variable">.P</span> (Mout[<span class="number">2</span>]));  </span><br><span class="line">		</span><br><span class="line">	mult	u3 (</span><br><span class="line">		<span class="variable">.CLK</span> (clk),</span><br><span class="line">		<span class="variable">.A</span> (Xin_Add[<span class="number">3</span>]),       </span><br><span class="line">		<span class="variable">.B</span> (<span class="number">12&#x27;d46</span>),       </span><br><span class="line">		<span class="variable">.P</span> (Mout[<span class="number">3</span>]));  		</span><br><span class="line"></span><br><span class="line">	mult	u4 (</span><br><span class="line">		<span class="variable">.CLK</span> (clk),</span><br><span class="line">		<span class="variable">.A</span> (Xin_Add[<span class="number">4</span>]),       </span><br><span class="line">		<span class="variable">.B</span> (<span class="number">12&#x27;d307</span>),       </span><br><span class="line">		<span class="variable">.P</span> (Mout[<span class="number">4</span>]));    </span><br><span class="line"></span><br><span class="line">	mult	u5 (</span><br><span class="line">		<span class="variable">.CLK</span> (clk),</span><br><span class="line">		<span class="variable">.A</span> (Xin_Add[<span class="number">5</span>]),       </span><br><span class="line">		<span class="variable">.B</span> (<span class="number">12&#x27;d850</span>),       </span><br><span class="line">		<span class="variable">.P</span> (Mout[<span class="number">5</span>]));  </span><br><span class="line"></span><br><span class="line">	mult	u6 (</span><br><span class="line">		<span class="variable">.CLK</span> (clk),</span><br><span class="line">		<span class="variable">.A</span> (Xin_Add[<span class="number">6</span>]),       </span><br><span class="line">		<span class="variable">.B</span> (<span class="number">12&#x27;d1545</span>),       </span><br><span class="line">		<span class="variable">.P</span> (Mout[<span class="number">6</span>]));  </span><br><span class="line">		</span><br><span class="line">	mult	u7 (</span><br><span class="line">		<span class="variable">.CLK</span> (clk),</span><br><span class="line">		<span class="variable">.A</span> (Xin_Add[<span class="number">7</span>]),       </span><br><span class="line">		<span class="variable">.B</span> (<span class="number">12&#x27;d2047</span>),       </span><br><span class="line">		<span class="variable">.P</span> (Mout[<span class="number">7</span>]));  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//采用2级流水线完成8输入加法运算</span></span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">20</span>:<span class="number">0</span>] sum1,sum2;	</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">		sum1 &lt;= Mout[<span class="number">0</span>]+Mout[<span class="number">1</span>]+Mout[<span class="number">2</span>]+Mout[<span class="number">3</span>];</span><br><span class="line">		sum2 &lt;= Mout[<span class="number">4</span>]+Mout[<span class="number">5</span>]+Mout[<span class="number">6</span>]+Mout[<span class="number">7</span>];</span><br><span class="line">		Yout &lt;= sum1 + sum2;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FirParallel_test_data.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FirParallel_test_data(</span><br><span class="line">    <span class="keyword">input</span> clk,                  <span class="comment">//2000Hz</span></span><br><span class="line">    <span class="keyword">output</span> out_valid_sin100Hz,</span><br><span class="line">    <span class="keyword">output</span> out_valid_sin500Hz,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] dout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] sin_data_100Hz; <span class="comment">//这里在如果用7bit在modelsim中仿真会报错，但在vivado中仿真不会报错</span></span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] sin_data_500Hz; <span class="comment">//实际上ip核中例化的是7bit</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生100Hz的正弦信号</span></span><br><span class="line">    dds_for_FirParallel u1(</span><br><span class="line">        <span class="variable">.aclk</span>(clk),</span><br><span class="line">        <span class="variable">.s_axis_config_tvalid</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">        <span class="variable">.s_axis_config_tdata</span>(<span class="number">16&#x27;d3277</span>),</span><br><span class="line">        <span class="variable">.m_axis_data_tvalid</span>(out_valid_sin100Hz),</span><br><span class="line">        <span class="variable">.m_axis_data_tdata</span>(sin_data_100Hz)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生500Hz的正弦信号</span></span><br><span class="line">    dds_for_FirParallel u2(</span><br><span class="line">        <span class="variable">.aclk</span>(clk),</span><br><span class="line">        <span class="variable">.s_axis_config_tvalid</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">        <span class="variable">.s_axis_config_tdata</span>(<span class="number">16&#x27;d16384</span>),</span><br><span class="line">        <span class="variable">.m_axis_data_tvalid</span>(out_valid_sin500Hz),</span><br><span class="line">        <span class="variable">.m_axis_data_tdata</span>(sin_data_500Hz)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        dout &lt;= sin_data_100Hz + sin_data_500Hz;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FirParallel_design.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FirParallel_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> out_valid_sin100Hz,</span><br><span class="line">    <span class="keyword">output</span> out_valid_sin500Hz,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">signed</span> [<span class="number">21</span>:<span class="number">0</span>] yout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] xin;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//频率叠加信号生成模块</span></span><br><span class="line">    FirParallel_test_data u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.out_valid_sin100Hz</span>(out_valid_sin100Hz),</span><br><span class="line">        <span class="variable">.out_valid_sin500Hz</span>(out_valid_sin500Hz),</span><br><span class="line">        <span class="variable">.dout</span>(xin)</span><br><span class="line">    );</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//并行线性相位FIR滤波模块</span></span><br><span class="line">    FirParallel u2(</span><br><span class="line">        <span class="variable">.clk</span>(clk), </span><br><span class="line">        <span class="variable">.Xin</span>(xin), </span><br><span class="line">        <span class="variable">.Yout</span>(yout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Testbench-1"><a href="#3-Testbench-1" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FirParallel_design_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">wire</span> out_valid_sin100Hz;</span><br><span class="line">    <span class="keyword">wire</span> out_valid_sin500Hz;</span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">21</span>:<span class="number">0</span>] yout;</span><br><span class="line"></span><br><span class="line">    FirParallel_design u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.out_valid_sin100Hz</span>(out_valid_sin100Hz),</span><br><span class="line">        <span class="variable">.out_valid_sin500Hz</span>(out_valid_sin500Hz),</span><br><span class="line">        <span class="variable">.yout</span>(yout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		clk = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">250000</span> clk &lt;= ~clk;	 <span class="comment">//产生2000Hz的系统时钟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/11/20/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIR%E6%BB%A4%E6%B3%A2%E5%99%A8/Snipaste_2023-11-20_21-08-07.png" alt="Snipaste_2023-11-20_21-08-07"></p>
</li>
</ul>
<hr>
<h1 id="串行FIR滤波器的硬件实现"><a href="#串行FIR滤波器的硬件实现" class="headerlink" title="串行FIR滤波器的硬件实现*"></a>串行FIR滤波器的硬件实现*</h1><h2 id="1-基于串行结构的FIR滤波器设计"><a href="#1-基于串行结构的FIR滤波器设计" class="headerlink" title="1.基于串行结构的FIR滤波器设计"></a>1.基于串行结构的FIR滤波器设计</h2><ul>
<li><p>核心思想：速度换面积</p>
</li>
<li><p>与并行FIR滤波器一致，实现16个抽头系数的低通滤波器，那么，滤波器的时钟速率是数据速率的8倍，因为此时只有一个乘法器，完成一次乘加运算，需要8个时钟周期，而进来的16个输入数据，需要在这8个时钟周期之内保持不变，所以数据时钟是滤波器时钟周期的8倍，那么对应频率就是：<strong>时钟频率是数据频率的8倍</strong></p>
</li>
<li><p>FPGA设计的系统框图如下：</p>
<p><img src="/2023/11/20/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIR%E6%BB%A4%E6%B3%A2%E5%99%A8/image-20231121135956807.png" alt="image-20231121135956807"></p>
</li>
<li><p>下述代码中有一段用<strong>for循环实现移位操作</strong>值得指出，个人认为很精彩：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数据存入移位寄存器Xin_Reg中</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] Xin_Reg[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] i,j; </span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (rst) <span class="keyword">begin</span> </span><br><span class="line">		<span class="comment">//初始化寄存器值为0</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i=i+<span class="number">1</span>)</span><br><span class="line">			 Xin_Reg[i]&lt;=<span class="number">8&#x27;d0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">	    <span class="keyword">if</span> (count==<span class="number">7</span>) <span class="keyword">begin</span></span><br><span class="line">			<span class="comment">//Xin_Reg[0] &lt;= Xin;     //写在for循环前面和后面结果一致，都可以</span></span><br><span class="line">		    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">15</span>; j=j+<span class="number">1</span>)</span><br><span class="line">			   Xin_Reg[j+<span class="number">1</span>] &lt;= Xin_Reg[j];</span><br><span class="line">			Xin_Reg[<span class="number">0</span>] &lt;= Xin;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-源文件-2"><a href="#2-源文件-2" class="headerlink" title="2.源文件"></a>2.源文件</h2><ul>
<li><p>FirFullSerial.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FirFullSerial(</span><br><span class="line">	<span class="keyword">input</span>		rst,                      <span class="comment">//复位信号，高电平有效</span></span><br><span class="line">	<span class="keyword">input</span>		clk,                      <span class="comment">//FPGA系统时钟，频率为16kHz</span></span><br><span class="line">	<span class="keyword">input</span>	 <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>]	Xin,          <span class="comment">//数据输入频率为2khZ</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">21</span>:<span class="number">0</span>] Yout);    <span class="comment">//滤波后的输出数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>  <span class="keyword">signed</span> [<span class="number">11</span>:<span class="number">0</span>] coe;            <span class="comment">//滤波器为12比特量化数据</span></span><br><span class="line">	<span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] add_s;           <span class="comment">//输入为8比特量化数据，两个对称系数相加需要9比特存储</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//实例化有符号数加法器IP核,对输入数据进行1位符号位扩展，输出结果为9比特数据</span></span><br><span class="line">	<span class="comment">//无流水线延时</span></span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] add_a;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>] add_b;</span><br><span class="line">	adder u2 (</span><br><span class="line">		<span class="variable">.A</span> (add_a),</span><br><span class="line">		<span class="variable">.B</span> (add_b),</span><br><span class="line">		<span class="variable">.S</span> (add_s));	</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//3位计数器，计数周期为8，为输入数据速率</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst)</span><br><span class="line">		<span class="keyword">if</span> (rst)</span><br><span class="line">			count &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			count &lt;= count + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将数据存入移位寄存器Xin_Reg中</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] Xin_Reg[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] i,j; </span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (rst) <span class="keyword">begin</span> </span><br><span class="line">			<span class="comment">//初始化寄存器值为0</span></span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i=i+<span class="number">1</span>)</span><br><span class="line">				 Xin_Reg[i]&lt;=<span class="number">8&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		    <span class="keyword">if</span> (count==<span class="number">7</span>) <span class="keyword">begin</span></span><br><span class="line">				<span class="comment">//Xin_Reg[0] &lt;= Xin;     //写在for循环前面和后面结果一致，都可以</span></span><br><span class="line">			    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">15</span>; j=j+<span class="number">1</span>)</span><br><span class="line">				   Xin_Reg[j+<span class="number">1</span>] &lt;= Xin_Reg[j];</span><br><span class="line">				Xin_Reg[<span class="number">0</span>] &lt;= Xin;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将对称系数的输入数据相加，同时将对应的滤波器系数送入乘法器</span></span><br><span class="line">	<span class="comment">//为了保证加法运算不溢出，输入输出数据均扩展为9比特。</span></span><br><span class="line">	<span class="comment">//需要注意的是，下面程序只使用了一个加法器</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">		    add_a &lt;= <span class="number">13&#x27;d0</span>;</span><br><span class="line">			add_b &lt;= <span class="number">13&#x27;d0</span>;</span><br><span class="line">			coe &lt;= <span class="number">12&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span> (count==<span class="number">3&#x27;d0</span>) <span class="keyword">begin</span></span><br><span class="line">			    add_a &lt;= &#123;Xin_Reg[<span class="number">0</span>][<span class="number">7</span>],Xin_Reg[<span class="number">0</span>]&#125;;</span><br><span class="line">			    add_b &lt;= &#123;Xin_Reg[<span class="number">15</span>][<span class="number">7</span>],Xin_Reg[<span class="number">15</span>]&#125;;</span><br><span class="line">				coe &lt;= <span class="number">12&#x27;d0</span>;<span class="comment">//c0</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">3&#x27;d1</span>) <span class="keyword">begin</span></span><br><span class="line">				add_a &lt;= &#123;Xin_Reg[<span class="number">1</span>][<span class="number">7</span>],Xin_Reg[<span class="number">1</span>]&#125;;</span><br><span class="line">				add_b &lt;= &#123;Xin_Reg[<span class="number">14</span>][<span class="number">7</span>],Xin_Reg[<span class="number">14</span>]&#125;;					</span><br><span class="line">				coe &lt;= -<span class="number">12&#x27;d7</span>; <span class="comment">//c1</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">3&#x27;d2</span>) <span class="keyword">begin</span></span><br><span class="line">				add_a &lt;= &#123;Xin_Reg[<span class="number">2</span>][<span class="number">7</span>],Xin_Reg[<span class="number">2</span>]&#125;;</span><br><span class="line">				add_b &lt;= &#123;Xin_Reg[<span class="number">13</span>][<span class="number">7</span>],Xin_Reg[<span class="number">13</span>]&#125;;						</span><br><span class="line">				coe &lt;= -<span class="number">12&#x27;d15</span>; <span class="comment">//c2</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">3&#x27;d3</span>) <span class="keyword">begin</span></span><br><span class="line">				add_a &lt;= &#123;Xin_Reg[<span class="number">3</span>][<span class="number">7</span>],Xin_Reg[<span class="number">3</span>]&#125;;</span><br><span class="line">				add_b &lt;= &#123;Xin_Reg[<span class="number">12</span>][<span class="number">7</span>],Xin_Reg[<span class="number">12</span>]&#125;;</span><br><span class="line">				coe &lt;= <span class="number">12&#x27;d46</span>; <span class="comment">//c3</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">3&#x27;d4</span>) <span class="keyword">begin</span></span><br><span class="line">				add_a &lt;= &#123;Xin_Reg[<span class="number">4</span>][<span class="number">7</span>],Xin_Reg[<span class="number">4</span>]&#125;;</span><br><span class="line">				add_b &lt;= &#123;Xin_Reg[<span class="number">11</span>][<span class="number">7</span>],Xin_Reg[<span class="number">11</span>]&#125;;						</span><br><span class="line">				coe &lt;= <span class="number">12&#x27;d307</span>; <span class="comment">//c4</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">3&#x27;d5</span>) <span class="keyword">begin</span></span><br><span class="line">				add_a &lt;= &#123;Xin_Reg[<span class="number">5</span>][<span class="number">7</span>],Xin_Reg[<span class="number">5</span>]&#125;;</span><br><span class="line">				add_b &lt;= &#123;Xin_Reg[<span class="number">10</span>][<span class="number">7</span>],Xin_Reg[<span class="number">10</span>]&#125;;				</span><br><span class="line">				coe &lt;= <span class="number">12&#x27;d850</span>; <span class="comment">//c5</span></span><br><span class="line">			<span class="keyword">end</span>					</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">3&#x27;d6</span>) <span class="keyword">begin</span></span><br><span class="line">				add_a &lt;= &#123;Xin_Reg[<span class="number">6</span>][<span class="number">7</span>],Xin_Reg[<span class="number">6</span>]&#125;;</span><br><span class="line">				add_b &lt;= &#123;Xin_Reg[<span class="number">9</span>][<span class="number">7</span>],Xin_Reg[<span class="number">9</span>]&#125;;						</span><br><span class="line">				coe &lt;= <span class="number">12&#x27;d1545</span>; <span class="comment">//c6</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">				add_a &lt;= &#123;Xin_Reg[<span class="number">7</span>][<span class="number">7</span>],Xin_Reg[<span class="number">7</span>]&#125;;</span><br><span class="line">				add_b &lt;= &#123;Xin_Reg[<span class="number">8</span>][<span class="number">7</span>],Xin_Reg[<span class="number">8</span>]&#125;;						</span><br><span class="line">				coe &lt;= <span class="number">12&#x27;d2047</span>; <span class="comment">//c7</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//以8倍数据速率调用乘法器IP核，由于滤波器长度为16，系数具有对称性，故可在一个数据</span></span><br><span class="line">	<span class="comment">//周期内完成所有8个滤波器系数与数据的乘法运算</span></span><br><span class="line">	<span class="comment">//实例化有符号数乘法器IP核mult</span></span><br><span class="line">	<span class="comment">//1级流水线延时输出</span></span><br><span class="line">	<span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">20</span>:<span class="number">0</span>] Mout;  </span><br><span class="line">	mult2 u11 (</span><br><span class="line">		<span class="variable">.clk</span> (clk),</span><br><span class="line">		<span class="variable">.a</span> (add_s),</span><br><span class="line">		<span class="variable">.b</span> (coe),</span><br><span class="line">		<span class="variable">.p</span> (Mout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对滤波器系数与输入数据的乘法结果进行累加，并输出滤波后的数据</span></span><br><span class="line">	<span class="comment">//考虑到乘法器及累加器的延时，需要计数器为2时对累加器清零，同时输出滤波器结果数据。</span></span><br><span class="line">	<span class="comment">//类似的时延长度一方面可通过精确计算获取，但更好的方法是通过行为仿真查看</span></span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">21</span>:<span class="number">0</span>] sum;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (rst) <span class="keyword">begin</span> </span><br><span class="line">			sum &lt;= <span class="number">22&#x27;d0</span>; </span><br><span class="line">			Yout &lt;= <span class="number">22&#x27;d0</span>;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span> (count == <span class="number">2</span>) <span class="keyword">begin</span></span><br><span class="line">				 Yout &lt;= sum;<span class="comment">//count==2时完成了8次乘累加</span></span><br><span class="line">				 sum &lt;= Mout;<span class="comment">//count==3时得到第一个乘数</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			    sum &lt;= sum + Mout;  <span class="comment">//1级延时</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FirFullSerial_design.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FirFullSerial_design(</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> clk_data,    <span class="comment">//2kHz</span></span><br><span class="line">	<span class="keyword">input</span> clk_fir,     <span class="comment">//16kHz</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">21</span>:<span class="number">0</span>] dout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] xin;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//频率叠加信号生成模块</span></span><br><span class="line">    FirParallel_test_data u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk_data),</span><br><span class="line">        <span class="variable">.out_valid_sin100Hz</span>(),</span><br><span class="line">        <span class="variable">.out_valid_sin500Hz</span>(),</span><br><span class="line">        <span class="variable">.dout</span>(xin)</span><br><span class="line">    );</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//串行FIR滤波模块</span></span><br><span class="line">    FirFullSerial u2(</span><br><span class="line">        <span class="variable">.clk</span>(clk_fir), </span><br><span class="line">        <span class="variable">.rst</span>(rst),</span><br><span class="line">        <span class="variable">.Xin</span>(xin), </span><br><span class="line">        <span class="variable">.Yout</span>(dout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Testbench-2"><a href="#3-Testbench-2" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FirFullSerial_tb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Inputs</span></span><br><span class="line">	<span class="keyword">reg</span> rst;</span><br><span class="line">	<span class="keyword">reg</span> clk_data;</span><br><span class="line">	<span class="keyword">reg</span> clk_fir;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Outputs</span></span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">21</span>:<span class="number">0</span>] dout;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the Unit Under Test (UUT)</span></span><br><span class="line">	FirFullSerial_design uut (</span><br><span class="line">		<span class="variable">.rst</span>(rst), </span><br><span class="line">		<span class="variable">.clk_data</span>(clk_data), </span><br><span class="line">		<span class="variable">.clk_fir</span>(clk_fir), </span><br><span class="line">		<span class="variable">.dout</span>(dout)</span><br><span class="line">	);</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">reg</span> clk_32k;</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="comment">// Initialize Inputs</span></span><br><span class="line">		rst = <span class="number">1</span>;</span><br><span class="line">		clk_data = <span class="number">0</span>;</span><br><span class="line">		clk_fir = <span class="number">0</span>;</span><br><span class="line">		clk_32k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Wait 100 ns for global reset to finish</span></span><br><span class="line">		#<span class="number">80000</span>;</span><br><span class="line">        rst = <span class="number">0</span>;  </span><br><span class="line">		<span class="comment">// Add stimulus here</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//生成32kHz的时钟频率</span></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">15625</span> clk_32k &lt;= !clk_32k;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cn=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_32k) <span class="keyword">begin</span></span><br><span class="line">		cn &lt;= cn + <span class="number">1</span>;</span><br><span class="line">	    clk_fir &lt;= cn[<span class="number">0</span>];    <span class="comment">//16kHz</span></span><br><span class="line">		clk_data &lt;= cn[<span class="number">3</span>];   <span class="comment">//2kHz</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/11/20/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIR%E6%BB%A4%E6%B3%A2%E5%99%A8/image-20231121141829792.png" alt="image-20231121141829792"></p>
<p><img src="/2023/11/20/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFIR%E6%BB%A4%E6%B3%A2%E5%99%A8/image-20231121141755650.png" alt="image-20231121141755650"></p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1xo4y1L7Ha/?spm_id_from=333.788&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">Xilinx/ISE版 FPGA数字信号处理设计-并行结构FIR滤波器设计_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI DSP</tag>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之CORDIC算法求正余弦值与模值</title>
    <url>/2023/11/12/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCORDIC%E7%AE%97%E6%B3%95%E6%B1%82%E6%AD%A3%E4%BD%99%E5%BC%A6%E5%80%BC%E4%B8%8E%E6%A8%A1%E5%80%BC/</url>
    <content><![CDATA[<p>本节主要介绍了cordic算法的基本原理，并解释了其为什么可以用来求解余弦值和复数信号的模值，并给出了示例的verilog代码。</p>
<span id="more"></span>
<h1 id="CORDIC算法"><a href="#CORDIC算法" class="headerlink" title="CORDIC算法"></a>CORDIC算法</h1><h2 id="1-平面坐标系旋转"><a href="#1-平面坐标系旋转" class="headerlink" title="1.平面坐标系旋转"></a>1.平面坐标系旋转</h2><ul>
<li>向量旋转公式：将向量$(x,y)$逆时针旋转$\phi$角度得到新向量$(x’,y’)$</li>
</ul>
<script type="math/tex; mode=display">
\begin{bmatrix}
    x'\\y'
    \end{bmatrix}= \begin{bmatrix}
    cos\phi & -sin\phi\\sin\phi & cos\phi
    \end{bmatrix}\cdot \begin{bmatrix}
    x\\y
    \end{bmatrix}</script><ul>
<li><p>提出公因子$cos\phi$有：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x'\\y'
\end{bmatrix}= cos\phi\cdot\begin{bmatrix}
1 & -tan\phi\\tan\phi & 1
\end{bmatrix}\cdot \begin{bmatrix}
x\\y
\end{bmatrix}</script><script type="math/tex; mode=display">
其中:cos\phi代表对向量长度的缩放,\begin{bmatrix}
1 & -tan\phi\\tan\phi & 1
\end{bmatrix}代表对向量的旋转</script></li>
<li><p>为减少计算量，引入<strong>伪旋转</strong>：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x''\\y''
\end{bmatrix}= \begin{bmatrix}
1 & -tan\phi\\tan\phi & 1
\end{bmatrix}\cdot \begin{bmatrix}
x\\y
\end{bmatrix}</script><ul>
<li><p><strong>伪旋转将改变向量长度</strong>：</p>
<p><img src="/2023/11/12/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCORDIC%E7%AE%97%E6%B3%95%E6%B1%82%E6%AD%A3%E4%BD%99%E5%BC%A6%E5%80%BC%E4%B8%8E%E6%A8%A1%E5%80%BC/image-20221202234552990.png" alt="image-20221202234552990" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-CORDIC方法"><a href="#2-CORDIC方法" class="headerlink" title="2.CORDIC方法"></a>2.CORDIC方法</h2><ul>
<li><p>为了便于硬件的计算，采用迭代的思想，旋转角度$\phi$可以通过若干步的旋转逼近，每次旋转一个角度$\phi^i$，并约定每次旋转的角度的正切值为2的倍数，<strong>即$tan\phi^i = 2^{-i}$，这样乘以正切值就可以变成移位操作</strong></p>
<p>| $i$  | $tan\phi^i=2^{-i}$ | $\phi^i$(degree) |<br>| :—: | :————————: | :———————: |<br>|  0   |      $2^{-0}$      |       45°        |<br>|  1   |      $2^{-1}$      |     26.565°      |<br>|  2   |      $2^{-2}$      |     14.036°      |<br>|  3   |      $2^{-3}$      |     7.1250°      |<br>|  4   |      $2^{-4}$      |     3.5763°      |<br>|  5   |      $2^{-5}$      |     1.7899°      |<br>|  6   |      $2^{-6}$      |     0.8951°      |<br>|  7   |      $2^{-7}$      |     0.4476°      |<br>|  8   |      $2^{-8}$      |     0.2238°      |<br>|  9   |      $2^{-9}$      |     0.1119°      |<br>|  10  |     $2^{-10}$      |     0.0559°      |<br>|  11  |     $2^{-11}$      |     0.0279°      |<br>|  12  |     $2^{-12}$      |     0.0139°      |<br>|  13  |     $2^{-13}$      |     0.0069°      |<br>|  14  |     $2^{-14}$      |     0.0035°      |<br>|  15  |     $2^{-15}$      |     0.0017°      |</p>
</li>
</ul>
<h2 id="3-旋转因子"><a href="#3-旋转因子" class="headerlink" title="3.旋转因子"></a>3.旋转因子</h2><ul>
<li><p>朝着目标角度进行旋转时，可能会出现没有超过目标角度的情况，当然也存在超过目标角度的情况，而我们迭代旋转的目的时要逼近目标角度，通过多次旋转，逐渐旋转到目标角度，因此$\phi^i$有可能是逆时针旋转也有可能是顺时针旋转。故引入旋转因子$d_i$，则伪旋转坐标方程为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x''\\y''
\end{bmatrix}= \begin{bmatrix}
1 & -d_i2^{-i}\\
d_i2^{-i} & 1
\end{bmatrix}\cdot \begin{bmatrix}
x\\y
\end{bmatrix}</script></li>
<li><p>写成迭代方程的形式为：</p>
<script type="math/tex; mode=display">
x_{i+1}=x_i-d_i2^{-i}y_i\\
y_{i+1}=y_i+d_i2^{-i}x_i</script><ul>
<li><strong>其中第$i$步顺时针旋转时$d_i=-1$，逆时针旋转时$d_i = 1$</strong></li>
</ul>
</li>
</ul>
<h2 id="4-角度累加器"><a href="#4-角度累加器" class="headerlink" title="4.角度累加器"></a>4.角度累加器</h2><ul>
<li><p>用来在每次迭代过程中追踪累加的旋转角度，<strong>即本次旋转后，目标角度与此时角度的差值</strong>，其计算公式如下：</p>
<script type="math/tex; mode=display">
z_{i+1}=z_i-d_i\phi^i</script><ul>
<li>其中$d_i=\pm1$</li>
<li>$\phi^i$代表每次旋转的角度，其需要使用LUT查找表（存储的值如上表的$\phi^i$所示）事先存储在FPGA中</li>
<li>$z_0$为目标角度或0（根据不同的模式决定）</li>
</ul>
</li>
</ul>
<h2 id="5-移位-加法算法"><a href="#5-移位-加法算法" class="headerlink" title="5.移位-加法算法"></a>5.移位-加法算法</h2><ul>
<li><p>原始的算法现在已经被简化为使用伪旋转方程式来表示迭代算法</p>
<ul>
<li>2次移位：$2^{-i}$用移位实现，每右移$i$位就把原来数值乘以2的$-i$次方了</li>
<li>1次查找表：每次迭代都会一个固定角度$\phi^i$的累加，用查找表实现$\phi^i$</li>
<li>3次加法：x，y，z的累加，共三次</li>
</ul>
</li>
<li><p><strong>对应迭代结构：</strong></p>
<p><img src="/2023/11/12/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCORDIC%E7%AE%97%E6%B3%95%E6%B1%82%E6%AD%A3%E4%BD%99%E5%BC%A6%E5%80%BC%E4%B8%8E%E6%A8%A1%E5%80%BC/image-20221203002651882.png" alt="image-20221203002651882" style="zoom:50%;"></p>
</li>
<li><p><strong>n级流水线结构：</strong></p>
<p><img src="/2023/11/12/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCORDIC%E7%AE%97%E6%B3%95%E6%B1%82%E6%AD%A3%E4%BD%99%E5%BC%A6%E5%80%BC%E4%B8%8E%E6%A8%A1%E5%80%BC/image-20221203002829242.png" alt="image-20221203002829242" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="6-伸缩因子"><a href="#6-伸缩因子" class="headerlink" title="6.伸缩因子"></a>6.伸缩因子</h2><ul>
<li><p>当简化算法以伪旋转时，$cos\phi$项被忽略，这样$(x_n,y_n)$就被缩放了$K_n$倍（个人认为准确来说是放大了$K_n$倍），如果迭代次数已知，可以预先计算出伸缩因子$K_n$，其计算公式如下：</p>
<script type="math/tex; mode=display">
K_n = \prod_{n}\frac{1}{cos\phi^i}=\prod_{n}(\sqrt{(1+2^{-2i})})</script><ul>
<li>当旋转16次之后，$K_n$基本不会变化，为1.64676，则此时$\frac1{K_n}$为0.607253</li>
</ul>
</li>
</ul>
<hr>
<h1 id="旋转模式求正余弦值"><a href="#旋转模式求正余弦值" class="headerlink" title="旋转模式求正余弦值"></a>旋转模式求正余弦值</h1><h2 id="1-旋转模式的关键"><a href="#1-旋转模式的关键" class="headerlink" title="1.旋转模式的关键"></a>1.旋转模式的关键</h2><ul>
<li><p><strong>旋转因子的判断</strong>：当目标角度与某次旋转后的角度差$z_i$大于0时，逆时针旋转，当$z_i$小于0时，顺时针旋转，有表达式如下：</p>
<script type="math/tex; mode=display">
d_i = \begin{cases}
+1,z_i\ge 0\\
-1,z_i <0
\end{cases}</script><ul>
<li><strong>注意：此时$z_0$等于目标角度</strong></li>
</ul>
</li>
<li><p><strong>初始坐标位于$(\frac 1{K_n},0)$</strong>：其实这里可以先简单的理解为初始坐标位于$(1,0)$的位置，只是我们将问题简化为了伪旋转，最后得到的结果还需要除以$K_n$，与其这样，不如在最开始时，就将坐标设为$(\frac 1{K_n},0)$（为了后续理解方便，我们先暂且认为初始坐标位于$(1,0)$）</p>
</li>
</ul>
<h2 id="2-求正余弦值的原理"><a href="#2-求正余弦值的原理" class="headerlink" title="2.求正余弦值的原理"></a>2.求正余弦值的原理</h2><ul>
<li><p>根据旋转的公式，将$(x,y)=(1,0)$带入，有：</p>
<script type="math/tex; mode=display">
\begin{cases}
x'=cos\phi \cdot x - sin\phi \cdot y\\
y'=sin\phi\cdot x+cos\phi\cdot y
\end{cases}\rightarrow
\begin{cases}
x'=cos\phi\\
y'=sin\phi
\end{cases}</script></li>
<li><p>而$(x’,y’)$是我们通过迭代计算可以求得的，则$x’$对应$cos\phi$，$y’$对应$sin\phi$</p>
</li>
<li><p>通过如下示意图可以更加形象地理解：</p>
<p><img src="/2023/11/12/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCORDIC%E7%AE%97%E6%B3%95%E6%B1%82%E6%AD%A3%E4%BD%99%E5%BC%A6%E5%80%BC%E4%B8%8E%E6%A8%A1%E5%80%BC/image-20231113143439502.png" alt="image-20231113143439502" style="zoom: 67%;"></p>
</li>
</ul>
<h2 id="3-象限预处理"><a href="#3-象限预处理" class="headerlink" title="3.象限预处理"></a>3.象限预处理</h2><ul>
<li>我们将上面表格的角度全部相加后约等于99.88°，则旋转角度的范围为$(-99.88°,99.88°)$，则可认为目标角度只能在第一象限和第四象限</li>
<li>若目标角度在第二和三象限，那么需要进行预处理，将目标先旋转到第一和四象限后再进行迭代运算，运算后可根据三角函数关系还原目标的真实角度<ul>
<li><strong>目标在第二象限（$\phi\in(90,180)$），预处理后旋转角度$\phi-90°$，求出$\phi-90°$对应的$(x’,y’)$后，对应$\phi$的坐标为$(-y’,x’)$</strong></li>
<li><strong>目标在第三象限（$\phi\in(180,270)$），预处理后旋转角度$\phi+90°$，求出$\phi+90°$对应的$(x’,y’)$后，对应$\phi$的坐标为$(y’,-x’)$</strong></li>
</ul>
</li>
</ul>
<h2 id="4-Verilog硬件实现"><a href="#4-Verilog硬件实现" class="headerlink" title="4.Verilog硬件实现"></a>4.Verilog硬件实现</h2><ul>
<li><p>此处代码借鉴的Reference中第三个，主要注意以下三点</p>
<ul>
<li>查找表角度的量化</li>
<li>中间结果xyz用17位存储，避免溢出</li>
<li>象限判断需要打拍，以至于在流水线结束时，当前象限对应的是流水线开始的象限。且象限判断利用输入角度phase_in[15:14]位</li>
</ul>
</li>
<li><p>Cordic_to_cos.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//360°--2^16,phase_in = 16bits (input [15:0] phase_in)</span></span><br><span class="line"><span class="comment">//1°--2^16/360</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot0  16&#x27;h2000    </span><span class="comment">//45</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot1  16&#x27;h12e4    </span><span class="comment">//26.5651</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot2  16&#x27;h09fb    </span><span class="comment">//14.0362</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot3  16&#x27;h0511    </span><span class="comment">//7.1250</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot4  16&#x27;h028b    </span><span class="comment">//3.5763</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot5  16&#x27;h0145    </span><span class="comment">//1.7899</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot6  16&#x27;h00a3    </span><span class="comment">//0.8952</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot7  16&#x27;h0051    </span><span class="comment">//0.4476</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot8  16&#x27;h0028    </span><span class="comment">//0.2238</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot9  16&#x27;h0014    </span><span class="comment">//0.1119</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot10 16&#x27;h000a    </span><span class="comment">//0.0560</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot11 16&#x27;h0005    </span><span class="comment">//0.0280</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot12 16&#x27;h0003    </span><span class="comment">//0.0140</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot13 16&#x27;h0002    </span><span class="comment">//0.0070</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot14 16&#x27;h0001    </span><span class="comment">//0.0035</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> rot15 16&#x27;h0000    </span><span class="comment">//0.0018</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Cordic_to_cos</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="comment">//input rst_n,</span></span><br><span class="line">    <span class="comment">//input ena,</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] phase_in,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] eps,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] sin,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] cos</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">parameter</span> PIPELINE = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">//parameter K = 16&#x27;h4dba;//k=0.607253*2^15</span></span><br><span class="line">    <span class="keyword">parameter</span> K = <span class="number">16&#x27;h9b74</span>;<span class="comment">//gian k=0.607253*2^16,9b74,n means the number pipeline</span></span><br><span class="line">    <span class="comment">//pipeline 16-level    //maybe overflow,matlab result not overflow</span></span><br><span class="line">    <span class="comment">//MSB is signed bit,transform the sin and cos according to phase_in[15:14]</span></span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x0=<span class="number">0</span>,y0=<span class="number">0</span>,z0=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x1=<span class="number">0</span>,y1=<span class="number">0</span>,z1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x2=<span class="number">0</span>,y2=<span class="number">0</span>,z2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x3=<span class="number">0</span>,y3=<span class="number">0</span>,z3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x4=<span class="number">0</span>,y4=<span class="number">0</span>,z4=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x5=<span class="number">0</span>,y5=<span class="number">0</span>,z5=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x6=<span class="number">0</span>,y6=<span class="number">0</span>,z6=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x7=<span class="number">0</span>,y7=<span class="number">0</span>,z7=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x8=<span class="number">0</span>,y8=<span class="number">0</span>,z8=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x9=<span class="number">0</span>,y9=<span class="number">0</span>,z9=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x10=<span class="number">0</span>,y10=<span class="number">0</span>,z10=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x11=<span class="number">0</span>,y11=<span class="number">0</span>,z11=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x12=<span class="number">0</span>,y12=<span class="number">0</span>,z12=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x13=<span class="number">0</span>,y13=<span class="number">0</span>,z13=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x14=<span class="number">0</span>,y14=<span class="number">0</span>,z14=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x15=<span class="number">0</span>,y15=<span class="number">0</span>,z15=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] x16=<span class="number">0</span>,y16=<span class="number">0</span>,z16=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] quadrant [PIPELINE:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=PIPELINE;i=i+<span class="number">1</span>)</span><br><span class="line">        quadrant[i] = <span class="number">2&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 0,not pipeline</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        x0 &lt;= &#123;<span class="number">1&#x27;b0</span>,K&#125;; <span class="comment">//add one signed bit,0 means positive</span></span><br><span class="line">        y0 &lt;= <span class="number">17&#x27;b0</span>;</span><br><span class="line">        z0 &lt;= &#123;<span class="number">3&#x27;b0</span>,phase_in[<span class="number">13</span>:<span class="number">0</span>]&#125;;<span class="comment">//control the phase_in to the range[0-Pi/2]</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 1</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(z0[<span class="number">16</span>])<span class="comment">//the diff is negative so clockwise</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        x1 &lt;= x0 + y0;</span><br><span class="line">        y1 &lt;= x0 - y0;</span><br><span class="line">        z1 &lt;= z0 + `rot0;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        x1 &lt;= x0 - y0;<span class="comment">//x1 &lt;= x0;</span></span><br><span class="line">        y1 &lt;= x0 + y0;<span class="comment">//y1 &lt;= x0;</span></span><br><span class="line">        z1 &lt;= z0 - `rot0;<span class="comment">//reversal 45</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 2</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z1[<span class="number">16</span>])<span class="comment">//the diff is negative so clockwise</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x2 &lt;= x1 + (y1&gt;&gt;&gt;<span class="number">4&#x27;d1</span>);</span><br><span class="line">            y2 &lt;= y1 - (x1&gt;&gt;&gt;<span class="number">4&#x27;d1</span>);</span><br><span class="line">            z2 &lt;= z1 + `rot1;<span class="comment">//clockwise 26</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x2 &lt;= x1 - (y1&gt;&gt;&gt;<span class="number">4&#x27;d1</span>);</span><br><span class="line">            y2 &lt;= y1 + (x1&gt;&gt;&gt;<span class="number">4&#x27;d1</span>);</span><br><span class="line">            z2 &lt;= z1 - `rot1;<span class="comment">//anti-clockwise 26</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 3</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z2[<span class="number">16</span>])<span class="comment">//the diff is negative so clockwise</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x3 &lt;= x2 + (y2&gt;&gt;&gt;<span class="number">4&#x27;d2</span>); <span class="comment">//right shift n bits,divide 2^n</span></span><br><span class="line">            y3 &lt;= y2 - (x2&gt;&gt;&gt;<span class="number">4&#x27;d2</span>); <span class="comment">//left adds n bits of MSB,in first quadrant x or y are positive,MSB =0 ？？</span></span><br><span class="line">            z3 &lt;= z2 + `rot2;<span class="comment">//clockwise 14    //difference of positive and negtive number and no round(4,5)</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x3 &lt;= x2 - (y2&gt;&gt;&gt;<span class="number">4&#x27;d2</span>);</span><br><span class="line">            y3 &lt;= y2 + (x2&gt;&gt;&gt;<span class="number">4&#x27;d2</span>);</span><br><span class="line">            z3 &lt;= z2 - `rot2;<span class="comment">//anti-clockwise 14</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 4</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z3[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x4 &lt;= x3 + (y3&gt;&gt;&gt;<span class="number">4&#x27;d3</span>);</span><br><span class="line">            y4 &lt;= y3 - (x3&gt;&gt;&gt;<span class="number">4&#x27;d3</span>);</span><br><span class="line">            z4 &lt;= z3 + `rot3;<span class="comment">//clockwise 7</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x4 &lt;= x3 - (y3&gt;&gt;&gt;<span class="number">4&#x27;d3</span>);</span><br><span class="line">            y4 &lt;= y3 + (x3&gt;&gt;&gt;<span class="number">4&#x27;d3</span>);</span><br><span class="line">            z4 &lt;= z3 - `rot3;<span class="comment">//anti-clockwise 7</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 5</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z4[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x5 &lt;= x4 + (y4&gt;&gt;&gt;<span class="number">4&#x27;d4</span>);</span><br><span class="line">            y5 &lt;= y4 - (x4&gt;&gt;&gt;<span class="number">4&#x27;d4</span>);</span><br><span class="line">            z5 &lt;= z4 + `rot4;<span class="comment">//clockwise 3</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x5 &lt;= x4 - (y4&gt;&gt;&gt;<span class="number">4&#x27;d4</span>);</span><br><span class="line">            y5 &lt;= y4 + (x4&gt;&gt;&gt;<span class="number">4&#x27;d4</span>);</span><br><span class="line">            z5 &lt;= z4 - `rot4;<span class="comment">//anti-clockwise 3</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//STAGE 6</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z5[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x6 &lt;= x5 + (y5&gt;&gt;&gt;<span class="number">4&#x27;d5</span>);</span><br><span class="line">            y6 &lt;= y5 - (x5&gt;&gt;&gt;<span class="number">4&#x27;d5</span>);</span><br><span class="line">            z6 &lt;= z5 + `rot5;<span class="comment">//clockwise 1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x6 &lt;= x5 - (y5&gt;&gt;&gt;<span class="number">4&#x27;d5</span>);</span><br><span class="line">            y6 &lt;= y5 + (x5&gt;&gt;&gt;<span class="number">4&#x27;d5</span>);</span><br><span class="line">            z6 &lt;= z5 - `rot5;<span class="comment">//anti-clockwise 1 </span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 7</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z6[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x7 &lt;= x6 + (y6&gt;&gt;&gt;<span class="number">4&#x27;d6</span>);</span><br><span class="line">            y7 &lt;= y6 - (x6&gt;&gt;&gt;<span class="number">4&#x27;d6</span>);</span><br><span class="line">            z7 &lt;= z6 + `rot6;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x7 &lt;= x6 - (y6&gt;&gt;&gt;<span class="number">4&#x27;d6</span>);</span><br><span class="line">            y7 &lt;= y6 + (x6&gt;&gt;&gt;<span class="number">4&#x27;d6</span>);</span><br><span class="line">            z7 &lt;= z6 - `rot6;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 8</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z7[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x8 &lt;= x7 + (y7&gt;&gt;&gt;<span class="number">4&#x27;d7</span>);</span><br><span class="line">            y8 &lt;= y7 - (x7&gt;&gt;&gt;<span class="number">4&#x27;d7</span>);</span><br><span class="line">            z8 &lt;= z7 + `rot7;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x8 &lt;= x7 - (y7&gt;&gt;&gt;<span class="number">4&#x27;d7</span>);</span><br><span class="line">            y8 &lt;= y7 + (x7&gt;&gt;&gt;<span class="number">4&#x27;d7</span>);</span><br><span class="line">            z8 &lt;= z7 - `rot7;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 9</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z8[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x9 &lt;= x8 + (y8&gt;&gt;&gt;<span class="number">4&#x27;d8</span>);</span><br><span class="line">            y9 &lt;= y8 - (x8&gt;&gt;&gt;<span class="number">4&#x27;d8</span>);</span><br><span class="line">            z9 &lt;= z8 + `rot8;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x9 &lt;= x8 - (y8&gt;&gt;&gt;<span class="number">4&#x27;d8</span>);</span><br><span class="line">            y9 &lt;= y8 + (x8&gt;&gt;&gt;<span class="number">4&#x27;d8</span>);</span><br><span class="line">            z9 &lt;= z8 - `rot8;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 10</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z9[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x10 &lt;= x9 + (y9&gt;&gt;&gt;<span class="number">4&#x27;d9</span>);</span><br><span class="line">            y10 &lt;= y9 - (x9&gt;&gt;&gt;<span class="number">4&#x27;d9</span>);</span><br><span class="line">            z10 &lt;= z9 + `rot9;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x10 &lt;= x9 - (y9&gt;&gt;&gt;<span class="number">4&#x27;d9</span>);</span><br><span class="line">            y10 &lt;= y9 + (x9&gt;&gt;&gt;<span class="number">4&#x27;d9</span>);</span><br><span class="line">            z10 &lt;= z9 - `rot9;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 11</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z10[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x11 &lt;= x10 + (y10&gt;&gt;&gt;<span class="number">4&#x27;d10</span>);</span><br><span class="line">            y11 &lt;= y10 - (x10&gt;&gt;&gt;<span class="number">4&#x27;d10</span>);</span><br><span class="line">            z11 &lt;= z10 + `rot10;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x11 &lt;= x10 - (y10&gt;&gt;&gt;<span class="number">4&#x27;d10</span>);</span><br><span class="line">            y11 &lt;= y10 + (x10&gt;&gt;&gt;<span class="number">4&#x27;d10</span>);</span><br><span class="line">            z11 &lt;= z10 - `rot10;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 12</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z11[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x12 &lt;= x11 + (y11&gt;&gt;&gt;<span class="number">4&#x27;d11</span>);</span><br><span class="line">            y12 &lt;= y11 - (x11&gt;&gt;&gt;<span class="number">4&#x27;d11</span>);</span><br><span class="line">            z12 &lt;= z11 + `rot11;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x12 &lt;= x11 - (y11&gt;&gt;&gt;<span class="number">4&#x27;d11</span>);</span><br><span class="line">            y12 &lt;= y11 + (x11&gt;&gt;&gt;<span class="number">4&#x27;d11</span>);</span><br><span class="line">            z12 &lt;= z11 - `rot11;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 13</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z12[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x13 &lt;= x12 + (y12&gt;&gt;&gt;<span class="number">4&#x27;d12</span>);</span><br><span class="line">            y13 &lt;= y12 - (x12&gt;&gt;&gt;<span class="number">4&#x27;d12</span>);</span><br><span class="line">            z13 &lt;= z12 + `rot12;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x13 &lt;= x12 - (y12&gt;&gt;&gt;<span class="number">4&#x27;d12</span>);</span><br><span class="line">            y13 &lt;= y12 + (x12&gt;&gt;&gt;<span class="number">4&#x27;d12</span>);</span><br><span class="line">            z13 &lt;= z12 - `rot12;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 14</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z13[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x14 &lt;= x13 + (y13&gt;&gt;&gt;<span class="number">4&#x27;d13</span>);</span><br><span class="line">            y14 &lt;= y13 - (x13&gt;&gt;&gt;<span class="number">4&#x27;d13</span>);</span><br><span class="line">            z14 &lt;= z13 + `rot13;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x14 &lt;= x13 - (y13&gt;&gt;&gt;<span class="number">4&#x27;d13</span>);</span><br><span class="line">            y14 &lt;= y13 + (x13&gt;&gt;&gt;<span class="number">4&#x27;d13</span>);</span><br><span class="line">            z14 &lt;= z13 - `rot13;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 15</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z14[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x15 &lt;= x14 + (y14&gt;&gt;&gt;<span class="number">4&#x27;d14</span>);</span><br><span class="line">            y15 &lt;= y14 - (x14&gt;&gt;&gt;<span class="number">4&#x27;d14</span>);</span><br><span class="line">            z15 &lt;= z14 + `rot14;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x15 &lt;= x14 - (y14&gt;&gt;&gt;<span class="number">4&#x27;d14</span>);</span><br><span class="line">            y15 &lt;= y14 + (x14&gt;&gt;&gt;<span class="number">4&#x27;d14</span>);</span><br><span class="line">            z15 &lt;= z14 - `rot14;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="comment">//stage 16</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(z15[<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x16 &lt;= x15 + (y15&gt;&gt;&gt;<span class="number">4&#x27;d15</span>);</span><br><span class="line">            y16 &lt;= y15 - (x15&gt;&gt;&gt;<span class="number">4&#x27;d15</span>);</span><br><span class="line">            z16 &lt;= z15 + `rot15;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            x16 &lt;= x15 - (y15&gt;&gt;&gt;<span class="number">4&#x27;d15</span>);</span><br><span class="line">            y16 &lt;= y15 + (x15&gt;&gt;&gt;<span class="number">4&#x27;d15</span>);</span><br><span class="line">            z16 &lt;= z15 - `rot15;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//according to the pipeline,register phase_in[15:14]</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        quadrant[<span class="number">0</span>] &lt;= phase_in[<span class="number">15</span>:<span class="number">14</span>];</span><br><span class="line">        quadrant[<span class="number">1</span>] &lt;= quadrant[<span class="number">0</span>];</span><br><span class="line">        quadrant[<span class="number">2</span>] &lt;= quadrant[<span class="number">1</span>];</span><br><span class="line">        quadrant[<span class="number">3</span>] &lt;= quadrant[<span class="number">2</span>];</span><br><span class="line">        quadrant[<span class="number">4</span>] &lt;= quadrant[<span class="number">3</span>];</span><br><span class="line">        quadrant[<span class="number">5</span>] &lt;= quadrant[<span class="number">4</span>];</span><br><span class="line">        quadrant[<span class="number">6</span>] &lt;= quadrant[<span class="number">5</span>];</span><br><span class="line">        quadrant[<span class="number">7</span>] &lt;= quadrant[<span class="number">6</span>];</span><br><span class="line">        quadrant[<span class="number">8</span>] &lt;= quadrant[<span class="number">7</span>];</span><br><span class="line">        quadrant[<span class="number">9</span>] &lt;= quadrant[<span class="number">8</span>];</span><br><span class="line">        quadrant[<span class="number">10</span>] &lt;= quadrant[<span class="number">9</span>];</span><br><span class="line">        quadrant[<span class="number">11</span>] &lt;= quadrant[<span class="number">10</span>];</span><br><span class="line">        quadrant[<span class="number">12</span>] &lt;= quadrant[<span class="number">11</span>];</span><br><span class="line">        quadrant[<span class="number">13</span>] &lt;= quadrant[<span class="number">12</span>];</span><br><span class="line">        quadrant[<span class="number">14</span>] &lt;= quadrant[<span class="number">13</span>];</span><br><span class="line">        quadrant[<span class="number">15</span>] &lt;= quadrant[<span class="number">14</span>];</span><br><span class="line">        quadrant[<span class="number">16</span>] &lt;= quadrant[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//alter register, according to quadrant[16] to transform the result to the right result</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">        eps &lt;= z16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(quadrant[<span class="number">16</span>]) <span class="comment">//or 15</span></span><br><span class="line">        <span class="number">2&#x27;b00</span>:<span class="keyword">begin</span> <span class="comment">//if the phase is in first quadrant,the sin(X)=sin(A),cos(X)=cos(A)</span></span><br><span class="line">                cos &lt;= x16;</span><br><span class="line">                sin &lt;= y16;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b01</span>:<span class="keyword">begin</span> <span class="comment">//if the phase is in second quadrant,the sin(X)=sin(A+90)=cosA,cos(X)=cos(A+90)=-sinA</span></span><br><span class="line">                cos &lt;= ~(y16) + <span class="number">1&#x27;b1</span>;<span class="comment">//-sin</span></span><br><span class="line">                sin &lt;= x16;<span class="comment">//cos</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b10</span>:<span class="keyword">begin</span> <span class="comment">//if the phase is in third quadrant,the sin(X)=sin(A+180)=-sinA,cos(X)=cos(A+180)=-cosA</span></span><br><span class="line">                cos &lt;= ~(x16) + <span class="number">1&#x27;b1</span>;<span class="comment">//-cos</span></span><br><span class="line">                sin &lt;= ~(y16) + <span class="number">1&#x27;b1</span>;<span class="comment">//-sin</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b11</span>:<span class="keyword">begin</span> <span class="comment">//if the phase is in forth quadrant,the sin(X)=sin(A+270)=-cosA,cos(X)=cos(A+270)=sinA</span></span><br><span class="line">                cos &lt;= y16;<span class="comment">//sin</span></span><br><span class="line">                sin &lt;= ~(x16) + <span class="number">1&#x27;b1</span>;<span class="comment">//-cos</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Cordic_to_cos_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Cordic_to_cos_tb;</span><br><span class="line">    <span class="comment">// test vector input registers</span></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] phase = <span class="number">16&#x27;h0000</span>;</span><br><span class="line">    <span class="comment">// wires                                               </span></span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] cosine_out;</span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] eps_out;</span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">16</span>:<span class="number">0</span>] sine_out;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">localparam</span> coef=<span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// assign statements (if any)  </span></span><br><span class="line"></span><br><span class="line">    Cordic_to_cos u1 (</span><br><span class="line">    <span class="comment">// port map - connection between master ports and signals/registers       </span></span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.cos</span>(cosine_out),</span><br><span class="line">        <span class="variable">.eps</span>(eps_out),</span><br><span class="line">        <span class="variable">.phase_in</span>(phase),</span><br><span class="line">        <span class="variable">.sin</span>(sine_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(10000*coef)</span> <span class="built_in">$stop</span>;                                            </span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line">                                                    </span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(5*coef)</span> clk=~clk;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        phase=phase+<span class="number">16&#x27;h0100</span>;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/11/12/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCORDIC%E7%AE%97%E6%B3%95%E6%B1%82%E6%AD%A3%E4%BD%99%E5%BC%A6%E5%80%BC%E4%B8%8E%E6%A8%A1%E5%80%BC/image-20231114114043879.png" alt="image-20231114114043879"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="向量模式求模值"><a href="#向量模式求模值" class="headerlink" title="向量模式求模值"></a>向量模式求模值</h1><h2 id="1-向量模式的关键"><a href="#1-向量模式的关键" class="headerlink" title="1.向量模式的关键"></a>1.向量模式的关键</h2><ul>
<li><p><strong>旋转因子的判断</strong>：与旋转模式不同，向量模式每次迭代通过判断 $y_i$的符号决定旋转方向。最终使初始向量旋转至与 X 轴的正半轴重合，<strong>向量模式每次微旋转的旋转角度存储在变量 $z$中</strong>，有：</p>
<script type="math/tex; mode=display">
d_i=\begin{cases}
+1,y_i\le 0\\
-1,y_i>0
\end{cases}</script></li>
<li><p><strong>初始坐标位于$(x,y)$（目标位置）：即从$(x,y)$开始旋转，并认为此坐标对应的角度为0度，即$z_0=0$</strong></p>
</li>
</ul>
<h2 id="2-求模值的原理"><a href="#2-求模值的原理" class="headerlink" title="2.求模值的原理"></a>2.求模值的原理</h2><ul>
<li>根据旋转的公式，<strong>将$(x’,y’)=(x’,0)$带入</strong>（因为最后会旋转到x的正半轴上，所以$y’=0$），有：</li>
</ul>
<script type="math/tex; mode=display">
\begin{cases}
x'=cos\phi \cdot x - sin\phi \cdot y\\
0=sin\phi\cdot x+cos\phi\cdot y
\end{cases}\rightarrow
\begin{cases}
y=-\frac{sin\phi}{cos\phi}x\\
x'=\sqrt{x^2+y^2}
\end{cases}</script><ul>
<li>而$x’$是我们通过迭代计算可以求得的，则$x’$对应模值$\sqrt{x^2+y^2}$</li>
<li>由于实际旋转的时候是伪旋转，所以实际上我们取：<ul>
<li>$x=\frac{复数的实部}{K_n}$</li>
<li>$y=\frac{复数的实部}{K_n}$</li>
</ul>
</li>
<li><p>最终可以得到$x’=复数的模值$，$z=复数的角度$</p>
</li>
<li><p>通过如下示意图可以更加形象地理解：</p>
<p><img src="/2023/11/12/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCORDIC%E7%AE%97%E6%B3%95%E6%B1%82%E6%AD%A3%E4%BD%99%E5%BC%A6%E5%80%BC%E4%B8%8E%E6%A8%A1%E5%80%BC/image-20231113152827127.png" alt="image-20231113152827127" style="zoom:67%;"></p>
</li>
</ul>
<h2 id="3-象限预处理-1"><a href="#3-象限预处理-1" class="headerlink" title="3.象限预处理"></a>3.象限预处理</h2><ul>
<li><strong>向量旋转限定了初始向量必须在第一或第四象限，这就要求$x&gt;0$。根据对称性，可以将所有的向量都搬移到第一象限，直接对$(x,y)$取绝对值即可，但是在最后输出真实结果时需要将向量再搬移回去。</strong></li>
</ul>
<h2 id="4-Verilog硬件实现-1"><a href="#4-Verilog硬件实现-1" class="headerlink" title="4.Verilog硬件实现"></a>4.Verilog硬件实现</h2><ul>
<li><p>参考：<a href="https://blog.csdn.net/weixin_44678052/article/details/130655887?ops_request_misc=%7B%22request%5Fid%22%3A%22169993548516800226597215%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169993548516800226597215&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130655887-null-null.142^v96^pc_search_result_base4&amp;utm_term=FPGA实现Cordic算法求解arctan和sqr(x*2 %2B y* 2">FPGA实现Cordic算法求解arctan和sqr(x<em>2 + y</em> 2)_FPGA之旅的博客-CSDN博客</a>&amp;spm=1018.2226.3001.4187)</p>
</li>
<li><p>Cordic_arctan.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Cordic_arctan(</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>           rst_n,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span>           cordic_req,</span><br><span class="line">    <span class="keyword">output</span>          cordic_ack,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">signed</span>[<span class="number">15</span>:<span class="number">0</span>]  X,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">signed</span>[<span class="number">15</span>:<span class="number">0</span>]  Y,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span>[<span class="number">15</span>:<span class="number">0</span>]            amplitude,  <span class="comment">//幅度，偏大1.64倍，这里做了近似处理</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">signed</span>[<span class="number">31</span>:<span class="number">0</span>]    theta    <span class="comment">//扩大了2^16</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot0  32&#x27;d2949120       </span><span class="comment">//45度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot1  32&#x27;d1740992       </span><span class="comment">//26.5651度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot2  32&#x27;d919872        </span><span class="comment">//14.0362度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot3  32&#x27;d466944        </span><span class="comment">//7.1250度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot4  32&#x27;d234368        </span><span class="comment">//3.5763度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot5  32&#x27;d117312        </span><span class="comment">//1.7899度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot6  32&#x27;d58688         </span><span class="comment">//0.8952度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot7  32&#x27;d29312         </span><span class="comment">//0.4476度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot8  32&#x27;d14656         </span><span class="comment">//0.2238度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot9  32&#x27;d7360          </span><span class="comment">//0.1119度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot10 32&#x27;d3648          </span><span class="comment">//0.0560度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot11 32&#x27;d1856          </span><span class="comment">//0.0280度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot12 32&#x27;d896           </span><span class="comment">//0.0140度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot13 32&#x27;d448           </span><span class="comment">//0.0070度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot14 32&#x27;d256           </span><span class="comment">//0.0035度*2^16</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> rot15 32&#x27;d128           </span><span class="comment">//0.0018度*2^16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span>[<span class="number">31</span>:<span class="number">0</span>]    Xn[<span class="number">16</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span>[<span class="number">31</span>:<span class="number">0</span>]    Yn[<span class="number">16</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">reg</span> <span class="keyword">signed</span>[<span class="number">31</span>:<span class="number">0</span>]    Zn[<span class="number">16</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>]           rot[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">reg</span>                 cal_delay[<span class="number">16</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> cordic_ack = cal_delay[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">assign</span> theta      = Zn[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">assign</span> amplitude  = ((Xn[<span class="number">16</span>] &gt;&gt;&gt; <span class="number">1</span>) + (Xn[<span class="number">16</span>]  &gt;&gt;&gt; <span class="number">3</span>) +(Xn[<span class="number">16</span>] &gt;&gt;&gt; <span class="number">4</span>)) &gt;&gt;&gt; <span class="number">16</span>;  <span class="comment">////幅度，偏大1.64倍，这里做了近似处理 ,然后缩小了2^16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        rot[<span class="number">0</span>] &lt;= `rot0;</span><br><span class="line">        rot[<span class="number">1</span>] &lt;= `rot1;</span><br><span class="line">        rot[<span class="number">2</span>] &lt;= `rot2;</span><br><span class="line">        rot[<span class="number">3</span>] &lt;= `rot3;</span><br><span class="line">        rot[<span class="number">4</span>] &lt;= `rot4;</span><br><span class="line">        rot[<span class="number">5</span>] &lt;= `rot5;</span><br><span class="line">        rot[<span class="number">6</span>] &lt;= `rot6;</span><br><span class="line">        rot[<span class="number">7</span>] &lt;= `rot7;</span><br><span class="line">        rot[<span class="number">8</span>] &lt;= `rot8;</span><br><span class="line">        rot[<span class="number">9</span>] &lt;= `rot9;</span><br><span class="line">        rot[<span class="number">10</span>] &lt;= `rot10;</span><br><span class="line">        rot[<span class="number">11</span>] &lt;= `rot11;</span><br><span class="line">        rot[<span class="number">12</span>] &lt;= `rot12;</span><br><span class="line">        rot[<span class="number">13</span>] &lt;= `rot13;</span><br><span class="line">        rot[<span class="number">14</span>] &lt;= `rot14;</span><br><span class="line">        rot[<span class="number">15</span>] &lt;= `rot15;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>( rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            cal_delay[<span class="number">0</span>] &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cal_delay[<span class="number">0</span>] &lt;= cordic_req;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">genvar</span> j;</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span> ;j &lt; <span class="number">17</span> ; j = j + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">begin</span>: loop</span><br><span class="line">            <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>( rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">                    cal_delay[j] &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cal_delay[j] &lt;= cal_delay[j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将坐标挪到第一和四项限中</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>( rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Xn[<span class="number">0</span>] &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            Yn[<span class="number">0</span>] &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">            Zn[<span class="number">0</span>] &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( cordic_req == <span class="number">1&#x27;b1</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>( X &lt; <span class="built_in">$signed</span>(<span class="number">0</span>) &amp;&amp; Y &lt; <span class="built_in">$signed</span>(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                Xn[<span class="number">0</span>] &lt;= -(X &lt;&lt; <span class="number">16</span>);</span><br><span class="line">                Yn[<span class="number">0</span>] &lt;= -(Y &lt;&lt; <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( X &lt; <span class="built_in">$signed</span>(<span class="number">0</span>) &amp;&amp; Y &gt; <span class="built_in">$signed</span>(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                Xn[<span class="number">0</span>] &lt;= -(X &lt;&lt; <span class="number">16</span>);</span><br><span class="line">                Yn[<span class="number">0</span>] &lt;= -(Y &lt;&lt; <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                Xn[<span class="number">0</span>] &lt;= X &lt;&lt; <span class="number">16</span>;</span><br><span class="line">                Yn[<span class="number">0</span>] &lt;= Y &lt;&lt; <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            Zn[<span class="number">0</span>] &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            Xn[<span class="number">0</span>] &lt;= Xn[<span class="number">0</span>];</span><br><span class="line">            Yn[<span class="number">0</span>] &lt;= Yn[<span class="number">0</span>];</span><br><span class="line">            Zn[<span class="number">0</span>] &lt;= Zn[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//旋转</span></span><br><span class="line">    <span class="keyword">genvar</span> i;</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span> ;i &lt; <span class="number">17</span> ;i = i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">begin</span>: loop2</span><br><span class="line">            <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>( rst_n == <span class="number">1&#x27;b0</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    Xn[i] &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                    Yn[i] &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                    Zn[i] &lt;= <span class="number">&#x27;d0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( cal_delay[i -<span class="number">1</span>] == <span class="number">1&#x27;b1</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>( Yn[i-<span class="number">1</span>][<span class="number">31</span>] == <span class="number">1&#x27;b0</span>)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        Xn[i] &lt;= Xn[i-<span class="number">1</span>] + (Yn[i-<span class="number">1</span>] &gt;&gt;&gt; (i-<span class="number">1</span>));</span><br><span class="line">                        Yn[i] &lt;= Yn[i-<span class="number">1</span>] - (Xn[i-<span class="number">1</span>] &gt;&gt;&gt; (i-<span class="number">1</span>));</span><br><span class="line">                        Zn[i] &lt;= Zn[i-<span class="number">1</span>] + rot[i-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        Xn[i] &lt;= Xn[i-<span class="number">1</span>] - (Yn[i-<span class="number">1</span>] &gt;&gt;&gt; (i-<span class="number">1</span>));</span><br><span class="line">                        Yn[i] &lt;= Yn[i-<span class="number">1</span>] + (Xn[i-<span class="number">1</span>] &gt;&gt;&gt; (i-<span class="number">1</span>));</span><br><span class="line">                        Zn[i] &lt;= Zn[i-<span class="number">1</span>] - rot[i-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    Xn[i] &lt;= Xn[i];</span><br><span class="line">                    Yn[i] &lt;= Yn[i];</span><br><span class="line">                    Zn[i] &lt;= Zn[i];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://blog.csdn.net/ngany/article/details/117401494">【精选】CORDIC算法详解及FPGA实现_ngany的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/471677202">FPGA的算法解析4：CORDIC 算法解析 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.cnblogs.com/aikimi7/p/3929592.html">https://www.cnblogs.com/aikimi7/p/3929592.html</a></li>
<li><a href="https://www.cnblogs.com/lazypigwhy/p/11201400.html">使用CORDIC算法求解角度正余弦及Verilog实现 - 比较懒 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_44678052/article/details/130655887?ops_request_misc=%7B%22request%5Fid%22%3A%22169993548516800226597215%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169993548516800226597215&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130655887-null-null.142^v96^pc_search_result_base4&amp;utm_term=FPGA实现Cordic算法求解arctan和sqr(x*2 %2B y* 2">FPGA实现Cordic算法求解arctan和sqr(x<em>2 + y</em> 2)_FPGA之旅的博客-CSDN博客</a>&amp;spm=1018.2226.3001.4187)</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog之入门级刷题</title>
    <url>/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>本文主要对牛客网Verilog刷题中的入门习题进行记录，其中标题带*号的表示题目相对有学习价值。</p>
<span id="more"></span>
<h1 id="四选一多路器"><a href="#四选一多路器" class="headerlink" title="四选一多路器"></a>四选一多路器</h1><ul>
<li><p>制作一个四选一的多路选择器，要求输出定义上为线网类型</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231110153403923.png" alt="image-20231110153403923" style="zoom: 33%;"></p>
</li>
<li><p>Mux41.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Mux41(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]d1,d2,d3,d0,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]sel,</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">1</span>:<span class="number">0</span>]mux_out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] mux_out_reg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(sel)</span><br><span class="line">            <span class="number">2&#x27;b00</span>: mux_out_reg = d3;</span><br><span class="line">            <span class="number">2&#x27;b01</span>: mux_out_reg = d2;</span><br><span class="line">            <span class="number">2&#x27;b10</span>: mux_out_reg = d1;</span><br><span class="line">            <span class="number">2&#x27;b11</span>: mux_out_reg = d0;</span><br><span class="line">            <span class="keyword">default</span>: mux_out_reg = <span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> mux_out = mux_out_reg;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Mux41_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Mux41_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]d1,d2,d3,d0;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]sel;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">1</span>:<span class="number">0</span>]mux_out;</span><br><span class="line"></span><br><span class="line">    Mux41 u1(</span><br><span class="line">        <span class="variable">.d1</span>(d1),</span><br><span class="line">        <span class="variable">.d2</span>(d2),</span><br><span class="line">        <span class="variable">.d3</span>(d3),</span><br><span class="line">        <span class="variable">.d0</span>(d0),</span><br><span class="line">        <span class="variable">.sel</span>(sel),</span><br><span class="line">        <span class="variable">.mux_out</span>(mux_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        d1 = <span class="number">0</span>;</span><br><span class="line">        d2 = <span class="number">1</span>;</span><br><span class="line">        d3 = <span class="number">2</span>;</span><br><span class="line">        d0 = <span class="number">3</span>;</span><br><span class="line">        #<span class="number">10</span> sel = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span> sel = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> sel = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231110153859533.png" alt="image-20231110153859533"></p>
<p>RTL原理图：</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231110154235961.png" alt="image-20231110154235961" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="异步复位的串联T触发器"><a href="#异步复位的串联T触发器" class="headerlink" title="异步复位的串联T触发器"></a>异步复位的串联T触发器</h1><ul>
<li><p><strong>T触发器逻辑功能为：在脉冲有效边沿到来时，T=0，触发器状态不变Qn+1=Qn；T=1，Qn=~Qn</strong></p>
</li>
<li><p>Tff_2.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Tff_2(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> data, clk, rst,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> q  </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> data_reg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst)<span class="keyword">begin</span></span><br><span class="line">            data_reg &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(data == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                data_reg &lt;= data_reg;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                data_reg &lt;= ~data_reg;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst)<span class="keyword">begin</span></span><br><span class="line">            q &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(data_reg == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                q &lt;= q;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data_reg == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                q &lt;= ~q;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Tff_2_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Tff_2_tb;</span><br><span class="line">    <span class="keyword">reg</span> data, clk, rst;</span><br><span class="line">    <span class="keyword">wire</span> q;</span><br><span class="line"></span><br><span class="line">    Tff_2 u1(</span><br><span class="line">        <span class="variable">.data</span>(data), </span><br><span class="line">        <span class="variable">.clk</span>(clk), </span><br><span class="line">        <span class="variable">.rst</span>(rst),</span><br><span class="line">        <span class="variable">.q</span>(q) </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> clk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复位和结束信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rst = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">11</span> rst = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">1000</span> <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他激励信号</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        data = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">21</span> data = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">20</span> data = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">40</span> data = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">20</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231110164517235.png" alt="image-20231110164517235"></p>
<p>RTL原理图：</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231110172248731.png" alt="image-20231110172248731"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h1><ul>
<li><p>如果是奇数个1 则结果为1，为偶数则结果为0（通过sel选择是进行奇校验还是偶校验）</p>
</li>
<li><p><strong>运用单目运算符（|,^,&amp;）可以进行如下检测：</strong></p>
<ul>
<li><code>e = &amp;d;</code>//检测是否全为1（若全为1，则e=1，若有0，则e=0）</li>
<li><code>f = ^d;</code>//奇偶校验（检测1的个数是奇数还是偶数，若是奇数，则f=1，若是偶数，则f=0）</li>
<li><code>g = |d;</code>//检测是否全为0（若全为0，则g=0，若有1，则g=1）</li>
</ul>
</li>
<li><p>odd_sel.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> odd_sel(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] bus,</span><br><span class="line">    <span class="keyword">input</span> sel,</span><br><span class="line">    <span class="keyword">output</span> check</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用单目运算符^判断bus中1的个数，若奇数个1，则结果为1，若偶数个1，则结果为0</span></span><br><span class="line">    <span class="keyword">wire</span> odd_even;</span><br><span class="line">    <span class="keyword">assign</span> odd_even = ^bus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sel == 1意味着进行奇校验，sel == 0意味着进行偶校验</span></span><br><span class="line">    <span class="keyword">assign</span> check = sel ? odd_even : ~odd_even;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图：</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231110175239174.png" alt="image-20231110175239174" style="zoom: 50%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="移位运算与乘法"><a href="#移位运算与乘法" class="headerlink" title="移位运算与乘法*"></a>移位运算与乘法*</h1><ul>
<li><p>已知d为一个8位数，请在每个时钟周期分别输出该数乘1/3/7/8,并输出一个信号通知此时刻输入的d有效（d给出的信号的上升沿表示写入有效）</p>
<ul>
<li><p>状态机与移位运算逻辑：</p>
<p>| 状态 |    输出位运算    |<br>| :—: | :———————: |<br>|  1   |        d         |<br>|  3   | (din &lt;&lt; 2) - din |<br>|  7   | (din &lt;&lt; 3) - din |<br>|  8   |    (din &lt;&lt; 3)    |</p>
</li>
<li><p><strong>状态机不受输入信号控制，循环跳转就可以</strong></p>
</li>
<li><strong>状态输出采用时序电路的方式，这样可以节省一个复位状态，在rst归0时输出为0</strong></li>
</ul>
</li>
<li><p>multi_sel.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> multi_sel(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]d,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> input_grant,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">10</span>:<span class="number">0</span>]out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">parameter</span> S0 = <span class="number">4&#x27;d1</span>,</span><br><span class="line">              S1 = <span class="number">4&#x27;d3</span>,</span><br><span class="line">              S2 = <span class="number">4&#x27;d7</span>,</span><br><span class="line">              S3 = <span class="number">4&#x27;d8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] state;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] next_state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] din;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            state &lt;= S0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            state &lt;= next_state;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一状态的判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            S0: next_state &lt;= S1;</span><br><span class="line">            S1: next_state &lt;= S2;</span><br><span class="line">            S2: next_state &lt;= S3;</span><br><span class="line">            S3: next_state &lt;= S0;</span><br><span class="line">            <span class="keyword">default</span>: next_state &lt;= S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态对应输出</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out &lt;= <span class="number">11&#x27;d0</span>;</span><br><span class="line">            input_grant &lt;= <span class="number">0</span>;</span><br><span class="line">            din &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(state)</span><br><span class="line">                S0: <span class="keyword">begin</span></span><br><span class="line">                    din &lt;= d; <span class="comment">//这里很妙，能保证后面的都是与din相乘，而不是与新输入的d相乘</span></span><br><span class="line">                    out &lt;= d;</span><br><span class="line">                    input_grant &lt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S1: <span class="keyword">begin</span></span><br><span class="line">                    out &lt;= (din &lt;&lt; <span class="number">2</span>) - din; <span class="comment">//d*3 = d*4-d</span></span><br><span class="line">                    input_grant &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S2: <span class="keyword">begin</span></span><br><span class="line">                    out &lt;= (din &lt;&lt; <span class="number">3</span>) - din; <span class="comment">//d*7 = d*8-d</span></span><br><span class="line">                    input_grant &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                S3: <span class="keyword">begin</span></span><br><span class="line">                    out &lt;= (din &lt;&lt; <span class="number">3</span>);</span><br><span class="line">                    input_grant &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span>              </span><br><span class="line">            <span class="keyword">endcase</span>  </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>multi_sel_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> multi_sel_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] d;</span><br><span class="line">    <span class="keyword">wire</span> input_grant;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">10</span>:<span class="number">0</span>] out;</span><br><span class="line"></span><br><span class="line">    multi_sel u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst</span>(rst),</span><br><span class="line">        <span class="variable">.d</span>(d),</span><br><span class="line">        <span class="variable">.input_grant</span>(input_grant),</span><br><span class="line">        <span class="variable">.out</span>(out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> clk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复位和结束信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rst = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">11</span> rst = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">1000</span> <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他激励信号</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        d = <span class="number">143</span>;</span><br><span class="line">        #<span class="number">40</span> d = <span class="number">7</span>;</span><br><span class="line">        #<span class="number">50</span> d = <span class="number">6</span>;</span><br><span class="line">        #<span class="number">10</span> d = <span class="number">128</span>;</span><br><span class="line">        #<span class="number">20</span> d = <span class="number">129</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231110194006603.png" alt="image-20231110194006603"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="位拆分与运算"><a href="#位拆分与运算" class="headerlink" title="位拆分与运算*"></a>位拆分与运算*</h1><ul>
<li><p>现在输入了一个压缩的16位数据，按照sel选择输出四个数据的相加结果,并输出valid_out信号（在不输出时候拉低）</p>
<ul>
<li>0:  不输出且只有此时的输入有效</li>
<li>1：输出[3:0]+[7:4]</li>
<li>2：输出[3:0]+[11:8]</li>
<li>3：输出[3:0]+[15:12]</li>
</ul>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231112014304793.png" alt="image-20231112014304793" style="zoom:33%;"></p>
</li>
<li><p>这题的关键其实在于：<strong>只有当sel信号为0时，输入数据才被锁存，后续执行的都是锁存的这个数据，只有当sel信号再次为0时，输入数据才会被再次锁存，而在这期间输入信号的改变，对输出是不起作用的</strong>。这一部分的代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] data_lock;  </span><br><span class="line"><span class="comment">//sel==0时将输入数据锁住，只有当sel再次为零的时候，输入的数据才有效</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst)</span><br><span class="line">        data_lock &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!sel)</span><br><span class="line">        data_lock &lt;= d; <span class="comment">//后续sel不等于0时都是对这个data_lock操作</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>data_cal.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> data_cal(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] d,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] sel,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] out,</span><br><span class="line">    <span class="keyword">output</span> validout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] out_reg;</span><br><span class="line">    <span class="keyword">reg</span> validout_reg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] data_lock;  </span><br><span class="line">    <span class="comment">//sel==0时将输入数据锁住，只有当sel再次为零的时候，输入的数据才有效</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst)</span><br><span class="line">            data_lock &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!sel)</span><br><span class="line">            data_lock &lt;= d;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            out_reg &lt;= <span class="number">5&#x27;b0</span>;</span><br><span class="line">            validout_reg &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(sel) </span><br><span class="line">                <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                    out_reg &lt;= <span class="number">5&#x27;b0</span>;</span><br><span class="line">                    validout_reg &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                    out_reg &lt;= data_lock[<span class="number">3</span>:<span class="number">0</span>] + data_lock[<span class="number">7</span>:<span class="number">4</span>];</span><br><span class="line">                    validout_reg &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                    out_reg &lt;= data_lock[<span class="number">3</span>:<span class="number">0</span>] + data_lock[<span class="number">11</span>:<span class="number">8</span>];</span><br><span class="line">                    validout_reg &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2&#x27;b11</span>: <span class="keyword">begin</span></span><br><span class="line">                    out_reg &lt;= data_lock[<span class="number">3</span>:<span class="number">0</span>] + data_lock[<span class="number">15</span>:<span class="number">12</span>];</span><br><span class="line">                    validout_reg &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                    out_reg &lt;= <span class="number">5&#x27;b0</span>;</span><br><span class="line">                    validout_reg &lt;= <span class="number">1&#x27;b0</span>;                   </span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> out = out_reg;</span><br><span class="line">    <span class="keyword">assign</span> validout = validout_reg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231112015014386.png" alt="image-20231112015014386"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="多功能数据处理器"><a href="#多功能数据处理器" class="headerlink" title="多功能数据处理器*"></a>多功能数据处理器*</h1><ul>
<li><p>根据指示信号select的不同，对输入信号a,b实现不同的运算。输入信号a,b为8bit有符号数，当select信号为0，输出a；当select信号为1，输出b；当select信号为2，输出a+b；当select信号为3，输出a-b</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231112143533256.png" alt="image-20231112143533256" style="zoom: 67%;"></p>
</li>
<li><p>此题提到了一个有符号数，<strong>我的理解是，在FPGA的加减法运算中，如果没有bit的溢出，那么其实你定义是无符号还是有符号，计算的结果都是一样的，那么为了防止溢出，在进行有符号加减法运算时，我们对输入的数据通常扩展一个符号位。对于加法运算通常将结果扩展为length(max(a,b)+1)</strong></p>
</li>
<li><p><strong>对于有符号数+无符号数的情况，有符号位前面扩展一个符号位，无符号数前面扩展0，结果用有符号数显示</strong></p>
</li>
<li><p><strong>对于无符号数+无符号数的情况，可以不扩展，因为要扩展也是扩展0，所有没必要</strong></p>
</li>
<li><p>所以我的建议是，在进行加减运算时，其实不需要指定输入数据是否signed，运算时进行相应符号位扩展就可</p>
</li>
<li><p><strong>data_select.v</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> data_select(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">signed</span>[<span class="number">7</span>:<span class="number">0</span>]a,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">signed</span>[<span class="number">7</span>:<span class="number">0</span>]b,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>]select,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>]c</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n)<span class="keyword">begin</span></span><br><span class="line">            c &lt;= <span class="number">9&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(select)</span><br><span class="line">                <span class="number">2&#x27;b00</span>: c &lt;= &#123;a[<span class="number">7</span>], a&#125;;</span><br><span class="line">                <span class="number">2&#x27;b01</span>: c &lt;= &#123;b[<span class="number">7</span>], b&#125;;</span><br><span class="line">                <span class="number">2&#x27;b10</span>: c &lt;= &#123;a[<span class="number">7</span>], a&#125; + &#123;b[<span class="number">7</span>], b&#125;;</span><br><span class="line">                <span class="number">2&#x27;b11</span>: c &lt;= &#123;a[<span class="number">7</span>], a&#125; - &#123;b[<span class="number">7</span>], b&#125;;</span><br><span class="line">                <span class="keyword">default</span>: c &lt;= <span class="number">9&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>data_select_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> data_select_tb;</span><br><span class="line">	<span class="keyword">reg</span> clk;</span><br><span class="line">	<span class="keyword">reg</span> rst_n;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span>[<span class="number">7</span>:<span class="number">0</span>]a;</span><br><span class="line">	<span class="keyword">reg</span> <span class="keyword">signed</span>[<span class="number">7</span>:<span class="number">0</span>]b;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]select;</span><br><span class="line">	<span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">8</span>:<span class="number">0</span>]c;</span><br><span class="line"></span><br><span class="line">    data_select u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.a</span>(a),</span><br><span class="line">        <span class="variable">.b</span>(b),</span><br><span class="line">        <span class="variable">.select</span>(select),</span><br><span class="line">        <span class="variable">.c</span>(c)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> clk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复位和结束信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rst_n = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">11</span> rst_n = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">1000</span> <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a = <span class="number">8&#x27;b0</span>;</span><br><span class="line">        b = <span class="number">8&#x27;b0</span>;</span><br><span class="line">        select = <span class="number">2&#x27;b0</span>;</span><br><span class="line">        #<span class="number">12</span> a = <span class="number">8&#x27;d127</span>;</span><br><span class="line">            b = -<span class="number">8&#x27;d100</span>;</span><br><span class="line">            select = <span class="number">2&#x27;d2</span>;</span><br><span class="line">        #<span class="number">20</span> a = -<span class="number">8&#x27;d125</span>;</span><br><span class="line">            b = -<span class="number">8&#x27;d128</span>;</span><br><span class="line">            select = <span class="number">2&#x27;d3</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231112144734119.png" alt="image-20231112144734119"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="求两个数的差值"><a href="#求两个数的差值" class="headerlink" title="求两个数的差值"></a>求两个数的差值</h1><ul>
<li><p>根据输入信号a,b的大小关系，求解两个数的差值：输入信号a,b为8bit位宽的无符号数。如果a&gt;b，则输出a-b，如果a≤b，则输出b-a。</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231112152523054.png" alt="image-20231112152523054" style="zoom:67%;"></p>
</li>
<li><p>data_minus.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> data_minus(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]a,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]b,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span>  <span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>]c</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            c &lt;= <span class="number">9&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) <span class="keyword">begin</span></span><br><span class="line">            c &lt;= a - b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            c &lt;= b - a;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>这里有个点是：在Verilog HDL中，仍然有必要根据设计需要采用关键字signed对信号进行声明。 例如，在进行比较运算时，对于无符号数据，1000大于0100；对于有 符号数据，1000小于0100。</strong>（虽然在此题中都是无符号，所以不用考虑）</p>
</li>
</ul>
<hr>
<h1 id="使用generate…for语句简化代码"><a href="#使用generate…for语句简化代码" class="headerlink" title="使用generate…for语句简化代码*"></a>使用generate…for语句简化代码*</h1><ul>
<li><p>在某个module中包含了很多相似的连续赋值语句，请使用generata…for语句编写代码，替代该语句，要求不能改变原module的功能。使用Verilog HDL实现以上功能并编写testbench验证。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> template_module( </span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data_in,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] data_out</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> data_out [<span class="number">0</span>] = data_in [<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">assign</span> data_out [<span class="number">1</span>] = data_in [<span class="number">6</span>];</span><br><span class="line">  <span class="keyword">assign</span> data_out [<span class="number">2</span>] = data_in [<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">assign</span> data_out [<span class="number">3</span>] = data_in [<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">assign</span> data_out [<span class="number">4</span>] = data_in [<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">assign</span> data_out [<span class="number">5</span>] = data_in [<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">assign</span> data_out [<span class="number">6</span>] = data_in [<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">assign</span> data_out [<span class="number">7</span>] = data_in [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>gen_for_module.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gen_for_module(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data_in,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] data_out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">genvar</span> i;</span><br><span class="line">    <span class="keyword">generate</span> <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>)  <span class="keyword">begin</span>: bit_block_name</span><br><span class="line">        <span class="keyword">assign</span> data_out[i] = data_in[<span class="number">7</span> - i];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在begin之后的bit_block_name，表示该generate…for语句块的名称，可以根据需要修改。<strong>特别需要注意的是，即使只有一个语句，也需要使用begin…end</strong>。同时需要使用endgenerate表示结束</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231112154435953.png" alt="image-20231112154435953" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h1 id="使用子模块实现三输入数的大小比较"><a href="#使用子模块实现三输入数的大小比较" class="headerlink" title="使用子模块实现三输入数的大小比较"></a>使用子模块实现三输入数的大小比较</h1><ul>
<li><p>请编写一个子模块，将输入两个8bit位宽的变量data_a,data_b，并输出data_a,data_b之中较小的数。并在主模块中例化，实现输出三个8bit输入信号的最小值的功能。</p>
</li>
<li><p>main_mod.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> main_mod(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]a,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]b,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]c,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]d</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] temp1;</span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] temp2;</span><br><span class="line"></span><br><span class="line">	child_mod u1(</span><br><span class="line">		<span class="variable">.clk</span>(clk),</span><br><span class="line">		<span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">		<span class="variable">.a</span>(a),</span><br><span class="line">		<span class="variable">.b</span>(b),</span><br><span class="line">		<span class="variable">.d</span>(temp1)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	child_mod u2(</span><br><span class="line">		<span class="variable">.clk</span>(clk),</span><br><span class="line">		<span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">		<span class="variable">.a</span>(a),</span><br><span class="line">		<span class="variable">.b</span>(c),</span><br><span class="line">		<span class="variable">.d</span>(temp2)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	child_mod u3(</span><br><span class="line">		<span class="variable">.clk</span>(clk),</span><br><span class="line">		<span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">		<span class="variable">.a</span>(temp1),</span><br><span class="line">		<span class="variable">.b</span>(temp2),</span><br><span class="line">		<span class="variable">.d</span>(d)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>child_mod.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> child_mod(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]b,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]d</span><br><span class="line"> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] d_reg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>( ~rst_n ) <span class="keyword">begin</span></span><br><span class="line">            d_reg &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>( a &gt; b )</span><br><span class="line">                d_reg &lt;= b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                d_reg &lt;= a;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> d = d_reg;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>RTL原理图</li>
</ul>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231112161742832.png" alt="image-20231112161742832" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="使用函数实现数据大小端转换"><a href="#使用函数实现数据大小端转换" class="headerlink" title="使用函数实现数据大小端转换"></a>使用函数实现数据大小端转换</h1><ul>
<li><p>请用函数实现一个4bit数据大小端（高位bit与低位bit对应互换）转换的功能。实现对两个不同的输入分别转换并输出。</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231112163254237.png" alt="image-20231112163254237" style="zoom: 67%;"></p>
</li>
<li><p>function_mod.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> function_mod(</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]a,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]b,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]c,</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]d</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> c = data_bit_converse(a, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">assign</span> d = data_bit_converse(b, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span>  [<span class="number">3</span>:<span class="number">0</span>] data_bit_converse;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] data; <span class="comment">//输入变量</span></span><br><span class="line">        <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] data_bit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">integer</span> i; <span class="comment">//函数内的变量</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; data_bit; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                data_bit_converse[i] = data[data_bit - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="4位数值比较器电路"><a href="#4位数值比较器电路" class="headerlink" title="4位数值比较器电路"></a>4位数值比较器电路</h1><ul>
<li><p>某4位数值比较器的功能表如下。请用Verilog语言采用门级描述方式，实现此4位数值比较器</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231116195138065.png" alt="image-20231116195138065" style="zoom: 50%;"></p>
</li>
<li><p>先用门级电路描述1bit比较器</p>
<p>|  A   |  B   | F(A&gt;B) | F(A&lt;B) | F(A=B) |<br>| :—: | :—: | :——: | :——: | :——: |<br>|  0   |  0   |   0    |   0    |   1    |<br>|  0   |  1   |   0    |   1    |   0    |<br>|  1   |  0   |   1    |   0    |   0    |<br>|  1   |  1   |   0    |   0    |   1    |</p>
<ul>
<li>则有：<script type="math/tex; mode=display">
F(A>B) = A\bar B\\
F(A<B) = \bar A B\\
F(A=B) = \bar A\bar B + AB =\overline{A\bar B+\bar AB}</script></li>
</ul>
</li>
<li><p>最后再调用四个1bit比较器，根据题目所述表格将其串起来</p>
</li>
<li><p>comparator_4.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> comparator_4(</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] B,</span><br><span class="line"> 	<span class="keyword">output</span> <span class="keyword">wire</span>	Y2, <span class="comment">//A&gt;B</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> Y1, <span class="comment">//A=B</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> Y0  <span class="comment">//A&lt;B</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> W_y2[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">wire</span> W_y1[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">wire</span> W_y0[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">genvar</span> gen_i;</span><br><span class="line">    <span class="keyword">for</span> (gen_i = <span class="number">0</span>; gen_i &lt; <span class="number">4</span>; gen_i = gen_i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        compare_1 compare_1_u(</span><br><span class="line">        <span class="variable">.A</span> (A[gen_i]   ),</span><br><span class="line">        <span class="variable">.B</span> (B[gen_i]   ),</span><br><span class="line">        <span class="variable">.Y2</span>(W_y2[gen_i]),<span class="comment">//A&gt;B</span></span><br><span class="line">        <span class="variable">.Y1</span>(W_y1[gen_i]),<span class="comment">//A=B</span></span><br><span class="line">        <span class="variable">.Y0</span>(W_y0[gen_i]) <span class="comment">//A&lt;B</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> Y2 = W_y2[<span class="number">3</span>] | ((W_y1[<span class="number">3</span>]) &amp; (W_y2[<span class="number">2</span>])) | ((W_y1[<span class="number">3</span>]) &amp; (W_y1[<span class="number">2</span>]) &amp; (W_y2[<span class="number">1</span>])) | ((W_y1[<span class="number">3</span>]) &amp; (W_y1[<span class="number">2</span>]) &amp; (W_y1[<span class="number">1</span>]) &amp; (W_y2[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">assign</span> Y0 = W_y0[<span class="number">3</span>] | ((W_y1[<span class="number">3</span>]) &amp; (W_y0[<span class="number">2</span>])) | ((W_y1[<span class="number">3</span>]) &amp; (W_y1[<span class="number">2</span>]) &amp; (W_y0[<span class="number">1</span>])) | ((W_y1[<span class="number">3</span>]) &amp; (W_y1[<span class="number">2</span>]) &amp; (W_y1[<span class="number">1</span>]) &amp; (W_y0[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">assign</span> Y1 = W_y1[<span class="number">3</span>] &amp; W_y1[<span class="number">2</span>] &amp; W_y1[<span class="number">1</span>] &amp; W_y1[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> compare_1(</span><br><span class="line">    <span class="keyword">input</span> A,</span><br><span class="line">    <span class="keyword">input</span> B,</span><br><span class="line">    <span class="keyword">output</span> Y2,<span class="comment">//A&gt;B</span></span><br><span class="line">    <span class="keyword">output</span> Y1,<span class="comment">//A=B</span></span><br><span class="line">    <span class="keyword">output</span> Y0 <span class="comment">//A&lt;B</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">assign</span> Y2 = A &amp; (!B);</span><br><span class="line">    <span class="keyword">assign</span> Y0 = (!A) &amp; B;</span><br><span class="line">    <span class="keyword">assign</span> Y1 = !(Y2 | Y0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="4bit超前进位加法器"><a href="#4bit超前进位加法器" class="headerlink" title="4bit超前进位加法器"></a>4bit超前进位加法器</h1><ul>
<li><p>请用Verilog语言采用门级描述方式，实现此4bit超前进位加法器，其逻辑表达式如下：</p>
<ul>
<li>中间变量：$G_i = A_i B_i,P_i = A_i \bigoplus B_i$</li>
<li>和：$S_i = P_i\bigoplus C_{i-1}$</li>
<li>进位：$C_i = G_i + P_i C_{i-1}$</li>
</ul>
</li>
<li><p>lca_4.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> lca_4(</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] A_in,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] B_in,</span><br><span class="line">    <span class="keyword">input</span> C_1,</span><br><span class="line"> 	<span class="keyword">output</span> <span class="keyword">wire</span> CO,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] S</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] G;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] P;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> G = A_in &amp; B_in;  <span class="comment">//按位与就ok</span></span><br><span class="line">    <span class="keyword">assign</span> P = A_in ^ B_in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">0</span>] = G[<span class="number">0</span>] | P[<span class="number">0</span>] &amp; C_1;</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">1</span>] = G[<span class="number">1</span>] | P[<span class="number">1</span>] &amp; C[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">2</span>] = G[<span class="number">2</span>] | P[<span class="number">2</span>] &amp; C[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> C[<span class="number">3</span>] = G[<span class="number">3</span>] | P[<span class="number">3</span>] &amp; C[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> S[<span class="number">0</span>] = P[<span class="number">0</span>] ^ C_1;</span><br><span class="line">    <span class="keyword">assign</span> S[<span class="number">1</span>] = P[<span class="number">1</span>] ^ C[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> S[<span class="number">2</span>] = P[<span class="number">2</span>] ^ C[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> S[<span class="number">3</span>] = P[<span class="number">3</span>] ^ C[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> CO = C[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20231116203246152.png" alt="image-20231116203246152"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="根据状态转移图或表写状态机"><a href="#根据状态转移图或表写状态机" class="headerlink" title="根据状态转移图或表写状态机"></a>根据状态转移图或表写状态机</h1><ul>
<li><p>某同步时序电路转换表如下，请使用D触发器和必要的逻辑门实现此同步时序电路，用Verilog语言描述。</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240110012824743.png" alt="image-20240110012824743" style="zoom:50%;"></p>
<ul>
<li><p>以上状态转移表对应的状态转移图如下：</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240110012938022.png" alt="image-20240110012938022" style="zoom: 33%;"></p>
</li>
</ul>
</li>
<li><p>Machine_state_design1.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Machine_state_design1(</span><br><span class="line">    <span class="keyword">input</span>                A   ,</span><br><span class="line">    <span class="keyword">input</span>                clk ,</span><br><span class="line">    <span class="keyword">input</span>                rst_n,</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">output</span>   <span class="keyword">wire</span>        Y   </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态定义</span></span><br><span class="line">    <span class="keyword">parameter</span> S0 = <span class="number">2&#x27;b00</span>,</span><br><span class="line">              S1 = <span class="number">2&#x27;b01</span>,</span><br><span class="line">              S2 = <span class="number">2&#x27;b10</span>,</span><br><span class="line">              S3 = <span class="number">2&#x27;b11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态的中间变量</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态跳转</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            state &lt;= S0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            state &lt;= next_state;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//次态判断</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(state) </span><br><span class="line">            S0: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(A) next_state = S3;</span><br><span class="line">                <span class="keyword">else</span> next_state = S1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S1: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(A) next_state = S0;</span><br><span class="line">                <span class="keyword">else</span> next_state = S2;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S2: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(A) next_state = S1;</span><br><span class="line">                <span class="keyword">else</span> next_state = S3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            S3: <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(A) next_state = S2;</span><br><span class="line">                <span class="keyword">else</span> next_state = S0;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: next_state = S0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">assign</span> Y = (state == S3) ? <span class="number">1&#x27;b1</span>: <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="ROM的简单实现"><a href="#ROM的简单实现" class="headerlink" title="ROM的简单实现"></a>ROM的简单实现</h1><ul>
<li><p>实现一个深度为8，位宽为4bit的ROM，数据初始化为0，2，4，6，8，10，12，14。可以通过输入地址addr，输出相应的数据data。接口信号图如下：</p>
<p><img src="/2023/11/10/Verilog%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%B7%E9%A2%98/image-20240110193442403.png" alt="image-20240110193442403" style="zoom:50%;"></p>
</li>
<li><p>ROM_easy_design.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ROM_easy_design(</span><br><span class="line">	<span class="keyword">input</span> clk,</span><br><span class="line">	<span class="keyword">input</span> rst_n,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]addr,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]data</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] value [<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] data_r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst_n) <span class="keyword">begin</span></span><br><span class="line">            data_r &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">            value[<span class="number">0</span>] &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">            value[<span class="number">1</span>] &lt;= <span class="number">4&#x27;d2</span>;</span><br><span class="line">            value[<span class="number">2</span>] &lt;= <span class="number">4&#x27;d4</span>;</span><br><span class="line">            value[<span class="number">3</span>] &lt;= <span class="number">4&#x27;d6</span>;</span><br><span class="line">            value[<span class="number">4</span>] &lt;= <span class="number">4&#x27;d8</span>;</span><br><span class="line">            value[<span class="number">5</span>] &lt;= <span class="number">4&#x27;d10</span>;</span><br><span class="line">            value[<span class="number">6</span>] &lt;= <span class="number">4&#x27;d12</span>;</span><br><span class="line">            value[<span class="number">7</span>] &lt;= <span class="number">4&#x27;d14</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            data_r &lt;= value[addr];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> data = data_r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><p>移位运算和乘法这一题有人（<a href="https://www.nowcoder.com/practice/1dd22852bcac42ce8f781737f84a3272?tpId=301&amp;tqId=5000607&amp;ru=/exam/oj&amp;qru=/ta/verilog-start/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Ftab%3DVerilog%E7%AF%87%26topicId%3D302">移位运算与乘法_牛客题霸_牛客网 (nowcoder.com)</a>）提供了更加简单的写法（它这相当于将cnt当成4个状态了，并用一段式状态机描述）：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> multi_sel(</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]d ,</span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">input</span> rst,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> input_grant,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">10</span>:<span class="number">0</span>]out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]cnt;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]din;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst) <span class="keyword">begin</span></span><br><span class="line">		cnt &lt;= <span class="number">0</span>;</span><br><span class="line">		out &lt;= <span class="number">0</span>;</span><br><span class="line">		input_grant &lt;= <span class="number">0</span>;</span><br><span class="line">		din &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		cnt &lt;= cnt+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> (cnt)</span><br><span class="line">			<span class="number">0</span>: <span class="keyword">begin</span></span><br><span class="line">				din &lt;= d;</span><br><span class="line">				input_grant &lt;= <span class="number">1</span>;</span><br><span class="line">				out &lt;= d;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="number">1</span>: <span class="keyword">begin</span></span><br><span class="line">				input_grant &lt;= <span class="number">0</span>;</span><br><span class="line">				out &lt;= (din&lt;&lt;<span class="number">2</span>)-din;</span><br><span class="line">			<span class="keyword">end</span>		</span><br><span class="line">			<span class="number">2</span>: <span class="keyword">begin</span></span><br><span class="line">				input_grant &lt;= <span class="number">0</span>;</span><br><span class="line">				out &lt;= (din&lt;&lt;<span class="number">3</span>)-din;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="number">3</span>: <span class="keyword">begin</span></span><br><span class="line">				input_grant &lt;= <span class="number">0</span>;</span><br><span class="line">				out &lt;= (din&lt;&lt;<span class="number">3</span>);</span><br><span class="line">			<span class="keyword">end</span>	</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于子模块实现三输入数的大小比较时，需要调用3个模块，这里很多同学可能疑惑为什么用3个而不是2个。参考：<a href="https://www.bilibili.com/video/BV1Tq4y1v7MN/?spm_id_from=333.788&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">FPGA数字IC牛客网Verilog刷题09-子模块例化_哔哩哔哩_bilibili</a>，解释如下：</p>
<ul>
<li>第一个模块：比较 T 时刻的 a 和 b，T+1 时刻出来 tmp1； 第二个模块：比较 T 时刻的 a 和 c，T+1 时刻 出来 tmp2； 第三个模块：比较 T+1 时刻的 tmp1 和 tmp2，T+2 时刻出来 d；</li>
<li><strong>如果只用 2 个子模块，那么 T时刻比较 a和 b得到 tmp1 ，再比较 tmp1和 c的时候是 T+1时刻的 c 和 T+1时刻的 tmp1</strong> ，而 tmp1代表的是 T时刻 a和 b的较小值，所以这时候比较的 T时刻的 a 、 b 和 T+1时刻的 c ，显然不符合要求。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之CFAR检测</title>
    <url>/2023/11/08/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCFAR%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>本节主要介绍了一维CFAR的基本原理以及它的MATLAB仿真与Verilog硬件实现的思路。</p>
<span id="more"></span>
<h1 id="一维CFAR的基本原理"><a href="#一维CFAR的基本原理" class="headerlink" title="一维CFAR的基本原理"></a>一维CFAR的基本原理</h1><ul>
<li>毫米波雷达中，CFAR（Constant False Alarm Rate）算法是一种常用的目标检测和跟踪算法。它的主要作用是在背景噪声（杂波）中检测出目标信号，同时保证误检概率不变。</li>
<li>CFAR算法的步骤如下：<ul>
<li>确定检测窗口的大小和形状，例如矩形、圆形等。</li>
<li>在检测窗口内计算信号功率的平均值和方差，可以使用不同的方法来计算，例如对数变换、线性平均、动态平均等。</li>
<li>将检测窗口划分为若干个子窗口，每个子窗口的大小和形状可以根据实际应用进行调整。</li>
<li>根据期望的误检概率和背景噪声的统计特性，计算每个子窗口的阈值，例如高斯分布下的阈值可以通过计算高斯分布的概率密度函数得到。</li>
<li>对于每个子窗口，比较信号功率与阈值的大小关系，判断该子窗口内是否存在目标信号。</li>
<li>对于检测到的目标信号，可以进行后续的处理和跟踪，例如目标分离、速度估计等。</li>
<li>CFAR算法分为两类：一类是均值类CFAR(CA-CFAR)算法，该类算法应用的前提是假设背景杂波是均匀分布的；另一类是有序统计类CFAR(OS-CFAR)算法，这类算法是为了应对邻域内多目标情况而设计的</li>
</ul>
</li>
<li>我的理解就是一个滑动窗口，其在不断滤波，类似深度学习中的卷积（但不一样，只是都是滤波的感觉）</li>
</ul>
<h2 id="1-均值类CFAR"><a href="#1-均值类CFAR" class="headerlink" title="1.均值类CFAR"></a>1.均值类CFAR</h2><p><img src="/2023/11/08/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCFAR%E6%A3%80%E6%B5%8B/image-20231108014322252.png" alt="image-20231108014322252" style="zoom:50%;"></p>
<script type="math/tex; mode=display">
\alpha =N(P_{FA}^{-\frac 1N}-1),P_{FA}为虚警概率</script><h3 id="1-1-CA-CFAR"><a href="#1-1-CA-CFAR" class="headerlink" title="1.1 CA-CFAR"></a>1.1 CA-CFAR</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ index, XT ]</span> = <span class="title">cfar_ca</span><span class="params">( xc, N, pro_N, PAD)</span></span></span><br><span class="line"></span><br><span class="line">alpha=N.*(PAD.^(<span class="number">-1.</span>/N)<span class="number">-1</span>);</span><br><span class="line">index=<span class="number">1</span>+N/<span class="number">2</span>+pro_N/<span class="number">2</span>:<span class="built_in">length</span>(xc)-N/<span class="number">2</span>-pro_N/<span class="number">2</span>;</span><br><span class="line">XT=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(index));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=index</span><br><span class="line">    cell_left=xc(<span class="number">1</span>,<span class="built_in">i</span>-N/<span class="number">2</span>-pro_N/<span class="number">2</span>:<span class="built_in">i</span>-pro_N/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">    cell_right=xc(<span class="number">1</span>,<span class="built_in">i</span>+pro_N/<span class="number">2</span>+<span class="number">1</span>:<span class="built_in">i</span>+N/<span class="number">2</span>+pro_N/<span class="number">2</span>);</span><br><span class="line">    Z=(sum(cell_left)+sum(cell_right))./N;</span><br><span class="line">    XT(<span class="number">1</span>,<span class="built_in">i</span>-N/<span class="number">2</span>-pro_N/<span class="number">2</span>)=Z.*alpha;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-GO-CFAR"><a href="#1-2-GO-CFAR" class="headerlink" title="1.2 GO-CFAR"></a>1.2 GO-CFAR</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ index, XT ]</span> = <span class="title">cfar_go</span><span class="params">( xc, N, pro_N, PAD)</span></span></span><br><span class="line"></span><br><span class="line">alpha=N.*(PAD.^(<span class="number">-1.</span>/N)<span class="number">-1</span>);</span><br><span class="line">index=<span class="number">1</span>+N/<span class="number">2</span>+pro_N/<span class="number">2</span>:<span class="built_in">length</span>(xc)-N/<span class="number">2</span>-pro_N/<span class="number">2</span>;</span><br><span class="line">XT=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(index));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=index</span><br><span class="line">    cell_left=xc(<span class="number">1</span>,<span class="built_in">i</span>-N/<span class="number">2</span>-pro_N/<span class="number">2</span>:<span class="built_in">i</span>-pro_N/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">    cell_right=xc(<span class="number">1</span>,<span class="built_in">i</span>+pro_N/<span class="number">2</span>+<span class="number">1</span>:<span class="built_in">i</span>+N/<span class="number">2</span>+pro_N/<span class="number">2</span>);</span><br><span class="line">    Z=<span class="built_in">max</span>([<span class="built_in">mean</span>(cell_left),<span class="built_in">mean</span>(cell_right)]);</span><br><span class="line">    </span><br><span class="line">    XT(<span class="number">1</span>,<span class="built_in">i</span>-N/<span class="number">2</span>-pro_N/<span class="number">2</span>)=Z.*alpha;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-SO-CFAR"><a href="#1-3-SO-CFAR" class="headerlink" title="1.3 SO-CFAR"></a>1.3 SO-CFAR</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ index, XT ]</span> = <span class="title">cfar_so</span><span class="params">( xc, N, pro_N, PAD)</span></span></span><br><span class="line"></span><br><span class="line">alpha=N.*(PAD.^(<span class="number">-1.</span>/N)<span class="number">-1</span>);</span><br><span class="line">index=<span class="number">1</span>+N/<span class="number">2</span>+pro_N/<span class="number">2</span>:<span class="built_in">length</span>(xc)-N/<span class="number">2</span>-pro_N/<span class="number">2</span>;</span><br><span class="line">XT=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(index));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=index</span><br><span class="line">    cell_left=xc(<span class="number">1</span>,<span class="built_in">i</span>-N/<span class="number">2</span>-pro_N/<span class="number">2</span>:<span class="built_in">i</span>-pro_N/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">    cell_right=xc(<span class="number">1</span>,<span class="built_in">i</span>+pro_N/<span class="number">2</span>+<span class="number">1</span>:<span class="built_in">i</span>+N/<span class="number">2</span>+pro_N/<span class="number">2</span>);</span><br><span class="line">    Z=<span class="built_in">min</span>([<span class="built_in">mean</span>(cell_left),<span class="built_in">mean</span>(cell_right)]);</span><br><span class="line">    </span><br><span class="line">    XT(<span class="number">1</span>,<span class="built_in">i</span>-N/<span class="number">2</span>-pro_N/<span class="number">2</span>)=Z.*alpha;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="2-统计类CFAR"><a href="#2-统计类CFAR" class="headerlink" title="2.统计类CFAR"></a>2.统计类CFAR</h2><h3 id="2-1-OS-CFAR"><a href="#2-1-OS-CFAR" class="headerlink" title="2.1 OS-CFAR"></a>2.1 OS-CFAR</h3><p><img src="/2023/11/08/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCFAR%E6%A3%80%E6%B5%8B/image-20231108015709762.png" alt="image-20231108015709762" style="zoom:50%;"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ index, XT ]</span> = <span class="title">cfar_os</span><span class="params">( xc, N, k, pro_N, PAD)</span></span></span><br><span class="line"></span><br><span class="line">alpha=N.*(PAD.^(<span class="number">-1.</span>/N)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">index=<span class="number">1</span>+N/<span class="number">2</span>+pro_N/<span class="number">2</span>:<span class="built_in">length</span>(xc)-N/<span class="number">2</span>-pro_N/<span class="number">2</span>;</span><br><span class="line">XT=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(index));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=index</span><br><span class="line">    cell_left=xc(<span class="number">1</span>,<span class="built_in">i</span>-N/<span class="number">2</span>-pro_N/<span class="number">2</span>:<span class="built_in">i</span>-pro_N/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">    cell_right=xc(<span class="number">1</span>,<span class="built_in">i</span>+pro_N/<span class="number">2</span>+<span class="number">1</span>:<span class="built_in">i</span>+N/<span class="number">2</span>+pro_N/<span class="number">2</span>);</span><br><span class="line">    cell_all=<span class="built_in">cat</span>(<span class="number">2</span>,cell_left,cell_right);</span><br><span class="line">    cell_sort=<span class="built_in">sort</span>(cell_all);</span><br><span class="line">    </span><br><span class="line">    Z=cell_sort(<span class="number">1</span>,k);</span><br><span class="line">    </span><br><span class="line">    XT(<span class="number">1</span>,<span class="built_in">i</span>-N/<span class="number">2</span>-pro_N/<span class="number">2</span>)=Z.*alpha;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="CFAR算法的MATLAB建模"><a href="#CFAR算法的MATLAB建模" class="headerlink" title="CFAR算法的MATLAB建模"></a>CFAR算法的MATLAB建模</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 函数名：CFAR_1D_Compute</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">  <span class="comment">% 创建人：沈诗艺</span></span><br><span class="line">  <span class="comment">% 日期：2023/11/11</span></span><br><span class="line">  <span class="comment">% 函数功能的简单描述：此函数执行一维CFAR处理，并将处理后得到的阈值与原频谱进行比较，从而得到最终的频谱值</span></span><br><span class="line">  <span class="comment">% 函数特别说明：此函数中对频谱序列边缘均采用补零操作</span></span><br><span class="line">  <span class="comment">% 输入参数：</span></span><br><span class="line">  <span class="comment">%     SF: 经过FFT后的频谱</span></span><br><span class="line">  <span class="comment">%     N_base: 一维CFAR处理的基本单元（两个对称基本单元的和）</span></span><br><span class="line">  <span class="comment">%     N_pro: 一维CFAR处理的保护单元（两个对称保护单元的和）</span></span><br><span class="line">  <span class="comment">%     Pfa：一维CFAR处理的虚警概率</span></span><br><span class="line">  <span class="comment">%     cfar_mode：此函数设置了4种常见的CFAR处理模式：</span></span><br><span class="line">  <span class="comment">%         cfar_mode = 0：执行CA-CFAR</span></span><br><span class="line">  <span class="comment">%         cfar_mode = 1：执行GO-CFAR</span></span><br><span class="line">  <span class="comment">%         cfar_mode = 2：执行SO-CFAR</span></span><br><span class="line">  <span class="comment">%         cfar_mode = 3：执行OS-CFAR</span></span><br><span class="line">  <span class="comment">%     OS_k：若执行OS-CFAR时，需设置取第k个最大值作为阈值，若省略此值，则默认为1</span></span><br><span class="line">  <span class="comment">% 输出参数：</span></span><br><span class="line">  <span class="comment">%     XT: CFAR处理后得到的阈值</span></span><br><span class="line">  <span class="comment">%     SF_cfar：原频谱abs(SF)与阈值XT比较后得到的最终CFAR结果</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">  <span class="comment">% 修改人：</span></span><br><span class="line">  <span class="comment">% 日期：</span></span><br><span class="line">  <span class="comment">% 相对上一版程序的修改部分：</span></span><br><span class="line">  <span class="comment">% 修改的内容说明：</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[XT, SF_cfar]</span>=<span class="title">CFAR_1D_Compute</span><span class="params">(SF, N_base, N_pro, Pfa, cfar_mode, OS_k)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(~exist(<span class="string">&#x27;OS_k&#x27;</span>,<span class="string">&#x27;var&#x27;</span>))</span><br><span class="line">        OS_k = <span class="number">1</span>;                                                           <span class="comment">%如果未出现该变量，则对其进行赋值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    xc_pad=[<span class="built_in">zeros</span>(<span class="number">1</span>,N_base/<span class="number">2</span>+N_pro/<span class="number">2</span>), <span class="built_in">abs</span>(SF), <span class="built_in">zeros</span>(<span class="number">1</span>,N_base/<span class="number">2</span>+N_pro/<span class="number">2</span>)]; <span class="comment">%补零操作</span></span><br><span class="line">    </span><br><span class="line">    alpha=N_base.*(Pfa.^(<span class="number">-1.</span>/N_base)<span class="number">-1</span>);</span><br><span class="line">    Z=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(SF));</span><br><span class="line">    XT=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(SF));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">1</span>:<span class="built_in">length</span>(SF)</span><br><span class="line">        cell_left = xc_pad(<span class="number">1</span>,<span class="built_in">i</span>:<span class="built_in">i</span>+N_base/<span class="number">2</span><span class="number">-1</span>);                               <span class="comment">%滑动窗左侧的基本单元</span></span><br><span class="line">        cell_right = xc_pad(<span class="number">1</span>,<span class="built_in">i</span>+N_base/<span class="number">2</span>+N_pro+<span class="number">1</span>:<span class="built_in">i</span>+N_base+N_pro);           <span class="comment">%滑动窗右侧的基本单元</span></span><br><span class="line">        <span class="keyword">if</span>(cfar_mode == <span class="number">0</span>)                                                  <span class="comment">%CA-CFAR</span></span><br><span class="line">            Z(<span class="number">1</span>,<span class="built_in">i</span>) = (sum(cell_left)+sum(cell_right))./N_base;</span><br><span class="line">        <span class="keyword">elseif</span>(cfar_mode == <span class="number">1</span>)                                              <span class="comment">%GO-CFAR</span></span><br><span class="line">            Z(<span class="number">1</span>,<span class="built_in">i</span>) = <span class="built_in">max</span>([<span class="built_in">mean</span>(cell_left),<span class="built_in">mean</span>(cell_right)]);</span><br><span class="line">        <span class="keyword">elseif</span>(cfar_mode == <span class="number">2</span>)                                              <span class="comment">%SO-CFAR</span></span><br><span class="line">            Z(<span class="number">1</span>,<span class="built_in">i</span>) = <span class="built_in">min</span>([<span class="built_in">mean</span>(cell_left),<span class="built_in">mean</span>(cell_right)]);</span><br><span class="line">        <span class="keyword">elseif</span>(cfar_mode == <span class="number">3</span>)                                              <span class="comment">%OS-CFAR</span></span><br><span class="line">            cell_all = <span class="built_in">cat</span>(<span class="number">2</span>,cell_left,cell_right);</span><br><span class="line">            cell_sort = <span class="built_in">sort</span>(cell_all);</span><br><span class="line">            Z(<span class="number">1</span>,<span class="built_in">i</span>) = cell_sort(<span class="number">1</span>,OS_k);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    XT(<span class="number">1</span>,:)=Z.*alpha;                                                       <span class="comment">%其结果是每个点的阈值</span></span><br><span class="line"></span><br><span class="line">    SF_cfar = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(SF));                  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">1</span>:<span class="built_in">length</span>(SF)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(SF(<span class="built_in">i</span>))&gt;XT(<span class="built_in">i</span>))                                                <span class="comment">%频谱&gt;XT，则保留原值</span></span><br><span class="line">            SF_cfar(<span class="number">1</span>,<span class="built_in">i</span>) = <span class="built_in">abs</span>(SF(<span class="built_in">i</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SF_cfar(<span class="number">1</span>,<span class="built_in">i</span>) = <span class="number">0</span>;                                               <span class="comment">%频谱&lt;XT，则对应点频谱置零</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="CFAR算法的Verilog硬件实现"><a href="#CFAR算法的Verilog硬件实现" class="headerlink" title="CFAR算法的Verilog硬件实现"></a>CFAR算法的Verilog硬件实现</h1><h2 id="1-基本思路"><a href="#1-基本思路" class="headerlink" title="1.基本思路"></a>1.基本思路</h2><ul>
<li><p>目前还只是初步优化思路，还没考虑量化以及参数可配置的问题，后续有时间再继续优化</p>
</li>
<li><p>其大致思路是通过时钟计数，并对计数器进行判断，从而对数据进行不同的计算，此外，数据是进到保护单元长度的时候就开始计算</p>
<p><img src="/2023/11/08/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCFAR%E6%A3%80%E6%B5%8B/image-20231221115036640.png" alt="image-20231221115036640"></p>
</li>
<li><p>首先，在时序电路中得想明白一个事，也就是我们在抓取寄存器输出的值时，它总是在时钟上升沿结束之后才更新的，所以我们在时钟上升沿开始去抓取数据时，只能抓取到旧值，只有在再下一个时钟时，才能抓取到上一个时钟更新的值</p>
<p><img src="/2023/11/08/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCFAR%E6%A3%80%E6%B5%8B/image-20231221115107922.png" alt="image-20231221115107922" style="zoom:50%;"></p>
</li>
<li><p>同理，可推导出在第12个时钟上升沿到来时，有：</p>
<p><img src="/2023/11/08/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCFAR%E6%A3%80%E6%B5%8B/image-20231221115143827.png" alt="image-20231221115143827" style="zoom:50%;"></p>
</li>
<li><p>当cnt&gt;11时，则可以进行加一个新移进来的数以及减一个最旧的数的操作了。对了，同样，还是得寄存左窗口最旧的那个值</p>
<p><img src="/2023/11/08/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCFAR%E6%A3%80%E6%B5%8B/image-20231221115235604.png" alt="image-20231221115235604" style="zoom: 33%;"></p>
</li>
<li><p>此外，需要设置一个完成标志位，其意味着所有窗口左右两侧的和均算出</p>
<ul>
<li>简单计算一下：<ul>
<li>在cnt == 11时，第一个滑窗左右的和被计算出</li>
<li>此后每个周期都能计算出一此和，这里先不考虑补零问题，那么意味着还需要做100-10-1 = 89次cfar</li>
<li>故当cnt == 11+89(即100时)，所有滑窗求和均算出，此时将finished标志位置高</li>
</ul>
</li>
</ul>
</li>
<li><p>而最终二者左基本单元和右基本单元的求和计算，会晚一个时钟周期计算出来，道理其实与前面解释的一样，获取时序电路的输出再计算，均会导致晚一个周期，而不是立马被计算出来</p>
</li>
</ul>
<h2 id="2-源代码"><a href="#2-源代码" class="headerlink" title="2.源代码"></a>2.源代码</h2><ul>
<li><p>CA_cfar.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> CA_cfar #(</span><br><span class="line">    <span class="keyword">parameter</span>  N_reg = <span class="number">11</span></span><br><span class="line">)(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> start,                <span class="comment">//启动信号</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">6</span>:<span class="number">0</span>] SF,             <span class="comment">//输入的FFT后的频谱幅度</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] alpha,          <span class="comment">//与cfar后Z值相乘的alpha</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">8</span>:<span class="number">0</span>] XT,            <span class="comment">//最终阈值</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> finished         <span class="comment">//一次cfar完成的标志位</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i, j;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] shift_reg [N_reg - <span class="number">1</span> : <span class="number">0</span>];  <span class="comment">//这里的shift_reg右边的位宽实际代表N_reg</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] Ncount;       <span class="comment">//时钟计数</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] temp;               <span class="comment">//寄存左侧窗口移出的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//移位寄存器实现</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N_reg - <span class="number">1</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                shift_reg[i] &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            temp &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(start) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N_reg - <span class="number">1</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                shift_reg[i] &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span>  </span><br><span class="line">            temp &lt;= <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N_reg - <span class="number">1</span>; j = j + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                shift_reg[j + <span class="number">1</span>] &lt;= shift_reg[j];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            shift_reg[<span class="number">0</span>] &lt;= SF;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟计数器</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            Ncount &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(start) <span class="keyword">begin</span></span><br><span class="line">            Ncount &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            Ncount &lt;= Ncount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> valid_flag;            <span class="comment">//数据全部移进来的标志信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            valid_flag &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(Ncount == <span class="number">11</span>) <span class="keyword">begin</span></span><br><span class="line">                valid_flag &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                valid_flag &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算完成标志位</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            finished &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(Ncount == <span class="number">100</span>) <span class="keyword">begin</span></span><br><span class="line">               finished &lt;= <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">               finished &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加法求和</span></span><br><span class="line">    <span class="comment">//1.左侧</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>] Adder_left;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            Adder_left &lt;= <span class="number">9&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(Ncount == <span class="number">4</span>) <span class="keyword">begin</span></span><br><span class="line">                Adder_left &lt;= shift_reg[<span class="number">0</span>] + shift_reg[<span class="number">1</span>] + shift_reg[<span class="number">2</span>] + shift_reg[<span class="number">3</span>];</span><br><span class="line">                temp &lt;= shift_reg[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span>(Ncount &gt; <span class="number">11</span>) <span class="keyword">begin</span></span><br><span class="line">                Adder_left &lt;= Adder_left + shift_reg[<span class="number">7</span>] - temp;</span><br><span class="line">                temp &lt;= shift_reg[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line">    <span class="comment">//2.右侧</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>] Adder_right;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            Adder_right &lt;= <span class="number">9&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line">            <span class="keyword">if</span>(Ncount == <span class="number">11</span>) <span class="keyword">begin</span></span><br><span class="line">                Adder_right &lt;= shift_reg[<span class="number">0</span>] + shift_reg[<span class="number">1</span>] + shift_reg[<span class="number">2</span>] + shift_reg[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span>(Ncount &gt; <span class="number">11</span>) <span class="keyword">begin</span></span><br><span class="line">                Adder_right &lt;= Adder_right + shift_reg[<span class="number">0</span>] - shift_reg[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右两侧求和</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">9</span>:<span class="number">0</span>] sum_mean;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            sum_mean &lt;= <span class="number">10&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(start) <span class="keyword">begin</span></span><br><span class="line">            sum_mean &lt;= <span class="number">10&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            sum_mean &lt;= Adder_left + Adder_right;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Testbench"><a href="#3-Testbench" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><ul>
<li><p>CA_cfar_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> CLOCK_PERIOD 10 </span></span><br><span class="line"><span class="keyword">module</span> CA_cfar_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst;</span><br><span class="line">    <span class="keyword">reg</span> start;               </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] SF;            </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] alpha;         </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">0</span>] XT;         </span><br><span class="line">    <span class="keyword">wire</span> finished;     </span><br><span class="line"></span><br><span class="line">    CA_cfar <span class="variable">#(.N_reg(11))</span> ca_U1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst</span>(rst),</span><br><span class="line">        <span class="variable">.start</span>(start),         </span><br><span class="line">        <span class="variable">.SF</span>(SF),            </span><br><span class="line">        <span class="variable">.alpha</span>(alpha),         </span><br><span class="line">        <span class="variable">.XT</span>(XT),            </span><br><span class="line">        <span class="variable">.finished</span>(finished)       </span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> clk = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLOCK_PERIOD/2)</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rst = <span class="number">0</span>;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">21</span> rst = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">20</span> start = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">10</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] dataI[<span class="number">99</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemb</span>(<span class="string">&quot;D:\\App_Data_File\\Vivado_data\\Vivado_project\\DSP_design\\CFAR_project\\cfar_test_data.txt&quot;</span>,dataI);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] ncount;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            ncount &lt;= <span class="number">7&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(start) <span class="keyword">begin</span></span><br><span class="line">            ncount &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            ncount &lt;= ncount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(~rst) <span class="keyword">begin</span></span><br><span class="line">            SF &lt;= <span class="number">7&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(ncount &lt; <span class="number">100</span>) <span class="keyword">begin</span></span><br><span class="line">                SF = dataI[ncount];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                SF = <span class="number">7&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/11/08/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCFAR%E6%A3%80%E6%B5%8B/image-20231221115618703.png" alt="image-20231221115618703"></p>
<p><img src="/2023/11/08/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BCFAR%E6%A3%80%E6%B5%8B/image-20231221115626102.png" alt="image-20231221115626102"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h2><ul>
<li><strong>目前一维CFAR可以做到CA、GO、SO、OS四种CFAR可选、保护单元和基本单元可调，等项目结束后将有偿提供代码，着急需要代码的可邮箱联系</strong>（2024.3.22）</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://blog.csdn.net/weixin_44296793/article/details/130161960">CFAR(恒虚警率)目标检测算法_cfar检测-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_35605018/article/details/109472749">[解疑][TI]TI毫米波雷达系列（五）：恒虚警算法（CFAR）原理-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/508870274">干货 | FMCW雷达信号处理的二维CFAR（2D CFAR、十字CFAR）检测算法 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI DSP</tag>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之高速度结构设计</title>
    <url>/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>本节主要介绍了高速度结构设计的基本方法，分别从高流量、低时滞、时序等三方面进行了优化</p>
<span id="more"></span>
<h1 id="高速度结构设计的基本概念"><a href="#高速度结构设计的基本概念" class="headerlink" title="高速度结构设计的基本概念"></a>高速度结构设计的基本概念</h1><ul>
<li>速度有三种基本定义：<ul>
<li>流量（Throughput）：定义为每个时钟周期处理的数据量，流量通常的度量是每秒的位数</li>
<li>时滞（Latency）：定义为数据输入与处理的数据输出之间的时间，时滞的一般度量是时间或时钟周期</li>
<li>时序（Timing）：定义为时序元件之间的逻辑延时，当一个设计没有“满足时序”时，意味着<strong>关键路径的延时，即触发器之间的最大延时</strong>比预定的时钟周期大</li>
</ul>
</li>
<li><strong>高流量结构使设计每秒可以处理的位数最大化</strong></li>
<li><strong>低时滞结构使一个模块输入端到输出端的延时最小化</strong></li>
<li><strong>时序优化可减少关键组合的路径延时</strong></li>
</ul>
<hr>
<h1 id="高流量"><a href="#高流量" class="headerlink" title="高流量"></a>高流量</h1><ul>
<li><p>高流量设计是与稳定状态数据率有关的设计，高流量设计的概念是<strong>流水线（pipeline）</strong></p>
</li>
<li><p>从算法的观点看，在流水线设计中一个重要的概念是“拆开环路”</p>
</li>
<li><p>考虑以下一段代码，它类似于在软件实现<strong>求X的三次幂</strong>中使用的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">XPower = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	XPower = X * XPower;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用Verilog语言实现X三次幂的算法（没有考虑输出范围）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,start,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] x,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] XPower,</span><br><span class="line">    <span class="keyword">output</span> finished</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] ncount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> finished = (ncount == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(start) <span class="keyword">begin</span></span><br><span class="line">            ncount &lt;= <span class="number">2</span>;</span><br><span class="line">            XPower &lt;= x;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!finished) <span class="keyword">begin</span></span><br><span class="line">            ncount &lt;= ncount - <span class="number">1</span>;</span><br><span class="line">            XPower &lt;= XPower * x;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图：</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106132244580.png" alt="image-20231106132244580" style="zoom:50%;"></p>
</li>
<li><p>观察被红色圈起来关于x的计算部分：XPower_reg寄存器一直在被重复使用，由于这类迭代实现，新的计算直到前面的计算已经完成才开始。、</p>
</li>
<li><p>这个迭代方法类似于软件实现，也应注意，要求某些握手信号来表示开始和完成一次计算，外部模块也必须利用这个握手信号来传递新数据到模块并接收一个完成的计算</p>
</li>
<li><p><strong>这个迭代实现的性能</strong>：</p>
<ul>
<li>流量=8/3，或2.7bit/时钟</li>
<li>时滞=3时钟</li>
<li>时序=关键路径中一个乘法器延时</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>流水线版本实现x三次方</strong>（没有考虑输出范围）：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] x,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] XPower</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] xpower1,xpower2;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] x1,x2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 1</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        x1 &lt;= x;</span><br><span class="line">        xpower1 &lt;= x;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 2</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        x2 &lt;= x1;</span><br><span class="line">        xpower2 &lt;= x1 * xpower1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipepline 3</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        XPower &lt;= x2 * xpower2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图：</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106134636610.png" alt="image-20231106134636610"></p>
</li>
<li><p>其实实现x的三次方计算，就是要进行两次乘法，于是用三层寄存器将两个乘法器隔开，这样每个乘法器都可以独立干自己的事情，而不受其他级的影响（这里我觉得第一级的寄存器可以不加，只是单纯的进行了一个赋值操作）</p>
</li>
<li><p>$x^3$的最后计算和$x$下一数值的第一次计算二者同时进行</p>
</li>
<li><strong>这个流水线设计的性能</strong>：<ul>
<li>流量=8/1 或8位/时钟</li>
<li>时滞=3个时钟</li>
<li>时序=关键路径中的一个乘法器延时</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>通常，如果要求将n次迭代环路的算法拆开后，流水线实现将呈现n倍的流量性能增加，拆开一个迭代环路的代价是成比例地增加面积</strong></p>
</li>
</ul>
<hr>
<h1 id="低时滞"><a href="#低时滞" class="headerlink" title="低时滞"></a>低时滞</h1><ul>
<li><p><strong>低时滞设计是通过最小化中间处理的延时来尽可能快速地把数据从输入端传递到输出端的设计</strong></p>
</li>
<li><p>去除流水线寄存器可以使输入到输出时序最小化</p>
</li>
<li><p>x三次方算法低时滞实现</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipepline_design(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] x,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] XPower    </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] xpower1,xpower2;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] x1,x2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 1</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        x1 &lt;= x;</span><br><span class="line">        xpower1 &lt;= x;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 2</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        x2 &lt;= x1;</span><br><span class="line">        xpower2 &lt;= x1 * xpower1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipepline 3</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        XPower &lt;= x2 * xpower2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106142501144.png" alt="image-20231106142501144" style="zoom: 50%;"></p>
</li>
<li><p>在上面的例子中，寄存器从流水线中分离出去，每一级都是前级的组合表达式</p>
</li>
<li><p><strong>这个低时滞实现的性能为</strong>：</p>
<ul>
<li>流量=8位/时钟（假设每个时钟一个新的输入）</li>
<li>时滞=在1和2个乘法器延时之间</li>
<li>时序=关键路径中2个乘法器延时</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可以通过移去流水线寄存器来减少时滞，但这一操作会增加寄存器之间的组合延时</strong></p>
</li>
</ul>
<hr>
<h1 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h1><ul>
<li><p><strong>时序指的是一个设计的时钟速度，在设计中任何两个时序元件之间的最大延时将决定最大的时钟速度</strong></p>
</li>
<li><p>最高速度或最大频率可以直接按照著名的最大频率方程定义：</p>
<script type="math/tex; mode=display">
F_{max}=\frac{1}{T_{clk-q}+T_{logic}+T_{routing}+T_{setup}-T_{skew}}</script><ul>
<li>$T_{clk-q}$是从时钟到达直至数据到达$Q$端的时间，$T_{logic}$是逻辑通过触发器之间的传播延时，$T_{routing}$是触发器之间的布线延时，$T_{setup}$是下一个时钟上升沿之前数据必须到达$D$端的最小时间（建立时间），$T_{skew}$是启动触发器和捕捉触发器之间时钟的传播延时</li>
</ul>
</li>
</ul>
<h2 id="1-添加寄存器层次"><a href="#1-添加寄存器层次" class="headerlink" title="1.添加寄存器层次"></a>1.添加寄存器层次</h2><ul>
<li><p><strong>该策略是添加中间的寄存器层次到关键路径，这个技术应该利用在高速流水线的设计</strong></p>
</li>
<li><p>其核心思想是：<strong>把关键路径分成两个更小延时的路径，添加寄存器层次改进时序</strong></p>
</li>
<li><p>假设以下有限脉冲响应（FIR）实现的结构不满足时序要求：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> validsample,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] A, B, C, X,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] Y</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] X1,X2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(validsample) <span class="keyword">begin</span></span><br><span class="line">            X1 &lt;= X;</span><br><span class="line">            X2 &lt;= X1;</span><br><span class="line">            Y &lt;= A * X + B * X1 + C * X2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106145041086.png" alt="image-20231106145041086"></p>
</li>
<li><p>所有乘/加操作发生在一个时钟周期，换而言之，<strong>一个乘法器和一个加法器组成的关键路径比最小时钟周期的要求大</strong></p>
</li>
</ul>
</li>
<li><p><strong>在乘法器和加法器之间添加一个流水线层次</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> validsample,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] A, B, C, X,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] Y</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] X1,X2;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] mul1, mul2, mul3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(validsample) <span class="keyword">begin</span></span><br><span class="line">            X1 &lt;= X;</span><br><span class="line">            X2 &lt;= X1;</span><br><span class="line">            mul1 &lt;= A * X;</span><br><span class="line">            mul2 &lt;= B * X1;</span><br><span class="line">            mul3 &lt;= C * X2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        Y &lt;= mul1 + mul2 + mul3;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106150022630.png" alt="image-20231106150022630"></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-并行结构"><a href="#2-并行结构" class="headerlink" title="2.并行结构"></a>2.并行结构</h2><ul>
<li><p><strong>该策略是重新组织关键路径</strong>，以致并行地实现逻辑结构。当通过一列串联的逻辑计算函数可以分解和并行时，就应该利用该技术</p>
</li>
<li><p>其核心思想是：<strong>把一个逻辑功能分为大量可以并行计算的更小的功能，减少路径延时为子结构的最小延时</strong></p>
</li>
<li><p>假设在高流量一节设计的三级流水线不满足时序的要求，位了产生并行结构，可以将乘法器分解成独立的操作，重新组合它们。例如，一个8位的二进制乘法器可以用字段A和B表示：</p>
<script type="math/tex; mode=display">
X=\{A,B\}</script><ul>
<li><p>其中$A$是最高有效位字段，$B$是最低有效位字段</p>
</li>
<li><p>因为在3次幂的例子中被乘数等于乘数，乘数操作可以重新组织如下：</p>
<script type="math/tex; mode=display">
X\times X=\{A,B\}\times \{A,B\} = \{(A\times A),(2\times A \times B),(B\times B)\}</script></li>
<li><p>这样就把问题简化为一个串行的4位乘法器，然后重新组合乘积</p>
</li>
</ul>
</li>
<li><p>可以用以下模块实现：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] x,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] XPower</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] xpower1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] xpower2;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] xpower2_ppAA, xpower2_ppAB, xpower2_ppBB;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] xpower3_ppAA, xpower3_ppAB, xpower3_ppBB;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] x1,x2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] xpower1_A = xpower1[<span class="number">7</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] xpower1_B = xpower1[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] x1_A = x1[<span class="number">7</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] x1_B = x1[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] xpower2_A = xpower2[<span class="number">7</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] xpower2_B = xpower2[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] x2_A = x2[<span class="number">7</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] x2_B = x2[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 1</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        x1 &lt;= x;</span><br><span class="line">        xpower1 &lt;= x;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 2</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        x2 &lt;= x1;</span><br><span class="line">        xpower2_ppAA &lt;= xpower1_A * x1_A;</span><br><span class="line">        xpower2_ppAB &lt;= xpower1_A * x1_B;</span><br><span class="line">        xpower2_ppBB &lt;= xpower1_B * x1_B;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipepline 3</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        xpower3_ppAA &lt;= xpower2_A * x2_A;</span><br><span class="line">        xpower3_ppAB &lt;= xpower2_A * x2_B;</span><br><span class="line">        xpower3_ppBB &lt;= xpower2_B * x2_B;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> xpower2 = (xpower2_ppAA &lt;&lt; <span class="number">8</span>) + (<span class="number">2</span> * xpower2_ppAB &lt;&lt; <span class="number">4</span>) + xpower2_ppBB;</span><br><span class="line">    <span class="keyword">assign</span> XPower = (xpower3_ppAA &lt;&lt; <span class="number">8</span>) + (<span class="number">2</span> * xpower3_ppAB &lt;&lt; <span class="number">4</span>) + xpower3_ppBB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL的部分原理图</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106153453752.png" alt="image-20231106153453752"></p>
</li>
<li><p>这个设计没有考虑任何溢出的问题，只是用来说明要点，<strong>乘法器可以拆分成能够独立操作的更小的功能</strong></p>
</li>
<li><p><strong>通过把乘法器拆成可以并行执行的更小的操作，最大的延时可以减小到通过任何子结构的最长延时</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="3-展开逻辑结构"><a href="#3-展开逻辑结构" class="headerlink" title="3.展开逻辑结构"></a>3.展开逻辑结构</h2><ul>
<li><p>该策略的核心是：<strong>去除不需要的特权编码（我的理解是写verilog时没有必要的优先级结构），展平逻辑结构，减少路径延时</strong></p>
</li>
<li><p>考虑下面地址译码器，其用于写入4个寄存器的控制信号：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,in,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] ctrl,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] rout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(ctrl[<span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">            rout[<span class="number">0</span>] = in;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctrl[<span class="number">1</span>]) <span class="keyword">begin</span></span><br><span class="line">            rout[<span class="number">1</span>] = in;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctrl[<span class="number">2</span>]) <span class="keyword">begin</span></span><br><span class="line">            rout[<span class="number">2</span>] = in;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ctrl[<span class="number">3</span>]) <span class="keyword">begin</span></span><br><span class="line">            rout[<span class="number">3</span>] = in;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图：</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/Snipaste_2023-11-06_15-50-24.png" alt="Snipaste_2023-11-06_15-50-24"></p>
</li>
<li><p>如果控制线是来自另一个模块地址译码器的选通，那么每个选通对于其他的选通是相互排斥的，因为它们都代表唯一的地址，所以这个模块中就不需要带有优先级的方式（用一堆if else判断，这会增加电路的延时）去编写代码</p>
</li>
</ul>
</li>
<li><p>为了去除此特权，展平此逻辑，可以按照如下方式给这个模块编码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,in,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] ctrl,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] rout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(ctrl[<span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">            rout[<span class="number">0</span>] = in;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">if</span> (ctrl[<span class="number">1</span>]) <span class="keyword">begin</span></span><br><span class="line">            rout[<span class="number">1</span>] = in;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (ctrl[<span class="number">2</span>]) <span class="keyword">begin</span></span><br><span class="line">            rout[<span class="number">2</span>] = in;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (ctrl[<span class="number">3</span>]) <span class="keyword">begin</span></span><br><span class="line">            rout[<span class="number">3</span>] = in;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106155920793.png" alt="image-20231106155920793" style="zoom: 33%;"></p>
</li>
</ul>
</li>
<li><p>（20240604）附：<strong>第一次知道原来一个always中多个if并行，编译器不会编译成多个mux并行（针对在多个if中对同一个变量赋值的情况），还是级联的mux，最后一个if的优先级最高（越靠近输出）</strong></p>
</li>
<li><p>可参考：<a href="https://blog.csdn.net/weixin_39520719/article/details/107809003">Verilog中单if语句、多if语句和case语句与优先级的关系_verilog if else if 执行顺序-CSDN博客</a></p>
</li>
<li><p>我当时是测试了这样一段代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>      </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">1</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">2</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">3</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">4</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>      </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">5</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">6</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">if</span>(cfar_flag[<span class="number">7</span>]) <span class="keyword">begin</span></span><br><span class="line">            object &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span>     </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>综合结果：（圈起来的优先级最高cfar_flag[7]）</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20240604111607659.png" alt="image-20240604111607659"></p>
</li>
<li><p>如果把if放在不同always中，那么就会综合出并行的效果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">genvar</span> i;</span><br><span class="line"><span class="keyword">generate</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cfar_flag[i]) <span class="keyword">begin</span></span><br><span class="line">                object &lt;= <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="keyword">end</span>        </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>综合结果：</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20240604114309065.png" alt="image-20240604114309065" style="zoom:80%;"></p>
</li>
</ul>
<h2 id="4-寄存器平衡"><a href="#4-寄存器平衡" class="headerlink" title="4.寄存器平衡"></a>4.寄存器平衡</h2><ul>
<li><p><strong>该策略是平等地重新分布寄存器之间的逻辑，减少任何两个寄存器之间最坏条件的延时</strong>（我的理解是有的两个寄存器之间的组合延时很长，有的很短，所以需要均分一下）</p>
</li>
<li><p>其核心是：<strong>从关键路径移动组合逻辑到相邻路径，寄存器平衡改善时序</strong></p>
</li>
<li><p>对于以下代码描述的3个8位输入的加法器</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] A, B, C,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] sum</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] rA, rB, rC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 1</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        rA &lt;= A;</span><br><span class="line">        rB &lt;= B;</span><br><span class="line">        rC &lt;= C;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 2</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        sum &lt;= rA + rB + rC;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图：</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106160745777.png" alt="image-20231106160745777" style="zoom:50%;"></p>
</li>
<li><p>第一个寄存器级是由$rA,rB,rC$组成的，第二级由$sum$组成级1和级2之间的逻辑是全部输入的加法器，但是<strong>输入与第一个寄存器之间不包含逻辑</strong></p>
</li>
</ul>
</li>
<li><p>如果通过加法器定义关键路径，在关键路径中的一些逻辑可以移回到第一级，以平衡在两个寄存器级之间的逻辑负载，做出以下修改：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] A, B, C,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] sum</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] rABsum, rC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 1</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        rABsum &lt;= A + B;</span><br><span class="line">        rC &lt;= C;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pipeline 2</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        sum &lt;= rABsum + rC;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图：</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106161856368.png" alt="image-20231106161856368" style="zoom:50%;"></p>
</li>
<li><p><strong>现在输入与第一个寄存器之间移回一个加法操作，这样平衡流水线级之间的逻辑，缩短了关键路径</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="5-重新安排路径"><a href="#5-重新安排路径" class="headerlink" title="5.重新安排路径"></a>5.重新安排路径</h2><ul>
<li><p><strong>该策略是在数据流中重新安排路径使关键路径最小化</strong>。当多个路径与关键路径组合时应该利用该技术</p>
</li>
<li><p>考虑以下的模块：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] A, B, C,</span><br><span class="line">    <span class="keyword">input</span> Cond1, Cond2,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] Out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(Cond1) <span class="keyword">begin</span></span><br><span class="line">            Out &lt;= A;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Cond2 &amp;&amp; (C &lt; <span class="number">8</span>)) <span class="keyword">begin</span></span><br><span class="line">            Out &lt;= B;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            Out &lt;= C;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图：</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106204049377.png" alt="image-20231106204049377" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>重新组织代码后：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pipeline_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] A, B, C,</span><br><span class="line">    <span class="keyword">input</span> Cond1, Cond2,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] Out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> CondB;</span><br><span class="line">    <span class="keyword">assign</span> CondB = (Cond2 &amp; !Cond1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(CondB &amp;&amp; (C &lt; <span class="number">8</span>)) <span class="keyword">begin</span></span><br><span class="line">            Out &lt;= B;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Cond1) <span class="keyword">begin</span></span><br><span class="line">            Out &lt;= A;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            Out &lt;= C;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>RTL原理图：</p>
<p><img src="/2023/11/06/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%AB%98%E9%80%9F%E5%BA%A6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20231106205103930.png" alt="image-20231106205103930"></p>
</li>
<li><p>由于重新组织代码，已经从与MUX串联的关键路径移去一个门</p>
</li>
</ul>
</li>
<li><p><strong>因此要特别注意，实际的函数是如何编码的，这对时序性能有直接的影响</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理之FFT终极理解</title>
    <url>/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>本节从离散傅里叶变换的深入理解说起，介绍了FFT的基本原理，其中包括基2、基4的按时间抽选FFT算法和按频率抽取FFT算法</p>
<span id="more"></span>
<h1 id="从DFT说起"><a href="#从DFT说起" class="headerlink" title="从DFT说起"></a>从DFT说起</h1><ul>
<li><p>DFT的基本公式：</p>
<script type="math/tex; mode=display">
X(k)=\sum_{n=0}^{N-1}x(n)W_N^{nk},k=0,1,...,N-1</script><script type="math/tex; mode=display">
W_N^{nk}=e^{-j\frac{2\pi}{N}nk}</script></li>
<li><p>看这个公式里面有个$\frac{2\pi}{N}$，有没有觉得很熟悉，哦没错，它其实就是数字角频率$w_0$（这个在我的其他笔记中有提到<a href="https://ssy1938010014.github.io/2023/03/03/信号处理中的小知识点/">信号处理中的小知识点 | ssy的小天地 (ssy1938010014.github.io)</a>）</p>
<ul>
<li><p>那么该如何理解它呢？正如在之前笔记中提到的，它代表在复数平面内每个点转过的角度</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231103170339511.png" alt="image-20231103170339511" style="zoom:50%;"></p>
</li>
<li><p>图中标出的$\theta$，其实就是数字角频率$w_0$，在对一个正弦波抽样后，得到的点，其实就没有时间的概念了，只是我们自己心里清楚，点与点之间的时间间隔是$T_s$（采样间隔）</p>
</li>
<li><p>那么如何数字角频率和实际模拟信号的角频率是如何对应的呢？即在之前笔记中提到的：$\Omega_0=w_0f_s$，那对于频域来说，旋转因子中的角频率不能只有$w_0$，不然就只能测出$w_0$对应模拟信号的频率，类似DTFT的基频和倍频，这里我们也多取一些角频率$w_0,2w_0,3w_0,…(N-1)w_0$，也就是$kw_0,k=0,1,…,N-1$。理想情况下，如果在频域$kw_0$有个冲击，那么就说明对应时域信号中含有角频率为$kw_0f_s=k\frac{2\pi}{N}f_s=2\pi\cdot \frac{kf_s}{N}$的正弦信号，即频率为$k\frac{f_s}{N}$的正弦信号（其实，这也从公式本质的切入点上，解释了数字k域与实际时域频率的对应关系）</p>
</li>
<li><p>上述一大段的解释可能也有误，但是我自己最极限的理解了，如果不理解也没关系，我觉得这里只需要记住：<strong>以角频率$w_0$每隔$T_s$时间在复数域内转动的N点（其在实轴上的投影就是$cos(\frac{2\pi}{N}n)$，其本身就是复数$e^{j\frac{2\pi}{N}n}$），在经过DFT之后，可以得到这个N点数字域对应模拟域的实际频率$f_0$，且$f_0=k\cdot \frac{f_s}{N}$</strong></p>
</li>
</ul>
</li>
<li><p>下面重点解释为啥$x(n)$与$e^{-j\frac{2\pi}{N}nk}$这么个玩意相乘，就能挑选出对应频率（这些解释都偏个人的感性解释，也不一定完全正确）</p>
<ul>
<li><p>首先，假设$x(n)=cos(\frac{2\pi}{N}n)$，$x(k)$就等于$k$确定情况下，$n=0\sim N-1$个$x(n)$对应的点与旋转因子中$e^{-j\frac{2\pi}{N}n},n=0\sim N-1$对应元素相乘（例如$x(0)\times e^{-j\frac{2\pi}{N}\cdot 0\cdot k},x(1)\times e^{-j\frac{2\pi}{N}\cdot 1\cdot k},x(2)\times e^{-j\frac{2\pi}{N}\cdot 2\cdot k},…$）。简单来说，这一步骤就是：<strong>在$k$（也就是某一频率）下，求信号对这一频率幅频特性曲线的贡献（这么说可能不太规范，通俗来讲，就是如果信号中含有这个频率，那么它的幅频特性曲线中，这个频率对应的幅度就会格外高，也就是说这一步就是在求这个幅度到底有多高）</strong></p>
</li>
<li><p>此时，你会发现，有个离谱的事情发生了$x(n)$是个$cos$，$e^{j\frac{2\pi}{N}n}$是个复数，这咋乘，就现在，我发现了欧拉的伟大，应用欧拉公式，有：</p>
<script type="math/tex; mode=display">
cos(\frac{2\pi}{N}n)=\frac{e^{j\frac{2\pi}{N}n}+e^{-j\frac{2\pi}{N}n}}{2}</script></li>
<li><p>现在是不是cos就能和复数相乘了，为了便于解释，假设$N=8$，那么$e^{j\frac{2\pi}{N}n}$在复平面上的8个点（图1）为：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/Snipaste_2023-11-04_02-41-55.png" alt="Snipaste_2023-11-04_02-41-55" style="zoom:50%;"></p>
</li>
<li><p>$e^{-j\frac{2\pi}{N}n}$在复平面上的8个点（图2）为：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/Snipaste_2023-11-04_02-43-08.png" alt="Snipaste_2023-11-04_02-43-08" style="zoom:50%;"></p>
</li>
<li><p>当$k=1$时，$W_N^{n}=e^{-j\frac{2\pi}{N}n}$，其在复平面上的8个点（图3）为：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/Snipaste_2023-11-04_02-43-08-1699037281630-3.png" alt="Snipaste_2023-11-04_02-43-08" style="zoom:50%;"></p>
<ul>
<li><p>图1中8个复数乘以图3中对应的复数（例如图1中n=1的复数乘以图3中n=1中的复数，图1中n=2的复数乘以图3中n=2中的复数），显然，每个点对点的相乘，其均是模值相乘，由于角度相反，那么相乘后相位为0，最终这8个点对点相乘求和的结果就是8，可视化示意图如下：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104030201498.png" alt="image-20231104030201498" style="zoom:50%;"></p>
</li>
<li><p>同样，图2中8个复数乘以图3中对应的复数，每个点对点结果是模值相乘，旋转角变为原来两倍，对结果求和后，最终为0</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104031359017.png" alt="image-20231104031359017" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>其实，$W_N^{nk}=e^{-j\frac{2\pi}{N}nk}$就是将复平面均匀分成8份，由$nk$决定，具体对应是八份中的哪一份，当$k=2$时，$nk$为$0,2,4,6,8,10,12,14$，由于8个点就转了一圈，即周期时8，那么$nk$实际对应的是$0,2,4,6,0,2,4,6$，其可视化示意如下（图4）：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104153953253.png" alt="image-20231104153953253" style="zoom:50%;"></p>
<ul>
<li>将图1与图4中n相同的点对应相乘，根据模值相乘，角度相加的原则，最终矢量相加的结果为0，图2乘以图4的结果也为0</li>
</ul>
</li>
<li><p>同理，当$k=3,4,5,6$时（$k=7$的情况后面会解释，存在对称性），图1乘以图4，图2乘以图4的结果均为0（这里没有严格上的数学推导，但我觉得对于理解FFT，自己带数进去算一遍更能理解）</p>
</li>
<li><p>总之，最后我们会发现：只有$e^{j\frac{2\pi}{N}n}$乘以$W_N^{nk}(k=1)$有值，其值为$e^{j\frac{2\pi}{N}n}$每个点的模值（这里都假设为1了）与$W_N^{nk}$对应点的模值（显然$W_N^{nk}$的模都是1）相乘后再求和（还要除以2，因为欧拉公式后$e^{j\frac{2\pi}{N}n}$前的系数为$\frac12$），其实，$e^{j\frac{2\pi}{N}n}$每个点的模值都一样，你想，$cos(\frac{2\pi}{N}n)$和$5cos(\frac{2\pi}{N}n)$用欧拉公式展开之后，不就是$e^{j\frac{2\pi}{N}n}$和$5e^{j\frac{2\pi}{N}n}$的区别么，那么实际上每个点的模值都是一样的，即$(1,1,1,1,1,1,1,1)$和$(5,5,5,5,5,5,5,5)$，那么<strong>实际上$cos(\frac{2\pi}{N}n)$乘以$W_N^{nk}$就是$\frac{A\times N}{2}$（其中$A$为正弦信号的幅度，$N$为采样的点数）</strong>，这个峰值会出现在$k=1$的位置（这里的解释都先不讨论$k=7$的情况）</p>
</li>
<li><p>哦对了，其实这里也很好的解释了<strong>采样点数$N$加倍，DFT结果幅值也会加倍</strong></p>
</li>
<li><p>有个细节是，当$k=0$时，很容易得到$cos(\frac{2\pi}{N}n)$乘以$W_N^{nk}$是16（因为不管是$e^{j\frac{2\pi}{N}n}$还是$e^{-j\frac{2\pi}{N}n}$都是一堆111去乘以$W_N^{nk}$的一堆1嘛），所以这也解释了<strong>零频对应的峰值是其他频率峰值的两倍</strong></p>
</li>
</ul>
</li>
<li><p>下面解释DFT的共轭对称性，即$X(k)=X^*(N-k)$</p>
<ul>
<li><p>那么我们来讨论$k=7$的情况，$W_N^{7n}=e^{-j\frac{2\pi}{N}n\cdot7}$，其在复平面上的8个点（图5）为：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104163326522.png" alt="image-20231104163326522" style="zoom:50%;"></p>
</li>
<li><p>不难发现，$k=7$时的情况刚好和$k=1$的情况是反过来的，<strong>此时是$e^{-j\frac{2\pi}{N}n}$乘以$W_N^{nk}$有值（且也为$\frac{A\times N}{2}$），$e^{j\frac{2\pi}{N}n}$乘以$W_N^{nk}$为0，所以频谱中还会在$k=7$时再出现一个峰值</strong></p>
</li>
<li><p>同时也解释了为什么复数信号的DFT是单边谱，<strong>因为复数信号只有$e^{j\frac{2\pi}{N}n}$部分，只存在$e^{j\frac{2\pi}{N}n}$乘以$W_N^{nk}$的结果，故复数信号只有单边谱（换句话来说，实数信号的双边谱多余的那边是$e^{-j\frac{2\pi}{N}n}$造成的）</strong></p>
</li>
<li><p>笑了，上面解释一大堆，其实就是用了<strong>旋转因子的对称性</strong>：$(W_N^{nk})^*=W_N^{-nk}=W_N^{(N-n)k}$</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="按时间抽选FFT算法"><a href="#按时间抽选FFT算法" class="headerlink" title="按时间抽选FFT算法"></a>按时间抽选FFT算法</h1><h2 id="1-基2-FFT算法"><a href="#1-基2-FFT算法" class="headerlink" title="1.基2-FFT算法"></a>1.基2-FFT算法</h2><ul>
<li><p>设序列$x(n)$点数为$N=2^L$，$L$为正整数</p>
</li>
<li><p>将序列$x(n)$<strong>按$n$的奇偶分为</strong>以下两组：</p>
<script type="math/tex; mode=display">
偶序列:x(2r)=x_1(r),r=0,1,...,\frac N2-1</script><script type="math/tex; mode=display">
奇序列:x(2r+1)=x_2(r),r=0,1,...,\frac N2-1</script></li>
<li><p>则其$N$点FFT为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X(k) &= \sum_{n=0}^{N-1}x(n)W_N^{nk}\\
&=\sum_{n=0}^{\frac N2-1}x(2r)W_N^{2rk}+\sum_{n=0}^{\frac N2-1}x(2r+1)W_N^{(2r+1)k}\\
&=\sum_{n=0}^{\frac N2-1}x_1(r)W_N^{2rk}+\sum_{n=0}^{\frac N2-1}x_2(r)W_N^{(2r+1)k}\\
&=\sum_{n=0}^{\frac N2-1}x_1(r)W_{\frac N2}^{rk}+W_N^k\sum_{n=0}^{\frac N2-1}x_2(r)W_{\frac N2}^{2rk}\\
&= X_1(k)+W_N^kX_2(k)
\end{aligned}</script><ul>
<li>其中有用到旋转因子的约分性$W_N^m=W_{\frac N2}^{\frac m2}$</li>
<li><strong>且$X_1(k)$和$X_2(k)$分别是$x_1(r)$和$x_2(r)$的$\frac N2$点DFT</strong></li>
</ul>
</li>
<li><p>对于$X(k+\frac N2)$，有：</p>
<script type="math/tex; mode=display">
X(k+\frac N2) = X_1(k+\frac N2)+W_N^{k+\frac N2}X_2(k+\frac N2)\\</script><ul>
<li><p>我们知道，频谱也是有周期的，以N（参与傅里叶变换的点数）个点为周期，对于DFT只是取了最中心的一个周期，而$X_1(k)$和$X_2(k)$都是$\frac N2$点DFT，故：</p>
<script type="math/tex; mode=display">
X_1(k)=X_1(k+\frac N2)</script><script type="math/tex; mode=display">
X_2(k)=X_2(k+\frac N2)</script></li>
<li><p>根据旋转因子的性质有：</p>
<script type="math/tex; mode=display">
W_N^{(k+\frac N2)}=W_N^k\cdot W_N^{\frac N2}=-W_N^k</script><ul>
<li>因为$W_N^{\frac N2}=-1$</li>
</ul>
</li>
<li><p>所以，最终$X(k+\frac N2)$的结果为：</p>
<script type="math/tex; mode=display">
X(k+\frac N2) = X_1(k)-W_N^kX_2(k)</script></li>
</ul>
</li>
<li><p><strong>整理上述推导，可以得到：</strong></p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
X(k) &= X_1(k)+W_N^kX_2(k)\\
X(k+\frac N2) &= X_1(k)-W_N^kX_2(k)
\end{aligned}
\end{cases},k=0,1,...,\frac N2-1</script><ul>
<li>这个式子画成信号流图就是一个蝶形变换，每求一个点的频谱，都需要知道对应偶序列的一个点和奇序列的一个点</li>
</ul>
</li>
<li><p>根据上式可知，只要能求出$k=0,1,…,\frac N2-1$对应的频谱，就可以同时得到$k=\frac N2,\frac N2+1,\frac N2+2,…,N-1$的频谱</p>
<ul>
<li><p>那么，如何得到频谱中前一半的值呢？根据公式，只需要能求出$X_1(k)$和$X_2(k)$就搞定了，而$X_1(k)$和$X_2(k)$是偶序列和奇序列的傅里叶变换，貌似也求不出来，那么就继续分解$X_1(k)$和$X_2(k)$</p>
</li>
<li><p>将$X_1(k)$对应的序列又分为偶序列和奇序列，$X_2(k)$对应的序列又分为偶序列和奇序列</p>
</li>
<li><p>一直这么分解下去，直到时域上只有两个点，2点DFT（这也称为蝶形变换）我们还是很容易得到的，即：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104184905802.png" alt="image-20231104184905802" style="zoom:80%;"></p>
<script type="math/tex; mode=display">
X(0)=x(0)+x(1)</script><script type="math/tex; mode=display">
X(1)=x(0)-x(1)</script></li>
<li><p>得到这两个点的DFT，我们就得到了4个点偶序列和奇序列的DFT，进而可以求出4个点的DFT，以此类推，从而可以求出更高点数的DFT</p>
</li>
<li><p>也就是说，我们对时域序列进行偶序列和奇序列分类，再对这个偶序列进行偶序列和奇序列分类，对这个奇序列进行偶序列和奇序列分类，分到最后时域上的序列两两一组，然后依次往下求蝶形变换，就可以得到最终N个序列的DFT结果，举一个8点FFT的例子，先画一个时域上两两分组的示意图：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104191548459.png" alt="image-20231104191548459" style="zoom:50%;"></p>
</li>
<li><p>一个标准的8点基2-FFT流图如下：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104191810967.png" alt="image-20231104191810967"></p>
</li>
</ul>
</li>
<li><p>所以简单概括来说，<strong>基2-FFT算法是，计算一个N点DFT时，先需要计算两个$\frac N2$点DFT，然后对每个$\frac N2$点DFT，继续往下划分，还需要计算2个$\frac N4$点DFT（总共这一层就有4个$\frac N4$点DFT结果），直至最后分解到$\frac N{2^k}$（$k$表示第k次分解）=2时（容易通过这个等式得到$k=log_2^{\frac N2}$），我们就能迅速计算出第$k$次分解后$2^k$个2点DFT的结果（这里单纯用数学归纳法都能计算出第$k$次分解后需要计算的DFT个数为$2^k$），之后我们就可以反推回去，得到$N$点DFT的结果</strong></p>
</li>
<li><strong>N点基2-FFT的计算量</strong>：<ul>
<li>蝶形级数：$M=log_2^N$</li>
<li>每级的蝶形数量：$\frac N2$</li>
<li>每个蝶形的计算量：<ul>
<li>加法2次</li>
<li>乘法1次</li>
</ul>
</li>
<li>总共的计算量：<ul>
<li>加法：$Nlog_2^N$</li>
<li>乘法：$\frac N2 log_2^N$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-基4-FFT算法"><a href="#2-基4-FFT算法" class="headerlink" title="2.基4-FFT算法"></a>2.基4-FFT算法</h2><ul>
<li><p>设序列$x(n)$点数为$N=4^L$，$L$为正整数</p>
</li>
<li><p>将$N=4^L$分为以下4组：</p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
x(4r) &= x_1(r)\\
x(4r+1) &= x_1(r)\\
x(4r+2) &= x_1(r)\\
x(4r+3) &= x_1(r)
\end{aligned}
\end{cases},r=0,1,...,\frac N4 -1</script></li>
<li><p>则其$N$点DFT为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X(k)&=\sum_{n=0}^{N-1}x(n)W_N^{nk}\\
&= \sum_{r=0}^{\frac N4-1}x(4r)W_N^{4rk}+\sum_{r=0}^{\frac N4-1}x(4r+1)W_N^{(4r+1)k}+\sum_{r=0}^{\frac N4-1}x(4r+2)W_N^{(4r+2)k}+\sum_{r=0}^{\frac N4-1}x(4r+3)W_N^{(4r+3)k}\\
&= \sum_{r=0}^{\frac N4-1}x_1(r)W_{\frac N4}^{rk}+W_N^k\sum_{r=0}^{\frac N4-1}x_2(r)W_{\frac N4}^{rk}+W_N^{2k}\sum_{r=0}^{\frac N4-1}x_3(r)W_{\frac N4}^{rk}+W_{\frac N4}^{3k}\sum_{r=0}^{\frac N4-1}x_4(r)W_{\frac N4}^{rk}\\
&= X_1(k)+W_N^kX_2(k)+W_N^{2k}X_3(k)+W_N^{3k}X_4(k)
\end{aligned}</script><ul>
<li>其中$X_1(k),X_2(k),X_3(k),X_4(k)$分别是$x_1(r),x_2(r),x_3(r),x_4(r)$的$\frac N4$点DFT</li>
</ul>
</li>
<li><p>由于$W_N^k$有以下性质：</p>
<script type="math/tex; mode=display">
W_N^{(k+\frac N4)}=W_N^{\frac N4}W_N^k=-jW_N^k</script><script type="math/tex; mode=display">
W_N^{(k+\frac N2)}=W_N^{\frac N2}W_N^k=-W_N^k</script><script type="math/tex; mode=display">
W_N^{(k+\frac {3N}4)}=W_N^{\frac {3N}4}W_N^k= jW_N^k</script></li>
<li><p>故有：</p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
X(k) &= X_1(k)+W_N^kX_2(k)+W_N^{2k}X_3(k)+W_N^{3k}X_4(k)\\
X(k+\frac N4) &= X_1(k)-jW_N^kX_2(k)-W_N^{2k}X_3(k)+jW_N^{3k}X_4(k)\\
X(k+\frac N2) &= X_1(k)-W_N^kX_2(k)+W_N^{2k}X_3(k)-W_N^{3k}X_4(k)\\
X(k+\frac {3k}{4}) &= X_1(k)+jW_N^kX_2(k)-W_N^{2k}X_3(k)-jW_N^{3k}X_4(k)
\end{aligned}
\end{cases},k=0,1,...,\frac N4 -1</script></li>
<li><p>与之基2类似，计算一个N点DFT时，先需要计算4个$\frac N4$点DFT，然后对每个$\frac N4$点DFT，继续往下划分，还需要计算4个$\frac{N}{16}$点DFT（总共这一层就有16个$\frac N{16}$点DFT结果），直至最后分解到$\frac N{4^k}$=4时（容易通过这个等式得到$k=log_4^{\frac N4}$），我们就能比较容易计算出第$k$次分解后$4^k$个4点DFT的结果（这里单纯用数学归纳法都能计算出第$k$次分解后需要计算的DFT个数为$4^k$），之后我们就可以反推回去，得到$N$点DFT的结果（只是这里反推时乘以的旋转因子与基2时不太一样，<strong>这里的蝶形运算是以4个点为基本单位</strong>）。</p>
<ul>
<li>以16点FFT为例，其运算过程的可视化示意图如下：（如果是64点FFT，就把下面这个图看成一个整体，复制粘贴4份分析）</li>
</ul>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104205651274.png" alt="image-20231104205651274" style="zoom:50%;"></p>
<ul>
<li><p>图中第一层的4点DFT的算法和基2FF算法计算4点FFT一样</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104205958813.png" alt="image-20231104205958813" style="zoom: 67%;"></p>
</li>
<li><p>将两幅图合起来理解就是：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104210238454.png" alt="image-20231104210238454" style="zoom: 67%;"></p>
</li>
<li><p>一个标准的16点基4-FFT流程图如下：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231104210134227.png" alt="image-20231104210134227"></p>
</li>
</ul>
</li>
<li><p><strong>N点基4-FFT的计算量</strong>：</p>
<ul>
<li>蝶形级数：$M=log_4^N$</li>
<li>每级的蝶形数量：$\frac N4$</li>
<li><strong>每个蝶形运算有4点输入和4点输出，则：</strong><ul>
<li><strong>加法8次</strong></li>
<li><strong>乘法3次</strong></li>
</ul>
</li>
<li>总共的计算量：<ul>
<li>加法：$2Nlog_4^N$</li>
<li>乘法：$\frac {3N}4 log_4^N$</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="按频率抽选FFT算法"><a href="#按频率抽选FFT算法" class="headerlink" title="按频率抽选FFT算法"></a>按频率抽选FFT算法</h1><h2 id="1-基2-FFT算法-1"><a href="#1-基2-FFT算法-1" class="headerlink" title="1.基2-FFT算法"></a>1.基2-FFT算法</h2><ul>
<li><p>设序列$x(n)$点数为$N=2^L$，$L$为正整数</p>
</li>
<li><p>将序列<strong>按$n$的顺序分为前后两组</strong>，其$N$点DFT为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X(k)&=\sum_{n=0}^{N-1}x(n)W_N^{nk}\\
&=\sum_{n=0}^{\frac N2-1}x(n)W_N^{nk}+\sum_{n=\frac N2}^{N-1}x(n)W_N^{nk}\\
&= \sum_{n=0}^{\frac N2 -1}x(n)W_N^{nk}+\sum_{n=0}^{\frac N2-1}x(n+\frac N2)W_N^{(n+\frac N2)k}\\
&= \sum_{n=0}^{\frac N2-1}[x(n)+x(n+\frac N2)W_N^{\frac N2k}]W_N^{nk}\\
&= \sum_{n=0}^{\frac N2-1}[x(n)+(-1)^kx(n+\frac N2)]W_N^{nk}
\end{aligned}</script></li>
<li><p><strong>按$k$的奇偶可将$X(k)$分为两部分</strong>：</p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
k &= 2r\\
k &= 2r+1
\end{aligned}
\end{cases},k=0,1,...,\frac N2-1</script></li>
<li><p>则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X(2r)&=\sum_{n=0}^{\frac N2 -1}[x(n)+x(n+\frac N2)]W_N^{2nr}\\
&=\sum_{n=0}^{\frac N2 -1}[x(n)+x(n+\frac N2)]W_{\frac N2}^{nr}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
X(2r+1)&=\sum_{n=0}^{\frac N2 -1}[x(n)-x(n+\frac N2)]W_N^{n(2r+1)}\\
&=\sum_{n=0}^{\frac N2 -1}[x(n)-x(n+\frac N2)]W_N^nW_{\frac N2}^{nr}
\end{aligned}</script><ul>
<li>令：<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
x_1(n)&=x(n)+x(n+\frac N2)\\
x_2(n)&=[x(n)-x(n+\frac N2)]W_N^n
\end{aligned}
\end{cases},n=0,1,...,\frac N2-1</script></li>
</ul>
</li>
<li><p>则得到：</p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
X(2r)&=\sum_{n=0}^{\frac N2-1}x_1(n)W_{\frac N2}^{nr}\\
X(2r+1)&=\sum_{n=0}^{\frac N2-1}x_2(n)W_{\frac N2}^{nr}
\end{aligned}
\end{cases},r=0,1,...,\frac N2-1</script><ul>
<li>仔细观察$\sum_{n=0}^{\frac N2-1}x_1(n)W_{\frac N2}^{nr}$这玩意不就是$x_1(n)$的$\frac N2$的DFT么</li>
</ul>
</li>
<li><p><strong>简而言之，有：</strong></p>
<script type="math/tex; mode=display">
X(k)的偶序列:X(2r)=DFT[x_1(n)]</script><script type="math/tex; mode=display">
X(k)的奇序列:X(2r+1)=DFT[x_2(n)]</script></li>
<li><p>也就是$X(k)$的偶序列只跟$x_1(n)$（与时域序列对半分有关）的傅里叶变换有关，$X(k)$的奇序列只跟$x_2(n)$（与时域序列对半分有关）的傅里叶变换有关，那么问题的关键在于首先要知道$x_1(n)$和$x_2(n)$是啥，如果能将$x_1(n)$和$x_2(n)$继续往下分，使得最后只剩下两个点，那么做2点DFT就可以得到$X(k)$中2个点的DFT</p>
<ul>
<li>以8点FFT为例，整个运算过程的可视化示意图如下：</li>
</ul>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231105133359626.png" alt="image-20231105133359626" style="zoom:50%;"></p>
<ul>
<li><p>下面是一个按频率抽选运算的完整的8点FFT流图：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231105133621770.png" alt="image-20231105133621770" style="zoom:80%;"></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-基4-FFT算法-1"><a href="#2-基4-FFT算法-1" class="headerlink" title="2.基4-FFT算法"></a>2.基4-FFT算法</h2><ul>
<li><p>设序列$x(n)$点数为$N=4^L$，$L$为正整数</p>
</li>
<li><p>将<strong>序列$x(n)$按$n$的顺序分为前后4组</strong>，其N点DFT为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X(k)&=\sum_{n=0}^{N-1}x(n)W_N^{nk}+\sum_{n=0}^{\frac N4-1}x(n)W_N^{nk}+\sum_{n=\frac N2}^{\frac {3N}4-1}x(n)W_N^{nk}+\sum_{n=\frac {3N}4}^{N-1}x(n)W_N^{nk}\\
&=\sum_{n=0}^{\frac N4-1}x(n)W_N^{nk}+\sum_{n=0}^{\frac N4-1}x(n+\frac N4)W_N^{(n+\frac N4)k}+\sum_{n=0}^{\frac N4-1}x(n+\frac N2)W_N^{(n+\frac N2)k}+\sum_{n=0}^{\frac N4-1}x(n+\frac {3N}4)W_N^{(n+\frac {3N}4)k}\\
&=\sum_{n=0}^{\frac N4-1}[x(n)+x(n+\frac N4)W_N^{\frac N4 k}+x(n+\frac N2)W_N^{\frac N2k}+x(n+\frac {3N}4)W_N^{\frac{3N}4k}]W_N^{nk}\\
&=\sum_{n=0}^{\frac N4-1}[x(n)+(-j)^kx(n+\frac N4)+(-1)^kx(n+\frac N2)+j^kx(n+\frac {3N}4)]W_N^{nk}
\end{aligned}</script></li>
<li><p><strong>按$k$将$X(k)$分为4部分</strong>：</p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
k &= 4r\\
k &= 4r+1\\
k &= 4r+2\\
k &= 4r+3
\end{aligned}
\end{cases},r=0,1,...,\frac N4-1</script></li>
<li><p>则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X(4r)&=\sum_{n=0}^{\frac N4-1}[x(n)+x(n+\frac N4)+x(n+\frac N2)+x(n+\frac {3N}4)]W_N^{4nr}\\
&=\sum_{n=0}^{\frac N4-1}[x(n)+x(n+\frac N4)+x(n+\frac N2)+x(n+\frac {3N}4)]W_{\frac N4}^{nr}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
X(4r+1)&=\sum_{n=0}^{\frac N4-1}[x(n)-jx(n+\frac N4)-x(n+\frac N2)+x(n+\frac {3N}4)]W_N^{n(4r+1)}\\
&=\sum_{n=0}^{\frac N4-1}[x(n)-jx(n+\frac N4)-x(n+\frac N2)+x(n+\frac {3N}4)]W_N^nW_{\frac N4}^{nr}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
X(4r+2)&=\sum_{n=0}^{\frac N4-1}[x(n)-x(n+\frac N4)+x(n+\frac N2)-x(n+\frac {3N}4)]W_N^{n(4r+2)}\\
&=\sum_{n=0}^{\frac N4-1}[x(n)-x(n+\frac N4)+x(n+\frac N2)-x(n+\frac {3N}4)]W_N^{2n}W_{\frac N4}^{nr}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
X(4r+3)&=\sum_{n=0}^{\frac N4-1}[x(n)+jx(n+\frac N4)-x(n+\frac N2)-jx(n+\frac {3N}4)]W_N^{n(4r+3)}\\
&=\sum_{n=0}^{\frac N4-1}[x(n)+jx(n+\frac N4)-x(n+\frac N2)-jx(n+\frac {3N}4)]W_N^{3n}W_{\frac N4}^{nr}
\end{aligned}</script><ul>
<li>令：<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
x_1(n)&=x(n)+x(n+\frac N4)+x(n+\frac N2)+x(n+\frac {3N}4)\\
x_2(n)&=[x(n)-jx(n+\frac N4)-x(n+\frac N2)+x(n+\frac {3N}4)]W_N^n\\
x_3(n)&=[x(n)-x(n+\frac N4)+x(n+\frac N2)-x(n+\frac {3N}4)]W_N^{2n}\\
x_4(n)&=[x(n)+jx(n+\frac N4)-x(n+\frac N2)-jx(n+\frac {3N}4)]W_N^{3n}
\end{aligned}
\end{cases},n=0,1,...,\frac N4-1</script></li>
</ul>
</li>
<li><p>则得到：</p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
X(4r)&=\sum_{n=0}^{\frac N4 -1}x_1(n)W_{\frac N4}^{nr}\\
X(4r+1)&=\sum_{n=0}^{\frac N4 -1}x_2(n)W_{\frac N4}^{nr}\\
X(4r+2)&=\sum_{n=0}^{\frac N4 -1}x_3(n)W_{\frac N4}^{nr}\\
X(4r+3)&=\sum_{n=0}^{\frac N4 -1}x_4(n)W_{\frac N4}^{nr}
\end{aligned}
\end{cases},r=0,1,...,\frac N4-1</script></li>
<li><p>简而言之，有：</p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
X(4r)&=DFT[x_1(n)]\\
X(4r+1)&=DFT[x_2(n)]\\
X(4r+2)&=DFT[x_3(n)]\\
X(4r+3)&=DFT[x_4(n)]
\end{aligned}
\end{cases}</script></li>
<li><p><strong>这样我们就把一个N点DFT按$k$的抽取分解为了4个$\frac N4$点DFT</strong></p>
</li>
<li><p>下面是一个按频率抽选运算的16点FFT流图：</p>
<p><img src="/2023/11/03/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8BFFT%E7%BB%88%E6%9E%81%E7%90%86%E8%A7%A3/image-20231105141302313.png" alt="image-20231105141302313" style="zoom: 67%;"></p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1Hu411r7xR/?spm_id_from=333.788&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">快速傅里叶变换FFT_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.cnblogs.com/lanlancky/p/17102834.html">基2和基4FFT - luckylan - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/bleauchat/article/details/88031656">基2与基4时分FFT算法浅析及其比较_基4fft-CSDN博客</a></li>
<li><a href="https://www.bilibili.com/video/BV1E8411A7tK/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">FPGA数字信号处理之基2FFT的verilog实现_2_哔哩哔哩_bilibili</a>（可以参考这个视频中的代码理解，但我觉得他在进行蝶形运算时并没有进行并行处理）</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之加法器与乘法器的设计</title>
    <url>/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>本节主要介绍了常见的加法器与乘法器的加速设计方法</p>
<span id="more"></span>
<h1 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h1><h2 id="1-Ripple-Carry-Adder（串行逐个进位加法器）"><a href="#1-Ripple-Carry-Adder（串行逐个进位加法器）" class="headerlink" title="1.Ripple Carry Adder（串行逐个进位加法器）"></a>1.Ripple Carry Adder（串行逐个进位加法器）</h2><ul>
<li><p>Ripple Carry Adder就是串联加法器，前一个加法器的进位会连接到下一个加法器的进位输入</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031150011522.png" alt="image-20231031150011522" style="zoom: 67%;"></p>
</li>
<li><p>Ripple Carry Adder的关键路径延迟为：</p>
<script type="math/tex; mode=display">
T_{RCA}=(N-1)T_{FA}+T_m</script><ul>
<li>$T_{FA}$是全加器的延时，$T_{m}$是全加器进位产生的延迟</li>
</ul>
</li>
<li><p>ripple_carry_adder.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ripple_carry_adder #(<span class="keyword">parameter</span> W=<span class="number">16</span>) (</span><br><span class="line">    <span class="keyword">input</span> clk, </span><br><span class="line">    <span class="keyword">input</span> [W-<span class="number">1</span>:<span class="number">0</span>] a, b, </span><br><span class="line">    <span class="keyword">input</span> cin, </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] s_r, </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> cout_r</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [W-<span class="number">1</span>:<span class="number">0</span>] s; </span><br><span class="line">    <span class="keyword">wire</span> cout; </span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] a_r, b_r; </span><br><span class="line">    <span class="keyword">reg</span> cin_r; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> &#123;cout,s&#125; = a_r + b_r + cin_r; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        a_r&lt;=a; </span><br><span class="line">        b_r&lt;=b; </span><br><span class="line">        cin_r&lt;=cin; </span><br><span class="line">        s_r&lt;=s; </span><br><span class="line">        cout_r&lt;=cout;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>原理图如下：</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031150916675.png" alt="image-20231031150916675" style="zoom: 80%;"></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-Carry-Look-ahead-Adder（超前进位加法器）"><a href="#2-Carry-Look-ahead-Adder（超前进位加法器）" class="headerlink" title="2.Carry Look-ahead Adder（超前进位加法器）"></a>2.Carry Look-ahead Adder（超前进位加法器）</h2><ul>
<li><p>对于Ripple Carry Adder加法器，就4位加法器算法而言，在最坏情况下，做一次加法运算需要经过4个全加器的传输时间才能得到最终运算结果，运算的延时主要是由于进位的延迟引起的，为了提高运算速度，必须尽量减小由于进位信号逐级传递所耗费的时间</p>
</li>
<li><p>Carry Look-ahead Adder（CLA）可以有效的解决这一问题</p>
<ul>
<li><p>进位输出位方程：</p>
<script type="math/tex; mode=display">
C_{i+1}=a_i\cdot b_i+c_i\cdot(a_i\bigoplus b_i)</script><ul>
<li>$\bigoplus $代表异或，$\cdot$代表与门</li>
</ul>
</li>
<li><p>其中，进位产生项$g_i$：</p>
<script type="math/tex; mode=display">
g_i=a_i\cdot b_i</script></li>
<li><p>进位传播项$p_i$：</p>
<script type="math/tex; mode=display">
p_i=a_i \bigoplus b_i</script></li>
<li><p>则$C_{i+1}$：</p>
<script type="math/tex; mode=display">
C_{i+1}=g_i+c_i\cdot p_i</script></li>
<li><p>而输出结果位$s_i$：</p>
<script type="math/tex; mode=display">
s_i=p_i\bigoplus c_i</script></li>
</ul>
</li>
<li><p><strong>故CLA的主要思想是先对每位计算$g_i$和$p_i$的值，然后运用它们来计算进位$c_{i+1}$和$s_i$，这避免了进位串行传播通过进位链，从而实现超前进位的目的</strong></p>
</li>
<li><p>一般是构建4bit的CLA，否则资源占用会过大：</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031152635985.png" alt="image-20231031152635985"></p>
</li>
<li><p>这里给出位数可变的通用CLA的设计文件BinaryCarryLookaheadAdder.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> BinaryCarryLookaheadAdder # (<span class="keyword">parameter</span> N=<span class="number">16</span>)(</span><br><span class="line">    <span class="keyword">input</span> [N-<span class="number">1</span>:<span class="number">0</span>] a,b, </span><br><span class="line">    <span class="keyword">input</span> c_in, </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] sum, </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> c_out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] p, g, P, G; </span><br><span class="line">    <span class="keyword">reg</span> [N:<span class="number">0</span>] c; </span><br><span class="line">    <span class="keyword">integer</span> i; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i=i+<span class="number">1</span>)  <span class="keyword">begin</span> <span class="comment">// Generate all ps and gs </span></span><br><span class="line">            p[i] = a[i] ^ b[i]; </span><br><span class="line">            g[i] = a[i] &amp; b[i];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// Linearly apply dot operators </span></span><br><span class="line">        P[<span class="number">0</span>] = p[<span class="number">0</span>]; </span><br><span class="line">        G[<span class="number">0</span>] = g[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;N; i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            P[i] = p[i] &amp; P[i-<span class="number">1</span>]; </span><br><span class="line">            G[i] = g[i] | (p[i] &amp; G[i-<span class="number">1</span>]) ;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span> <span class="comment">//Generate all carries and sum </span></span><br><span class="line">        c[<span class="number">0</span>] = c_in; </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i=i+<span class="number">1</span>) <span class="keyword">begin</span> </span><br><span class="line">            c[i+<span class="number">1</span>] = G[i] | (P[i] &amp; c[<span class="number">0</span>]); </span><br><span class="line">            sum[i] = p[i] ^ c[i]; </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        c_out = c[N]; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>原理图如下：</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/Snipaste_2023-10-30_19-46-30.png" alt="Snipaste_2023-10-30_19-46-30"></p>
<h2 id="3-Carry-Select-Adder（进位选择加法器）"><a href="#3-Carry-Select-Adder（进位选择加法器）" class="headerlink" title="3.Carry Select Adder（进位选择加法器）"></a>3.Carry Select Adder（进位选择加法器）</h2></li>
</ul>
</li>
<li><p>Carry Select Adder采用面积换速度的思想，由于进位不确定导致下一级加法器只能等待，反正进位不是0就是1，那么可以提前算出1或者0的情况，最后再由进位去选择算好的结果</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031154457762.png" alt="image-20231031154457762" style="zoom:80%;"></p>
<ul>
<li>图中所说的第二级其实只是做了MUX的判断，具体需要结合代码分析理解</li>
</ul>
</li>
<li><p>HierarchicalCSA.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HierarchicalCSA(a, b, cin, sum, c_out);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] a,b;</span><br><span class="line">    <span class="keyword">input</span> cin; </span><br><span class="line">    <span class="keyword">output</span> c_out; </span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] sum; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> c4, c8, c8_0, c8_1, c12_0, c12_1, c16_0, c16_1, c16L2_0, c16L2_1; </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">4</span>] sumL1_0, sumL1_1; </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">12</span>] sumL2_0, sumL2_1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Level one of hierarchical CSA </span></span><br><span class="line">    <span class="keyword">assign</span> &#123;c4,sum[<span class="number">3</span>:<span class="number">0</span>]&#125; = a[<span class="number">3</span>:<span class="number">0</span>] + b[<span class="number">3</span>:<span class="number">0</span>] + cin; </span><br><span class="line">    <span class="keyword">assign</span> &#123;c8_0, sumL1_0[<span class="number">7</span>:<span class="number">4</span>]&#125; = a[<span class="number">7</span>:<span class="number">4</span>] + b[<span class="number">7</span>:<span class="number">4</span>] + <span class="number">1&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">assign</span> &#123;c8_1, sumL1_1[<span class="number">7</span>:<span class="number">4</span>]&#125; = a[<span class="number">7</span>:<span class="number">4</span>] + b[<span class="number">7</span>:<span class="number">4</span>] + <span class="number">1&#x27;b1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> &#123;c12_0,sumL1_0[<span class="number">11</span>:<span class="number">8</span>]&#125; = a[<span class="number">11</span>:<span class="number">8</span>] + b[<span class="number">11</span>:<span class="number">8</span>] + <span class="number">1&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">assign</span> &#123;c12_1,sumL1_1[<span class="number">11</span>:<span class="number">8</span>]&#125; = a[<span class="number">11</span>:<span class="number">8</span>] + b[<span class="number">11</span>:<span class="number">8</span>] + <span class="number">1&#x27;b1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> &#123;c16_0, sumL1_0[<span class="number">15</span>:<span class="number">12</span>]&#125; = a[<span class="number">15</span>:<span class="number">12</span>] + b[<span class="number">15</span>:<span class="number">12</span>] + <span class="number">1&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">assign</span> &#123;c16_1, sumL1_1[<span class="number">15</span>:<span class="number">12</span>]&#125; = a[<span class="number">15</span>:<span class="number">12</span>] + b[<span class="number">15</span>:<span class="number">12</span>] + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Level two of hierarchical CSA </span></span><br><span class="line">    <span class="keyword">assign</span> c8 = c4 ? c8_1 : c8_0; </span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">7</span>:<span class="number">4</span>] = c4 ? sumL1_1[<span class="number">7</span>:<span class="number">4</span>]: sumL1_0[<span class="number">7</span>:<span class="number">4</span>]; </span><br><span class="line">    <span class="comment">// Selecting sum and carry within a group </span></span><br><span class="line">    <span class="keyword">assign</span> c16L2_0 = c12_0 ? c16_1 : c16_0; </span><br><span class="line">    <span class="keyword">assign</span> sumL2_0[<span class="number">15</span>:<span class="number">12</span>] = c12_0 ? sumL1_1[<span class="number">15</span>:<span class="number">12</span>] : sumL1_0[<span class="number">15</span>:<span class="number">12</span>]; </span><br><span class="line">    <span class="keyword">assign</span> c16L2_1 = c12_1 ? c16_1 : c16_0; </span><br><span class="line">    <span class="keyword">assign</span> sumL2_1[<span class="number">15</span>:<span class="number">12</span>] = c12_1 ? sumL1_1[<span class="number">15</span>:<span class="number">12</span>]: sumL1_0[<span class="number">15</span>:<span class="number">12</span>]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Level three selecting the final outputs </span></span><br><span class="line">    <span class="keyword">assign</span> c_out = c8 ? c16L2_1 : c16L2_0; </span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">15</span>:<span class="number">8</span>] = c8 ? &#123;sumL2_1[<span class="number">15</span>:<span class="number">12</span>], sumL1_1[<span class="number">11</span>:<span class="number">8</span>]&#125; : &#123;sumL2_0[<span class="number">15</span>:<span class="number">12</span>], sumL1_0[<span class="number">11</span>:<span class="number">8</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>原理图如下：</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/Snipaste_2023-10-30_22-23-02.png" alt="Snipaste_2023-10-30_22-23-02" style="zoom: 50%;"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-Carry-Save-Adder（进位保留加法器"><a href="#4-Carry-Save-Adder（进位保留加法器" class="headerlink" title="4. Carry Save Adder（进位保留加法器)"></a>4. Carry Save Adder（进位保留加法器)</h2><ul>
<li><p>Carry Save Adder（CSA）它的内部结构实际上跟全加器FA一样，只是它不将进位传递给下一位，而是将其保留下来</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031155720102.png" alt="image-20231031155720102" style="zoom: 80%;"></p>
</li>
<li><p>由此引申出来的CSA树，可以得到参考：<a href="https://blog.csdn.net/weixin_45791458/article/details/133518505">数字IC前端学习笔记：数字乘法器的优化设计（进位保留乘法器）_日晨难再的博客-CSDN博客</a></p>
</li>
</ul>
<hr>
<h1 id="乘法器"><a href="#乘法器" class="headerlink" title="乘法器"></a>乘法器</h1><h2 id="1-Wallace-Tree乘法器"><a href="#1-Wallace-Tree乘法器" class="headerlink" title="1.Wallace Tree乘法器"></a>1.Wallace Tree乘法器</h2><ul>
<li><p>Wallace Tree是基于CSA的结构的，它能同时对不同的3bit结果使用CSA压缩成2bit，再在结果中又结合成3bit，继续压缩至2bit，直至最后压缩到只有2bit，此时可以用CLA去计算这个2bit的结果</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031160740596.png" alt="image-20231031160740596" style="zoom:80%;"></p>
</li>
<li><p>详情参考：<a href="https://blog.csdn.net/zhouxuanyuye/article/details/105543551?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=wallace乘法器&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-105543551.nonecase&amp;spm=1018.2226.3001.4187">【HDL系列】乘法器(4)——图解Wallace树_multiplier hdl-CSDN博客</a>（写的非常形象）</p>
</li>
<li><p>例子参考：<a href="https://www.bilibili.com/video/BV1WM4y1n7KB/?spm_id_from=333.337.search-card.all.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">18a 數位邏輯設計 Fast Multiplier — Wallace Tree Example_哔哩哔哩_bilibili</a>（视频中举例也十分清楚）</p>
</li>
</ul>
<h2 id="2-Booth乘法器"><a href="#2-Booth乘法器" class="headerlink" title="2.Booth乘法器"></a>2.Booth乘法器</h2><h3 id="2-1-Radix2-Booth"><a href="#2-1-Radix2-Booth" class="headerlink" title="2.1 Radix2 Booth"></a>2.1 Radix2 Booth</h3><ul>
<li><p>Booth算法的目的是解决<strong>有符号乘法</strong>运算中复杂的符号修正问题，同时也能减少部分乘积项（PP）的数量</p>
</li>
<li><p>设n位乘法B的补码形式为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
B &= -B_{n-1}\cdot 2^{n-1}+B_{n-2}\cdot 2^{n-2}+\dots+B_1\cdot 2^1+B_0\cdot 2^0\\
  &= -B_{n-1}2^{n-1}+(\sum_{i=0}^{n-2}B_i\cdot2^i)
\end{aligned}</script></li>
<li><p>对上式做一些变换后可得到：</p>
<script type="math/tex; mode=display">
B=\sum_{i=0,B_{-1}=0}^{n-1}(-B_i+B_{i-1})\cdot 2^i=\sum_{i=0}^{n-1}E_i\cdot 2^i</script></li>
<li><p>则有两个有符号乘积结果$P$：</p>
<script type="math/tex; mode=display">
P=A\times B=A\times(\sum_{i=0}^{n-1}E_i\cdot 2^i) = \sum_{i=0}^{n-1}(A\times E_i)\cdot 2^i</script><ul>
<li>其中：$E_i=-B_i+B_{i-1},0\le i \le n-1,B_{-1}=0$</li>
<li>$E_i$称为编码值，$A\times E_i$称为部分积</li>
</ul>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031162452338.png" alt="image-20231031162452338" style="zoom:80%;"></p>
</li>
<li><p><strong>缺点：对于101010101010这样的乘数，需要计算的部分积个数没有变，反而多了编码的步骤，计算延迟增加，得不偿失，故实际中很少使用，而采用其优化而来的Radix4 Booth算法</strong></p>
</li>
</ul>
<h3 id="2-2-Radix4-Booth"><a href="#2-2-Radix4-Booth" class="headerlink" title="2.2 Radix4 Booth"></a>2.2 Radix4 Booth</h3><ul>
<li><p>对于有符号数补码而言，扩展其最高位对数值并无影响。因此任何奇数位宽的有符号数补码都可以看成是偶数位宽</p>
</li>
<li><p>设一个二进制乘数B，位宽为n，且n为偶数，则B可以表示为：</p>
<script type="math/tex; mode=display">
B=\sum_{i=0,B_{-1}=0}^{\frac n2-1}(-2B_{2i+1}+B_{2i}+B_{2i-1})\cdot 2^{2i}=\sum_{i=0}^{\frac n2 -1}E_i\cdot 4^i</script></li>
<li><p>则有两个有符号乘积结果$P$：</p>
<script type="math/tex; mode=display">
P=A\times B=A\times \sum_{i=0}^{\frac n2 -1}E_i\cdot 4^i =\sum_{i=0}^{\frac n2 -1}(A\times E_i)\cdot 4^i</script><ul>
<li>其中，$E_i=-2B_{2i+1}+B_{2i}+B_{2i-1},0\le i\le \frac n2 -1,B_{-1}=0$</li>
<li><strong>且$\frac n2$为部分积的个数</strong></li>
</ul>
</li>
<li><p><strong>Radix4 Booth算法每次编码的位数为3bit，使得部分积的数目减少为原始Booth算法的一半</strong></p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031163518501.png" alt="image-20231031163518501" style="zoom: 67%;"></p>
</li>
<li><p>而Radix4 Booth的编码结果如下：</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031163635108.png" alt="image-20231031163635108" style="zoom: 80%;"></p>
</li>
<li><p><strong>对除0外的操作都先对被乘数A的最高位添上一个符号位，再进行操作，+2A是左移，-2A代表取补码后左移（或者左移后再取补码也可）</strong></p>
</li>
<li><p>Radix4 Booth编码实现的两个8bit有符号数相乘，输出为16bit有符号数</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031164644373.png" alt="image-20231031164644373" style="zoom: 80%;"></p>
<ul>
<li><p>相关代码：</p>
</li>
<li><p>Booth_mul_top.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Booth_mul_top(</span><br><span class="line">    a_i,</span><br><span class="line">    b_i,</span><br><span class="line">    mul_o</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">parameter</span> length = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">input</span>   [length-<span class="number">1</span> : <span class="number">0</span>]  a_i,b_i;</span><br><span class="line">    <span class="keyword">output</span>  [length*<span class="number">2</span>-<span class="number">1</span>:<span class="number">0</span>]  mul_o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span>    [length   : <span class="number">0</span>]  booth_o0 ;</span><br><span class="line">    <span class="keyword">wire</span>    [length   : <span class="number">0</span>]  booth_o1 ;</span><br><span class="line">    <span class="keyword">wire</span>    [length   : <span class="number">0</span>]  booth_o2 ;</span><br><span class="line">    <span class="keyword">wire</span>    [length   : <span class="number">0</span>]  booth_o3 ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span>    [length*<span class="number">2</span>-<span class="number">1</span>: <span class="number">0</span>]  pp0 ;</span><br><span class="line">    <span class="keyword">wire</span>    [length*<span class="number">2</span>-<span class="number">1</span>: <span class="number">0</span>]  pp1 ;</span><br><span class="line">    <span class="keyword">wire</span>    [length*<span class="number">2</span>-<span class="number">1</span>: <span class="number">0</span>]  pp2 ;</span><br><span class="line">    <span class="keyword">wire</span>    [length*<span class="number">2</span>-<span class="number">1</span>: <span class="number">0</span>]  pp3 ;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//module booth4code (a_i,b_i,booth_o);</span></span><br><span class="line">    booth4code booth4_0  (a_i , &#123;b_i[<span class="number">1</span>:<span class="number">0</span>],<span class="number">1&#x27;b0</span>&#125;   , booth_o0 );</span><br><span class="line">    booth4code booth4_1  (a_i ,  b_i[<span class="number">3</span>:<span class="number">1</span>]         , booth_o1 );</span><br><span class="line">    booth4code booth4_2  (a_i ,  b_i[<span class="number">5</span>:<span class="number">3</span>]         , booth_o2 );</span><br><span class="line">    booth4code booth4_3  (a_i ,  b_i[<span class="number">7</span>:<span class="number">5</span>]         , booth_o3 );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span>  pp0  = &#123;&#123; <span class="number">7</span>&#123;booth_o0 [length]&#125;&#125; , &#123;booth_o0   &#125;&#125;; <span class="comment">//2*0</span></span><br><span class="line">    <span class="keyword">assign</span>  pp1  = &#123;&#123; <span class="number">5</span>&#123;booth_o1 [length]&#125;&#125; , &#123;booth_o1  &#125; , &#123;  <span class="number">2</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;&#125;;  <span class="comment">//&lt;&lt; 2  </span></span><br><span class="line">    <span class="keyword">assign</span>  pp2  = &#123;&#123; <span class="number">3</span>&#123;booth_o2 [length]&#125;&#125; , &#123;booth_o2  &#125; , &#123;  <span class="number">4</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;&#125;;  <span class="comment">//&lt;&lt; 4  </span></span><br><span class="line">    <span class="keyword">assign</span>  pp3  = &#123;&#123; <span class="number">1</span>&#123;booth_o3 [length]&#125;&#125; , &#123;booth_o3  &#125; , &#123;  <span class="number">6</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;&#125;;  <span class="comment">//&lt;&lt; 6  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> cout_0 ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [length*<span class="number">2</span> : <span class="number">0</span>] cpr_o_0  ;</span><br><span class="line">    <span class="keyword">wire</span> [length*<span class="number">2</span> : <span class="number">0</span>] cpr_o_1  ;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//wallace tree</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//first level of wallace tree: 42compressor</span></span><br><span class="line">    <span class="comment">//module compressor42 (in1,in2,in3,in4,cin,out1,out2,cout);</span></span><br><span class="line">    <span class="comment">//out1 needs to be multiplied by two (out1&lt;&lt;1)</span></span><br><span class="line">    <span class="comment">//module        compressor42   (in1  ,in2  ,in3  ,in4  , cin  ,out1        ,out2        ,cout      );</span></span><br><span class="line">    compressor42 compressor42_1_0  (pp0  ,pp1  ,pp2  ,pp3  , <span class="number">1&#x27;b0</span> ,cpr_o_0  ,cpr_o_1  ,cout_0 );</span><br><span class="line">    <span class="comment">//本例中输入数据位宽是8，刚好一个42压缩即可，如果位宽较大，则需要进行多级位宽压缩</span></span><br><span class="line">    <span class="keyword">wire</span> cout;</span><br><span class="line">    <span class="comment">//carry lookahead adder</span></span><br><span class="line">    <span class="comment">//module cla (op1,op2,sum,cout);</span></span><br><span class="line">    cla cla_0 (cpr_o_0[length*<span class="number">2</span>-<span class="number">1</span>:<span class="number">0</span>]&lt;&lt;<span class="number">1</span> ,cpr_o_1[length*<span class="number">2</span>-<span class="number">1</span>:<span class="number">0</span>] ,mul_o ,cout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>booth4code.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> booth4code(</span><br><span class="line">    a_i,</span><br><span class="line">    b_i,</span><br><span class="line">    booth_o</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> length = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">input</span>      [length-<span class="number">1</span> : <span class="number">0</span>]  a_i;         <span class="comment">//full 8-bit input</span></span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">2</span>:<span class="number">0</span>]           b_i;         <span class="comment">//3 of 8 bit input</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [length   : <span class="number">0</span>]  booth_o;     <span class="comment">//booth output</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(b_i)</span><br><span class="line">            <span class="number">3&#x27;b000</span> : booth_o &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="number">3&#x27;b001</span> : booth_o &lt;= &#123; a_i[length-<span class="number">1</span>], a_i&#125;;</span><br><span class="line">            <span class="number">3&#x27;b010</span> : booth_o &lt;= &#123; a_i[length-<span class="number">1</span>], a_i&#125;;</span><br><span class="line">            <span class="number">3&#x27;b011</span> : booth_o &lt;=   a_i&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//3&#x27;b100 : booth_o &lt;= -(a_i&lt;&lt;1);</span></span><br><span class="line">            <span class="number">3&#x27;b100</span> : booth_o &lt;=  (-&#123; a_i[length-<span class="number">1</span>], a_i&#125;)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="number">3&#x27;b101</span> : booth_o &lt;= -&#123;a_i[length-<span class="number">1</span>],a_i&#125;;</span><br><span class="line">            <span class="number">3&#x27;b110</span> : booth_o &lt;= -&#123;a_i[length-<span class="number">1</span>],a_i&#125;;</span><br><span class="line">            <span class="number">3&#x27;b111</span> : booth_o &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">default</span>: booth_o &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>compressor42.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> compressor42(</span><br><span class="line">    in1,in2,in3,in4,cin,out1,out2,cout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> length = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">input</span>   [length*<span class="number">2</span>-<span class="number">1</span> : <span class="number">0</span>]  in1,in2,in3,in4;</span><br><span class="line">    <span class="keyword">input</span>                     cin;</span><br><span class="line">    <span class="keyword">output</span>  [length*<span class="number">2</span> : <span class="number">0</span>]  out1,out2;</span><br><span class="line">    <span class="keyword">output</span>                    cout;</span><br><span class="line">    <span class="keyword">wire</span>    [length*<span class="number">2</span>-<span class="number">1</span> : <span class="number">0</span>]  w1,w2,w3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> w1 = in1 ^ in2 ^ in3 ^ in4;</span><br><span class="line">    <span class="keyword">assign</span> w2 = (in1 &amp; in2) | (in3 &amp; in4);</span><br><span class="line">    <span class="keyword">assign</span> w3 = (in1 | in2) &amp; (in3 | in4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> out2 = &#123; w1[length*<span class="number">2</span>-<span class="number">1</span>] , w1&#125; ^ &#123;w3 , cin&#125;;</span><br><span class="line">    <span class="keyword">assign</span> cout = w3[length*<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> out1 = (&#123; w1[length*<span class="number">2</span>-<span class="number">1</span>] , w1&#125; &amp; &#123;w3 , cin&#125;) | (( ~&#123;w1[length*<span class="number">2</span>-<span class="number">1</span>] , w1&#125;) &amp; &#123; w2[length*<span class="number">2</span>-<span class="number">1</span>] , w2&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>cla.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> cla(</span><br><span class="line">    op1,</span><br><span class="line">    op2,</span><br><span class="line">    sum,</span><br><span class="line">    cout</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">parameter</span>  width = <span class="number">16</span> ; </span><br><span class="line">    <span class="keyword">input</span>  [width-<span class="number">1</span>:<span class="number">0</span>] op1;</span><br><span class="line">    <span class="keyword">input</span>  [width-<span class="number">1</span>:<span class="number">0</span>] op2;</span><br><span class="line">    <span class="keyword">output</span> [width-<span class="number">1</span>:<span class="number">0</span>] sum;</span><br><span class="line">    <span class="keyword">output</span> cout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [width&gt;&gt;<span class="number">2</span>:<span class="number">0</span>] c;      <span class="comment">//16是4位宽，右移2位是2</span></span><br><span class="line">    <span class="keyword">assign</span> c[<span class="number">0</span>] = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">assign</span> cout = c[width&gt;&gt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    cla_4bit u_cla_4bit_0  (<span class="variable">.op1</span>( op1[ <span class="number">0</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">0</span>*<span class="number">4</span>] ),<span class="variable">.op2</span>( op2[ <span class="number">0</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">0</span>*<span class="number">4</span>] ),<span class="variable">.cin</span>( c[<span class="number">0</span> ] ),<span class="variable">.sum</span>( sum[ <span class="number">0</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">0</span>*<span class="number">4</span>] ),<span class="variable">.cout</span>( c[<span class="number">0</span> +<span class="number">1</span>]));</span><br><span class="line">    cla_4bit u_cla_4bit_1  (<span class="variable">.op1</span>( op1[ <span class="number">1</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">1</span>*<span class="number">4</span>] ),<span class="variable">.op2</span>( op2[ <span class="number">1</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">1</span>*<span class="number">4</span>] ),<span class="variable">.cin</span>( c[<span class="number">1</span> ] ),<span class="variable">.sum</span>( sum[ <span class="number">1</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">1</span>*<span class="number">4</span>] ),<span class="variable">.cout</span>( c[<span class="number">1</span> +<span class="number">1</span>]));</span><br><span class="line">    cla_4bit u_cla_4bit_2  (<span class="variable">.op1</span>( op1[ <span class="number">2</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">2</span>*<span class="number">4</span>] ),<span class="variable">.op2</span>( op2[ <span class="number">2</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">2</span>*<span class="number">4</span>] ),<span class="variable">.cin</span>( c[<span class="number">2</span> ] ),<span class="variable">.sum</span>( sum[ <span class="number">2</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">2</span>*<span class="number">4</span>] ),<span class="variable">.cout</span>( c[<span class="number">2</span> +<span class="number">1</span>]));</span><br><span class="line">    cla_4bit u_cla_4bit_3  (<span class="variable">.op1</span>( op1[ <span class="number">3</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">3</span>*<span class="number">4</span>] ),<span class="variable">.op2</span>( op2[ <span class="number">3</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">3</span>*<span class="number">4</span>] ),<span class="variable">.cin</span>( c[<span class="number">3</span> ] ),<span class="variable">.sum</span>( sum[ <span class="number">3</span>*<span class="number">4</span>+<span class="number">3</span>: <span class="number">3</span>*<span class="number">4</span>] ),<span class="variable">.cout</span>( c[<span class="number">3</span> +<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>cla_4bit.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> cla_4bit(</span><br><span class="line">    op1,op2,cin,sum,cout</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> width = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span>  [width-<span class="number">1</span>:<span class="number">0</span>] op1;</span><br><span class="line">    <span class="keyword">input</span>  [width-<span class="number">1</span>:<span class="number">0</span>] op2;</span><br><span class="line">    <span class="keyword">input</span>  cin;</span><br><span class="line">    <span class="keyword">output</span> [width-<span class="number">1</span>:<span class="number">0</span>] sum;</span><br><span class="line">    <span class="keyword">output</span> cout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [width-<span class="number">1</span>:<span class="number">0</span>] g;</span><br><span class="line">    <span class="keyword">wire</span> [width-<span class="number">1</span>:<span class="number">0</span>] p;</span><br><span class="line">    <span class="keyword">wire</span> [width:<span class="number">0</span>] c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//gp generator</span></span><br><span class="line">    pg_gen u_pg_gen_0 (<span class="variable">.a</span>( op1[<span class="number">0</span>]),<span class="variable">.b</span>( op2[<span class="number">0</span>]),<span class="variable">.g</span>( g[<span class="number">0</span>]  ),<span class="variable">.p</span>( p[<span class="number">0</span>]  ));</span><br><span class="line">    pg_gen u_pg_gen_1 (<span class="variable">.a</span>( op1[<span class="number">1</span>]),<span class="variable">.b</span>( op2[<span class="number">1</span>]),<span class="variable">.g</span>( g[<span class="number">1</span>]  ),<span class="variable">.p</span>( p[<span class="number">1</span>]  ));</span><br><span class="line">    pg_gen u_pg_gen_2 (<span class="variable">.a</span>( op1[<span class="number">2</span>]),<span class="variable">.b</span>( op2[<span class="number">2</span>]),<span class="variable">.g</span>( g[<span class="number">2</span>]  ),<span class="variable">.p</span>( p[<span class="number">2</span>]  ));</span><br><span class="line">    pg_gen u_pg_gen_3 (<span class="variable">.a</span>( op1[<span class="number">3</span>]),<span class="variable">.b</span>( op2[<span class="number">3</span>]),<span class="variable">.g</span>( g[<span class="number">3</span>]  ),<span class="variable">.p</span>( p[<span class="number">3</span>]  ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//carry generator</span></span><br><span class="line">    <span class="keyword">assign</span> c[<span class="number">0</span>] = cin;</span><br><span class="line">    <span class="keyword">assign</span> c[<span class="number">1</span>] = g[<span class="number">0</span>] + ( c[<span class="number">0</span>] &amp; p[<span class="number">0</span>] );</span><br><span class="line">    <span class="keyword">assign</span> c[<span class="number">2</span>] = g[<span class="number">1</span>] + ( (g[<span class="number">0</span>] + ( c[<span class="number">0</span>] &amp; p[<span class="number">0</span>]) ) &amp; p[<span class="number">1</span>] );</span><br><span class="line">    <span class="keyword">assign</span> c[<span class="number">3</span>] = g[<span class="number">2</span>] + ( (g[<span class="number">1</span>] + ( (g[<span class="number">0</span>] + (c[<span class="number">0</span>] &amp; p[<span class="number">0</span>]) ) &amp; p[<span class="number">1</span>])) &amp; p[<span class="number">2</span>] );</span><br><span class="line">    <span class="keyword">assign</span> c[<span class="number">4</span>] = g[<span class="number">3</span>] + ( (g[<span class="number">2</span>] + ( (g[<span class="number">1</span>] + ( (g[<span class="number">0</span>] + (c[<span class="number">0</span>] &amp; p[<span class="number">0</span>]) ) &amp; p[<span class="number">1</span>])) &amp; p[<span class="number">2</span>] )) &amp; p[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">assign</span> cout = c[width];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sum generator</span></span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">0</span>] = p[<span class="number">0</span>] ^ c[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">1</span>] = p[<span class="number">1</span>] ^ c[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">2</span>] = p[<span class="number">2</span>] ^ c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">3</span>] = p[<span class="number">3</span>] ^ c[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pg_gen.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pg_gen(</span><br><span class="line">    a,b,g,p</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> a;</span><br><span class="line">    <span class="keyword">input</span> b;</span><br><span class="line">    <span class="keyword">output</span> g;</span><br><span class="line">    <span class="keyword">output</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> g = a &amp; b;</span><br><span class="line">    <span class="keyword">assign</span> p = a ^ b;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Testbench</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Booth_mul_tb;</span><br><span class="line">    <span class="keyword">reg</span>   [<span class="number">7</span> : <span class="number">0</span>]  a_i,b_i;</span><br><span class="line">    <span class="keyword">wire</span>  [<span class="number">15</span> : <span class="number">0</span>]  mul_o;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Booth_mul_top u0(</span><br><span class="line">        <span class="variable">.a_i</span>(a_i),</span><br><span class="line">        <span class="variable">.b_i</span>(b_i),</span><br><span class="line">        <span class="variable">.mul_o</span>(mul_o)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a_i = <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line">        b_i = <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        a_i = <span class="number">8&#x27;b1000_1111</span>;</span><br><span class="line">        b_i = <span class="number">8&#x27;b0000_0010</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        a_i = <span class="number">8&#x27;b0000_0010</span>;</span><br><span class="line">        b_i = <span class="number">8&#x27;b0000_0001</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        a_i = <span class="number">8&#x27;b1000_0010</span>;</span><br><span class="line">        b_i = <span class="number">8&#x27;b0000_0001</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        a_i = <span class="number">8&#x27;b1000_0010</span>;</span><br><span class="line">        b_i = <span class="number">8&#x27;b1000_0001</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        b_i[<span class="number">3</span>:<span class="number">1</span>] = <span class="number">3&#x27;b001</span>;</span><br><span class="line">        a_i = <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line">        b_i = <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        a_i = <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line">        b_i = <span class="number">8&#x27;b0000_0010</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        a_i = <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line">        b_i = <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">10</span>;</span><br><span class="line">        a_i = <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line">        b_i = <span class="number">8&#x27;b0000_0000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            a_i = a_i + <span class="number">1</span>;</span><br><span class="line">            b_i = b_i + <span class="number">1</span>;</span><br><span class="line">            #<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">1000</span> <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>仿真结果如下：</p>
<p><img src="/2023/10/31/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20231031165217224.png" alt="image-20231031165217224"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV15P411s7qJ?p=4&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">R4booth乘法器设计与仿真_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1s84y1W72L/?spm_id_from=333.788&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">【IC设计】【前端到后端全流程】【基于Booth2算法的32位乘法器】3-Booth算法与Booth2算法讲解以及RTL设计_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI DSP</tag>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>AWR2243级联板之MIMO数据采集处理及其原理</title>
    <url>/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>本节主要介绍了用TI的AWR2243级联板采集数据的基本配置流程，后续可能会更新一些如何设置参数的内容（目前没时间弄这块，可能要等比较久~）</p>
<span id="more"></span>
<h1 id="MIMO数据采集流程"><a href="#MIMO数据采集流程" class="headerlink" title="MIMO数据采集流程"></a>MIMO数据采集流程</h1><ul>
<li>对于AWR2243级联板，需要通过TDA2XX配置与采集数据，因为TDA2XX可以通过有限局域网（Ethernet）实现GUI到级联设备的通信</li>
<li>使用mmWaveStudio GUI的主要功能是：<ul>
<li>对所有2243进行固件下载</li>
<li>对所有2243进行配置</li>
<li>配置TDA2XX，为了使用它通过CSI接口获取ADC后的原始数据</li>
<li>对ADC数据进行处理以及可视化展示</li>
</ul>
</li>
<li>软件安装：<ul>
<li>mmWaveStudio 3.0.0.14</li>
<li>MCR_R2015aSP1_win32_installer.exe（这个应该跟数据后处理有关，若没下载好，会导致studio页面打开什么也没有，本人亲测踩雷）</li>
<li>balenaEtcher-Portable-1.5.39-x64.exe (用于烧写TDA2XX的固件，具体流程见mmwave_studio_cascade_user_guide.pdf中的4.2)</li>
<li>mmwave_dfp_02_02_00_03（支持AWR2243 1.0版本的固件）</li>
<li>Tera Term（串口通信软件）</li>
<li>WinSCP（数据传输及文件管理软件，采集结束后，软件会使用WinSCP自动将采集数据从板子上传输至电脑）</li>
</ul>
</li>
</ul>
<h2 id="1-硬件连接"><a href="#1-硬件连接" class="headerlink" title="1.硬件连接"></a>1.硬件连接</h2><ul>
<li><p>将TDA2XXX采集板与AWR2243板使用板载接口连接；将TDA2采集板与电脑使用mini-USB连接线进行连接</p>
</li>
<li><p>将TDA2XXX的以太网接口与电脑的以太网接口用网线连接，并设置电脑端的IP地址</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023191631813.png" alt="image-20231023191631813"></p>
</li>
<li><p>连接12V、5A的电源线</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023191305156.png" alt="image-20231023191305156" style="zoom: 33%;"></p>
</li>
</ul>
<h2 id="2-AWR2243级联板的配置"><a href="#2-AWR2243级联板的配置" class="headerlink" title="2.AWR2243级联板的配置"></a>2.AWR2243级联板的配置</h2><ul>
<li><p><strong>打开mmwaveStudio，首先设置“Radar System”为“Cascade”，并点击“Set Up TDAxx Capture Card”连接TDA采集板</strong></p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023191953646.png" alt="image-20231023191953646" style="zoom: 33%;"></p>
</li>
<li><p><strong>通过IP地址连接TDA2xx：</strong></p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023192156327.png" alt="image-20231023192156327" style="zoom:50%;"></p>
</li>
<li><p><strong>烧录配置文件：</strong></p>
<ul>
<li><p>配置文件位于：</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023192553884.png" alt="image-20231023192553884" style="zoom:50%;"></p>
</li>
<li><p>打开此配置文件，需要修改Meta固件（说实话，不太懂这个Meta固件跟MSS和BSS固件有个啥区别）的位置</p>
<ul>
<li>Meta固件位置：</li>
</ul>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023192340311.png" alt="image-20231023192340311" style="zoom:50%;"></p>
<ul>
<li><p>即：</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023192832419.png" alt="image-20231023192832419"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>设置完成后点击“Run”开始配置参数</strong>：</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023193113647.png" alt="image-20231023193113647"></p>
</li>
</ul>
<h2 id="3-AWR2243级联板的数据采集"><a href="#3-AWR2243级联板的数据采集" class="headerlink" title="3.AWR2243级联板的数据采集"></a>3.AWR2243级联板的数据采集</h2><ul>
<li><p>数据采集对应的文件是：</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023193340648.png" alt="image-20231023193340648"></p>
</li>
<li><p>可以在这个文件中capture_directory的位置修改捕获的ADC数据保存的位置</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023194440482.png" alt="image-20231023194440482"></p>
</li>
<li><p><strong>设置完成后点击“Run”开始采集数据</strong>：</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023194620997.png" alt="image-20231023194620997"></p>
</li>
<li><p>最终数据会保存在：</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023194706280.png" alt="image-20231023194706280" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="4-AWR2243级联板的数据处理"><a href="#4-AWR2243级联板的数据处理" class="headerlink" title="4.AWR2243级联板的数据处理"></a>4.AWR2243级联板的数据处理</h2><ul>
<li><p>利用官方提供的处理代码进行数据处理，matlab代码位置如下：</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023195133839.png" alt="image-20231023195133839" style="zoom: 50%;"></p>
</li>
<li><p><strong>首先在系统设置中添加环境变量</strong>：</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023195337381.png" alt="image-20231023195337381" style="zoom: 50%;"></p>
</li>
<li><p>其次，<strong>运行 “add_paths.m”</strong> <strong>文件，将路径添加至Matlab</strong></p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023195820659.png" alt="image-20231023195820659" style="zoom: 50%;"></p>
</li>
<li><p>修改<strong>4chip_cascade_MIMO_example\main\cascade\input文件夹里面的testlist.txt文件</strong></p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023200039762.png" alt="image-20231023200039762"></p>
</li>
<li><p>运行<strong>Cascade_MIMO_signalProcessing.m</strong></p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/image-20231023200849679.png" alt="image-20231023200849679" style="zoom:33%;"></p>
</li>
<li><p>最终MATLAB中会显示一个可视化结果：</p>
<p><img src="/2023/10/23/AWR2243%E7%BA%A7%E8%81%94%E6%9D%BF%E4%B9%8BMIMO%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/AWR2243_test1.jpg" alt="AWR2243_test1"></p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://blog.csdn.net/qq_40470415/article/details/115454198">TI级联雷达使用心得_ti级联雷达历程_阿凡四的博客-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>TI</tag>
        <tag>AWR2243</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之常用接口（基于PYNQ-Z2开发板）</title>
    <url>/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节主要介绍了SPI与CSI2接口协议。</p>
<span id="more"></span> 
<h1 id="SPI接口"><a href="#SPI接口" class="headerlink" title="SPI接口"></a>SPI接口</h1><h2 id="1-SPI接口协议的基本概念"><a href="#1-SPI接口协议的基本概念" class="headerlink" title="1.SPI接口协议的基本概念"></a>1.SPI接口协议的基本概念</h2><ul>
<li><p>SPI（Serial Peripheral interface），串行外设接口，SPI协议主要作为<strong>主控芯片去配置外围芯片的接口协议</strong></p>
</li>
<li><p>SPI是一种<strong>高速的、全双工、同步、串行、主从结构</strong>通信总线</p>
</li>
<li><p>SPI需要至少4根线，分别是MISO（主机输入从机输出）、MOSI（主机输出从机输入）、SCLK（时钟）、CS（片选）【或者叫SS】</p>
<p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231022171636889.png" alt="image-20231022171636889" style="zoom:50%;"></p>
</li>
<li><p>通信过程：</p>
<ul>
<li><p>SPI总线在进行数据传送时，<strong>先传送高位，后传送低位</strong></p>
</li>
<li><p>SPI协议规定一个SPI设备不能在数据通信过程中仅仅只充当发送或接收方。<strong>故在每个clk周期内，SPI设备都会发送并接收一个bit大小的数据</strong>，即SPI只有主模式和从模式之分，没有读和写的说法，因为实质上每次SPI是主从设备在交换数据，也就是说，你发送一个数据必然会收到一个数据（SPI设备在进行通信的过程中，主设备与从设备之间会产生一个数据链路回环）</p>
</li>
<li><p><strong>时钟通过时钟极性（CPOL）和时钟相位（CPHA）控制两个SPI设备间何时进行数据交换何时对接收到的数据进行采样</strong>，来保证数据在两个设备之间是同步传输的</p>
<ul>
<li><strong>CPOL表示SCLK空闲时的状态</strong>：<ul>
<li>CPOL=0，空闲时SCLK为低电平</li>
<li>CPOL=1，空闲时SCLK为高电平</li>
</ul>
</li>
<li><strong>CPOL表示采样时刻</strong>：<ul>
<li>CPHA=0，每个周期的第一个时钟沿采样</li>
<li>CPHA=0，每个周期的第二个时钟沿采样</li>
</ul>
</li>
</ul>
</li>
<li><p>SPI工作的四种不同模式：</p>
<ul>
<li><p>CPOL=0，CPHA=0：</p>
<p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231022173756537.png" alt="image-20231022173756537" style="zoom: 80%;"></p>
</li>
<li><p>CPOL=0，CPHA=1：</p>
<p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231022174251122.png" alt="image-20231022174251122" style="zoom:80%;"></p>
</li>
<li><p>CPOL=1，CPHA=0：</p>
<p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231022174504083.png" alt="image-20231022174504083" style="zoom:80%;"></p>
</li>
<li><p>CPOL=1，CPHA=1：</p>
<p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231022174328058.png" alt="image-20231022174328058" style="zoom:80%;"></p>
</li>
</ul>
<p>| CPOL/CPHA的设定 | 第一位数据的输出       | 其他位的输出 | 数据采样   |<br>| ———————- | ——————————— | —————— | ————— |<br>| CPOL=0，CPHA=0  | 在第一个SCLK上升沿之前 | SCLK下降沿   | SCLK上升沿 |<br>| CPOL=0，CPHA=1  | 第一个SCLK下降沿       | SCLK下降沿   | SCLK上升沿 |<br>| CPOL=1，CPHA=0  | 在第一个SCLK下升沿之前 | SCLK上升沿   | SCLK下降沿 |<br>| CPOL=1，CPHA=1  | 第一个SCLK上降沿       | SCLK上升沿   | SCLK下降沿 |</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-ZYNQ-SPI数据回环实验"><a href="#2-ZYNQ-SPI数据回环实验" class="headerlink" title="2.ZYNQ SPI数据回环实验"></a>2.ZYNQ SPI数据回环实验</h2><h3 id="2-1-vivado相关配置"><a href="#2-1-vivado相关配置" class="headerlink" title="2.1 vivado相关配置"></a>2.1 vivado相关配置</h3><ul>
<li><p>在hello world实验的基础上加上SPI控制器的配置，如下：</p>
<p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231023113419498.png" alt="image-20231023113419498"></p>
</li>
<li><p>对SPI接口引出如下引脚：</p>
<p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231023113554218.png" alt="image-20231023113554218" style="zoom: 67%;"></p>
</li>
<li><p>最终block结构如下：</p>
<p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231023113649187.png" alt="image-20231023113649187" style="zoom: 50%;"></p>
</li>
<li><p>引脚约束如下：</p>
<p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231023113307224.png" alt="image-20231023113307224"></p>
</li>
<li><p>生成bit stream后导出硬件</p>
</li>
</ul>
<h3 id="2-2-Vitis代码编写"><a href="#2-2-Vitis代码编写" class="headerlink" title="2.2 Vitis代码编写"></a>2.2 Vitis代码编写</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xspips.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xil_printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleep.h&quot;</span></span></span><br><span class="line">XSpiPs Spi0;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SpiPs_RecvByte(BaseAddress) \</span></span><br><span class="line"><span class="meta">		(u8)XSpiPs_In32((BaseAddress) + XSPIPS_RXD_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SpiPs_SendByte(BaseAddress, Data) \</span></span><br><span class="line"><span class="meta">		XSpiPs_Out32((BaseAddress) + XSPIPS_TXD_OFFSET, (Data))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spi0_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SpiRead</span><span class="params">(<span class="type">int</span> ByteCount)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SpiWrite</span><span class="params">(u8 *Sendbuffer, <span class="type">int</span> ByteCount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ReadBuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> WriteBuffer[<span class="number">1024</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> Status;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">	xil_printf(<span class="string">&quot;SPI Selftest Example \r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Status = spi0_init();</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		xil_printf(<span class="string">&quot;SPI Selftest Example Failed\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		SpiWrite(WriteBuffer,<span class="number">10</span>);</span><br><span class="line">		SpiRead(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">//xil_printf(&quot;read back \n&quot;);</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			xil_printf(<span class="string">&quot;%d,&quot;</span>,ReadBuffer[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		xil_printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">memset</span>(ReadBuffer, <span class="number">0x00</span>, <span class="number">1024</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	xil_printf(<span class="string">&quot;Successfully ran SPI Selftest Example\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SpiRead</span><span class="params">(<span class="type">int</span> ByteCount)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Count;</span><br><span class="line">	u32 StatusReg;</span><br><span class="line"></span><br><span class="line">	StatusReg = XSpiPs_ReadReg(Spi0.Config.BaseAddress,</span><br><span class="line">					XSPIPS_SR_OFFSET);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Polling the Rx Buffer for Data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		StatusReg = XSpiPs_ReadReg(Spi0.Config.BaseAddress,</span><br><span class="line">					XSPIPS_SR_OFFSET);</span><br><span class="line">	&#125;<span class="keyword">while</span>(!(StatusReg &amp; XSPIPS_IXR_RXNEMPTY_MASK));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reading the Rx Buffer</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span>(Count = <span class="number">0</span>; Count &lt; ByteCount; Count++)&#123;</span><br><span class="line">		ReadBuffer[Count] = SpiPs_RecvByte(</span><br><span class="line">				Spi0.Config.BaseAddress);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SpiWrite</span><span class="params">(u8 *Sendbuffer, <span class="type">int</span> ByteCount)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 StatusReg;</span><br><span class="line">	<span class="type">int</span> TransCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	StatusReg = XSpiPs_ReadReg(Spi0.Config.BaseAddress,</span><br><span class="line">				XSPIPS_SR_OFFSET);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((ByteCount &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		(TransCount &lt; XSPIPS_FIFO_DEPTH)) &#123;</span><br><span class="line">		SpiPs_SendByte(Spi0.Config.BaseAddress,</span><br><span class="line">				*Sendbuffer);</span><br><span class="line">		Sendbuffer++;</span><br><span class="line">		++TransCount;</span><br><span class="line">		ByteCount--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wait for the transfer to finish by polling Tx fifo status.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		StatusReg = XSpiPs_ReadReg(</span><br><span class="line">				Spi0.Config.BaseAddress,</span><br><span class="line">					XSPIPS_SR_OFFSET);</span><br><span class="line">	&#125; <span class="keyword">while</span> ((StatusReg &amp; XSPIPS_IXR_TXOW_MASK) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spi0_init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> Status;</span><br><span class="line">	XSpiPs_Config *SpiConfig;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the SPI device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SpiConfig = XSpiPs_LookupConfig(XPAR_XSPIPS_0_DEVICE_ID);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == SpiConfig) &#123;</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Status = XSpiPs_CfgInitialize(&amp;Spi0, SpiConfig, SpiConfig-&gt;BaseAddress);</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Perform a self-test to check hardware build.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Status = XSpiPs_SelfTest(&amp;Spi0);</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	xil_printf(<span class="string">&quot;%s self test succ\r\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	Status = XSpiPs_SetOptions(&amp;Spi0, XSPIPS_MASTER_OPTION);</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		xil_printf(<span class="string">&quot;%s XSpiPs_SetOptions fail\n&quot;</span>, __func__);</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	Status = XSpiPs_SetClkPrescaler(&amp;Spi0, XSPIPS_CLK_PRESCALE_64);</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		xil_printf(<span class="string">&quot;%s XSpiPs_SetClkPrescaler fail\n&quot;</span>, __func__);</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	XSpiPs_Enable(&amp;Spi0);</span><br><span class="line">	xil_printf(<span class="string">&quot;spi 0 config finish\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-实验结果"><a href="#2-3-实验结果" class="headerlink" title="2.3 实验结果"></a>2.3 实验结果</h3><p><img src="/2023/10/20/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231023113132477.png" alt="image-20231023113132477" style="zoom:50%;"></p>
<hr>
<h1 id="CSI2接口"><a href="#CSI2接口" class="headerlink" title="CSI2接口"></a>CSI2接口</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.uisrc.com/portal.php?mod=view&amp;aid=70">S02-CH10 SPI通信测试实验 - 2-ZYNQ入门 - UISRC工程师学习站 - Powered by uisrc.com!</a></li>
<li><a href="https://blog.csdn.net/CSD_N_csdn/article/details/108475671">ZYNQ学习之SPI的使用_zynq spi-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/weixin_46022434/article/details/105624672">SPI协议详解（工作特点、时序图）_spi时序-CSDN博客</a></li>
<li><a href="https://www.bilibili.com/video/BV1SK4y1X7jp?p=15&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">DAY5 SPI总线_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>TI AWR2243文档阅读之Programming Chirp Parameters in TI Radar Devices</title>
    <url>/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/</url>
    <content><![CDATA[<p>本节是针对TI官方提供的波形配置的文档进行了阅读，并分析了文档中主要讲了哪些模块</p>
<span id="more"></span>
<h1 id="典型FMCW-chirp和Fram-Structure"><a href="#典型FMCW-chirp和Fram-Structure" class="headerlink" title="典型FMCW chirp和Fram Structure"></a>典型FMCW chirp和Fram Structure</h1><p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231010230402242.png" alt="image-20231010230402242" style="zoom: 50%;"></p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231010230432804.png" alt="image-20231010230432804" style="zoom:50%;"></p>
<hr>
<h1 id="FMCW测量目标信息"><a href="#FMCW测量目标信息" class="headerlink" title="FMCW测量目标信息"></a>FMCW测量目标信息</h1><h2 id="1-测距及距离分辨率"><a href="#1-测距及距离分辨率" class="headerlink" title="1.测距及距离分辨率"></a>1.测距及距离分辨率</h2><ul>
<li><p>距离计算：</p>
<script type="math/tex; mode=display">
d=\frac{f\times c}{2\times S}</script></li>
<li><p>距离分辨率：</p>
<script type="math/tex; mode=display">
d_{res}=\frac c{2B}</script></li>
<li><p>因为雷达采集板提供的带宽有限（TI’sAWR2243 radar device provides a large 20-MHz bandwidth），所以最大距离收到了中频带宽的限制，有：</p>
<script type="math/tex; mode=display">
d_{max}=\frac{IF_{max}\times c}{2\times S}</script></li>
<li><p>在complex 1x采样模式，中频带宽限制为$0.9\times ADC_{采样频率}$；在complex 2x和real采样模式下，IF带宽限制为$0.9\times \frac{ADC_{采样频率}}{2}$（hemaximum ADC sampling frequency inthe TI’sradar devices is45MHz (AWR22xx)）</p>
<ul>
<li><p>但是并不能看懂，什么是complex 1x和complex 2x和real模式，于是就搜啊搜，搜到的也很少</p>
</li>
<li><p>搜到了一张图关于它们三者的一张图</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/pastedimage1637716999480v1.png" alt="img"></p>
</li>
<li><p>还有一个指路文档：Using a complex-baseband architecture in FMCW radar systems.pdf，说是在这个文档里面有更加详细的解释，但是，依然没有在这个文档里面把这三种采样模式看得很明白，只是能知道IQ通道复数采用和实数采样的中频信号，但实在不懂这怎么就跟中频带宽去对应上的</p>
<ul>
<li><p>接收信号与实数信号混频后的中频信号</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011000146144.png" alt="image-20231011000146144" style="zoom:50%;"></p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011000111359.png" alt="image-20231011000111359" style="zoom: 33%;"></p>
</li>
<li><p>接收信号与复数信号混频后的中频信号</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011000235276.png" alt="image-20231011000235276" style="zoom:50%;"></p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011000331557.png" alt="image-20231011000331557" style="zoom: 33%;"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-测速与速度分辨率"><a href="#2-测速与速度分辨率" class="headerlink" title="2.测速与速度分辨率"></a>2.测速与速度分辨率</h2><ul>
<li><p>速度计算：</p>
<script type="math/tex; mode=display">
则:v=\frac{\lambda\Delta\Phi}{4\pi T_c}</script></li>
<li><p>最大无模糊速度：</p>
<script type="math/tex; mode=display">
v_{max}=\frac{\lambda}{4T_c}\quad(\because \Delta \Phi_{max}=\pi)</script></li>
<li><p>速度分辨率：</p>
<script type="math/tex; mode=display">
V_{res}=\frac\lambda{2NT_c}</script></li>
</ul>
<h2 id="3-测角与角度分辨率"><a href="#3-测角与角度分辨率" class="headerlink" title="3.测角与角度分辨率"></a>3.测角与角度分辨率</h2><ul>
<li><p>角度计算：</p>
<script type="math/tex; mode=display">
\theta=arcsin(\frac{\phi\lambda}{2\pi d})</script></li>
<li><p>最大无模糊角度：</p>
<script type="math/tex; mode=display">
\theta_{max}=arcsin(\frac{\lambda}{2d})\quad(\because \phi_{max}=\pi)</script></li>
<li><p>角度分辨率：</p>
<script type="math/tex; mode=display">
\theta_{res}=\frac{\lambda}{Ndcos(\theta)}</script></li>
<li><p>MIMO雷达的有效接收通道：</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011001458283.png" alt="image-20231011001458283" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h1 id="配置Chirp-RAM-and-Chirp-Profiles"><a href="#配置Chirp-RAM-and-Chirp-Profiles" class="headerlink" title="配置Chirp RAM and Chirp Profiles"></a>配置Chirp RAM and Chirp Profiles</h1><ul>
<li><p>Chirp Profiles是基本的 Chirp 配置模板，可用于定义在一个或多个定义参数（起始频率、斜率、空闲时间等）方面具有显着差异的 Chirp 变体</p>
</li>
<li><p>Chirp RAM：是在Chirp Profiles配置模板上的细小变化，最多可对 512 个独特的chirp进行预编程并存储在Chirp RAM 中（感觉这里文档中没有解释得很清楚，并没有整明白Chirp RAM中每一个chirp究竟在对应的配置模板上，多了哪些细微的配置）</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011005020297.png" alt="image-20231011005020297" style="zoom: 50%;"></p>
</li>
</ul>
<hr>
<h1 id="Chirp的时序参数"><a href="#Chirp的时序参数" class="headerlink" title="Chirp的时序参数"></a>Chirp的时序参数</h1><p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011011536392.png" alt="image-20231011011536392" style="zoom: 50%;"></p>
<ul>
<li><p>其实在mmwave中输入slope, ADC samples, sampling rate，就能自动配置这些时序参数</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011011714519.png" alt="image-20231011011714519"></p>
</li>
</ul>
<hr>
<h1 id="高级帧配置Advanced-Chirp-Configurations"><a href="#高级帧配置Advanced-Chirp-Configurations" class="headerlink" title="高级帧配置Advanced Chirp Configurations"></a>高级帧配置Advanced Chirp Configurations</h1><p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011015218374.png" alt="image-20231011015218374" style="zoom:50%;"></p>
<ul>
<li><p>高级帧配置 API 提供了将帧分成不同子帧（最多 4 个，因为chirp profile模板的个数最多为4）的功能</p>
</li>
<li><p>每个子帧由多个线性调频脉冲串（bursts of chirps）（最多512个脉冲串）组成。 </p>
</li>
<li><p>每个脉冲串（bursts）可以最多可由 512 个独特的chirp（因为chirp RAM最多是512）组成</p>
</li>
<li><p>子帧中的一系列脉冲串可以在软件中循环最多 64 次，就是把几个不同的脉冲串捆在一起，然后循环最多64次</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011015159068.png" alt="image-20231011015159068" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="二进制相位调制（BPM-MIMO）"><a href="#二进制相位调制（BPM-MIMO）" class="headerlink" title="二进制相位调制（BPM-MIMO）"></a>二进制相位调制（BPM-MIMO）</h1><ul>
<li>原理详情请见：SWRA554A.pdf</li>
<li>可以通过”rlSetBpmChirpConfig ”API进行相关配置</li>
</ul>
<hr>
<h1 id="Chirp配置的顺序"><a href="#Chirp配置的顺序" class="headerlink" title="Chirp配置的顺序"></a>Chirp配置的顺序</h1><p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011020451036.png" alt="image-20231011020451036" style="zoom:50%;"></p>
<h2 id="1-Device-Manager-APIs"><a href="#1-Device-Manager-APIs" class="headerlink" title="1.Device Manager APIs"></a>1.Device Manager APIs</h2><ul>
<li><strong>这些 API 用于启动和初始化传感器：</strong><ul>
<li>rlDevicePowerOn：该函数初始化驱动程序并为驱动程序进行必要的资源分配。 它通过创建必要的操作系统服务（如信号量、互斥锁、队列等）来初始化主机协议驱动程序。 它还使雷达设备（级联时为多个设备）脱离重置，并打开与这些设备的通信通道（SPI、邮箱等）</li>
<li>DeviceFileDownload：此函数将二进制文件从主机下载到雷达设备的内部 RAM。 该文件可以是固件补丁文件、应用程序代码、校准数据或配置数据。</li>
<li>rlDeviceRfStart：该函数初始化雷达设备中的 RF(BIST) 子系统。 该函数立即返回，并且异步事件 (RL_EVENT_AR_DEVICE_START_COMPLETE) 指示 RF 初始化完成。 用户应用程序应在调用任何雷达传感器控制 API 之前等待此事件。</li>
</ul>
</li>
</ul>
<h2 id="2-Radar-RF-Control-APIs"><a href="#2-Radar-RF-Control-APIs" class="headerlink" title="2.Radar RF Control APIs"></a>2.Radar RF Control APIs</h2><ul>
<li><strong>这些 API 用于配置 RF 参数、线性调频脉冲配置文件和帧配置：</strong><ul>
<li>rlSetChannelConfig：此API允许配置要使用的TX数量（共 3 个）和 RX数量（共 4 个）。 它还允许选择是在独立模式还是级联模式下使用传感器。</li>
<li>rlSetAdcOutConfig：此 API 允许配置每个样本的bit位数 (12/14/16)。 它还允许选择ADC数据是否应为real、complex-1x 或complex- 2x。</li>
<li>rlSetLowPowerModeConfig：该 API 允许设置低功耗 ADC 模式以节省电量。 在此模式下，最大 ADC 采样率受到限制。</li>
<li>rlSetProfileConfig：配置Chirp Profiles，这些配置包括：chirp start frequency, idle time, ADC start time, chirp slope, chirp duration, TX power level in the chirp, number of ADC samples per chirp, the ADC sampling rate, High pass filter (HPF) cut off frequencies and RX gain setting.（这里有个疑问是为什么文档中在将chirp profile的时候并没有给出这么多要设置的量）</li>
<li>rlSetChirpConfig：一旦定义了配置文件，每个独特的chirp都可以与这些配置文件中的一个相关联。 除此之外，API 还允许在一些重要参数（例如start frequency, idle time and ADC start time）中进行有限的线性调频脉冲变化（超出配置文件）。</li>
<li>rlSetFrameConfig：This API allows selecting the sequence of the chirps that form the frame, number of frames that need to be transferred and the periodicity of the frames. The periodicity would define the inter-frame time (periodicity –chirp time), hence, the duty cycle of the transmission.（该 API 允许选择形成帧的线性调频脉冲序列、需要传输的帧数以及帧的周期性。 周期性将定义帧间时间（周期性-线性调频时间），从而定义传输的占空比。）</li>
</ul>
</li>
</ul>
<h2 id="3-Radar-Data-Control-APIs"><a href="#3-Radar-Data-Control-APIs" class="headerlink" title="3.Radar Data Control APIs"></a>3.Radar Data Control APIs</h2><ul>
<li>在线性调频期间捕获的 ADC 数据通过高速调试接口或 CSI 传输出器件。 </li>
<li><strong>Data Control APIs 允许配置需要传出的 ADC 数据和高速接口 (LVDS/CSI) 配置</strong>。 除了 ADC 数据外，还可以传输一些与线性调频信号质量和线性调频参数（分别称为 CQ（线性调频信号质量）和 CP（线性调频信号参数））相关的附加信息。</li>
<li>可以使用这些 API 完成 LVDS/CSI 配置、通道配置等。</li>
</ul>
<h2 id="4-Frame-Trigger-API"><a href="#4-Frame-Trigger-API" class="headerlink" title="4.Frame Trigger API"></a>4.Frame Trigger API</h2><ul>
<li>一旦配置了线性调频脉冲和帧，就可以通过软件 API 或使用数字 SYNC_IN 信号硬件触发来触发它们。</li>
<li>触发框架的软件API是rlSensorStart。</li>
</ul>
<hr>
<h1 id="TI’s-mmwave-link-APIs的代码出处"><a href="#TI’s-mmwave-link-APIs的代码出处" class="headerlink" title="TI’s mmwave link APIs的代码出处"></a>TI’s mmwave link APIs的代码出处</h1><p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011105221504.png" alt="image-20231011105221504" style="zoom:50%;"></p>
<ul>
<li>这个代码文件目前我还没有细看，只是先找到了这几个接口的出处</li>
</ul>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011105932994.png" alt="image-20231011105932994" style="zoom:50%;"></p>
<ul>
<li><p>其实在这个里面有一些不错的文档解释</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BProgramming%20Chirp%20Parameters%20in%20TI%20Radar%20Devices/image-20231011111029505.png" alt="image-20231011111029505" style="zoom:50%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>TI</tag>
        <tag>AWR2243</tag>
      </tags>
  </entry>
  <entry>
    <title>TI AWR2243文档阅读之mmWave Radar Interface Control Document</title>
    <url>/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/</url>
    <content><![CDATA[<p>本节是针对TI官方提供的接口配置的文档进行了阅读，并分析了文档中主要将了哪些模块</p>
<span id="more"></span>
<h1 id="TI毫米波雷达传感器通信的基础"><a href="#TI毫米波雷达传感器通信的基础" class="headerlink" title="TI毫米波雷达传感器通信的基础"></a>TI毫米波雷达传感器通信的基础</h1><h2 id="1-通信的基本结构"><a href="#1-通信的基本结构" class="headerlink" title="1.通信的基本结构"></a>1.通信的基本结构</h2><h3 id="1-1-SPI"><a href="#1-1-SPI" class="headerlink" title="1.1 SPI"></a>1.1 SPI</h3><ul>
<li>AWR2243 / xWR6243雷达设备通过SPI接口与外部主机处理器通信。<strong>通过SPI向AWR2243 / xWR6243设备发送命令</strong>，从外部主机处理器对雷达设备进行配置和控制。</li>
<li>SPI这个接口是同步的。该接口包括4路信号( SPICCLK、SPICS、Data In and Data Out)</li>
</ul>
<h3 id="1-2-Mailbox"><a href="#1-2-Mailbox" class="headerlink" title="1.2 Mailbox"></a>1.2 Mailbox</h3><ul>
<li><p>这个应该是MSS与BSS的通信接口，但目前并不清楚AW2243中MSS是哪个部分（因为一直以为MSS是指MCU部分，但AWR2243并没有内部处理器）</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011111915637.png" alt="image-20231011111915637" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="2-雷达信号结构（MailboxRadar-Message-Structure）"><a href="#2-雷达信号结构（MailboxRadar-Message-Structure）" class="headerlink" title="2.雷达信号结构（MailboxRadar Message Structure）"></a>2.雷达信号结构（MailboxRadar Message Structure）</h2><ul>
<li><p>Radar Message Structure应该就是雷达传感器与外界通信时，彼此遵循的一种信号格式</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011112118308.png" alt="image-20231011112118308" style="zoom:50%;"></p>
</li>
</ul>
<h3 id="2-1-SYNC"><a href="#2-1-SYNC" class="headerlink" title="2.1 SYNC"></a>2.1 SYNC</h3><ul>
<li><p>消息的起始位，标志着消息的开始</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011112832510.png" alt="image-20231011112832510" style="zoom:50%;"></p>
</li>
</ul>
<h3 id="2-2-MSGHDR"><a href="#2-2-MSGHDR" class="headerlink" title="2.2 MSGHDR"></a>2.2 MSGHDR</h3><h4 id="2-2-1-OPCODE"><a href="#2-2-1-OPCODE" class="headerlink" title="2.2.1 OPCODE"></a>2.2.1 OPCODE</h4><p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011113216065.png" alt="image-20231011113216065" style="zoom:50%;"></p>
<ul>
<li>MSGID尚未完全研究清楚，应该是一些更细节的分类，比如是错误响应，静态参数设置命令之类的</li>
</ul>
<h4 id="2-2-2-LENGTH"><a href="#2-2-2-LENGTH" class="headerlink" title="2.2.2 LENGTH"></a>2.2.2 LENGTH</h4><ul>
<li><p>就是message header+message data+CRC的长度</p>
</li>
<li><p>LENGTH的最小长度为12byte，最大长度为252byte（因为LEN最多有12bit，那么最多表示$2^{12}$个数，就正好等于$256\times 8$，即256byte，其实应该是可以表示256byte的长度的，可能是为了LENGTH+SYNC正好是256byte吧，就限制LENGTH最大为252byte吧）</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011114532160.png" alt="image-20231011114532160" style="zoom:50%;"></p>
</li>
<li><p>LENGTH-CRC的长度必须是4byte的倍数</p>
</li>
</ul>
<h4 id="2-2-3-FLAGS"><a href="#2-2-3-FLAGS" class="headerlink" title="2.2.3 FLAGS"></a>2.2.3 FLAGS</h4><ul>
<li><p>FLAGS用于控制雷达设备与外部主机之间的通信</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011114948954.png" alt="image-20231011114948954" style="zoom:50%;"></p>
</li>
</ul>
<h4 id="2-2-4-REMCHUNKS"><a href="#2-2-4-REMCHUNKS" class="headerlink" title="2.2.4 REMCHUNKS"></a>2.2.4 REMCHUNKS</h4><ul>
<li>如果消息长度大于256byte，则将其分割成多个小于256字节的块(chunk)。 当该字段非零时，该字段指示预期的剩余块的数量。</li>
</ul>
<h4 id="2-2-5-NSBC"><a href="#2-2-5-NSBC" class="headerlink" title="2.2.5 NSBC"></a>2.2.5 NSBC</h4><ul>
<li><p>通常会将一条消息分成多个子块（sub block）传输（请注意block和chunk的区别，一个是把message分为好几个小段，一个是message太大了，才分成一些个块）</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011115938961.png" alt="image-20231011115938961" style="zoom:50%;"></p>
</li>
</ul>
<h4 id="2-2-6-CHKSUM"><a href="#2-2-6-CHKSUM" class="headerlink" title="2.2.6 CHKSUM"></a>2.2.6 CHKSUM</h4><ul>
<li>对MSGHDR消息头的16bit校验信号</li>
</ul>
<h4 id="2-2-7-MSGDATA"><a href="#2-2-7-MSGDATA" class="headerlink" title="2.2.7 MSGDATA"></a>2.2.7 MSGDATA</h4><p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011120249098.png" alt="image-20231011120249098" style="zoom:50%;"></p>
<h4 id="2-2-8-CRC"><a href="#2-2-8-CRC" class="headerlink" title="2.2.8 CRC"></a>2.2.8 CRC</h4><ul>
<li><p>应该也是一种校验方式吧，是根据MSGHDR 和 MSGDATA 中的所有字节计算</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011120448016.png" alt="image-20231011120448016" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><h2 id="1-雷达通信的基本协议"><a href="#1-雷达通信的基本协议" class="headerlink" title="1.雷达通信的基本协议"></a>1.雷达通信的基本协议</h2><ul>
<li>主机向雷达设备发送消息请求确认。 主机为雷达设备的响应设置 1 ms 的超时时间</li>
<li>雷达设备检查 CHKSUM 字段的消息头有效性，检查 MSGDATA 字段的正确性，还计算消息的 CRC 并将其与接收到的 CRC 进行比较。<ul>
<li>如果计算出的 CHKSUM 与接收到的 CHKSUM 不匹配，则雷达设备不会发送任何响应。 发送器将超时并最终重新发送命令并设置RETRY标志</li>
<li>如果 CRC 匹配且所有参数均有效/正确，则雷达设备向主机发送 ACK </li>
<li>如果 CRC 匹配，但消息中的任何参数无效/不正确，则雷达设备向主机发送 ERROR 响应 </li>
<li>如果 CRC 不匹配，雷达设备将向主机发送 NACK 响应</li>
</ul>
</li>
<li>在接收到ACK后，主机可以向雷达设备发送下一个命令</li>
<li>如果主机在超时时间内收到来自雷达设备的 NACK，它将再次发送消息，则在没有RETRY FLAG set的情况下再次发送消息。</li>
<li>如果主机在超时期间内没有收到雷达设备的任何响应，则它发送与RETRY FLAG set相同的命令。</li>
</ul>
<h2 id="2-通信顺序"><a href="#2-通信顺序" class="headerlink" title="2.通信顺序"></a>2.通信顺序</h2><h3 id="2-1-Command-Response-Sequence-Host"><a href="#2-1-Command-Response-Sequence-Host" class="headerlink" title="2.1 Command/Response Sequence (Host)"></a>2.1 Command/Response Sequence (Host)</h3><ol>
<li>Host prepares the message</li>
<li>Host writes the message to the communication channel and starts Retry Timer (∼1 ms) </li>
<li>Host then waits for HOST IRQ high Interrupt <ul>
<li>If IRQ is received, go to Step 4 </li>
<li>If Retry Time expires, Enable Retry Flag and go to Step 2 </li>
</ul>
</li>
<li>Host writes CNYS (SYNC word = 0x5678 0x8765) and Dummy bytes (0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF 0xFFFF) on communication channel </li>
<li>Host waits for low on Host IRQ line<ul>
<li>If Host IRQ line is low, go to Step 6 </li>
<li>If Retry Time expires, Flag Error </li>
</ul>
</li>
<li>Host reads the header from communication channel </li>
<li>Host checks the validity of header (verify checksum) <ul>
<li>If header is valid, parse the header and go to Step 8</li>
<li>If header is invalid, ignore the header and reports to error to Application </li>
</ul>
</li>
<li>Host reads the payload from communication channel </li>
<li>Host checks the validity of the message (verify CRC) <ul>
<li>If message is valid, process the message </li>
<li>If message is invalid, go to Step 2 with new sequence number</li>
</ul>
</li>
</ol>
<ul>
<li>其实感觉这个通信顺序（是先发送命令再接收数据吗？）跟通信协议有些区别，比如step2主机发送message中真实data是什么样子，step7主机读取数据的时候，为什么header校验失败就直接发送error了，不应该是CRC失败才发送error么？先存疑在这</li>
</ul>
<h3 id="2-2-Bootup-Asynchronous-Event"><a href="#2-2-Bootup-Asynchronous-Event" class="headerlink" title="2.2 Bootup/ Asynchronous Event"></a>2.2 Bootup/ Asynchronous Event</h3><ul>
<li><p>这玩意还不太懂</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011123354989.png" alt="image-20231011123354989" style="zoom: 80%;"></p>
</li>
</ul>
<h3 id="2-3-SPI时序（Command-Response）"><a href="#2-3-SPI时序（Command-Response）" class="headerlink" title="2.3 SPI时序（Command/Response）"></a>2.3 SPI时序（Command/Response）</h3><p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011124344497.png" alt="image-20231011124344497"></p>
<hr>
<h1 id="雷达接口信息详细描述"><a href="#雷达接口信息详细描述" class="headerlink" title="雷达接口信息详细描述"></a>雷达接口信息详细描述</h1><ul>
<li><p>本部分介绍了与雷达收发信机通信所使用的所有雷达接口消息</p>
<p><img src="/2023/10/11/TI%20AWR2243%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E4%B9%8BmmWave%20Radar%20Interface%20Control%20Document/image-20231011125353204.png" alt="image-20231011125353204" style="zoom:50%;"></p>
</li>
<li><p>这一节只能做一个大致总结，要用的时候还得再查接口手册</p>
</li>
</ul>
<h2 id="1-AWR-ACK-MSG"><a href="#1-AWR-ACK-MSG" class="headerlink" title="1. AWR_ACK_MSG"></a>1. AWR_ACK_MSG</h2><ul>
<li>CRC校验成功时发送此信号</li>
<li>这里有个问题是此信号的MSGID是多少？</li>
</ul>
<h2 id="2-AWR-NACK-MSG"><a href="#2-AWR-NACK-MSG" class="headerlink" title="2. AWR_NACK_MSG"></a>2. AWR_NACK_MSG</h2><ul>
<li>CRC校验失败时发送此信号</li>
</ul>
<h2 id="3-AWR-ERROR-MSG"><a href="#3-AWR-ERROR-MSG" class="headerlink" title="3. AWR_ERROR_MSG"></a>3. AWR_ERROR_MSG</h2><ul>
<li>在发现主机命令有误时发送此信号</li>
<li>这个信号的数据有1个block：<strong>AWR_RESP_ERROR_SB</strong></li>
</ul>
<h2 id="4-AWR-RF-STATIC-CONF-SET-MSG"><a href="#4-AWR-RF-STATIC-CONF-SET-MSG" class="headerlink" title="4. AWR_RF_STATIC_CONF_SET_MSG"></a>4. AWR_RF_STATIC_CONF_SET_MSG</h2><ul>
<li>静态设置，在雷达收发机功率循环之后必须配置一次（说实话，并没有很懂这里）</li>
<li>这个信号的数据有13个block：<ul>
<li><strong>AWR_CHAN_CONF_SET_SB</strong>：选择是否级联，以及选择级联后的相关配置</li>
<li><strong>AWR_ADCOUT_CONF_SET_SB</strong>：ADC输出的数据格式，以及ADC的采样模式（Real、Complex 1x、Complex 2x、Pseudo Real）</li>
<li><strong>AWR_LOWPOWERMODE_CONF_SET_SB</strong>：是否通过降低某些IF模拟模块的偏置电流来降低功率</li>
<li><strong>AWR_DYNAMICPOWERSAVE_CONF_SET_SB</strong>：是否选用省电模式</li>
<li><strong>AWR_HIGHSPEEDINTFCLK_CONF_SET_SB</strong>：关于高速接口时钟速率，这与以LVDS或CSI2格式将ADC数据从AWR设备发送到主机有关。</li>
<li><strong>AWR_RF_DEVICE_CFG_SB</strong>：在BSS中配置异步事件的方向</li>
<li><strong>AWR_RF_RADAR_MISC_CTL_SB</strong>：移相器和高级帧的设置等的使能信号与其他RF配置（其他的部分没看懂是个啥配置）</li>
<li><strong>AWR_CAL_MON_FREQUENCY_LIMITS_SB</strong>：已经弃用了，别管</li>
<li><strong>AWR_RF_INIT_CALIBRATION_CONF_SB</strong>：配置设备执行开机时间校准</li>
<li><strong>AWR_CAL_MON_FREQUENCY_TX_POWER_LIMITS_ SB</strong>：为每个TX设置射频频率传输限制以及TX功率限制</li>
<li><strong>AWR_CAL_DATA_RESTORE_SB</strong>：应该是用来存储AWR_CAL_ DATA_SAVE_SB里面的RF校准数据（也没有太明白）</li>
<li><strong>AWR_PHASE_SHIFTER_CAL_DATA_RESTORE_SB</strong>：应该是用来存储AWR_PHASE_ SHIFTER_CAL_DATA_SAVE_SB里面移相器的校准数据（也没有太明白）</li>
<li><strong>AWR_APLL_SYNTH_BW_CONTROL_SB</strong>：这是 AWR2243 和 xWR6x43 中新增的一项功能。此子块用于控制 APLL 和合成器的带宽。</li>
</ul>
</li>
</ul>
<h2 id="5-AWR-RF-STATIC-CONF-GET-MSG"><a href="#5-AWR-RF-STATIC-CONF-GET-MSG" class="headerlink" title="5. AWR_RF_STATIC_CONF_GET_MSG"></a>5. AWR_RF_STATIC_CONF_GET_MSG</h2><ul>
<li><p>应该是主机读取从机的动态配置相关数据的</p>
</li>
<li><p>这个信号的数据有2个block：</p>
<ul>
<li><strong>AWR_CAL_DATA_SAVE_SB</strong>：该子模块从设备读取校准数据，稍后可以使用AWR_CAL_DATA_RESTORE_SB命令注入这些数据。（校准数据的总大小为 672 字节，由于 SPI 限制，已将其分成 3 个块 （校准数据的总大小为 672 字节，由于 SPI 限制，已将其分成 3 个块（NUM_CHUNKS），每个块 224 字节。主机应从雷达设备接收所有这 3 个块，以后主机只能将相关数据存储在非易失性存储器中。）</li>
<li><strong>AWR_PHASE_SHIFTER_CAL_DATA_SAVE_SB</strong>：该子模块从器件读取移相器的校准数据，稍后可以使用AWR_PHASE_SHIFTER_CAL_DATA_RESTORE_SB命令注入这些数据。</li>
</ul>
</li>
</ul>
<h2 id="6-AWR-RF-INIT-MSG"><a href="#6-AWR-RF-INIT-MSG" class="headerlink" title="6. AWR_RF_INIT_MSG"></a>6. AWR_RF_INIT_MSG</h2><ul>
<li>RF初始化消息，执行雷达收发器的启动时间校准。</li>
<li>这个信号的数据有1个block：<ul>
<li><strong>AWR_RF_INIT_SB</strong>：BSS处理器在收到此子模块时被唤醒，RF模拟和数字基带部分被初始化。</li>
</ul>
</li>
</ul>
<h2 id="7-AWR-RF-DYNAMIC-CONF-SET-MSG"><a href="#7-AWR-RF-DYNAMIC-CONF-SET-MSG" class="headerlink" title="7. AWR_RF_DYNAMIC_CONF_SET_MSG"></a>7. AWR_RF_DYNAMIC_CONF_SET_MSG</h2><h2 id="8-AWR-RF-DYNAMIC-CONF-GET-MSG"><a href="#8-AWR-RF-DYNAMIC-CONF-GET-MSG" class="headerlink" title="8. AWR_RF_DYNAMIC_CONF_GET_MSG"></a>8. AWR_RF_DYNAMIC_CONF_GET_MSG</h2><h2 id="9-AWR-RF-FRAME-TRIG-MSG"><a href="#9-AWR-RF-FRAME-TRIG-MSG" class="headerlink" title="9. AWR_RF_FRAME_TRIG_MSG"></a>9. AWR_RF_FRAME_TRIG_MSG</h2><ul>
<li>雷达收发器启动波形的帧触发消息</li>
<li>这个信号的数据有1个block：<ul>
<li><strong>AWR_FRAMESTARTSTOP_CONF_SB</strong>：此子块启动或停止帧的传输</li>
</ul>
</li>
</ul>
<h2 id="10-AWR-RF-ADVANCED-FEATURES-CONF-SET-MSG"><a href="#10-AWR-RF-ADVANCED-FEATURES-CONF-SET-MSG" class="headerlink" title="10. AWR_RF_ADVANCED_FEATURES_ CONF_SET_MSG"></a>10. AWR_RF_ADVANCED_FEATURES_ CONF_SET_MSG</h2><ul>
<li>一些高级配置</li>
<li>此接口仅适用于xWR6243 设备</li>
<li>这个信号的数据有3个block：<ul>
<li><strong>AWR_BPM_COMMON_CONF_SET_SB</strong>：此处定义了 BPM 模式的来源</li>
<li><strong>AWR_BPM_CHIRP_CONF_SET_SB</strong>：此子模块定义与每个TX中的BPM（二进制相位调制）功能相关的静态配置</li>
<li><strong>AWR_POWER_SAVE_MODE_CONF_SET_SB</strong>：定义了省电的模式</li>
</ul>
</li>
</ul>
<h2 id="11-AWR-RF-MONITORING-CONF-SET-MSG"><a href="#11-AWR-RF-MONITORING-CONF-SET-MSG" class="headerlink" title="11. AWR_RF_MONITORING_CONF_SET_MSG"></a>11. AWR_RF_MONITORING_CONF_SET_MSG</h2><ul>
<li>这个信号的数据有31个block：<ul>
<li><strong>WR_MONITOR_RF_DIG_LATENTFAULT_CONF_SB</strong>：启动监控功能以及选择测试模式（但没懂）</li>
<li><strong>AWR_MONITOR_RF_DIG_PERIODIC_CONF_SB</strong>：启用的监控功能会定期执行，并根据报告模式发送报告。</li>
<li><strong>AWR_MONITOR_ANALOG_ENABLES_CONF_SB</strong>：</li>
</ul>
</li>
</ul>
<h2 id="12-AWR-RF-STATUS-GET-MSG"><a href="#12-AWR-RF-STATUS-GET-MSG" class="headerlink" title="12. AWR_RF_STATUS_GET_MSG"></a>12. AWR_RF_STATUS_GET_MSG</h2><ul>
<li><p>获取有关响应的状态信息</p>
</li>
<li><p>这个信号的数据有5个block：</p>
<ul>
<li><strong>AWR_RF_VERSION_GET_SB</strong>：读取射频硬件和固件版本</li>
<li><strong>AWR_RF_CPUFAULT_STATUS_GET_SB</strong>：提供射频 BSS CPU 故障信息</li>
<li><strong>AWR_RF_ESMFAULT_STATUS_GET_SB</strong>：提供有关其他RF子系统故障的信息</li>
<li><strong>AWR_RF_DIEID_GET_SB</strong>：有关器件芯片 ID 的信息</li>
<li><strong>AWR_RF_BOOTUPBIST_STATUS_GET_SB</strong>：提供有关启动自检状态的信息</li>
</ul>
</li>
</ul>
<h2 id="13-AWR-RF-MONITORING-REPORT-GET-MSG"><a href="#13-AWR-RF-MONITORING-REPORT-GET-MSG" class="headerlink" title="13. AWR_RF_MONITORING_REPORT_GET_ MSG"></a>13. AWR_RF_MONITORING_REPORT_GET_ MSG</h2><ul>
<li>DFE 统计报告来自雷达收发器的 GET 消息（这个真一点没看懂）</li>
<li>这个信号的数据有1个block：<ul>
<li><strong>AWR_RF_DFE_STATISTICS_REPORT_GET_SB</strong>：</li>
</ul>
</li>
</ul>
<h2 id="14-AWR-RF-MISC-CONF-SET-MSG"><a href="#14-AWR-RF-MISC-CONF-SET-MSG" class="headerlink" title="14. AWR_RF_MISC_CONF_SET_MSG"></a>14. AWR_RF_MISC_CONF_SET_MSG</h2><ul>
<li><p>雷达收发器的其他配置消息子块</p>
</li>
<li><p>这个信号的数据有7个block：</p>
<ul>
<li><strong>AWR_RF_TEST_SOURCE_CONFIG_SET_SB</strong>：此子块用于配置 BSS 的测试源</li>
<li><strong>AWR_RF_TEST_SOURCE_ENABLE_SET_SB</strong>：此子块用于启用BSS的测试源</li>
<li><strong>AWR_RF_LDO_BYPASS_SB</strong>：此子模块启用 BSS 中的 LDO 旁路选项</li>
<li><strong>AWR_RF_PALOOPBACK_CFG_SB</strong>：此子块为所有已启用的配置文件启用/禁用 PA 环回。这用于调试 TX 和 RX 链是否正常工作</li>
<li><strong>AWR_RF_PSLOOPBACK_CFG_SB</strong>：此子块为所有已启用的配置文件启用/禁用 PS（移相器）环回。这用于调试 TX（在 PA 之前）和 RX 链。</li>
<li><strong>AWR_RF_IFLOOPBACK_CFG_SB</strong>：此子块为所有已启用的配置文件启用/禁用 IF 环回。这用于调试 RX IF 链。</li>
<li><strong>AWR_RF_GPADC_CFG_SET_SB</strong>：此子模块启用外部输入的 GPADC 读取（仅在 xWR1642/xWR1843/xWR6843/AWR2243/xWR6243 中可用）</li>
</ul>
</li>
</ul>
<h2 id="15-AWR-RF-MISC-CONF-GET-MSG"><a href="#15-AWR-RF-MISC-CONF-GET-MSG" class="headerlink" title="15. AWR_RF_MISC_CONF_GET_MSG"></a>15. AWR_RF_MISC_CONF_GET_MSG</h2><ul>
<li>这个信号的数据有1个block：<ul>
<li><strong>AWR_RF_TEMPERATURE_GET_SB</strong>：此子模块提供设备温度传感器信息</li>
</ul>
</li>
</ul>
<h2 id="16-AWR-RF-ASYNC-EVENT-MSG1"><a href="#16-AWR-RF-ASYNC-EVENT-MSG1" class="headerlink" title="16. AWR_RF_ASYNC_EVENT_MSG1"></a>16. AWR_RF_ASYNC_EVENT_MSG1</h2><ul>
<li>AWR_RF_ASYNC_EVENT_MSG1消息由雷达收发器发送到主机。此消息表示设备内发生了特定事件。</li>
<li>这个信号的数据有22个block：<ul>
<li><strong>AWR_AE_RF_CPUFAULT_SB</strong>：此子块指示 BIST SS 的 CPU 故障状态</li>
<li><strong>AWR_AE_RF_ESMFAULT_SB</strong>：此子块指示 BIST SS 中任何其他故障的状态</li>
<li><strong>AWR_AE_RF_INITCALIBSTATUS_SB</strong>：此子块表示RF BISTSS的初始校准已完成</li>
<li><strong>AWR_AE_RF_MONITOR_TYPE_TRIGGER_DONE_SB</strong>：此子块指示，触发的监视器类型是通过执行完成的，Host 可以使用此信号触发下一个类型的监视器。</li>
<li><strong>AWR_AE_RF_FRAME_TRIGGER_RDY_SB</strong>：此子块表示从设备现在已准备好接收帧触发的外部同步，这并不表示在硬件触发模式下帧的物理触发。在 SW 触发模式下，此异步事件表示帧由 SW 触发。</li>
<li><strong>AWR_AE_RF_GPADC_RESULT_DATA_SB</strong>：此子块表示 GPADC 测量已完成，并且还包含每个启用通道的测量数据。可以忽略未启用的通道的数据。</li>
<li><strong>AWR_FRAME_END_AE_SB</strong>：此子块表示帧的结束</li>
<li><strong>AWR_ANALOGFAULT_AE_SB</strong>：该子模块指示模拟电源故障或LDO短路情况。一旦检测到故障，则无法恢复该功能，需要重新启动传感器。</li>
<li><strong>AWR_CAL_MON_TIMING_FAIL_REPORT_AE_SB</strong>：此子块指示与校准或监控相关的任何定时故障</li>
<li><strong>AWR_RUN_TIME_CALIB_SUMMARY_REPORT_AE_ SB</strong>：如果在AWR_RUN_TIME_CALIBRATION_CONF_AND_TRIGGER_SB中启用了校准报告，则此子块指示校准状态（一次或运行时间）</li>
<li><strong>AWR_MONITOR_RF_DIG_LATENTFAULT_REPORT_ AE_SB</strong>：该异步事件包含潜在故障的数字监控状态（没懂）</li>
<li><strong>AWR_MONITOR_REPORT_HEADER_AE_SB</strong>：报告标题包含所有已启用监视器的通用信息，例如当前 FTTI 编号和当前温度。</li>
<li><strong>AWR_MONITOR_RF_DIG_PERIODIC_REPORT_AE_ SB</strong>：该异步事件定期发送，以指示定期数字监控测试的状态。（没懂一点）</li>
<li><strong>AWR_MONITOR_TEMPERATURE_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，包含各种射频模拟和数字模块附近的测量温度</li>
<li><strong>AWR_MONITOR_RX_GAIN_PHASE_REPORT_AE_SB</strong>：此子模块是AWR设备发送到主机的监控报告，包含测量的RX增益和相位值，环回功率和噪声功率。主机可以使用噪声功率来检测是否存在干扰。</li>
<li><strong>AWR_MONITOR_RX_NOISE_FIGURE_REPORT_AE_ SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含与配置文件的完整 IF 频段对应的测量 RX 噪声系数值。</li>
<li><strong>AWR_MONITOR_RX_IFSTAGE_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含给定 IF 频率下测得的 RX IF 滤波器衰减值。</li>
<li><strong>AWR_MONITOR_TX0_POWER_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含显式监控线性调频期间测得的 TX0 功率值。</li>
<li><strong>AWR_MONITOR_TX1_POWER_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含显式监控线性调频期间测得的 TX1 功率值。</li>
<li><strong>AWR_MONITOR_TX2_POWER_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含显式监控线性调频期间测得的 TX2 功率值。</li>
<li><strong>AWR_MONITOR_TX0_BALLBREAK_REPORT_AE_SB</strong>：该API是AWR设备发送到主机的监控报告API，包含测量的TX反射系数的幅度值，用于检测TX ball break。</li>
<li><strong>AWR_MONITOR_TX1_BALLBREAK_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含测量的 TX 反射系数的幅度值，用于检测TX ball break。（感觉这个跟TX0配置一样，不懂它们之间有个啥区别）</li>
</ul>
</li>
</ul>
<h2 id="17-AWR-RF-ASYNC-EVENT-MSG2"><a href="#17-AWR-RF-ASYNC-EVENT-MSG2" class="headerlink" title="17. AWR_RF_ASYNC_EVENT_MSG2"></a>17. AWR_RF_ASYNC_EVENT_MSG2</h2><ul>
<li>AWR_RF_ASYNC_EVENT_MSG2消息由雷达收发器发送到主机。此消息表示设备内发生了特定事件。</li>
<li>这个信号的数据有17个block：<ul>
<li><strong>AWR_MONITOR_TX2_BALLBREAK_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含测量的 TX 反射系数的幅度值，用于检测TX ball break。（感觉这个跟TX0配置一样，不懂它们之间有个啥区别）</li>
<li><strong>AWR_MONITOR_TX_GAIN_PHASE_MISMATCH_ REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含显式监控线性调频期间测得的 TX 增益和相位失配值。</li>
<li><strong>AWR_MONITOR_TX0_PHASE_SHIFTER_REPORT_AE_ SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含测量的 TX0 相位值、幅度值和噪声功率。</li>
<li><strong>AWR_MONITOR_TX1_PHASE_SHIFTER_REPORT_AE_ SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含测量的 TX1 相位值、幅度值和噪声功率。</li>
<li><strong>AWR_MONITOR_TX2_PHASE_SHIFTER_REPORT_AE_ SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含测量的 TX2 相位值、幅度值和噪声功率。</li>
<li><strong>AWR_MONITOR_SYNTHESIZER_FREQUENCY_ REPORT_AE_SB</strong>：该 API 是 AWR 设备发送到主机的监控报告 API，其中包含与线性调频期间测量的频率误差相关的信息。</li>
<li><strong>AWR_MONITOR_EXTERNAL_ANALOG_SIGNALS_ REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含使用 GPADC 测量的外部信号电压值。</li>
<li><strong>AWR_MONITOR_TX0_INTERNAL_ANALOG_SIGNALS_ REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，包含有关内部 TX0内部模拟信号的信息，包括 Tx 移相器 DAC 监控报告。</li>
<li><strong>AWR_MONITOR_TX1_INTERNAL_ANALOG_SIGNALS_ REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，包含有关内部 TX1内部模拟信号的信息，包括 Tx 移相器 DAC 监控报告。</li>
<li><strong>AWR_MONITOR_TX2_INTERNAL_ANALOG_ SIGNALS_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含有关内部 TX2 内部模拟信号的信息。</li>
<li><strong>AWR_MONITOR_RX_INTERNAL_ANALOG_ SIGNALS_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含有关内部 RX 内部模拟信号的信息。</li>
<li><strong>AWR_MONITOR_PMCLKLO_INTERNAL_ANALOG_ SIGNALS_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含有关内部 PM、CLK 和 LO 子系统的内部模拟信号以及级联设备中 20GHz 同步输入/输出功率的信息。</li>
<li><strong>AWR_MONITOR_GPADC_INTERNAL_ANALOG_ SIGNALS_REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含有关已启用测量的 GPADC 输入直流信号的测量值的信息。</li>
<li><strong>AWR_MONITOR_PLL_CONTROL_VOLTAGE_ REPORT_AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含显式监控线性调频期间测得的 PLL 控制电压值。</li>
<li><strong>AWR_MONITOR_DUAL_CLOCK_COMP_REPORT_ AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含有关相对频率测量的信息。</li>
<li><strong>AWR_MONITOR_RX_MIXER_IN_POWER_REPORT_ AE_SB</strong>：此 API 是 AWR 设备发送到主机的监控报告 API，其中包含测量的 RX 混频器输入电压摆幅值。</li>
<li><strong>AWR_MONITOR_SYNTHESIZER_FREQUENCY_ NONLIVE_REPORT_AE_SB</strong>：这是 AWR2243/xWR6243 器件新增的一项功能。此 API 是设备发送到主机的非实时监控报告 SB，其中包含与两个配置文件配置的监控线性调频期间测量的频率错误相关的信息。</li>
</ul>
</li>
</ul>
<h2 id="18-AWR-DEV-RFPOWERUP-MSG"><a href="#18-AWR-DEV-RFPOWERUP-MSG" class="headerlink" title="18. AWR_DEV_RFPOWERUP_MSG"></a>18. AWR_DEV_RFPOWERUP_MSG</h2><h2 id="19-AWR-DEV-CONF-SET-MSG"><a href="#19-AWR-DEV-CONF-SET-MSG" class="headerlink" title="19. AWR_DEV_CONF_SET_MSG"></a>19. AWR_DEV_CONF_SET_MSG</h2><h2 id="20-AWR-DEV-CONF-GET-MSG"><a href="#20-AWR-DEV-CONF-GET-MSG" class="headerlink" title="20. AWR_DEV_CONF_GET_MSG"></a>20. AWR_DEV_CONF_GET_MSG</h2><h2 id="21-AWR-DEV-FILE-DOWNLOAD-MSG"><a href="#21-AWR-DEV-FILE-DOWNLOAD-MSG" class="headerlink" title="21. AWR_DEV_FILE_DOWNLOAD_MSG"></a>21. AWR_DEV_FILE_DOWNLOAD_MSG</h2><h2 id="22-AWR-DEV-FRAME-CONFIG-APPLY-MSG"><a href="#22-AWR-DEV-FRAME-CONFIG-APPLY-MSG" class="headerlink" title="22. AWR_DEV_FRAME_CONFIG_APPLY_MSG"></a>22. AWR_DEV_FRAME_CONFIG_APPLY_MSG</h2><h2 id="23-AWR-DEV-STATUS-GET-MSG"><a href="#23-AWR-DEV-STATUS-GET-MSG" class="headerlink" title="23. AWR_DEV_STATUS_GET_MSG"></a>23. AWR_DEV_STATUS_GET_MSG</h2><h2 id="24-AWR-DEV-ASYNC-EVENT-MSG"><a href="#24-AWR-DEV-ASYNC-EVENT-MSG" class="headerlink" title="24. AWR_DEV_ASYNC_EVENT_MSG"></a>24. AWR_DEV_ASYNC_EVENT_MSG</h2><hr>
<h1 id="API的编程顺序"><a href="#API的编程顺序" class="headerlink" title="API的编程顺序"></a>API的编程顺序</h1>]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>TI</tag>
        <tag>AWR2243</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之典型IP核</title>
    <url>/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/</url>
    <content><![CDATA[<p>本节主要介绍了数字信号处理在FPGA硬件实现中，经常需要使用的IP核（基于vivado的开发环境）。</p>
<span id="more"></span>
<h1 id="乘法器IP核的使用"><a href="#乘法器IP核的使用" class="headerlink" title="乘法器IP核的使用"></a>乘法器IP核的使用</h1><h2 id="1-IP核的相关配置"><a href="#1-IP核的相关配置" class="headerlink" title="1.IP核的相关配置"></a>1.IP核的相关配置</h2><p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231012150732762.png" alt="image-20231012150732762" style="zoom:50%;"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231012144456111.png" alt="image-20231012144456111" style="zoom:50%;"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231012151357723.png" alt="image-20231012151357723"></p>
<h2 id="2-Testbench"><a href="#2-Testbench" class="headerlink" title="2.Testbench"></a>2.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mulit_ip_tb();</span><br><span class="line">	<span class="comment">// Inputs</span></span><br><span class="line">	<span class="keyword">reg</span> clk;</span><br><span class="line">	<span class="keyword">reg</span> sclr;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">17</span>:<span class="number">0</span>] a;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">17</span>:<span class="number">0</span>] b;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Outputs</span></span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">35</span>:<span class="number">0</span>] p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the Unit Under Test (UUT)</span></span><br><span class="line">	mult_gen_0 uut (</span><br><span class="line">		<span class="variable">.CLK</span>(clk), </span><br><span class="line">		<span class="variable">.SCLR</span>(sclr), </span><br><span class="line">		<span class="variable">.A</span>(a), </span><br><span class="line">		<span class="variable">.B</span>(b), </span><br><span class="line">		<span class="variable">.P</span>(p)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		clk = <span class="number">0</span>;     <span class="comment">//设置时钟信号初始状态</span></span><br><span class="line">		sclr = <span class="number">1</span>;    <span class="comment">//上电后开始复位清零</span></span><br><span class="line">		a = <span class="number">0</span>;       <span class="comment">//设置输入信号的初始状态</span></span><br><span class="line">		b = <span class="number">0</span>;       <span class="comment">//设置输入信号的初始状态</span></span><br><span class="line">		#<span class="number">100</span>;        <span class="comment">//等待100ns</span></span><br><span class="line">		sclr = <span class="number">0</span>;    <span class="comment">//取消复位清零</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//生成周期为20ns，频率为50MHz的时钟信号</span></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> clk &lt;= ~clk;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//生成两个输入信号a、b</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        a &lt;= a + <span class="number">10</span> ;</span><br><span class="line">		b &lt;= b + <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231012153823359.png" alt="image-20231012153823359"></p>
</li>
</ul>
<hr>
<h1 id="ROM-IP核的使用"><a href="#ROM-IP核的使用" class="headerlink" title="ROM IP核的使用"></a>ROM IP核的使用</h1><h2 id="1-IP核的相关配置-1"><a href="#1-IP核的相关配置-1" class="headerlink" title="1.IP核的相关配置"></a>1.IP核的相关配置</h2><p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231012164231297.png" alt="image-20231012164231297" style="zoom:50%;"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231012164449327.png" alt="image-20231012164449327"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231012170057287.png" alt="image-20231012170057287"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231012170346016.png" alt="image-20231012170346016"></p>
<h2 id="2-MATLAB代码"><a href="#2-MATLAB代码" class="headerlink" title="2.MATLAB代码"></a>2.MATLAB代码</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%           参数定义</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">fc=<span class="number">3e6</span>;         <span class="comment">% 信号频率</span></span><br><span class="line">fs=<span class="number">65e6</span>;        <span class="comment">% 采样频率</span></span><br><span class="line">L=<span class="number">1024</span>;          <span class="comment">% 采样点数</span></span><br><span class="line">ADC_bit=<span class="number">16</span>;     <span class="comment">% 采样位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%              产生信号</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:(L<span class="number">-1</span>)/fs;</span><br><span class="line">noise=<span class="built_in">randn</span>(<span class="number">1</span>,<span class="built_in">length</span>(t));</span><br><span class="line">noise=<span class="number">0</span>;</span><br><span class="line">st=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*t)+noise;</span><br><span class="line">y=st/<span class="built_in">max</span>(<span class="built_in">abs</span>(st));                 <span class="comment">% 归一化</span></span><br><span class="line">yt=<span class="built_in">round</span>(y*(<span class="number">2</span>^(ADC_bit<span class="number">-1</span>)<span class="number">-1</span>));     <span class="comment">% 16bit量化</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(st);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(y);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(yt);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%            MATLAB生成coe文件</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 在.coe文件中</span></span><br><span class="line"><span class="comment">% 第一行为定义数据格式, 2代表 ROM 的数据格式为二进制。</span></span><br><span class="line"><span class="comment">% 从第 3 行开始到第最后一行，是这个  L（数据长度为1024）* ADC_bit（16bit） 大小 ROM 的初始化数据。</span></span><br><span class="line"><span class="comment">% 第一行到倒数第二行的数字后面用逗号，最后一行数字结束用分号。</span></span><br><span class="line">fid=fopen(<span class="string">&#x27;data0.coe&#x27;</span>,<span class="string">&#x27;w&#x27;</span>); </span><br><span class="line">fprintf(fid,<span class="string">&#x27;Memory_Initialization_Radix = 2;\r\n&#x27;</span>); <span class="comment">% 二进制</span></span><br><span class="line">fprintf(fid,<span class="string">&#x27;Memory_Initialization_Vector = \r\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> p=<span class="number">1</span>:L</span><br><span class="line">    B_s=dec2bin(yt(p)+(yt(p)&lt;<span class="number">0</span>)*<span class="number">2</span>^ADC_bit,ADC_bit);<span class="comment">%十进制转二进制</span></span><br><span class="line">    <span class="keyword">for</span> q=<span class="number">1</span>:ADC_bit  <span class="comment">% 16位，依次判断这16位的数值</span></span><br><span class="line">        <span class="keyword">if</span> B_s(q)==<span class="string">&#x27;1&#x27;</span></span><br><span class="line">            data=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d&#x27;</span>,data);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%  下面if语句的目的</span></span><br><span class="line">    <span class="comment">%  每行数字后面用逗号(,)，最后一行数字结束用分号(;)</span></span><br><span class="line">    <span class="keyword">if</span> (p&lt;L)</span><br><span class="line">        fprintf(fid,<span class="string">&#x27;,\r\n&#x27;</span>); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;;\r\n&#x27;</span>);    <span class="comment">% 分号(;)  结束标志位</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench"><a href="#3-Testbench" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> rom_ip_tb();</span><br><span class="line">    <span class="keyword">reg</span> sys_clk; <span class="comment">//50MHz时钟</span></span><br><span class="line">    <span class="keyword">reg</span> rst_n;   <span class="comment">//复位，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] rom_data; <span class="comment">//ROM读出数据  每个数据有16bit</span></span><br><span class="line">    <span class="keyword">reg</span>  [<span class="number">9</span>:<span class="number">0</span>]  rom_addr; <span class="comment">//ROM输入地址  1024个数据，需要2^10个地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//产生ROM地址读取数据</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n)</span><br><span class="line">            rom_addr &lt;= <span class="number">10&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rom_addr &lt;= rom_addr+<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化ROM</span></span><br><span class="line">    blk_mem_gen_0 rom_ip_inst</span><br><span class="line">    (</span><br><span class="line">        <span class="variable">.clka</span> (sys_clk ),   <span class="comment">//inoput clka</span></span><br><span class="line">        <span class="variable">.addra</span> (rom_addr ), <span class="comment">//input [9:0] addra  1024个数据，需要2^10个地址</span></span><br><span class="line">        <span class="variable">.douta</span> (rom_data )  <span class="comment">//output [15:0] douta    </span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        sys_clk = <span class="number">0</span>;</span><br><span class="line">        rst_n = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">21</span> rst_n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> sys_clk = ~sys_clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231012172524577.png" alt="image-20231012172524577"></p>
</li>
<li><p>其实结构输出data数据与上升沿并不是齐平的，说明不能在上升沿结束立马得到数据，而是有一定延时</p>
</li>
</ul>
<h2 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4.Reference"></a>4.Reference</h2><ul>
<li><a href="https://blog.csdn.net/weixin_46136963/article/details/118367784">Vivado ROM IP的生成和调用_ila waveform style_ML__LM的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/wordwarwordwar/article/details/82811449">Vivado中单端口和双端口RAM的区别-CSDN博客</a></li>
<li><a href="https://ica123.com/archives/22650">Vivado真双端口（TDP）RAM IP核的生成与配置详解 - 芯片天地 (ica123.com)</a></li>
</ul>
<hr>
<h1 id="DDS-IP核的使用"><a href="#DDS-IP核的使用" class="headerlink" title="DDS IP核的使用"></a>DDS IP核的使用</h1><ul>
<li><p>DDS的作用，产生正余弦波</p>
</li>
<li><p>其产生原理如下图，其通过在圆周上不断旋转，在y轴和x轴上的投影构成正余弦波：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231120165850569.png" alt="image-20231120165850569" style="zoom: 80%;"></p>
</li>
<li><p>每个时钟周期旋转一格，当在一圈内旋转的格越多时（即把圆分成的份数越多时），精度越高，设格数为$2^B,B为bit数$，那么输出频率$f_{out}$为：</p>
<script type="math/tex; mode=display">
f_{out} = \frac{f_{clk}}{2^B}</script></li>
<li><p>那么在时钟频率和bit数都确定时，如何调整输出频率呢？用通俗易懂的话来说，也就是：虽然圆被分成了很多份，但我读格子的时候，隔几格再读一个数，不就可以改变输出频率了么，设读数的间隔为$F_{cw}$，则输出频率$f_{out}$有：</p>
<script type="math/tex; mode=display">
f_{out}=F_{cw}\cdot \frac{f_{clk}}{2^B}</script><ul>
<li>其实，$\frac{f_{clk}}{2^B}$就相当于数字频率分辨率（类比FFT的采样频率$f_s$）</li>
</ul>
</li>
</ul>
<h2 id="1-IP核的相关配置-2"><a href="#1-IP核的相关配置-2" class="headerlink" title="1.IP核的相关配置"></a>1.IP核的相关配置</h2><p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231120171253311.png" alt="image-20231120171253311" style="zoom: 33%;"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231120171453447.png" alt="image-20231120171453447" style="zoom:33%;"></p>
<h2 id="2-Testbench-1"><a href="#2-Testbench-1" class="headerlink" title="2.Testbench"></a>2.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ms / 1ms </span><span class="comment">//这里这里仿真的尺度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> DDS_ip_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk_100Hz;</span><br><span class="line">    <span class="keyword">wire</span> out_valid;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] sin_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生2Hz的正弦信号</span></span><br><span class="line">    dds_compiler_0 u1(</span><br><span class="line">        <span class="variable">.aclk</span>(clk_100Hz),</span><br><span class="line">        <span class="variable">.s_axis_config_tvalid</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">        <span class="variable">.s_axis_config_tdata</span>(<span class="number">16&#x27;d1311</span>),</span><br><span class="line">        <span class="variable">.m_axis_data_tvalid</span>(out_valid),</span><br><span class="line">        <span class="variable">.m_axis_data_tdata</span>(sin_data)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		clk_100Hz = <span class="number">0</span>;</span><br><span class="line">		#<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk_100Hz &lt;= ~clk_100Hz;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231120164947730.png" alt="image-20231120164947730"></p>
</li>
</ul>
<hr>
<h1 id="FIR-IP核的使用"><a href="#FIR-IP核的使用" class="headerlink" title="FIR IP核的使用"></a>FIR IP核的使用</h1><h2 id="1-IP核的相关配置-3"><a href="#1-IP核的相关配置-3" class="headerlink" title="1.IP核的相关配置"></a>1.IP核的相关配置</h2><p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231121155548381.png" alt="image-20231121155548381"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231121155927847.png" alt="image-20231121155927847"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231121160309324.png" alt="image-20231121160309324"></p>
<h2 id="2-MATLAB代码-1"><a href="#2-MATLAB代码-1" class="headerlink" title="2.MATLAB代码"></a>2.MATLAB代码</h2><ul>
<li>注意：下述代码中量化与在FIR滤波器设计这一节中提到的不一致，下述代码中直接乘以$2^{11}$，方便后续右移11将大小还原</li>
<li>下述matlab代码主要用来求滤波系数，其实可以用matlab中<code>filterDesigner</code>可视化的GUI设计滤波器并导出coe系数文件</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N=<span class="number">62</span>;                              <span class="comment">%滤波器长度</span></span><br><span class="line">fs=<span class="number">12.5</span>*<span class="number">10</span>^<span class="number">6</span>;                      <span class="comment">%采样频率</span></span><br><span class="line">fc=<span class="number">10</span>^<span class="number">6</span>;                           <span class="comment">%低通滤波器的3dB截止频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%采用fir1函数设计FIR滤波器</span></span><br><span class="line">b=fir1(N<span class="number">-1</span>,fc*<span class="number">2</span>/fs);</span><br><span class="line"></span><br><span class="line"><span class="comment">%对滤波器系数进行量化</span></span><br><span class="line">B=<span class="number">12</span>;                              <span class="comment">%量化位宽为12比特</span></span><br><span class="line"><span class="comment">%Q_h=b/max(abs(b));                 %系数归一化处理</span></span><br><span class="line"><span class="comment">%Q_h=Q_h*(2^(B-1)-1);               %乘以B比特位宽的最大正整数</span></span><br><span class="line">Q_h=b*(<span class="number">2</span>^<span class="number">11</span>);               <span class="comment">%乘以B比特位宽的最大正整数</span></span><br><span class="line">Q_h12=<span class="built_in">round</span>(Q_h);                  <span class="comment">%四舍五入</span></span><br><span class="line"></span><br><span class="line">ma=<span class="built_in">max</span>(<span class="built_in">abs</span>(Q_h12))</span><br><span class="line"></span><br><span class="line"><span class="comment">%将生成的滤波器系数数据写入FPGA所需的COE文件中</span></span><br><span class="line">fid=fopen(<span class="string">&#x27;D:\App_Data_File\Vivado_data\Vivado_project\DSP_design\FIR_design\fir_coefficient.coe&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);  <span class="comment">%新建并打开COE文件</span></span><br><span class="line">fprintf(fid,<span class="string">&#x27;radix = 10;\r\n&#x27;</span>);    <span class="comment">%写滤波器系数的进制</span></span><br><span class="line">fprintf(fid,<span class="string">&#x27;coefdata =\r\n&#x27;</span>);     <span class="comment">%写系数数据的标识</span></span><br><span class="line">fprintf(fid,<span class="string">&#x27;%8d\r\n&#x27;</span>,Q_h12);      <span class="comment">%写滤波器系数</span></span><br><span class="line">fprintf(fid,<span class="string">&#x27;;&#x27;</span>);                  <span class="comment">%写分号“;”</span></span><br><span class="line">fclose(fid);                       <span class="comment">%关闭COE文件</span></span><br><span class="line"></span><br><span class="line">m=sum(<span class="built_in">abs</span>(Q_h12))                  <span class="comment">%求滤波器系数绝对值之和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%求滤波器的幅频响应</span></span><br><span class="line">m_12=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(fft(Q_h12,<span class="number">1024</span>)));</span><br><span class="line"> <span class="comment">%对幅频响应归一化处理</span></span><br><span class="line">m_12=m_12-<span class="built_in">max</span>(m_12); </span><br><span class="line"></span><br><span class="line"><span class="comment">%设置幅频响应的横坐标单位为MHz</span></span><br><span class="line">x_f=[<span class="number">0</span>:(fs/<span class="built_in">length</span>(m_12)):fs/<span class="number">2</span>]/<span class="number">10</span>^<span class="number">6</span>;</span><br><span class="line"><span class="comment">%只显示正频率部分的幅频响应</span></span><br><span class="line">m12=m_12(<span class="number">1</span>:<span class="built_in">length</span>(x_f));</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘制幅频响应曲线</span></span><br><span class="line"><span class="built_in">plot</span>(x_f,m12);</span><br><span class="line">xlabel(<span class="string">&#x27;频率(MHz)&#x27;</span>);ylabel(<span class="string">&#x27;幅度(dB)&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;12bit量化&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/untitled.bmp" alt="untitled" style="zoom: 67%;"></p>
<h2 id="3-Testbench-1"><a href="#3-Testbench-1" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><ul>
<li><p>FIR_ip_design.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FIR_ip_design(</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> clk_data,    <span class="comment">//12.5MHz</span></span><br><span class="line">	<span class="keyword">input</span> clk_fir,     <span class="comment">//50MHz</span></span><br><span class="line">    <span class="keyword">output</span> m_data_tvalid,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">19</span>:<span class="number">0</span>] dout,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">8</span>:<span class="number">0</span>] dout_normal</span><br><span class="line">    );</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] xin;</span><br><span class="line">    <span class="keyword">wire</span> s_tready;</span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">23</span>:<span class="number">0</span>] m_tdata;</span><br><span class="line"></span><br><span class="line">    fir_ip_test_data u0 (</span><br><span class="line">       <span class="variable">.clk</span>(clk_data), </span><br><span class="line">       <span class="variable">.dout</span>(xin)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    fir_compiler_0 u1 (</span><br><span class="line">      <span class="variable">.aclk</span>(clk_fir),  <span class="comment">// input clk</span></span><br><span class="line">      <span class="variable">.s_axis_data_tvalid</span>(<span class="number">1&#x27;b1</span>),         </span><br><span class="line">      <span class="variable">.s_axis_data_tready</span>(s_tready),         </span><br><span class="line">      <span class="variable">.s_axis_data_tdata</span>(xin),      <span class="comment">// input [7 : 0] din</span></span><br><span class="line">      <span class="variable">.m_axis_data_tvalid</span>(m_data_tvalid),</span><br><span class="line">      <span class="variable">.m_axis_data_tdata</span>(m_tdata)     <span class="comment">// output [23 : 0] dout,因为axi4总线的最小单位是8bit，所以自动补齐到24bit</span></span><br><span class="line">    );   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> dout = m_tdata[<span class="number">19</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> dout_normal = dout[<span class="number">19</span>:<span class="number">11</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>fir_ip_test_data.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fir_ip_test_data(</span><br><span class="line">    <span class="keyword">input</span> clk,                        <span class="comment">//系统时钟为12.5MHz</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] dout      <span class="comment">//输出为500kHz和2MHz的叠加信号</span></span><br><span class="line">    );</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">7</span>:<span class="number">0</span>] sin500k,sin2m; <span class="comment">//实际DDS ip核设置的是7bit，为了使modelsim仿真不报错，设置为8bit</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//生成500kHz的正弦信号</span></span><br><span class="line">	dds_for_fir_ip u1(</span><br><span class="line">	  <span class="variable">.aclk</span>(clk), </span><br><span class="line">	  <span class="variable">.s_axis_config_tvalid</span>(<span class="number">1&#x27;b1</span>), </span><br><span class="line">	  <span class="variable">.s_axis_config_tdata</span>(<span class="number">16&#x27;d2621</span>),</span><br><span class="line">      <span class="variable">.m_axis_data_tvalid</span>(),</span><br><span class="line">	  <span class="variable">.m_axis_data_tdata</span>(sin500k) </span><br><span class="line">    );</span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//生成2MHz的正弦信号</span></span><br><span class="line">	dds_for_fir_ip u2 (</span><br><span class="line">	  <span class="variable">.aclk</span>(clk), </span><br><span class="line">	  <span class="variable">.s_axis_config_tvalid</span>(<span class="number">1&#x27;b1</span>), </span><br><span class="line">	  <span class="variable">.s_axis_config_tdata</span>(<span class="number">16&#x27;d10486</span>), </span><br><span class="line">      <span class="variable">.m_axis_data_tvalid</span>(),</span><br><span class="line">	  <span class="variable">.m_axis_data_tdata</span>(sin2m) </span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//求和运算输出频率叠加信号</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">	   dout &lt;= sin500k + sin2m;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FIR_ip_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FIR_ip_tb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inputs</span></span><br><span class="line">	<span class="keyword">reg</span> rst;</span><br><span class="line">	<span class="keyword">reg</span> clk_data;</span><br><span class="line">	<span class="keyword">reg</span> clk_fir;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Outputs</span></span><br><span class="line">    <span class="keyword">wire</span> m_data_tvalid;</span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">19</span>:<span class="number">0</span>] dout;</span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">0</span>] dout_normal;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the Unit Under Test (UUT)</span></span><br><span class="line">	FIR_ip_design uut (</span><br><span class="line">		<span class="variable">.rst</span>(rst), </span><br><span class="line">		<span class="variable">.clk_data</span>(clk_data), </span><br><span class="line">		<span class="variable">.clk_fir</span>(clk_fir), </span><br><span class="line">        <span class="variable">.m_data_tvalid</span>(m_data_tvalid),</span><br><span class="line">		<span class="variable">.dout</span>(dout),</span><br><span class="line">		<span class="variable">.dout_normal</span>(dout_normal)</span><br><span class="line">	);</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">reg</span> clk_100m;</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="comment">// Initialize Inputs</span></span><br><span class="line">		rst = <span class="number">1</span>;</span><br><span class="line">		clk_data = <span class="number">0</span>;</span><br><span class="line">		clk_fir = <span class="number">0</span>;</span><br><span class="line">		clk_100m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Wait 100 ns for global reset to finish</span></span><br><span class="line">		#<span class="number">100</span>;</span><br><span class="line">        rst = <span class="number">0</span>;  </span><br><span class="line">		<span class="comment">// Add stimulus here</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk_100m &lt;= !clk_100m;  </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cn=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_100m) <span class="keyword">begin</span></span><br><span class="line">        cn &lt;= cn + <span class="number">1</span>;</span><br><span class="line">        clk_fir &lt;= cn[<span class="number">0</span>];    <span class="comment">//50MHz</span></span><br><span class="line">        clk_data &lt;= cn[<span class="number">2</span>];   <span class="comment">//12.5MHz</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>仿真结果如下：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231121161030105.png" alt="image-20231121161030105"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231121205139577.png" alt="image-20231121205139577"></p>
</li>
</ul>
<h2 id="4-Reference-1"><a href="#4-Reference-1" class="headerlink" title="4.Reference"></a>4.Reference</h2><ul>
<li><a href="https://blog.csdn.net/keilzc/article/details/104249702">Vivado FIR滤波器IP核实现_vivado的fir滤波器ip核用法-CSDN博客</a></li>
<li><a href="https://www.bilibili.com/video/BV1rh41157xL/?spm_id_from=333.999.0.0&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">Xilinx/ISE版 FPGA数字信号处理－完整的FIR核设计过程_哔哩哔哩_bilibili</a></li>
<li><a href="https://blog.csdn.net/Multiroad/article/details/126164902">基于xilinx-IP的FIR滤波器多通道实现_xilinx fir滤波-CSDN博客</a></li>
</ul>
<hr>
<h1 id="FFT-IP核的使用"><a href="#FFT-IP核的使用" class="headerlink" title="FFT IP核的使用"></a>FFT IP核的使用</h1><h2 id="1-IP核的相关配置-4"><a href="#1-IP核的相关配置-4" class="headerlink" title="1.IP核的相关配置"></a>1.IP核的相关配置</h2><p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231024141407431.png" alt="image-20231024141407431" style="zoom:50%;"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231024142435510.png" alt="image-20231024142435510" style="zoom:50%;"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231024143541679.png" alt="image-20231024143541679" style="zoom:50%;"></p>
<h2 id="2-MATLAB代码-2"><a href="#2-MATLAB代码-2" class="headerlink" title="2.MATLAB代码"></a>2.MATLAB代码</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%           参数定义</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">fs=<span class="number">100</span>;        <span class="comment">% 采样频率</span></span><br><span class="line">f1 = <span class="number">10</span>;       <span class="comment">% 信号频率</span></span><br><span class="line">f2 = <span class="number">30</span>;</span><br><span class="line">L=<span class="number">128</span>;         <span class="comment">% 采样点数</span></span><br><span class="line">ADC_bit=<span class="number">16</span>;    <span class="comment">% 采样点数据的位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%              产生信号</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:(L<span class="number">-1</span>)/fs;</span><br><span class="line">s1 = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f1*t);    </span><br><span class="line">s2 = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f2*t);</span><br><span class="line">st = <span class="number">2</span> + s1 + s2;</span><br><span class="line">y=st/<span class="built_in">max</span>(<span class="built_in">abs</span>(st));                 <span class="comment">% 归一化</span></span><br><span class="line">yt=<span class="built_in">round</span>(y*(<span class="number">2</span>^(ADC_bit<span class="number">-1</span>)<span class="number">-1</span>));     <span class="comment">% 16bit量化</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(st);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(y);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(yt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%            MATLAB生成TXT文件</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%。</span></span><br><span class="line">fid=fopen(<span class="string">&#x27;D:\App_Data_File\Vivado_data\Vivado_project\Zynq7020_Project\FFT_ip\MATLABdata_before_fft.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>); </span><br><span class="line"><span class="keyword">for</span> p=<span class="number">1</span>:L</span><br><span class="line">    B_s=dec2bin(yt(p)+(yt(p)&lt;<span class="number">0</span>)*<span class="number">2</span>^ADC_bit,ADC_bit);<span class="comment">%十进制转二进制</span></span><br><span class="line">    <span class="keyword">for</span> q=<span class="number">1</span>:ADC_bit  <span class="comment">% 16位，依次判断这16位的数值</span></span><br><span class="line">        <span class="keyword">if</span> B_s(q)==<span class="string">&#x27;1&#x27;</span></span><br><span class="line">            data=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d&#x27;</span>,data);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p&lt;L)</span><br><span class="line">        fprintf(fid,<span class="string">&#x27;\r\n&#x27;</span>); </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);</span><br><span class="line">y = fft(yt,L);</span><br><span class="line">y = <span class="built_in">abs</span>(y);</span><br><span class="line">n = <span class="number">0</span>:(L<span class="number">-1</span>);</span><br><span class="line">f = n*fs/L;</span><br><span class="line"><span class="built_in">plot</span>(f,y);</span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-2"><a href="#3-Testbench-2" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231024232553967.png" alt="image-20231024232553967" style="zoom:50%;"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fft_tb2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>  clk;</span><br><span class="line">    <span class="keyword">reg</span>  rst_n;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] dati_in;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] datq_in;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">23</span>:<span class="number">0</span>]  dati_out;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">23</span>:<span class="number">0</span>]  datq_out;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>]   dataI [<span class="number">127</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">47</span>:<span class="number">0</span>]  fft_abs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>  fft_s_data_tvalid;</span><br><span class="line">    <span class="keyword">wire</span>  [<span class="number">31</span>:<span class="number">0</span>] fft_s_data_tdata;</span><br><span class="line">    <span class="comment">//reg  fft_s_data_tlast;</span></span><br><span class="line">    <span class="keyword">wire</span> fft_s_config_tready;</span><br><span class="line">    <span class="keyword">wire</span>          fft_s_data_tready;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">47</span>:<span class="number">0</span>] fft_m_data_tdata;</span><br><span class="line">    <span class="keyword">wire</span>          fft_m_data_tvalid;</span><br><span class="line">    <span class="keyword">wire</span>          fft_m_data_tlast;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>]    fft_m_data_tuser;</span><br><span class="line">    <span class="keyword">wire</span>          fft_event_frame_started;</span><br><span class="line">    <span class="keyword">wire</span>          fft_event_tlast_unexpected;</span><br><span class="line">    <span class="keyword">wire</span>          fft_event_tlast_missing;</span><br><span class="line">    <span class="keyword">wire</span>          fft_event_status_channel_halt;</span><br><span class="line">    <span class="keyword">wire</span>          fft_event_data_in_channel_halt;</span><br><span class="line">    <span class="keyword">wire</span>          fft_event_data_out_channel_halt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span>  <span class="keyword">begin</span></span><br><span class="line">    clk=<span class="number">1</span>;</span><br><span class="line">    rst_n=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//fft_s_data_tlast=1&#x27;b0;</span></span><br><span class="line">    fft_s_data_tvalid=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    dati_in=<span class="number">0</span>;</span><br><span class="line">    datq_in=<span class="number">0</span>;</span><br><span class="line">    dati_out=<span class="number">0</span>;</span><br><span class="line">    datq_out=<span class="number">0</span>;</span><br><span class="line">    fft_abs=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">$readmemb</span>(<span class="string">&quot;D:\\App_Data_File\\Vivado_data\\Vivado_project\\Zynq7020_Project\\FFT_ip\\MATLABdata_before_fft.txt&quot;</span>,dataI);</span><br><span class="line">    #<span class="number">100</span></span><br><span class="line">    rst_n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span>  clk=~clk;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>]  count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span>  clk)  <span class="keyword">begin</span></span><br><span class="line">       <span class="keyword">if</span> (fft_s_data_tready) <span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">if</span>(count==<span class="number">128</span>) <span class="keyword">begin</span></span><br><span class="line">           fft_s_data_tvalid=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    	   	   <span class="comment">//fft_s_data_tlast=1&#x27;b0;</span></span><br><span class="line">    	   #<span class="number">10000</span></span><br><span class="line">           count=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">    	 <span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">127</span>)<span class="keyword">begin</span></span><br><span class="line">           dati_in&lt;= dataI[count];</span><br><span class="line">           datq_in&lt;=<span class="number">16&#x27;d0</span>;</span><br><span class="line">           fft_s_data_tvalid&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">    	   <span class="comment">//fft_s_data_tlast&lt;=1&#x27;b1;</span></span><br><span class="line">           count&lt;=count+<span class="number">1</span>;	 </span><br><span class="line">    	 <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">           dati_in&lt;= dataI[count];</span><br><span class="line">           datq_in&lt;=<span class="number">16&#x27;d0</span>;</span><br><span class="line">           fft_s_data_tvalid=<span class="number">1&#x27;b1</span>;</span><br><span class="line">           count&lt;=count+<span class="number">1</span>;</span><br><span class="line">    	   <span class="comment">//fft_s_data_tlast&lt;=1&#x27;b0;</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> fft_s_data_tdata = &#123;dati_in,datq_in&#125;; <span class="comment">//尤其注意这里</span></span><br><span class="line"></span><br><span class="line">    fft_test u_fft_test(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">    <span class="variable">.tvalid_i</span>(fft_s_data_tvalid),</span><br><span class="line">    <span class="variable">.tdata_i</span>(fft_s_data_tdata),</span><br><span class="line">    <span class="comment">//.fft_s_data_tlast(fft_s_data_tlast),</span></span><br><span class="line">    <span class="variable">.fft_s_config_tready</span>(fft_s_config_tready),</span><br><span class="line">    <span class="variable">.fft_s_data_tready</span>(fft_s_data_tready),</span><br><span class="line">    <span class="variable">.fft_m_data_tdata</span>(fft_m_data_tdata),</span><br><span class="line">    <span class="variable">.fft_m_data_tvalid</span>(fft_m_data_tvalid),</span><br><span class="line">    <span class="variable">.fft_m_data_tlast</span>(fft_m_data_tlast),</span><br><span class="line">    <span class="variable">.fft_m_data_tuser</span>(fft_m_data_tuser),</span><br><span class="line">    <span class="variable">.fft_event_frame_started</span>(fft_event_frame_started),</span><br><span class="line">    <span class="variable">.fft_event_tlast_unexpected</span>(fft_event_tlast_unexpected),</span><br><span class="line">    <span class="variable">.fft_event_tlast_missing</span>(fft_event_tlast_missing),</span><br><span class="line">    <span class="variable">.fft_event_status_channel_halt</span>(fft_event_status_channel_halt),</span><br><span class="line">    <span class="variable">.fft_event_data_in_channel_halt</span>(fft_event_data_in_channel_halt),</span><br><span class="line">    <span class="variable">.fft_event_data_out_channel_halt</span>(fft_event_data_out_channel_halt)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span>(fft_m_data_tvalid) <span class="keyword">begin</span></span><br><span class="line">        dati_out&lt;=fft_m_data_tdata[<span class="number">23</span>:<span class="number">0</span>];</span><br><span class="line">        datq_out&lt;=fft_m_data_tdata[<span class="number">47</span>:<span class="number">24</span>];    </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">      fft_abs&lt;=<span class="built_in">$signed</span>(dati_out)* <span class="built_in">$signed</span>(dati_out)+ <span class="built_in">$signed</span>(datq_out)* <span class="built_in">$signed</span>(datq_out);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fft_test(</span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">input</span> rst_n,</span><br><span class="line"><span class="keyword">input</span>  tvalid_i,</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] tdata_i,</span><br><span class="line"><span class="comment">//input  fft_s_data_tlast,</span></span><br><span class="line"><span class="keyword">output</span> fft_s_config_tready,</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span>          fft_s_data_tready,</span><br><span class="line"><span class="keyword">output</span> [<span class="number">47</span>:<span class="number">0</span>] fft_m_data_tdata,</span><br><span class="line"><span class="keyword">output</span>          fft_m_data_tvalid,</span><br><span class="line"><span class="keyword">output</span>          fft_m_data_tlast,</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]    fft_m_data_tuser,</span><br><span class="line"><span class="keyword">output</span>          fft_event_frame_started,</span><br><span class="line"><span class="keyword">output</span>          fft_event_tlast_unexpected,</span><br><span class="line"><span class="keyword">output</span>          fft_event_tlast_missing,</span><br><span class="line"><span class="keyword">output</span>          fft_event_status_channel_halt,</span><br><span class="line"><span class="keyword">output</span>          fft_event_data_in_channel_halt,</span><br><span class="line"><span class="keyword">output</span>          fft_event_data_out_channel_halt</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>  fft_s_data_tvalid=<span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">31</span>:<span class="number">0</span>] fft_s_data_tdata=<span class="number">32&#x27;d0</span>;</span><br><span class="line"><span class="keyword">reg</span>  fft_s_data_tlast=<span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>]  count=<span class="number">8&#x27;d0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span>  clk)  <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">    fft_s_data_tvalid&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    fft_s_data_tdata&lt;=<span class="number">32&#x27;d0</span>;</span><br><span class="line">    fft_s_data_tlast&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    count&lt;=<span class="number">8&#x27;d0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (tvalid_i &amp;&amp; fft_s_data_tready) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">127</span>)<span class="keyword">begin</span></span><br><span class="line">        fft_s_data_tvalid&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">	      fft_s_data_tlast&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">	      fft_s_data_tdata&lt;=tdata_i;</span><br><span class="line">        count&lt;=<span class="number">0</span>;	 </span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        fft_s_data_tvalid=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        count&lt;=count+<span class="number">1</span>;</span><br><span class="line">	      fft_s_data_tlast&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">	      fft_s_data_tdata&lt;=tdata_i;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    fft_s_data_tvalid&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">	  fft_s_data_tlast&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">	  fft_s_data_tdata&lt;=fft_s_data_tdata;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  xfft_0 u1_fft(</span><br><span class="line">    <span class="variable">.aclk</span>(clk),                                                <span class="comment">// input wire aclk</span></span><br><span class="line">    <span class="variable">.aresetn</span>(rst_n),                                           <span class="comment">// input wire aresetn</span></span><br><span class="line">    <span class="variable">.s_axis_config_tdata</span>(<span class="number">8&#x27;d1</span>),                                <span class="comment">// input wire [7 : 0] s_axis_config_tdata</span></span><br><span class="line">    <span class="variable">.s_axis_config_tvalid</span>(<span class="number">1&#x27;b1</span>),                               <span class="comment">// input wire s_axis_config_tvalid</span></span><br><span class="line">    <span class="variable">.s_axis_config_tready</span>(fft_s_config_tready),                <span class="comment">// output wire s_axis_config_tready</span></span><br><span class="line">    <span class="variable">.s_axis_data_tdata</span>(fft_s_data_tdata),                      <span class="comment">// input wire [31 : 0] s_axis_data_tdata</span></span><br><span class="line">    <span class="variable">.s_axis_data_tvalid</span>(fft_s_data_tvalid),                    <span class="comment">// input wire s_axis_data_tvalid</span></span><br><span class="line">    <span class="variable">.s_axis_data_tready</span>(fft_s_data_tready),                    <span class="comment">// output wire s_axis_data_tready</span></span><br><span class="line">    <span class="variable">.s_axis_data_tlast</span>(fft_s_data_tlast),                      <span class="comment">// input wire s_axis_data_tlast</span></span><br><span class="line">    <span class="variable">.m_axis_data_tdata</span>(fft_m_data_tdata),                      <span class="comment">// output wire [47 : 0] m_axis_data_tdata</span></span><br><span class="line">    <span class="variable">.m_axis_data_tuser</span>(fft_m_data_tuser),                      <span class="comment">// output wire [7 : 0] m_axis_data_tuser</span></span><br><span class="line">    <span class="variable">.m_axis_data_tvalid</span>(fft_m_data_tvalid),                    <span class="comment">// output wire m_axis_data_tvalid</span></span><br><span class="line">    <span class="variable">.m_axis_data_tready</span>(<span class="number">1&#x27;b1</span>),                                 <span class="comment">// input wire m_axis_data_tready</span></span><br><span class="line">    <span class="variable">.m_axis_data_tlast</span>(fft_m_data_tlast),                      <span class="comment">// output wire m_axis_data_tlast</span></span><br><span class="line">    <span class="variable">.event_frame_started</span>(fft_event_frame_started),                  <span class="comment">// output wire event_frame_started</span></span><br><span class="line">    <span class="variable">.event_tlast_unexpected</span>(fft_event_tlast_unexpected),            <span class="comment">// output wire event_tlast_unexpected</span></span><br><span class="line">    <span class="variable">.event_tlast_missing</span>(fft_event_tlast_missing),                  <span class="comment">// output wire event_tlast_missing</span></span><br><span class="line">    <span class="variable">.event_status_channel_halt</span>(fft_event_status_channel_halt),      <span class="comment">// output wire event_status_channel_halt</span></span><br><span class="line">    <span class="variable">.event_data_in_channel_halt</span>(fft_event_data_in_channel_halt),    <span class="comment">// output wire event_data_in_channel_halt</span></span><br><span class="line">    <span class="variable">.event_data_out_channel_halt</span>(fft_event_data_out_channel_halt)   <span class="comment">// output wire event_data_out_channel_halt</span></span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231024224042607.png" alt="image-20231024224042607"></p>
</li>
<li><p>放大一点看结果的频谱图</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20231024224616096.png" alt="image-20231024224616096"></p>
</li>
<li><p>这里的结果和matlab中的一致：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/sinwave_for_fft.bmp" alt="sinwave_for_fft"></p>
</li>
</ul>
<h2 id="4-Reference-2"><a href="#4-Reference-2" class="headerlink" title="4.Reference"></a>4.Reference</h2><ul>
<li><a href="https://blog.csdn.net/weixin_41594632/article/details/112689545">Vivado Xilinx FFT IP核v9.0 使用详解（附仿真实例）_vivado fft仿真-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/637653195">vivado FFT ip核全解析。 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/qq_43622265/article/details/105905927">Vivado中FFT IP核的使用_vivado中fft核的用法-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/yanchuan23/article/details/122512191">Vivado联合ModelSim仿真设置（附图步骤）_vivado modelsim_NemoYxc的博客-CSDN博客</a></li>
<li><a href="https://www.bilibili.com/video/BV18h4y1k7PZ/?spm_id_from=333.999.0.0&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">VIVADO快速傅里叶变换FFT IP核详解（端口篇）_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1ah4y1k7A7/?spm_id_from=333.999.0.0&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">VIVADO快速傅里叶变换FFT IP核详解（配置篇）_哔哩哔哩_bilibili</a></li>
</ul>
<hr>
<h1 id="Cordic-IP核的使用"><a href="#Cordic-IP核的使用" class="headerlink" title="Cordic IP核的使用"></a>Cordic IP核的使用</h1><h2 id="1-IP核的相关配置-5"><a href="#1-IP核的相关配置-5" class="headerlink" title="1.IP核的相关配置"></a>1.IP核的相关配置</h2><p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240319191134297.png" alt="image-20240319191134297"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240319192249585.png" alt="image-20240319192249585"></p>
<h2 id="2-Testbench-2"><a href="#2-Testbench-2" class="headerlink" title="2.Testbench"></a>2.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Cordic_ip_tb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// square Parameters</span></span><br><span class="line">    <span class="keyword">parameter</span> PERIOD  = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// square Inputs</span></span><br><span class="line">    <span class="keyword">reg</span>   clk                                  = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">reg</span>   rst_n                                = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">reg</span>   data_in_valid                        = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">reg</span>   [<span class="number">31</span>:<span class="number">0</span>]  data_in                      = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// square Outputs</span></span><br><span class="line">    <span class="keyword">wire</span>  data_out_valid                       ;</span><br><span class="line">    <span class="keyword">wire</span>  [<span class="number">15</span>:<span class="number">0</span>]  data_out                     ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">forever</span> <span class="variable">#(PERIOD/2)</span>  clk=~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">52</span> rst_n  =  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    cordic_square square_U1(</span><br><span class="line">        <span class="variable">.aclk</span>(clk),</span><br><span class="line">        <span class="variable">.aresetn</span>(rst_n),</span><br><span class="line">        <span class="variable">.s_axis_cartesian_tvalid</span>(data_in_valid),</span><br><span class="line">        <span class="variable">.s_axis_cartesian_tdata</span>(data_in),       <span class="comment">//其实data_in最多31bit，VHL参考模板有误，还是得看IP核是如何设置的</span></span><br><span class="line">        <span class="variable">.m_axis_dout_tvalid</span>(data_out_valid),</span><br><span class="line">        <span class="variable">.m_axis_dout_tdata</span>(data_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>	[<span class="number">4</span>:<span class="number">0</span>]		cnt ;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span>	clk <span class="keyword">or</span> <span class="keyword">negedge</span>	rst_n)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(!rst_n)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    data_in_valid &lt;= <span class="number">0</span>;</span><br><span class="line">                    data_in &lt;= <span class="number">0</span>;</span><br><span class="line">                    cnt &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span>	<span class="keyword">if</span>(cnt &lt; <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    data_in_valid &lt;= <span class="number">1</span>;</span><br><span class="line">                    data_in &lt;= &#123;<span class="built_in">$random</span>&#125; % &#123;<span class="number">8</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;</span><br><span class="line">                    cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    data_in_valid &lt;= <span class="number">0</span>;</span><br><span class="line">                    data_in &lt;= <span class="number">0</span>;</span><br><span class="line">                    cnt &lt;= cnt;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="RF-Data-Converter-IP核的使用"><a href="#RF-Data-Converter-IP核的使用" class="headerlink" title="RF Data Converter IP核的使用"></a>RF Data Converter IP核的使用</h1><h2 id="1-IP核的相关配置-6"><a href="#1-IP核的相关配置-6" class="headerlink" title="1.IP核的相关配置"></a>1.IP核的相关配置</h2><p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240110125626654.png" alt="image-20240110125626654"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240110125946346.png" alt="image-20240110125946346"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240110130310317.png" alt="image-20240110130310317"></p>
<ul>
<li><p>最终配置如下：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240110132214936.png" alt="image-20240110132214936"></p>
</li>
</ul>
<h2 id="2-MATLAB代码-3"><a href="#2-MATLAB代码-3" class="headerlink" title="2.MATLAB代码"></a>2.MATLAB代码</h2><ul>
<li><p>用来生成测试单频信号的数据</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%           参数定义</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">fc=<span class="number">156.25e6</span>;         <span class="comment">% 信号频率</span></span><br><span class="line">fs=<span class="number">2.5e9</span>;        <span class="comment">% 采样频率</span></span><br><span class="line">L=<span class="number">16</span>;          <span class="comment">% 采样点数</span></span><br><span class="line">ADC_bit=<span class="number">16</span>;     <span class="comment">% 采样位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%              产生信号</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:(L<span class="number">-1</span>)/fs;</span><br><span class="line">noise=<span class="built_in">randn</span>(<span class="number">1</span>,<span class="built_in">length</span>(t));</span><br><span class="line">noise=<span class="number">0</span>;</span><br><span class="line">st=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*t)+noise;</span><br><span class="line">y=st/<span class="built_in">max</span>(<span class="built_in">abs</span>(st));                 <span class="comment">% 归一化</span></span><br><span class="line">yt=<span class="built_in">round</span>(y*(<span class="number">2</span>^(ADC_bit<span class="number">-1</span>)<span class="number">-1</span>));     <span class="comment">% 16bit量化</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(st);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(y);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(yt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%            MATLAB生成coe文件</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 在.coe文件中</span></span><br><span class="line"><span class="comment">% 第一行为定义数据格式, 2代表 ROM 的数据格式为二进制。</span></span><br><span class="line"><span class="comment">% 从第 3 行开始到第最后一行，是这个  L（数据长度为1024）* ADC_bit（16bit） 大小 ROM 的初始化数据。</span></span><br><span class="line"><span class="comment">% 第一行到倒数第二行的数字后面用逗号，最后一行数字结束用分号。</span></span><br><span class="line">fid=fopen(<span class="string">&#x27;sin156o25M.coe&#x27;</span>,<span class="string">&#x27;w&#x27;</span>); </span><br><span class="line">fprintf(fid,<span class="string">&#x27;Memory_Initialization_Radix = 2;\r\n&#x27;</span>); <span class="comment">% 二进制</span></span><br><span class="line">fprintf(fid,<span class="string">&#x27;Memory_Initialization_Vector = \r\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> p=<span class="number">1</span>:L</span><br><span class="line">    B_s=dec2bin(yt(p)+(yt(p)&lt;<span class="number">0</span>)*<span class="number">2</span>^ADC_bit,ADC_bit);<span class="comment">%十进制转二进制</span></span><br><span class="line">    <span class="keyword">for</span> q=<span class="number">1</span>:ADC_bit  <span class="comment">% 16位，依次判断这16位的数值</span></span><br><span class="line">        <span class="keyword">if</span> B_s(q)==<span class="string">&#x27;1&#x27;</span></span><br><span class="line">            data=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d&#x27;</span>,data);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%  下面if语句的目的</span></span><br><span class="line">    <span class="comment">%  每行数字后面用逗号(,)，最后一行数字结束用分号(;)</span></span><br><span class="line">    <span class="keyword">if</span> (p&lt;L)</span><br><span class="line">        fprintf(fid,<span class="string">&#x27;,\r\n&#x27;</span>); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;;\r\n&#x27;</span>);    <span class="comment">% 分号(;)  结束标志位</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>MATLAB生成的波形：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240110135744248.png" alt="image-20240110135744248"></p>
</li>
<li><p>DAC结果：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240110135807426.png" alt="image-20240110135807426" style="zoom:80%;"></p>
</li>
</ul>
</li>
</ul>
<h2 id="3-Python代码"><a href="#3-Python代码" class="headerlink" title="3.Python代码"></a>3.Python代码</h2><ul>
<li><p>用来处理经过ADC后的数据，画出波形</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_string</span>(<span class="params">input_str, chunk_size</span>):</span><br><span class="line">    <span class="keyword">return</span> [input_str[i:i + chunk_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(input_str), chunk_size)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    hex_num = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/media/data/zhl/ila_data_20240108_215000.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">                number = line.strip()</span><br><span class="line">                hex_num.append(number)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;文件不存在&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;异常:<span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;文件读取完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hex_num = np.array(hex_num)</span></span><br><span class="line"></span><br><span class="line">    int_num = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> hex_num:</span><br><span class="line">        <span class="comment"># 对每一行，先reshape为16*8的样子，然后再转换数据类型</span></span><br><span class="line">        temp = split_string(line, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> temp:</span><br><span class="line">            int_num.append(<span class="built_in">int</span>(item, <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(int_num)):</span><br><span class="line">        <span class="keyword">if</span> (int_num[i] &amp; <span class="number">0x8000</span>) == <span class="number">0x8000</span>:</span><br><span class="line">            <span class="comment"># 补码，取反加一</span></span><br><span class="line">            int_num[i] = -((int_num[i]-<span class="number">1</span>) ^ <span class="number">0xFFFF</span>)</span><br><span class="line"></span><br><span class="line">    width = <span class="number">2000</span></span><br><span class="line">    height = <span class="number">500</span></span><br><span class="line">    dpi = <span class="number">180</span></span><br><span class="line">    fig = plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)</span><br><span class="line">    plt.plot(int_num)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ADC结果：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240110135454794.png" alt="image-20240110135454794"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-Reference-3"><a href="#4-Reference-3" class="headerlink" title="4.Reference"></a>4.Reference</h2><ul>
<li><a href="https://blog.csdn.net/weixin_41445387/article/details/119615042">RFSoC应用笔记 - RF数据转换器 -02- IP配置指南_Vuko-wxh的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/lightninghenry/article/details/110421299">XILINX RFSoC全面解析（五）—— Zynq UItrascale+ RF Data Converter IP核详解_zynq ultrascal + rf data converter-CSDN博客</a></li>
<li>特别感谢湟霖同学对本次调试的鼎力支持</li>
</ul>
<hr>
<h1 id="FIFO-IP核的使用"><a href="#FIFO-IP核的使用" class="headerlink" title="FIFO IP核的使用"></a>FIFO IP核的使用</h1><h2 id="1-IP核的相关配置-7"><a href="#1-IP核的相关配置-7" class="headerlink" title="1.IP核的相关配置"></a>1.IP核的相关配置</h2><p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240111151849763.png" alt="image-20240111151849763"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240111152255385.png" alt="image-20240111152255385"></p>
<ul>
<li>且对于Standard FIFO：实际位宽为255，对于First Word Fall Through：实际位宽为257</li>
</ul>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240111152355346.png" alt="image-20240111152355346"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240111153202181.png" alt="image-20240111153202181"></p>
<h2 id="2-源代码"><a href="#2-源代码" class="headerlink" title="2.源代码"></a>2.源代码</h2><ul>
<li><p>ip_fifo.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ip_fifo(</span><br><span class="line">    <span class="keyword">input</span>    sys_clk ,  <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>    sys_rst_n  <span class="comment">// 复位信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//wire define</span></span><br><span class="line">    <span class="keyword">wire</span>         fifo_wr_en         ;  <span class="comment">// FIFO写使能信号</span></span><br><span class="line">    <span class="keyword">wire</span>         fifo_rd_en         ;  <span class="comment">// FIFO读使能信号</span></span><br><span class="line">    <span class="keyword">wire</span>  [<span class="number">7</span>:<span class="number">0</span>]  fifo_din           ;  <span class="comment">// 写入到FIFO的数据</span></span><br><span class="line">    <span class="keyword">wire</span>  [<span class="number">7</span>:<span class="number">0</span>]  fifo_dout          ;  <span class="comment">// 从FIFO读出的数据</span></span><br><span class="line">    <span class="keyword">wire</span>         almost_full        ;  <span class="comment">// FIFO将满信号</span></span><br><span class="line">    <span class="keyword">wire</span>         almost_empty       ;  <span class="comment">// FIFO将空信号</span></span><br><span class="line">    <span class="keyword">wire</span>         fifo_full          ;  <span class="comment">// FIFO满信号</span></span><br><span class="line">    <span class="keyword">wire</span>         fifo_empty         ;  <span class="comment">// FIFO空信号</span></span><br><span class="line">    <span class="keyword">wire</span>  [<span class="number">7</span>:<span class="number">0</span>]  fifo_wr_data_count ;  <span class="comment">// FIFO写时钟域的数据计数</span></span><br><span class="line">    <span class="keyword">wire</span>  [<span class="number">7</span>:<span class="number">0</span>]  fifo_rd_data_count ;  <span class="comment">// FIFO读时钟域的数据计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****************************************************</span></span><br><span class="line">    <span class="comment">//**                    main code</span></span><br><span class="line">    <span class="comment">//*****************************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//例化FIFO IP核</span></span><br><span class="line">    fifo_generator_0  fifo_ip_u1 (</span><br><span class="line">        <span class="variable">.wr_clk</span>        ( sys_clk            ),  <span class="comment">// input wire wr_clk</span></span><br><span class="line">        <span class="variable">.rd_clk</span>        ( sys_clk            ),  <span class="comment">// input wire rd_clk</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">.wr_en</span>         ( fifo_wr_en         ),  <span class="comment">// input wire wr_en</span></span><br><span class="line">        <span class="variable">.rd_en</span>         ( fifo_rd_en         ),  <span class="comment">// input wire rd_en</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">.din</span>           ( fifo_din           ),  <span class="comment">// input wire [7 : 0] din</span></span><br><span class="line">        <span class="variable">.dout</span>          ( fifo_dout          ),  <span class="comment">// output wire [7 : 0] dout</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable">.almost_full</span>   (almost_full         ),  <span class="comment">// output wire almost_full</span></span><br><span class="line">        <span class="variable">.almost_empty</span>  (almost_empty        ),  <span class="comment">// output wire almost_empty</span></span><br><span class="line">        <span class="variable">.full</span>          ( fifo_full          ),  <span class="comment">// output wire full</span></span><br><span class="line">        <span class="variable">.empty</span>         ( fifo_empty         ),  <span class="comment">// output wire empty</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">.wr_data_count</span> ( fifo_wr_data_count ),  <span class="comment">// output wire [7 : 0] wr_data_count	</span></span><br><span class="line">        <span class="variable">.rd_data_count</span> ( fifo_rd_data_count )   <span class="comment">// output wire [7 : 0] rd_data_count</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//例化写FIFO模块</span></span><br><span class="line">    fifo_wr  u_fifo_wr(</span><br><span class="line">        <span class="variable">.clk</span>            ( sys_clk    ),   <span class="comment">// 写时钟</span></span><br><span class="line">        <span class="variable">.rst_n</span>          ( sys_rst_n  ),   <span class="comment">// 复位信号</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">.fifo_wr_en</span>     ( fifo_wr_en )  , <span class="comment">// fifo写请求</span></span><br><span class="line">        <span class="variable">.fifo_wr_data</span>   ( fifo_din    ) , <span class="comment">// 写入FIFO的数据</span></span><br><span class="line">        <span class="variable">.almost_empty</span>   ( almost_empty ), <span class="comment">// fifo空信号</span></span><br><span class="line">        <span class="variable">.almost_full</span>    ( almost_full  )  <span class="comment">// fifo满信号</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//例化读FIFO模块</span></span><br><span class="line">    fifo_rd  u_fifo_rd(</span><br><span class="line">        <span class="variable">.clk</span>          ( sys_clk    ),      <span class="comment">// 读时钟</span></span><br><span class="line">        <span class="variable">.rst_n</span>        ( sys_rst_n  ),      <span class="comment">// 复位信号</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">.fifo_rd_en</span>   ( fifo_rd_en ),      <span class="comment">// fifo读请求</span></span><br><span class="line">        <span class="variable">.fifo_dout</span>    ( fifo_dout  ),      <span class="comment">// 从FIFO输出的数据</span></span><br><span class="line">        <span class="variable">.almost_empty</span> ( almost_empty ),    <span class="comment">// fifo空信号</span></span><br><span class="line">        <span class="variable">.almost_full</span>  ( almost_full  )     <span class="comment">// fifo满信号</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>fifo_wr.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fifo_wr(</span><br><span class="line">    <span class="comment">//mudule clock</span></span><br><span class="line">    <span class="keyword">input</span>                  clk    ,           <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>                  rst_n  ,           <span class="comment">// 复位信号</span></span><br><span class="line">    <span class="comment">//FIFO interface       </span></span><br><span class="line">    <span class="keyword">input</span>                  almost_empty,      <span class="comment">// FIFO将空信号</span></span><br><span class="line">    <span class="keyword">input</span>                  almost_full ,      <span class="comment">// FIFO将满信号</span></span><br><span class="line">	<span class="keyword">output</span>    <span class="keyword">reg</span>          fifo_wr_en ,       <span class="comment">// FIFO写使能</span></span><br><span class="line">    <span class="keyword">output</span>    <span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>]   fifo_wr_data       <span class="comment">// 写入FIFO的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reg define</span></span><br><span class="line">    <span class="keyword">reg</span>  [<span class="number">1</span>:<span class="number">0</span>]  state            ; <span class="comment">//动作状态</span></span><br><span class="line">    <span class="keyword">reg</span>  		almost_empty_d0  ;  <span class="comment">//almost_empty 延迟一拍</span></span><br><span class="line">    <span class="keyword">reg</span>  		almost_empty_syn ;  <span class="comment">//almost_empty 延迟两拍</span></span><br><span class="line">    <span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]  dly_cnt          ; <span class="comment">//延迟计数器</span></span><br><span class="line">    <span class="comment">//*****************************************************</span></span><br><span class="line">    <span class="comment">//**                    main code</span></span><br><span class="line">    <span class="comment">//*****************************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为 almost_empty 信号是属于FIFO读时钟域的</span></span><br><span class="line">    <span class="comment">//所以要将其同步到写时钟域中</span></span><br><span class="line">    <span class="keyword">always</span>@( <span class="keyword">posedge</span> clk ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>( !rst_n ) <span class="keyword">begin</span></span><br><span class="line">            almost_empty_d0  &lt;= <span class="number">1&#x27;b0</span> ;</span><br><span class="line">            almost_empty_syn &lt;= <span class="number">1&#x27;b0</span> ;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            almost_empty_d0  &lt;= almost_empty ;</span><br><span class="line">            almost_empty_syn &lt;= almost_empty_d0 ;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向FIFO中写入数据</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">            fifo_wr_en   &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            fifo_wr_data &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">            state        &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            dly_cnt      &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(state)</span><br><span class="line">                <span class="number">2&#x27;d0</span>: <span class="keyword">begin</span> </span><br><span class="line">                    <span class="keyword">if</span>(almost_empty_syn) <span class="keyword">begin</span>  <span class="comment">//如果检测到FIFO将被读空</span></span><br><span class="line">                        state &lt;= <span class="number">2&#x27;d1</span>;        <span class="comment">//就进入延时状态</span></span><br><span class="line">                    <span class="keyword">end</span> </span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        state &lt;= state;</span><br><span class="line">                <span class="keyword">end</span> </span><br><span class="line">                <span class="number">2&#x27;d1</span>: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(dly_cnt == <span class="number">4&#x27;d10</span>) <span class="keyword">begin</span>  <span class="comment">//延时10拍</span></span><br><span class="line">                                                <span class="comment">//原因是FIFO IP核内部状态信号的更新存在延时</span></span><br><span class="line">                                                <span class="comment">//延迟10拍以等待状态信号更新完毕                   </span></span><br><span class="line">                        dly_cnt    &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">                        state      &lt;= <span class="number">2&#x27;d2</span>;     <span class="comment">//开始写操作</span></span><br><span class="line">                        fifo_wr_en &lt;= <span class="number">1&#x27;b1</span>;     <span class="comment">//打开写使能</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dly_cnt &lt;= dly_cnt + <span class="number">4&#x27;d1</span>;</span><br><span class="line">                <span class="keyword">end</span>             </span><br><span class="line">                <span class="number">2&#x27;d2</span>: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(almost_full) <span class="keyword">begin</span>        <span class="comment">//等待FIFO将被写满</span></span><br><span class="line">                        fifo_wr_en   &lt;= <span class="number">1&#x27;b0</span>;  <span class="comment">//关闭写使能</span></span><br><span class="line">                        fifo_wr_data &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">                        state        &lt;= <span class="number">2&#x27;d0</span>;  <span class="comment">//回到第一个状态</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span>                 <span class="comment">//如果FIFO没有被写满</span></span><br><span class="line">                        fifo_wr_en   &lt;= <span class="number">1&#x27;b1</span>;  <span class="comment">//则持续打开写使能</span></span><br><span class="line">                        fifo_wr_data &lt;= fifo_wr_data + <span class="number">1&#x27;d1</span>;  <span class="comment">//且写数据值持续累加</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span> </span><br><span class="line">                <span class="keyword">default</span> : state &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>fifo_rd.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo_rd(</span><br><span class="line">    <span class="comment">//system clock</span></span><br><span class="line">    <span class="keyword">input</span>               clk ,        <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>               rst_n ,      <span class="comment">// 复位信号</span></span><br><span class="line">    <span class="comment">//FIFO interface</span></span><br><span class="line">    <span class="keyword">input</span>        [<span class="number">7</span>:<span class="number">0</span>]  fifo_dout ,  <span class="comment">// 从FIFO读出的数据</span></span><br><span class="line">    <span class="keyword">input</span>               almost_full ,<span class="comment">// FIFO将满信号</span></span><br><span class="line">    <span class="keyword">input</span>               almost_empty,<span class="comment">// FIFO将空信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">reg</span>         fifo_rd_en   <span class="comment">// FIFO读使能</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reg define</span></span><br><span class="line">    <span class="keyword">reg</span>  [<span class="number">1</span>:<span class="number">0</span>]  state           ;  <span class="comment">// 动作状态</span></span><br><span class="line">    <span class="keyword">reg</span>         almost_full_d0  ;  <span class="comment">// fifo_full 延迟一拍</span></span><br><span class="line">    <span class="keyword">reg</span>  		almost_full_syn ;  <span class="comment">// fifo_full 延迟两拍</span></span><br><span class="line">    <span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]  dly_cnt         ;  <span class="comment">//延迟计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****************************************************</span></span><br><span class="line">    <span class="comment">//**                    main code</span></span><br><span class="line">    <span class="comment">//*****************************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为 fifo_full 信号是属于FIFO写时钟域的</span></span><br><span class="line">    <span class="comment">//所以要将其同步到读时钟域中</span></span><br><span class="line">    <span class="keyword">always</span>@( <span class="keyword">posedge</span> clk ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>( !rst_n ) <span class="keyword">begin</span></span><br><span class="line">            almost_full_d0  &lt;= <span class="number">1&#x27;b0</span> ;</span><br><span class="line">            almost_full_syn &lt;= <span class="number">1&#x27;b0</span> ;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            almost_full_d0  &lt;= almost_full ;</span><br><span class="line">            almost_full_syn &lt;= almost_full_d0 ;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读出FIFO的数据</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk ) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">            fifo_rd_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            state      &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            dly_cnt    &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(state)</span><br><span class="line">                <span class="number">2&#x27;d0</span>: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(almost_full_syn)      <span class="comment">//如果检测到FIFO将被写满</span></span><br><span class="line">                        state &lt;= <span class="number">2&#x27;d1</span>;       <span class="comment">//就进入延时状态</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        state &lt;= state;</span><br><span class="line">                <span class="keyword">end</span> </span><br><span class="line">                <span class="number">2&#x27;d1</span>: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(dly_cnt == <span class="number">4&#x27;d10</span>) <span class="keyword">begin</span>  <span class="comment">//延时10拍</span></span><br><span class="line">                                                <span class="comment">//原因是FIFO IP核内部状态信号的更新存在延时</span></span><br><span class="line">                                                <span class="comment">//延迟10拍以等待状态信号更新完毕</span></span><br><span class="line">                        dly_cnt &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">                        state   &lt;= <span class="number">2&#x27;d2</span>;        <span class="comment">//开始读操作</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dly_cnt &lt;= dly_cnt + <span class="number">4&#x27;d1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2&#x27;d2</span>: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(almost_empty) <span class="keyword">begin</span>     <span class="comment">//等待FIFO将被读空</span></span><br><span class="line">                        fifo_rd_en &lt;= <span class="number">1&#x27;b0</span>;    <span class="comment">//关闭读使能</span></span><br><span class="line">                        state      &lt;= <span class="number">2&#x27;d0</span>;    <span class="comment">//回到第一个状态</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span>                       <span class="comment">//如果FIFO没有被读空</span></span><br><span class="line">                        fifo_rd_en &lt;= <span class="number">1&#x27;b1</span>;    <span class="comment">//则持续打开读使能</span></span><br><span class="line">                <span class="keyword">end</span> </span><br><span class="line">                <span class="keyword">default</span> : state &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>整体架构：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240111153246240.png" alt="image-20240111153246240" style="zoom:50%;"></p>
</li>
<li><p>Vivado中的RTL视图：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240111153458045.png" alt="image-20240111153458045"></p>
</li>
</ul>
<h2 id="3-Testbench-3"><a href="#3-Testbench-3" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><ul>
<li><p>ip_fifo_tb.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ip_fifo_tb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inputs</span></span><br><span class="line">    <span class="keyword">reg</span> sys_clk;</span><br><span class="line">    <span class="keyword">reg</span> sys_rst_n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Instantiate the Unit Under Test (UUT)</span></span><br><span class="line">    ip_fifo  u_ip_fifo (</span><br><span class="line">        <span class="variable">.sys_clk</span>         (sys_clk), </span><br><span class="line">        <span class="variable">.sys_rst_n</span>       (sys_rst_n)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Genarate the clk</span></span><br><span class="line">    <span class="keyword">parameter</span> PERIOD = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        sys_clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="variable">#(PERIOD/2)</span> sys_clk = <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="variable">#(PERIOD/2)</span>;</span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// Initialize Inputs</span></span><br><span class="line">        sys_rst_n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Wait 100 ns for global reset to finish</span></span><br><span class="line">        #<span class="number">100</span>  ;</span><br><span class="line">        sys_rst_n = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Add stimulus here</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>仿真结果：</p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240111153831859.png" alt="image-20240111153831859"></p>
<p><img src="/2023/10/10/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%85%B8%E5%9E%8BIP%E6%A0%B8/image-20240111154343389.png" alt="image-20240111154343389"></p>
</li>
</ul>
<h2 id="4-Reference-4"><a href="#4-Reference-4" class="headerlink" title="4.Reference"></a>4.Reference</h2><ul>
<li><a href="https://www.bilibili.com/video/BV1P5411A7Dx?p=3&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">27_实战篇：FIFO IP 核实验（第三讲：程序设计）_哔哩哔哩_bilibili</a></li>
</ul>
<hr>
<h1 id="AXI-DMA-IP核的使用"><a href="#AXI-DMA-IP核的使用" class="headerlink" title="AXI DMA IP核的使用"></a>AXI DMA IP核的使用</h1>]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA数字信号处理之数的运算</title>
    <url>/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>本节主要介绍了浮点数与定点数的表示方法、FPGA进行数字运算的准则以及有效字长效应出现的原因</p>
<span id="more"></span>
<h1 id="定点整数与小数的表示方法"><a href="#定点整数与小数的表示方法" class="headerlink" title="定点整数与小数的表示方法"></a>定点整数与小数的表示方法</h1><ul>
<li><p><strong>N位负数，补码数值+原码值=$2^N$</strong></p>
<ul>
<li>例：4位补码数据：-5的补码与11（$2^4-5$）的原码相同1011</li>
<li>例：4位补码数据：-7的补码与9（$2^4-7$）的原码相同1011</li>
</ul>
</li>
<li><p>定点小数的补码：</p>
<ul>
<li><p><strong>原则：小数点左移一位，数值为$\frac12$倍</strong></p>
</li>
<li><p>小数的转换方法：乘以2的整数次倍M，即乘以$2^M$，转为成整数（如果是负数的话再转换为补码），再将小数点左移M位</p>
<ul>
<li><p>例：十进制-1.5转换为2进制</p>
<script type="math/tex; mode=display">
1.5\times 2^1=3\\
3的二进制补码是：2^3-3=5,5的原码是：101\\
左移1位\rightarrow 10.1</script></li>
<li><p>例：十进制25.125转为2进制</p>
<script type="math/tex; mode=display">
25.125\times 2^3=201\\
201的原码是：11001001
左移3位\rightarrow 11001.001</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h2 id="1-浮点数的表示方式"><a href="#1-浮点数的表示方式" class="headerlink" title="1.浮点数的表示方式"></a>1.浮点数的表示方式</h2><ul>
<li><p>单精度 32 位浮点数的 IEEE 浮点格式：</p>
<script type="math/tex; mode=display">
x=(-1)^s\times 1\times m\times 2^{e-b}</script><ul>
<li>$s$代表符号位</li>
<li>$m$代表小数部分，其隐含了一个1.，也就是它表示1~2之间的数</li>
<li>$e$代表偏指数，$b$是偏差，$e-b$代表真实指数</li>
</ul>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019103533554.png" alt="image-20231019103533554" style="zoom: 67%;"></p>
</li>
<li><p>例子：</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019103627373.png" alt="image-20231019103627373" style="zoom:67%;"></p>
</li>
</ul>
<h2 id="2-浮点数的加法运算"><a href="#2-浮点数的加法运算" class="headerlink" title="2.浮点数的加法运算"></a>2.浮点数的加法运算</h2><p>假设有两个浮点数$0_1010_00101$和$0_1001_00101$，设偏差为7，即$b=7$</p>
<ul>
<li><p>step1：通过相应移动较小指数的数字的尾数来对齐两个指数</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019103851186.png" alt="image-20231019103851186"></p>
</li>
<li><p>step2：尾数相加</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019103944151.png" alt="image-20231019103944151"></p>
</li>
<li><p>step3：位数本来只有5bit，将得到的结果最后一位截掉</p>
</li>
<li><p>step4：最后的结果是$1.10111_b\times 2^3$，它是10bit格式$0_1010_10111$</p>
</li>
</ul>
<h2 id="3-浮点数的乘法运算"><a href="#3-浮点数的乘法运算" class="headerlink" title="3.浮点数的乘法运算"></a>3.浮点数的乘法运算</h2><p>若有两个浮点数3.5($0_1000_11000$)和5.0($0_1001_01000$)，设偏差为7，即$b=7$</p>
<ul>
<li><p>step1：两个数的指数相加并减去偏差</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019105539709.png" alt="image-20231019105539709" style="zoom:67%;"></p>
</li>
<li><p>step2：添加隐含的1.，将尾数进行两个无符号乘法运算</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019110015307.png" alt="image-20231019110015307" style="zoom: 50%;"></p>
</li>
<li><p>step3：整理得到的结果</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019110242933.png" alt="image-20231019110242933" style="zoom:67%;"></p>
</li>
<li><p>step4：将结果写成浮点数格式：</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019110404916.png" alt="image-20231019110404916" style="zoom: 67%;"></p>
</li>
</ul>
<hr>
<h1 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h1><h2 id="1-定点数的表示方法"><a href="#1-定点数的表示方法" class="headerlink" title="1.定点数的表示方法"></a>1.定点数的表示方法</h2><ul>
<li><p>定点数采用$Q_{n,m}$格式，其中$n$表示小数点左边的位数，也就是整数部分的位数，$m$表示小数点右边的位数，也就是小数点右边的位数</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019110717122.png" alt="image-20231019110717122" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-定点数的加法运算"><a href="#2-定点数的加法运算" class="headerlink" title="2.定点数的加法运算"></a>2.定点数的加法运算</h2><p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019111054752.png" alt="image-20231019111054752" style="zoom: 67%;"></p>
<ul>
<li>。在 Q2.2 中，格式 a 是 1110，在 Q4.4 格式中，格式 b 是 0111 0110。由于 n1 小于 n2，因此扩展了 a 的符号位以将其格式从 Q2.2 更改为 Q4.2</li>
</ul>
<h2 id="3-定点数的乘法运算"><a href="#3-定点数的乘法运算" class="headerlink" title="3.定点数的乘法运算"></a>3.定点数的乘法运算</h2><ul>
<li><p>对于乘法运算，有：</p>
<script type="math/tex; mode=display">
Q_{n1.m1}\times Q_{n2.m2}=Q(n_1+n_2).(m_1+m_2)</script><ul>
<li>对于两个有符号乘法，其实是：<script type="math/tex; mode=display">
Q_{n1.m1}\times Q_{n2.m2}=Q(n_1+n_2-1).(m_1+m_2+1)</script></li>
</ul>
</li>
</ul>
<h3 id="3-1-无符号数-times-无符号数"><a href="#3-1-无符号数-times-无符号数" class="headerlink" title="3.1 无符号数$\times$无符号数"></a>3.1 无符号数$\times$无符号数</h3><ul>
<li><p>无符号数的乘法不需要符号的拓展</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019113000346.png" alt="image-20231019113000346" style="zoom:50%;"></p>
</li>
</ul>
<h3 id="3-2-有符号数-times-无符号数"><a href="#3-2-有符号数-times-无符号数" class="headerlink" title="3.2 有符号数$\times$无符号数"></a>3.2 有符号数$\times$无符号数</h3><p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019113607806.png" alt="image-20231019113607806" style="zoom: 67%;"></p>
<h3 id="3-3-无符号数-times-有符号数"><a href="#3-3-无符号数-times-有符号数" class="headerlink" title="3.3 无符号数$\times$有符号数"></a>3.3 无符号数$\times$有符号数</h3><p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019114039349.png" alt="image-20231019114039349" style="zoom:67%;"></p>
<h3 id="3-4-有符号数-times-有符号数"><a href="#3-4-有符号数-times-有符号数" class="headerlink" title="3.4 有符号数$\times$有符号数"></a>3.4 有符号数$\times$有符号数</h3><p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019114509204.png" alt="image-20231019114509204" style="zoom:67%;"></p>
<ul>
<li><p><strong>并且最终的结果要左移一位，即0000_1001左移一位，得到0001_0010</strong>（个人认为其实它的最高位是冗余符号位，左移与否并不重要）</p>
</li>
<li><p>总结一下：</p>
<ul>
<li>只要是负数，都用补码</li>
<li>$A\times B$，A为有符号数，相乘时符号位扩展</li>
<li>B为有符号数负数，最后符号位与A相乘的结果取补码</li>
</ul>
</li>
</ul>
<h2 id="4-带截断的舍弃"><a href="#4-带截断的舍弃" class="headerlink" title="4.带截断的舍弃"></a>4.带截断的舍弃</h2><p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231019115132253.png" alt="image-20231019115132253" style="zoom: 67%;"></p>
<hr>
<h1 id="AD-DA接口程序设计"><a href="#AD-DA接口程序设计" class="headerlink" title="AD/DA接口程序设计"></a>AD/DA接口程序设计</h1><ul>
<li><p>无符号转成有符号：-$2^{N-1}$</p>
</li>
<li><p>有符号转成无符号：+$2^{N-1}$</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231012163136239.png" alt="image-20231012163136239" style="zoom:50%;"></p>
</li>
<li><p>将AD采样得到的无符号数据转化成有符号数据，可供程序的其他模块使用</p>
</li>
<li><p>将有符号数据转成无符号数据送给DA</p>
</li>
</ul>
<hr>
<h1 id="FPGA的四则运算"><a href="#FPGA的四则运算" class="headerlink" title="FPGA的四则运算"></a>FPGA的四则运算</h1><h2 id="1-加减运算"><a href="#1-加减运算" class="headerlink" title="1.加减运算"></a>1.加减运算</h2><ul>
<li><p>源代码</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Data_compute(</span><br><span class="line">    <span class="keyword">input</span>	[<span class="number">3</span>:<span class="number">0</span>]    d1,           			   <span class="comment">//操作数d1</span></span><br><span class="line">    <span class="keyword">input</span>	[<span class="number">3</span>:<span class="number">0</span>]    d2,           			   <span class="comment">//操作数d2</span></span><br><span class="line">    <span class="keyword">output</span> 	[<span class="number">3</span>:<span class="number">0</span>]	unsigned_out,  		       <span class="comment">//无符号数加法输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] signed_out);   		   <span class="comment">//有符号数加法输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//无符号数加法运算</span></span><br><span class="line">    <span class="keyword">assign</span> unsigned_out = d1 + d2;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//有符号数加法运算</span></span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] s_d1;</span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] s_d2;</span><br><span class="line">    <span class="keyword">assign</span> s_d1 = d1;</span><br><span class="line">    <span class="keyword">assign</span> s_d2 = d2;</span><br><span class="line">    <span class="keyword">assign</span> signed_out = s_d1 + s_d2;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tst;</span><br><span class="line">	<span class="comment">// Inputs</span></span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] d1;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] d2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Outputs</span></span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] unsigned_out;</span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] signed_out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the Unit Under Test (UUT)</span></span><br><span class="line">	Data_compute uut (</span><br><span class="line">		<span class="variable">.d1</span>(d1), </span><br><span class="line">		<span class="variable">.d2</span>(d2), </span><br><span class="line">		<span class="variable">.unsigned_out</span>(unsigned_out), </span><br><span class="line">		<span class="variable">.signed_out</span>(signed_out)</span><br><span class="line">	);</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="comment">// Initialize Inputs</span></span><br><span class="line">		d1 = <span class="number">0</span>;</span><br><span class="line">		d2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Wait 100 ns for global reset to finish</span></span><br><span class="line">		#<span class="number">100</span>;</span><br><span class="line">		<span class="comment">// Add stimulus here</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">reg</span> clk=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> #<span class="number">10</span> clk &lt;= ~clk;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span> </span><br><span class="line">        d1 &lt;= d1 + <span class="number">1</span>;</span><br><span class="line">		d2 &lt;= d2 + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231009150200684.png" alt="image-20231009150200684"></p>
</li>
<li><p>有符号数和无符号数的其实在二进制上的运算结果是一致的，只是看我们把它当作有符号数还是无符号数（对于加法和减法运算，无论有符号数还是无符号数参与运算，其结果均完全相同，因为二进制数的运算规则是完全相同的。如果将二进制数转换成十进制数，就可以看出两者的差别了）</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231009150516702.png" alt="image-20231009150516702"></p>
</li>
<li><p>$B$bit的二进制数，若当成无符号整数，表示的范围为$0\sim 2^B-1$，若当成有符号整数，表示的范围是$-2^{B-1}\sim 2^{B-1}-1$</p>
</li>
<li><strong>如果二进制数的表示范围没有溢出，将运算数据均看成无符号数或有符号数，则运算结果都正确</strong></li>
<li><strong>两个$B$bit的二进制数进行加法和减法运算，若要运算结果不溢出，则需要$B+1$bit的数存放运算结果</strong></li>
</ul>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231009151153488.png" alt="image-20231009151153488" style="zoom: 80%;"></p>
<ul>
<li>计算多个数加减，计算的个数为$M$，则扩展位宽$N$倍，有$2^N\ge M$<ul>
<li>例：两个10bit的有符号数A和B进行加法运算，则运算结果的最小值为$-2^{10}$，运算结果的最大值为$2^{10}-1$，因此需要用11bit。依次类推，如果有3～4个10 bit的有符号数进行加法运算，则需要用12bit 的数表示运算结果；如果有5～8个10bit的有符号数进行加法运算， 需要用13bit的数表示运算结果</li>
</ul>
</li>
</ul>
<h2 id="2-乘除运算"><a href="#2-乘除运算" class="headerlink" title="2.乘除运算"></a>2.乘除运算</h2><ul>
<li><p>采用移位相加实现乘法运算</p>
<ul>
<li>乘法左移：</li>
</ul>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231009153227099.png" alt="image-20231009153227099" style="zoom:80%;"></p>
<ul>
<li><p>除法右移：</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231009153331133.png" alt="image-20231009153331133" style="zoom:80%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="有效字长效应"><a href="#有效字长效应" class="headerlink" title="有效字长效应"></a>有效字长效应</h1><h2 id="1-乘加运算的位宽"><a href="#1-乘加运算的位宽" class="headerlink" title="1.乘加运算的位宽"></a>1.乘加运算的位宽</h2><ul>
<li><p><strong>计算所有滤波器系数绝对值之和，再计算表示该绝对值之和所需的最小无符号二进制数的位宽为n ，则滤波器输出的有效数据位为N+n</strong></p>
</li>
<li><p>例：$2^8&gt;1+80+80+1$，故总共需要的位宽是$10+8=18$</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/image-20231009161358196.png" alt="image-20231009161358196" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-滤波器系数的字长效应"><a href="#2-滤波器系数的字长效应" class="headerlink" title="2.滤波器系数的字长效应"></a>2.滤波器系数的字长效应</h2><ul>
<li><p>数字滤波器的系数直接决定了系统函数的零点位置、极点位置 和频率响应，因此，由于实际数字滤波器系数存在的误差，必将使数 字滤波器的零点位置和极点位置发生偏移，频率响应发生变化，从而影响数字滤波器的性能，甚至严重到使单位圆内的极点位置偏移到单位圆外，造成数字滤波器的不稳定</p>
</li>
<li><p><strong>系数量化对数字滤波器性能的影响和字长有关</strong>，也与数字滤波器结构有关</p>
</li>
<li><p>滤波器系数的字长效应例子：</p>
<script type="math/tex; mode=display">
H(z)=\frac{0.05}{1+1.7z^{-1}+0.745z^{-2}}</script><ul>
<li><p>量化的方法：分子分母同时乘以一个整数，使其均为整数</p>
</li>
<li><p>MATLAB程序：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">b=<span class="number">0.05</span>;</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">1.7</span>,<span class="number">0.745</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%对滤波器系数进行归一化处理</span></span><br><span class="line">m=<span class="built_in">max</span>(<span class="built_in">max</span>(b),<span class="built_in">max</span>(a));</span><br><span class="line">b1=b/m;</span><br><span class="line">a1=a/m;</span><br><span class="line"></span><br><span class="line"><span class="comment">%滤波器系数进行量化处理</span></span><br><span class="line">Q=<span class="number">8</span>;                                        </span><br><span class="line">b8=<span class="built_in">floor</span>(b1*(<span class="number">2</span>^(Q<span class="number">-1</span>)<span class="number">-1</span>));</span><br><span class="line">a8=<span class="built_in">floor</span>(a1*(<span class="number">2</span>^(Q<span class="number">-1</span>)<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">N=<span class="number">2048</span>;</span><br><span class="line">xn=<span class="number">0</span>:N<span class="number">-1</span>;</span><br><span class="line">xn=xn/N*<span class="number">2</span>;                                     <span class="comment">%频率归一化处理</span></span><br><span class="line">dn=[<span class="number">1</span>,<span class="built_in">zeros</span>(<span class="number">1</span>,N<span class="number">-1</span>)];                           <span class="comment">%产生单位抽样序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%计算原系统的频率响应</span></span><br><span class="line">hn=filter(b,a,dn);                             <span class="comment">%计算系统单位脉冲响应</span></span><br><span class="line">fn=<span class="number">10</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(fft(hn,N)));                   <span class="comment">%计算系统频率响应</span></span><br><span class="line">fn=fn-<span class="built_in">max</span>(fn);                                 <span class="comment">%幅度归一化处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%计算8比特系数量化后的系统的频率响应</span></span><br><span class="line">hn8=filter(b8,a8,dn);                          <span class="comment">%计算系统单位脉冲响应</span></span><br><span class="line">fn8=<span class="number">10</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(fft(hn8,N)));                 <span class="comment">%计算系统频率响应</span></span><br><span class="line">fn8=fn8-<span class="built_in">max</span>(fn8);                              <span class="comment">%幅度归一化处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%绘制系统的频率响应图</span></span><br><span class="line"><span class="built_in">plot</span>(xn(<span class="number">1</span>:N/<span class="number">2</span>),fn(<span class="number">1</span>:N/<span class="number">2</span>),<span class="string">&#x27;-&#x27;</span>,xn(<span class="number">1</span>:N/<span class="number">2</span>),fn8(<span class="number">1</span>:N/<span class="number">2</span>),<span class="string">&#x27;--&#x27;</span>);                     </span><br><span class="line">xlabel(<span class="string">&#x27;归一化频率（fs/2）&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;归一化幅度（dB）&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;原系统的频率响应&#x27;</span>,<span class="string">&#x27;8比特量化后的频率响应&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%计算系数的极点</span></span><br><span class="line">s0=roots(a)</span><br><span class="line">s8=roots(a8)</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/QuantCoeff.bmp" alt="QuantCoeff" style="zoom:50%;"></p>
</li>
<li><p>从该图可明显看出系数量化后系统的频率响应与原系统的频率响应的差别，量化位数越大，频率响应越接近</p>
</li>
<li><p>观察极点位置：随着量化位数的减小， 极点值偏离原系统的极点值越来越大，对于该系统来说，当量化位数小于7位时，系统的极点已在单位圆外，不再是一个因果稳定系统</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-滤波器运算的字长效应"><a href="#3-滤波器运算的字长效应" class="headerlink" title="3.滤波器运算的字长效应"></a>3.滤波器运算的字长效应</h2><ul>
<li><p><strong>定点数的乘法运算存在有限字长效应，因为2个$B$bit的定点数相乘，要保留所有的有效位就需要使用$2B$bit的数</strong>，截位或舍入必定会引起有限字长效应；在浮点数运算中，乘法或加法运算均有可能引起尾数位的增加，因此也存在有限字长效应</p>
</li>
<li><p>滤波器运算的字长效应例子：</p>
<script type="math/tex; mode=display">
H(z)=\frac{1}{1+0.5z^{-1}}</script><ul>
<li><p>在无限精度运算的情况下，其差分方程为：</p>
<script type="math/tex; mode=display">
y(n)=-0.5y(n-1)+x(n)</script></li>
<li><p>在定点数运算中，每次乘法和加法运算后都必须对尾数进行舍入或截位处理，即量化处理，而量化过程是一个非线性过程，处理后相 应的非线性差分方程变为：</p>
<script type="math/tex; mode=display">
w(n)=Q[-0.5w(n-1)+x(n)]</script></li>
<li><p>MATLAB程序：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=[<span class="number">7</span>/<span class="number">8</span> <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">15</span>)];</span><br><span class="line">y=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(x));    <span class="comment">%存放原始运算结果</span></span><br><span class="line">B=<span class="number">2</span>;                     <span class="comment">%量化位数</span></span><br><span class="line">Qy=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(x));   <span class="comment">%存放量化运算结果</span></span><br><span class="line">Qy2=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(x));  <span class="comment">%存放量化运算结果</span></span><br><span class="line">Qy4=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(x));  <span class="comment">%存放量化运算结果</span></span><br><span class="line">Qy6=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(x));  <span class="comment">%存放量化运算结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%系统系数</span></span><br><span class="line">A=<span class="number">0.5</span>;</span><br><span class="line">b=[<span class="number">1</span>];</span><br><span class="line">a=[<span class="number">1</span>,A];</span><br><span class="line"></span><br><span class="line"><span class="comment">%未经过量化处理的运算</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(x);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span>==<span class="number">1</span></span><br><span class="line">        y(<span class="built_in">i</span>)=x(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y(<span class="built_in">i</span>)=-A*y(<span class="built_in">i</span><span class="number">-1</span>)+x(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%经过2比特量化处理的运算</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(x);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span>==<span class="number">1</span></span><br><span class="line">        Qy(<span class="built_in">i</span>)=x(<span class="built_in">i</span>);</span><br><span class="line">        Qy(<span class="built_in">i</span>)=<span class="built_in">round</span>(Qy(<span class="built_in">i</span>)*(<span class="number">2</span>^(B<span class="number">-1</span>)))/<span class="number">2</span>^(B<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Qy(<span class="built_in">i</span>)=-A*Qy(<span class="built_in">i</span><span class="number">-1</span>)+x(<span class="built_in">i</span>);</span><br><span class="line">        Qy(<span class="built_in">i</span>)=<span class="built_in">round</span>(Qy(<span class="built_in">i</span>)*(<span class="number">2</span>^(B<span class="number">-1</span>)))/<span class="number">2</span>^(B<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Qy2=Qy;</span><br><span class="line"></span><br><span class="line">B=<span class="number">4</span>;</span><br><span class="line"><span class="comment">%经过4比特量化处理的运算</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(x);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span>==<span class="number">1</span></span><br><span class="line">        Qy(<span class="built_in">i</span>)=x(<span class="built_in">i</span>);</span><br><span class="line">        Qy(<span class="built_in">i</span>)=<span class="built_in">round</span>(Qy(<span class="built_in">i</span>)*(<span class="number">2</span>^(B<span class="number">-1</span>)))/<span class="number">2</span>^(B<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Qy(<span class="built_in">i</span>)=-A*Qy(<span class="built_in">i</span><span class="number">-1</span>)+x(<span class="built_in">i</span>);</span><br><span class="line">        Qy(<span class="built_in">i</span>)=<span class="built_in">round</span>(Qy(<span class="built_in">i</span>)*(<span class="number">2</span>^(B<span class="number">-1</span>)))/<span class="number">2</span>^(B<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Qy4=Qy;</span><br><span class="line"></span><br><span class="line">B=<span class="number">6</span>;</span><br><span class="line"><span class="comment">%经过6比特量化处理的运算</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(x);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span>==<span class="number">1</span></span><br><span class="line">        Qy(<span class="built_in">i</span>)=x(<span class="built_in">i</span>);</span><br><span class="line">        Qy(<span class="built_in">i</span>)=<span class="built_in">round</span>(Qy(<span class="built_in">i</span>)*(<span class="number">2</span>^(B<span class="number">-1</span>)))/<span class="number">2</span>^(B<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Qy(<span class="built_in">i</span>)=-A*Qy(<span class="built_in">i</span><span class="number">-1</span>)+x(<span class="built_in">i</span>);</span><br><span class="line">        Qy(<span class="built_in">i</span>)=<span class="built_in">round</span>(Qy(<span class="built_in">i</span>)*(<span class="number">2</span>^(B<span class="number">-1</span>)))/<span class="number">2</span>^(B<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Qy6=Qy;</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图显示不同量化位宽的滤波结果</span></span><br><span class="line">xa=<span class="number">0</span>:<span class="number">1</span>:<span class="built_in">length</span>(x)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">plot</span>(xa,y,<span class="string">&#x27;-&#x27;</span>,xa,Qy2,<span class="string">&#x27;--&#x27;</span>,xa,Qy4,<span class="string">&#x27;O&#x27;</span>,xa,Qy6,<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;原系统运算结果&#x27;</span>,<span class="string">&#x27;2bit量化运算结果&#x27;</span>,<span class="string">&#x27;4bit量化运算结果&#x27;</span>,<span class="string">&#x27;6bit量化运算结果&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;运算次数&#x27;</span>);ylabel(<span class="string">&#x27;滤波结果&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下：</li>
</ul>
<p><img src="/2023/10/09/FPGA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/QuantArith.bmp" alt="QuantArith" style="zoom: 67%;"></p>
</li>
<li><p>从图中可以看出，当采用无限精度进行运算时，输出响应逐渐趋近于0；经过量化 处理后，输出响应在几次运算后在固定值处振荡，量化位数越少，振荡幅度就越大</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1fT411B7zj/?spm_id_from=333.788&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">Xilinx/ISE版 FPGA数字信号处理设计-定点整数与小数的表示方法_哔哩哔哩_bilibili</a></li>
<li><a href="https://blog.csdn.net/qq_44626493/article/details/107935257">Verilog实现二进制有符号定点数的乘法运算_verilog乘法运算-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理之应用设计</title>
    <url>/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>本节主要介绍了利用FFT进行频谱分析以及滤波器结构</p>
<span id="more"></span>
<h1 id="应用FFT分析信号频谱"><a href="#应用FFT分析信号频谱" class="headerlink" title="应用FFT分析信号频谱"></a>应用FFT分析信号频谱</h1><h2 id="1-谱线与实际频率的关系"><a href="#1-谱线与实际频率的关系" class="headerlink" title="1.谱线与实际频率的关系"></a>1.谱线与实际频率的关系</h2><ul>
<li><p>DTFT的幅频特性是以$w$数字角频率$2\pi$为周期的函数</p>
</li>
<li><p>而DFT的幅频特性的横坐标是$0\sim N-1$，故其共有$N$个点</p>
</li>
<li><p>数字角频率和模拟角频率的关系为$w\times f_s=\Omega$</p>
</li>
<li><p>故$w=2\pi$就对应模拟频率$f_s$，就对应第$N$个点，即第$N$个点所对应的实际频率就是$f_s$</p>
<ul>
<li>这么分析看似没问题吧，但是，有个问题是DFT的横坐标$k$，只能取$0\sim N-1$，$k=0$的点占了一个零频，故即使点与点之间的频率间隔是$\frac{f_s}{N}$，那么最终能取到的最大频率只能是$\frac{(N-1)}{N}\cdot f_s$</li>
</ul>
</li>
<li><p>故谱线与实际频率的对应关系为：</p>
<script type="math/tex; mode=display">
f_0=(N_i-1)\cdot \frac{f_s}{N}</script><ul>
<li>其中，$N_i$代表第$i$个点，而第$N_i$个点有$N_i-1$个频率间隔</li>
</ul>
</li>
<li><p>借助MATLAB程序加深理解</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear all;</span><br><span class="line"></span><br><span class="line">fs=<span class="number">1000</span>;</span><br><span class="line">N=<span class="number">500</span>;</span><br><span class="line">xn=<span class="number">0</span>:(N<span class="number">-1</span>);</span><br><span class="line">t=xn/fs; <span class="comment">%这里的t代表信号长度，而1/t也决定了实际分辨率</span></span><br><span class="line"></span><br><span class="line">f0=<span class="number">0</span>;</span><br><span class="line">f1=<span class="number">2</span>;</span><br><span class="line">f2=<span class="number">680</span>;</span><br><span class="line">s=<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f0*t)+<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f1*t)+<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f2*t);</span><br><span class="line">s_fft=<span class="built_in">abs</span>(fft(s,N));</span><br><span class="line">stem(xn,s_fft);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/fft_k_to_freq.bmp" alt="fft_k_to_freq"></p>
<ul>
<li>根据上述公式，通过计算得到$f_0,f_1,f_2$对应第1，2，161个点，那么对应的$k$值为0，1，160（这里用1000-680KHz的频率去计算）</li>
<li>从上述结果也能很明显的看出$x(k_0)=x(N-k_0)$（这个结论对$f_0=0$不适用）</li>
<li>同时，也可以得出$k=0$这一点确实对应着零频</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-栅栏效应与实际分辨率"><a href="#2-栅栏效应与实际分辨率" class="headerlink" title="2.栅栏效应与实际分辨率"></a>2.栅栏效应与实际分辨率</h2><ul>
<li><p>栅栏效应：就是真实频率落在了点与点之间的缝隙里，补零操作可以缓解栅栏效应</p>
</li>
<li><p>实际分辨率：</p>
<script type="math/tex; mode=display">
d_f=\frac{f_s}{N}</script></li>
<li><p>借助MATLAB程序加深理解</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear all;</span><br><span class="line"></span><br><span class="line">fs=<span class="number">100</span>;</span><br><span class="line">N=<span class="number">100</span>;</span><br><span class="line">xn=<span class="number">0</span>:(N<span class="number">-1</span>);</span><br><span class="line">t=xn/fs; <span class="comment">%这里的t代表信号长度，而1/t也决定了实际分辨率</span></span><br><span class="line"></span><br><span class="line">f0=<span class="number">10</span>;f1=<span class="number">11</span>;</span><br><span class="line">s=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f0*t)+<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f1*t);</span><br><span class="line">xn=xn/N*fs;<span class="comment">%此时xn横坐标为实际频率</span></span><br><span class="line">s_fft=<span class="built_in">abs</span>(fft(s,N));</span><br><span class="line">s_zero_fft=<span class="built_in">abs</span>(fft(s,<span class="number">2</span>*N));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(xn,s_fft);</span><br><span class="line">title(<span class="string">&quot;N=500 FFT&quot;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;f/Hz&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Amp&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">0</span>:<span class="number">199</span>]/<span class="number">200</span>*fs,s_zero_fft);</span><br><span class="line">title(<span class="string">&quot;N=500 padding=500 FFT&quot;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;f/Hz&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Amp&#x27;</span>)</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/FFT_df.bmp" alt="FFT_df"></p>
<ul>
<li>虽然说理论上1Hz可以分辨开，但由于实际观察时显示分辨率不够，所以导致通过观察频谱图无法分辨出两个目标</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>不补零的情况下，能够分辨的频率间隔其实是$2\times d_f$</strong></p>
<p><img src="/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/FFT_df-1696759150791-3.bmp" alt="FFT_df"></p>
</li>
</ul>
<hr>
<h1 id="时域离散系统的网络结构"><a href="#时域离散系统的网络结构" class="headerlink" title="时域离散系统的网络结构"></a>时域离散系统的网络结构</h1><ul>
<li><p>网络的基本组成结构：</p>
<p><img src="/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/image-20231008181123070.png" alt="image-20231008181123070" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="1-IIR的网络结构"><a href="#1-IIR的网络结构" class="headerlink" title="1.IIR的网络结构"></a>1.IIR的网络结构</h2><ul>
<li><p>IIR的差分方程：</p>
<script type="math/tex; mode=display">
y(n)=\sum_{k=1}^Na_ky(n-k)+\sum_{r=0}^Mb_rx(n-r)</script></li>
<li><p>直接Ⅰ型结构：</p>
<p><img src="/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/image-20231008183456136.png" alt="image-20231008183456136" style="zoom: 80%;"></p>
</li>
<li><p>直接Ⅱ型结构：</p>
</li>
</ul>
<p><img src="/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/image-20231008183544678.png" alt="image-20231008183544678" style="zoom:80%;"></p>
<ul>
<li><p>级联型结构：</p>
<p><img src="/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/image-20231008183634723.png" alt="image-20231008183634723" style="zoom:80%;"></p>
</li>
</ul>
<h2 id="2-FIR的网络结构"><a href="#2-FIR的网络结构" class="headerlink" title="2.FIR的网络结构"></a>2.FIR的网络结构</h2><ul>
<li>FIR的差分方程：<script type="math/tex; mode=display">
y(n)=\sum_{k=0}^{N-1}h(k)x(n-k)</script></li>
</ul>
<ul>
<li><p>直接型结构：</p>
<p><img src="/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/image-20231008183936210.png" alt="image-20231008183936210" style="zoom:80%;"></p>
</li>
<li><p>级联型结构：</p>
<p><img src="/2023/10/07/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/image-20231008184103088.png" alt="image-20231008184103088" style="zoom:80%;"></p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://blog.csdn.net/qq_42580947/article/details/106231299">数字滤波器(一)—IIR与FIR的基本结构与MATLAB实现_iir结构-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理之频域处理</title>
    <url>/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>本节主要介绍了数字信号处理中的一些频域上的处理，包括低通带通采样定理，DTFT、DFS、DFT。</p>
<span id="more"></span>
<h1 id="带通采样定理"><a href="#带通采样定理" class="headerlink" title="带通采样定理"></a>带通采样定理</h1><ul>
<li><p><strong>采样是频谱的左右搬移（以采样频率$f_s$左右搬移）</strong></p>
</li>
<li><p>那么对于一个$f_L\sim f_H$的窄带信号采样，有：</p>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/image-20231006214111761.png" alt="image-20231006214111761" style="zoom: 67%;"></p>
<ul>
<li><p>只有当频谱不发生交叠时，才能完全恢复出时域信号</p>
</li>
<li><p>那么需满足如下条件：</p>
<script type="math/tex; mode=display">
f_L\ge -f_L+(k-1)f_s</script><script type="math/tex; mode=display">
f_H\le -f_H+kf_s</script></li>
<li><p>整合上述两式可得到：</p>
<script type="math/tex; mode=display">
\frac{2f_H}{k}\le f_s \le \frac{2f_L}{k-1}</script><script type="math/tex; mode=display">
1\le k\le int[\frac{f_H}{B}],B=f_L-f_H</script></li>
</ul>
</li>
<li><p>用一个matlab示例程序来演示带通采样频率的取值</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;                      <span class="comment">%清屏</span></span><br><span class="line">clear all;                <span class="comment">%清变量</span></span><br><span class="line"></span><br><span class="line">fL=<span class="number">60</span>;</span><br><span class="line">fH=<span class="number">69</span>;</span><br><span class="line">B=fH-fL;</span><br><span class="line">k=<span class="number">1</span>:(fH/B);</span><br><span class="line">fs_min=<span class="number">2</span>*fH./k</span><br><span class="line">fs_max=<span class="number">2</span>*fL./(k<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/image-20231006215453694.png" alt="image-20231006215453694" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="奈奎斯特采样定理"><a href="#奈奎斯特采样定理" class="headerlink" title="奈奎斯特采样定理"></a>奈奎斯特采样定理</h1><ul>
<li><p>采样频率$f_s\ge 2f_H$（信号最高频率为$f_H$）</p>
</li>
<li><p>用一个matlab程序示例来理解</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;                      <span class="comment">%清屏</span></span><br><span class="line">clear all;                <span class="comment">%清变量</span></span><br><span class="line"></span><br><span class="line">N=<span class="number">70</span>;                     <span class="comment">%数据长度</span></span><br><span class="line">fs=<span class="number">64000</span>;                 <span class="comment">%采样频率</span></span><br><span class="line">f0=<span class="number">67000</span>;</span><br><span class="line">f1=<span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:(N<span class="number">-1</span>);</span><br><span class="line">t=t/fs;                   <span class="comment">%时间序列</span></span><br><span class="line"></span><br><span class="line">s0=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f0*t);</span><br><span class="line">s1=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f1*t);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line">subplot(<span class="number">211</span>);<span class="built_in">plot</span>(t,s0); title(<span class="string">&#x27;f0=67kHz&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);<span class="built_in">plot</span>(t,s1); title(<span class="string">&#x27;f1=3kHz&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/Nyquist.bmp" alt="Nyquist" style="zoom:50%;"></p>
</li>
<li><p>可见采样后67KHz的频率和3KHz的频率的时域信号一样</p>
</li>
<li><p>其原因在于，采样是频谱以$f_s$的线性搬移，搬移后的频率会通过一个低通滤波器，也就是只留下频谱在$\pm \frac{f_s}2$之间的频率，即：</p>
<script type="math/tex; mode=display">
f_{out}=\pm k\times f_s \pm f_i\\
f_{out}\le \frac{f_s}2</script></li>
<li><p>所以67KHz会有一个搬移到3KHz（67KHz-64KHz），3KHz在32KHz内，故采样滤波后会输出一个3KHz的正弦波</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="时域离散傅里叶变换"><a href="#时域离散傅里叶变换" class="headerlink" title="时域离散傅里叶变换"></a>时域离散傅里叶变换</h1><ul>
<li><p>离散时间傅里叶变换的公式：</p>
<script type="math/tex; mode=display">
x(e^{jw})=\sum_{n=-\infty}^{+\infty}x(n)e^{-jwn}</script><script type="math/tex; mode=display">
逆变换:x(n)=\frac1{2\pi}\int_{2\pi}x(e^{jw})e^{jwn}dw</script></li>
<li><p><strong>$x(e^{jw})$是角频率以$2\pi$为周期的函数</strong></p>
</li>
<li><p>理想低通滤波器的iDTFT</p>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/image-20231006235153087.png" alt="image-20231006235153087" style="zoom: 50%;"></p>
<ul>
<li><p>逆变换的公式推导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
h(n)&=\frac1{2\pi}\int_{2\pi}x(e^{jw})e^{jwn}dw\\
&=\frac1{2\pi}\int_{w_c}^{w_c}e^{jwn}dw\\
&=\frac1{2\pi jn}[e^{jw_cn}-e^{-jw_cn}]\\
&=\frac{sin(w_cn)}{\pi n}
\end{aligned}</script></li>
<li><p>由Matlab可以画出理想低通滤波器的时域波形</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;                      <span class="comment">%清屏</span></span><br><span class="line">clear all;                <span class="comment">%清变量</span></span><br><span class="line"></span><br><span class="line">wc=<span class="number">0.5</span>;</span><br><span class="line">n=<span class="number">-200</span>:<span class="number">200</span>;</span><br><span class="line">hn=<span class="built_in">sin</span>(wc*n)./(<span class="built_in">pi</span>*n);</span><br><span class="line">stem(n,hn)</span><br><span class="line">xlabel(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;hn&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/rect_ift.bmp" alt="rect_ift" style="zoom:80%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="时域离散傅里叶级数"><a href="#时域离散傅里叶级数" class="headerlink" title="时域离散傅里叶级数"></a>时域离散傅里叶级数</h1><ul>
<li>离散傅里叶级数的公式：<script type="math/tex; mode=display">
x(k)=\frac1N\sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}Nkn}\quad k=0\sim N-1</script></li>
</ul>
<script type="math/tex; mode=display">
x(n)=\sum_{k=0}^{N-1}x(k)e^{j\frac{2\pi}{N}kn}</script><ul>
<li>更详细的解释见我的另一篇文章：<a href="https://ssy1938010014.github.io/2023/03/03/信号处理中的小知识点/">信号处理中的小知识点</a></li>
</ul>
<hr>
<h1 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h1><ul>
<li><p>离散傅里叶变换的公式：</p>
<script type="math/tex; mode=display">
x(k)=\sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi k}Nn} \quad k=0\sim N-1</script><script type="math/tex; mode=display">
逆变换:x(n)=\frac1N\sum_{k=0}^{N-1}x(k)e^{j\frac{2\pi k}Nn}</script></li>
<li><p><strong>DFT一定是关于$\frac N2$共轭对称的，也就是$x(k_0)=x(N-k_0)$共轭</strong></p>
</li>
</ul>
<h2 id="1-MATLAB辅助理解DFT"><a href="#1-MATLAB辅助理解DFT" class="headerlink" title="1.MATLAB辅助理解DFT"></a>1.MATLAB辅助理解DFT</h2><ul>
<li><p>通过Matlab来理解DFT的计算过程：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;                      <span class="comment">%清屏</span></span><br><span class="line">clear all;                <span class="comment">%清变量</span></span><br><span class="line"></span><br><span class="line">N=<span class="number">16</span>;                     <span class="comment">%矩形序列的周期</span></span><br><span class="line">L=<span class="number">4</span>;                      <span class="comment">%矩形序列的长度</span></span><br><span class="line">rn=<span class="built_in">ones</span>(<span class="number">1</span>,L);             <span class="comment">%矩形的长度</span></span><br><span class="line">xn=[rn,<span class="built_in">zeros</span>(<span class="number">1</span>,N-L)];</span><br><span class="line">n=<span class="number">0</span>:N<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">xk=fft(rn,N);             <span class="comment">%离散谱</span></span><br><span class="line"></span><br><span class="line">w=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">xw=(<span class="number">1</span>-<span class="built_in">exp</span>(-<span class="built_in">j</span>*w*L))./(<span class="number">1</span>-<span class="built_in">exp</span>(-<span class="built_in">j</span>*w)); <span class="comment">%连续谱</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">311</span>)</span><br><span class="line">stem(n,xn);title(<span class="string">&#x27;x(n)&#x27;</span>);grid on;</span><br><span class="line">subplot(<span class="number">312</span>);</span><br><span class="line">stem(n,<span class="built_in">abs</span>(xk));title(<span class="string">&#x27;X(K)&#x27;</span>); grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">313</span>)</span><br><span class="line"><span class="built_in">plot</span>(w,<span class="built_in">abs</span>(xw));title(<span class="string">&#x27;X(jw)&#x27;</span>);grid on;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/image-20231007020954256.png" alt="image-20231007020954256" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>借助matlab讨论N点不同时对幅频特性的影响</p>
<ul>
<li><p><strong>不同序列信号，参与DFT计算的N不同时，DFT可以一样，也可以不一样</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear all;            <span class="comment">%清屏清变量</span></span><br><span class="line"></span><br><span class="line">n1=<span class="number">0</span>:<span class="number">3</span>; n2=<span class="number">4</span>:<span class="number">7</span>;</span><br><span class="line">n=[n1,n2];</span><br><span class="line"></span><br><span class="line">x2n1=n1+<span class="number">1</span>;</span><br><span class="line">x2n2=<span class="number">8</span>-n2;</span><br><span class="line">x2n=[x2n1,x2n2];</span><br><span class="line"></span><br><span class="line">x3n1=<span class="number">4</span>-n1;</span><br><span class="line">x3n2=n2<span class="number">-3</span>;</span><br><span class="line">x3n=[x3n1,x3n2];</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">321</span>);stem(x2n);title(<span class="string">&#x27;xn2&#x27;</span>);</span><br><span class="line">subplot(<span class="number">322</span>);stem(x3n);title(<span class="string">&#x27;xn3&#x27;</span>);</span><br><span class="line">subplot(<span class="number">323</span>);stem(<span class="built_in">abs</span>(fft(x2n,<span class="number">8</span>)));title(<span class="string">&#x27;DFT(x2n,8)&#x27;</span>);</span><br><span class="line">subplot(<span class="number">324</span>);stem(<span class="built_in">abs</span>(fft(x3n,<span class="number">8</span>)));title(<span class="string">&#x27;DFT(x3n,8)&#x27;</span>);</span><br><span class="line">subplot(<span class="number">325</span>);stem(<span class="built_in">abs</span>(fft(x2n,<span class="number">16</span>)));title(<span class="string">&#x27;DFT(x2n,16)&#x27;</span>);</span><br><span class="line">subplot(<span class="number">326</span>);stem(<span class="built_in">abs</span>(fft(x3n,<span class="number">16</span>)));title(<span class="string">&#x27;DFT(x3n,16)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">subplot(<span class="number">221</span>);stem([x2n x2n x2n x2n]);title(<span class="string">&#x27;xn2\_8\_repeat4&#x27;</span>);</span><br><span class="line">subplot(<span class="number">222</span>);stem([x3n x3n x3n x3n]);title(<span class="string">&#x27;xn3\_8\_repeat4&#x27;</span>);</span><br><span class="line">x2n=[x2n,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">8</span>)];</span><br><span class="line">x3n=[x3n,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">8</span>)];</span><br><span class="line">subplot(<span class="number">223</span>);stem([x2n x2n x2n x2n]);title(<span class="string">&#x27;xn2\_16\_repeat4&#x27;</span>);</span><br><span class="line">subplot(<span class="number">224</span>);stem([x3n x3n x3n x3n]);title(<span class="string">&#x27;xn3\_16\_repeat4&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下：</li>
</ul>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/DFT_diff_N_8_16_answer.bmp" alt="DFT_diff_N_8_16_answer"></p>
<ul>
<li><p>观察到，输入有限序列xn2和xn3不同，但当做8点ffts时，二者结果相同，做16点fft时，二者结果不同</p>
</li>
<li><p>究其原因，首先画出xn2和xn3分别进行8和16点周期延拓的序列图像</p>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/DFT_diff_N_8_16.bmp" alt="DFT_diff_N_8_16"></p>
</li>
<li><p>从图中可以看到，进行8点周期延拓后，xn2和xn3是相同的周期信号，只是相位不同，但并不会影响DFT的幅频特性</p>
</li>
<li><p>进行16点周期延拓后，xn2和xn3显然不是同一个周期信号，故DFT的结果也会不一致</p>
</li>
<li><p>从上述分析得出结论，<strong>DFT是将M个有限序列进行N点（N&gt;M时补零）进行周期延拓，然后选取一个周期内的序列，进行DFT计算</strong></p>
</li>
</ul>
</li>
<li><p><strong>对同一序列，进行不同N的DFT计算，结果也会不同</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear all;            <span class="comment">%清屏清变量</span></span><br><span class="line"></span><br><span class="line">fs=<span class="number">100</span>;                   <span class="comment">%采样频率</span></span><br><span class="line">f=<span class="number">10</span>;                     <span class="comment">%信号频率</span></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:<span class="number">10</span>;              <span class="comment">%时间序列</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f*t);          <span class="comment">%正弦信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%绘制幅频响应</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">211</span>);stem(<span class="built_in">abs</span>(fft(x,<span class="number">40</span>)));</span><br><span class="line">subplot(<span class="number">212</span>);stem(<span class="built_in">abs</span>(fft(x,<span class="number">45</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">x40=[x(<span class="number">1</span>:<span class="number">40</span>),x(<span class="number">1</span>:<span class="number">40</span>),x(<span class="number">1</span>:<span class="number">40</span>),x(<span class="number">1</span>:<span class="number">40</span>)];</span><br><span class="line">x45=[x(<span class="number">1</span>:<span class="number">45</span>),x(<span class="number">1</span>:<span class="number">45</span>),x(<span class="number">1</span>:<span class="number">45</span>),x(<span class="number">1</span>:<span class="number">45</span>)];</span><br><span class="line">subplot(<span class="number">211</span>);<span class="built_in">plot</span>(x40); title(<span class="string">&#x27;x40&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);<span class="built_in">plot</span>(x45); title(<span class="string">&#x27;x45&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下：</li>
</ul>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/DFT_sin_diff_N_answer.bmp" alt="DFT_sin_diff_N_answer"></p>
<ul>
<li><p>从结果图中观察到对sin函数进行40点DFT和45点DFT是不一样</p>
</li>
<li><p>究其原因，首先可以画出在时域上分别采样40点和45点的时域波形</p>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/DFT_sin_diff_N.bmp" alt="DFT_sin_diff_N"></p>
</li>
<li><p><strong>观察上图，因为在时域上取45点序列进行周期延拓后形成的波形，并不是一个正常的正弦波，故最后的DFT结果当然跟理想的sin频谱不一样，其实这里就是出现频谱泄露的原因，也就是后面为什么会有窗函数这个玩意</strong></p>
</li>
<li><p>关于为什么40点是正常的正弦波而45点不是正常的正弦波的解释：</p>
<ul>
<li>信号频率为10Hz，采样频率为100Hz，也就是一个周期采10个点，40个点也就是采了4个周期</li>
<li>而45并不是10的倍数，采样了4个多一点的周期，所以周期延拓后并不是一个正常的正弦波</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>借sin函数讨论不同N对幅频特性中幅度的影响</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear all;            <span class="comment">%清屏清变量</span></span><br><span class="line"></span><br><span class="line">fs=<span class="number">100</span>;                   <span class="comment">%采样频率</span></span><br><span class="line">f=<span class="number">10</span>;                     <span class="comment">%信号频率</span></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:<span class="number">10</span>;              <span class="comment">%时间序列</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f*t);          <span class="comment">%正弦信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%绘制幅频响应</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">411</span>);stem(<span class="built_in">abs</span>(fft(x,<span class="number">20</span>)));title(<span class="string">&#x27;DFT\_x20&#x27;</span>);</span><br><span class="line">subplot(<span class="number">412</span>);stem(<span class="built_in">abs</span>(fft(x,<span class="number">80</span>)));title(<span class="string">&#x27;DFT\_x80&#x27;</span>);</span><br><span class="line">subplot(<span class="number">413</span>);stem(<span class="built_in">abs</span>(fft(x,<span class="number">160</span>)));title(<span class="string">&#x27;DFT\_x160&#x27;</span>);</span><br><span class="line">subplot(<span class="number">414</span>);stem(<span class="built_in">abs</span>(fft(x,<span class="number">1000</span>)));title(<span class="string">&#x27;DFT\_x1000&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/DFT_sin_N_double_amp.bmp" alt="DFT_sin_N_double_amp"></p>
</li>
<li><p>这张图完美诠释了，N点double，FFT幅度会double</p>
</li>
<li><p><strong>但前提是N&lt;M，且N需要是$\frac{f_s}{f_0}$的倍数</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-循环卷积原理"><a href="#2-循环卷积原理" class="headerlink" title="2.循环卷积原理"></a>2.循环卷积原理</h2><ul>
<li><p>公式如下：</p>
<script type="math/tex; mode=display">
x_1(n)\circledast x_2(n)\rightarrow x_1(k)\cdot x_2(k)</script><script type="math/tex; mode=display">
x_1(n)\cdot x_2(n)\rightarrow \frac1N[x_1(k)\circledast x_2(k)]</script></li>
<li><p>循环卷积长度：若$x(n):L,h(n):M$，那么循环长度$N$为：</p>
<script type="math/tex; mode=display">
N=max(L,M)</script><ul>
<li><strong>是对$L$或者$M$的长度补零，补到比$L+M-1$长</strong>，那么循环卷积和线性卷积相等</li>
</ul>
</li>
<li><p><strong>当循环卷积长度$\ge$线性卷积长度$(L+M-1)$时，二者计算得到的结果相等</strong></p>
</li>
<li><p>循环卷积的计算示例：</p>
<p>|                        |      |      | $a(n)$ | 1    | 2    | 3    | 4    |      |      |      |           |<br>| ——————————— | —— | —— | ——— | —— | —— | —— | —— | —— | —— | —— | ————- |<br>| $b(n)$翻转后的周期延拓 | 0    | 7    | 6      | 5    | 0    | 7    | 6    | 5    | 0    | 7    | $c(0)=50$ |<br>| 翻转延拓后向右移动1    | 5    | 0    | 7      | 6    | 5    | 0    | 7    | 6    | 5    | 0    | $c(1)=44$ |<br>| 翻转延拓后向右移动2    | 6    | 5    | 0      | 7    | 6    | 5    | 0    | 7    | 6    | 5    | $c(2)=34$ |<br>| 翻转延拓后向右移动3    | 7    | 6    | 5      | 0    | 7    | 6    | 5    | 0    | 7    | 6    | $c(3)=52$ |</p>
</li>
<li><p>MATLAB的验证</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;</span><br><span class="line">an=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">bn=[<span class="number">5</span> <span class="number">6</span> <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%4点DFT验证循环卷积的计算</span></span><br><span class="line">an_fft_4=fft(an,<span class="number">4</span>);</span><br><span class="line">bn_fft_4=fft(bn,<span class="number">4</span>);</span><br><span class="line">cn_circle_4=ifft((an_fft_4.*bn_fft_4),<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%6点DFT验证循环卷积与线性卷积相等</span></span><br><span class="line">an_fft_6=fft(an,<span class="number">6</span>);</span><br><span class="line">bn_fft_6=fft(bn,<span class="number">6</span>);</span><br><span class="line">cn_linear=conv(an,bn)</span><br><span class="line">cn_circle_6=ifft((an_fft_6.*bn_fft_6),<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%大于6点DFT时循环卷积的结果</span></span><br><span class="line">an_fft_8=fft(an,<span class="number">8</span>);</span><br><span class="line">bn_fft_8=fft(bn,<span class="number">8</span>);</span><br><span class="line">cn_circle_8=ifft((an_fft_8.*bn_fft_8),<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下：</li>
</ul>
<p><img src="/2023/10/06/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E9%A2%91%E5%9F%9F%E5%A4%84%E7%90%86/image-20231007112338168.png" alt="image-20231007112338168" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV13W4y187qy/?spm_id_from=333.788&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">学以致用系列课程之数字信号处理]_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之AXI DMA（基于PYNQ-Z2开发板）</title>
    <url>/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%20DMA%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节对AXI DMA的进行了基本介绍，并通过AXI DMA环路实验简单演示了AXI DMA IP核的使用</p>
<span id="more"></span> 
<h1 id="AXI-DMA简介"><a href="#AXI-DMA简介" class="headerlink" title="AXI DMA简介"></a>AXI DMA简介</h1><ul>
<li><p><strong>AXI DMA：AXI Direct Memory Access 直接内存访问</strong></p>
<ul>
<li><strong>AXI DMA 为内存和AXI4—Stream外设之间提供了高带宽的直接内存访问</strong></li>
<li>其可选的S/G功能可以将CPU从数据搬运任务中解放出来</li>
<li>AXI DMA 通过AXI4-Lite接口对寄存器做一些配置和获取</li>
<li>使用AXI_DMA可以大大提高数据传输的效率和速度。它通过直接访问主存中的数据，避免了CPU的介入，从而实现了高速、并行的数据传输。而且，由于AXI_DMA是专门设计用于处理数据传输的协议，它提供了一系列优化的特性，如数据缓冲、数据对齐、FIFO和错误处理等，可以更好地满足系统的性能需求</li>
</ul>
</li>
<li><p><strong>MM2S</strong>：MemoryMap to Stream ,存储器映射（AXI4—Full）到 AXI4—Stream</p>
</li>
</ul>
<ul>
<li><strong>S2MM</strong>：Stream to MemoryMap ,AXI4—Stream到存储器映射（AXI4—Full）</li>
<li><p><strong>AXI DMA 编程顺序</strong>：</p>
<ul>
<li><strong>Direct Register Mode （简单DMA）</strong>：<ul>
<li>此模式提供了在MM2S和S2MM通道上进行简单DMA传输的配置，只需较少的FPGA资源，通过访问DMACR、源地址或者目的地址和长度寄存器发起DMA传输。当传输完成后，如果使能了产生中断输出，那么DMASR寄存器相关联的通道位会有效</li>
</ul>
</li>
<li><strong>DMA的MM2S（存储器映射到Stream）通道的启动顺序</strong>：<ul>
<li>开启/使能MM2S通道</li>
<li>如果需要的话，可以使能中断</li>
<li>写一个有效的源地址到MM2S_SA寄存器：如果没有使能DRE的功能，在指定起始地址时，需要注意字节地址对齐，哪些地址是对齐或者不对齐的， 取决于Stream流的数据位宽</li>
<li>写传输的字节数到MM2S_LENGTH寄存器：一个长度为0的值是无效的，而一个非0值，将会决定存储器映射到Stream流的数据个数。需要注意的是，必须最后一个配置MM2S_LENGTH寄存器，而其他寄存器的配置顺序没有要求</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>S/G模式</strong>：</p>
<ul>
<li>它把传输的基本参数存储在内存中，这些参数就是被称为BD（Buffer Descriptor ），在工作时，通过SG接口加载和更新BD中的状态。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="AXI-DMA环路测试实验"><a href="#AXI-DMA环路测试实验" class="headerlink" title="AXI DMA环路测试实验"></a>AXI DMA环路测试实验</h1><ul>
<li><p>实验任务：使用PL的AXI DMA IP核从DDR3中读取数据，并将数据写回到DDR3中</p>
<p><img src="/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%20DMA%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002144918385.png" alt="image-20231002144918385" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="1-Vivado中的相关配置"><a href="#1-Vivado中的相关配置" class="headerlink" title="1.Vivado中的相关配置"></a>1.Vivado中的相关配置</h2><ul>
<li><p>ZYNQ processing system的配置：自动配置好后，还需要加上如下配置</p>
<p><img src="/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%20DMA%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002145724577.png" alt="image-20231002145724577" style="zoom:50%;"></p>
<p><img src="/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%20DMA%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002145902728.png" alt="image-20231002145902728" style="zoom:50%;"></p>
</li>
<li><p>添加AXI4-Stream Data FIFO IP核模拟一个stream流外设</p>
</li>
<li><p>添加Concat ip核合并中断端口</p>
</li>
<li><p>最终Block框图如下：</p>
<p><img src="/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%20DMA%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002151427960.png" alt="image-20231002151427960"></p>
</li>
</ul>
<h2 id="2-AXI-DMA-IP核的使用"><a href="#2-AXI-DMA-IP核的使用" class="headerlink" title="2.AXI DMA IP核的使用"></a>2.AXI DMA IP核的使用</h2><p><img src="/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%20DMA%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002144003054.png" alt="image-20231002144003054" style="zoom: 33%;"></p>
<h2 id="3-Vitis中的代码编写"><a href="#3-Vitis中的代码编写" class="headerlink" title="3.Vitis中的代码编写"></a>3.Vitis中的代码编写</h2><ul>
<li><p>使用Xilinx提供的简单DMA中断示例代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xaxidma.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xil_exception.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xscugic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************** Constant Definitions *****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA_DEV_ID          XPAR_AXIDMA_0_DEVICE_ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_INTR_ID          XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_INTR_ID          XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTC_DEVICE_ID      XPAR_SCUGIC_SINGLE_DEVICE_ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DDR_BASE_ADDR       XPAR_PS7_DDR_0_S_AXI_BASEADDR   <span class="comment">//0x00100000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_BASE_ADDR       (DDR_BASE_ADDR + 0x1000000)     <span class="comment">//0x01100000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_BUFFER_BASE      (MEM_BASE_ADDR + 0x00100000)    <span class="comment">//0x01200000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_BUFFER_BASE      (MEM_BASE_ADDR + 0x00300000)    <span class="comment">//0x01400000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESET_TIMEOUT_COUNTER   10000    <span class="comment">//复位时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_START_VALUE        0x0      <span class="comment">//测试起始值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PKT_LEN             0x100    <span class="comment">//发送包长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************** Function Prototypes ******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">check_data</span><span class="params">(<span class="type">int</span> length, u8 start_value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">tx_intr_handler</span><span class="params">(<span class="type">void</span> *callback)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rx_intr_handler</span><span class="params">(<span class="type">void</span> *callback)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">setup_intr_system</span><span class="params">(XScuGic * int_ins_ptr, XAxiDma * axidma_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">        u16 tx_intr_id, u16 rx_intr_id)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">disable_intr_system</span><span class="params">(XScuGic * int_ins_ptr, u16 tx_intr_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        u16 rx_intr_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************** Variable Definitions *****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> XAxiDma axidma;     <span class="comment">//XAxiDma实例</span></span><br><span class="line"><span class="type">static</span> XScuGic intc;       <span class="comment">//中断控制器的实例</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> tx_done;      <span class="comment">//发送完成标志</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> rx_done;      <span class="comment">//接收完成标志</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> error;        <span class="comment">//传输出错标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************** Function Definitions *****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    u8 value;</span><br><span class="line">    u8 *tx_buffer_ptr;</span><br><span class="line">    u8 *rx_buffer_ptr;</span><br><span class="line">    XAxiDma_Config *config;</span><br><span class="line"></span><br><span class="line">    tx_buffer_ptr = (u8 *) TX_BUFFER_BASE;</span><br><span class="line">    rx_buffer_ptr = (u8 *) RX_BUFFER_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xil_printf</span>(<span class="string">&quot;\r\n--- Entering main() --- \r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    config = <span class="built_in">XAxiDma_LookupConfig</span>(DMA_DEV_ID);</span><br><span class="line">    <span class="keyword">if</span> (!config) &#123;</span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;No config found for %d\r\n&quot;</span>, DMA_DEV_ID);</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化DMA引擎</span></span><br><span class="line">    status = <span class="built_in">XAxiDma_CfgInitialize</span>(&amp;axidma, config);</span><br><span class="line">    <span class="keyword">if</span> (status != XST_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;Initialization failed %d\r\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">XAxiDma_HasSg</span>(&amp;axidma)) &#123;</span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;Device configured as SG mode \r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立中断系统</span></span><br><span class="line">    status = <span class="built_in">setup_intr_system</span>(&amp;intc, &amp;axidma, TX_INTR_ID, RX_INTR_ID);</span><br><span class="line">    <span class="keyword">if</span> (status != XST_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;Failed intr setup\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化标志信号</span></span><br><span class="line">    tx_done = <span class="number">0</span>;</span><br><span class="line">    rx_done = <span class="number">0</span>;</span><br><span class="line">    error   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    value = TEST_START_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_PKT_LEN; i++) &#123;</span><br><span class="line">        tx_buffer_ptr[i] = value;</span><br><span class="line">        value = (value + <span class="number">1</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Xil_DCacheFlushRange</span>((UINTPTR) tx_buffer_ptr, MAX_PKT_LEN);   <span class="comment">//刷新Data Cache</span></span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">XAxiDma_SimpleTransfer</span>(&amp;axidma, (UINTPTR) tx_buffer_ptr,</span><br><span class="line">    MAX_PKT_LEN, XAXIDMA_DMA_TO_DEVICE);</span><br><span class="line">    <span class="keyword">if</span> (status != XST_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">XAxiDma_SimpleTransfer</span>(&amp;axidma, (UINTPTR) rx_buffer_ptr,</span><br><span class="line">    MAX_PKT_LEN, XAXIDMA_DEVICE_TO_DMA);</span><br><span class="line">    <span class="keyword">if</span> (status != XST_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Xil_DCacheFlushRange</span>((UINTPTR) rx_buffer_ptr, MAX_PKT_LEN);   <span class="comment">//刷新Data Cache</span></span><br><span class="line">    <span class="keyword">while</span> (!tx_done &amp;&amp; !rx_done &amp;&amp; !error)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">//传输出错</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;Failed test transmit%s done, &quot;</span></span><br><span class="line">                <span class="string">&quot;receive%s done\r\n&quot;</span>, tx_done ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; not&quot;</span>,</span><br><span class="line">                rx_done ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; not&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传输完成，检查数据是否正确</span></span><br><span class="line">    status = <span class="built_in">check_data</span>(MAX_PKT_LEN, TEST_START_VALUE);</span><br><span class="line">    <span class="keyword">if</span> (status != XST_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;Data check failed\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xil_printf</span>(<span class="string">&quot;Successfully ran AXI DMA Loop\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">disable_intr_system</span>(&amp;intc, TX_INTR_ID, RX_INTR_ID);</span><br><span class="line"></span><br><span class="line">    Done: <span class="built_in">xil_printf</span>(<span class="string">&quot;--- Exiting main() --- \r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查数据缓冲区</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">check_data</span><span class="params">(<span class="type">int</span> length, u8 start_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u8 value;</span><br><span class="line">    u8 *rx_packet;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    value = start_value;</span><br><span class="line">    rx_packet = (u8 *) RX_BUFFER_BASE;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rx_packet[i] != value) &#123;</span><br><span class="line">            <span class="built_in">xil_printf</span>(<span class="string">&quot;Data error %d: %x/%x\r\n&quot;</span>, i, rx_packet[i], value);</span><br><span class="line">            <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">        value = (value + <span class="number">1</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DMA TX中断处理函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">tx_intr_handler</span><span class="params">(<span class="type">void</span> *callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> timeout;</span><br><span class="line">    u32 irq_status;</span><br><span class="line">    XAxiDma *axidma_inst = (XAxiDma *) callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取待处理的中断</span></span><br><span class="line">    irq_status = <span class="built_in">XAxiDma_IntrGetIrq</span>(axidma_inst, XAXIDMA_DMA_TO_DEVICE);</span><br><span class="line">    <span class="comment">//确认待处理的中断</span></span><br><span class="line">    <span class="built_in">XAxiDma_IntrAckIrq</span>(axidma_inst, irq_status, XAXIDMA_DMA_TO_DEVICE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Tx出错</span></span><br><span class="line">    <span class="keyword">if</span> ((irq_status &amp; XAXIDMA_IRQ_ERROR_MASK)) &#123;</span><br><span class="line">        error = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">XAxiDma_Reset</span>(axidma_inst);</span><br><span class="line">        timeout = RESET_TIMEOUT_COUNTER;</span><br><span class="line">        <span class="keyword">while</span> (timeout) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">XAxiDma_ResetIsDone</span>(axidma_inst))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            timeout -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Tx完成</span></span><br><span class="line">    <span class="keyword">if</span> ((irq_status &amp; XAXIDMA_IRQ_IOC_MASK))</span><br><span class="line">        tx_done = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DMA RX中断处理函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rx_intr_handler</span><span class="params">(<span class="type">void</span> *callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 irq_status;</span><br><span class="line">    <span class="type">int</span> timeout;</span><br><span class="line">    XAxiDma *axidma_inst = (XAxiDma *) callback;</span><br><span class="line"></span><br><span class="line">    irq_status = <span class="built_in">XAxiDma_IntrGetIrq</span>(axidma_inst, XAXIDMA_DEVICE_TO_DMA);</span><br><span class="line">    <span class="built_in">XAxiDma_IntrAckIrq</span>(axidma_inst, irq_status, XAXIDMA_DEVICE_TO_DMA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Rx出错</span></span><br><span class="line">    <span class="keyword">if</span> ((irq_status &amp; XAXIDMA_IRQ_ERROR_MASK)) &#123;</span><br><span class="line">        error = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">XAxiDma_Reset</span>(axidma_inst);</span><br><span class="line">        timeout = RESET_TIMEOUT_COUNTER;</span><br><span class="line">        <span class="keyword">while</span> (timeout) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">XAxiDma_ResetIsDone</span>(axidma_inst))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            timeout -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Rx完成</span></span><br><span class="line">    <span class="keyword">if</span> ((irq_status &amp; XAXIDMA_IRQ_IOC_MASK))</span><br><span class="line">        rx_done = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立DMA中断系统</span></span><br><span class="line"><span class="comment">//  @param   int_ins_ptr是指向XScuGic实例的指针</span></span><br><span class="line"><span class="comment">//  @param   AxiDmaPtr是指向DMA引擎实例的指针</span></span><br><span class="line"><span class="comment">//  @param   tx_intr_id是TX通道中断ID</span></span><br><span class="line"><span class="comment">//  @param   rx_intr_id是RX通道中断ID</span></span><br><span class="line"><span class="comment">//  @return：成功返回XST_SUCCESS，否则返回XST_FAILURE</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">setup_intr_system</span><span class="params">(XScuGic * int_ins_ptr, XAxiDma * axidma_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">        u16 tx_intr_id, u16 rx_intr_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    XScuGic_Config *intc_config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化中断控制器驱动</span></span><br><span class="line">    intc_config = <span class="built_in">XScuGic_LookupConfig</span>(INTC_DEVICE_ID);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == intc_config) &#123;</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    status = <span class="built_in">XScuGic_CfgInitialize</span>(int_ins_ptr, intc_config,</span><br><span class="line">            intc_config-&gt;CpuBaseAddress);</span><br><span class="line">    <span class="keyword">if</span> (status != XST_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置优先级和触发类型</span></span><br><span class="line">    <span class="built_in">XScuGic_SetPriorityTriggerType</span>(int_ins_ptr, tx_intr_id, <span class="number">0xA0</span>, <span class="number">0x3</span>);</span><br><span class="line">    <span class="built_in">XScuGic_SetPriorityTriggerType</span>(int_ins_ptr, rx_intr_id, <span class="number">0xA0</span>, <span class="number">0x3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为中断设置中断处理函数</span></span><br><span class="line">    status = <span class="built_in">XScuGic_Connect</span>(int_ins_ptr, tx_intr_id,</span><br><span class="line">            (Xil_InterruptHandler) tx_intr_handler, axidma_ptr);</span><br><span class="line">    <span class="keyword">if</span> (status != XST_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">XScuGic_Connect</span>(int_ins_ptr, rx_intr_id,</span><br><span class="line">            (Xil_InterruptHandler) rx_intr_handler, axidma_ptr);</span><br><span class="line">    <span class="keyword">if</span> (status != XST_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">XScuGic_Enable</span>(int_ins_ptr, tx_intr_id);</span><br><span class="line">    <span class="built_in">XScuGic_Enable</span>(int_ins_ptr, rx_intr_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启用来自硬件的中断</span></span><br><span class="line">    <span class="built_in">Xil_ExceptionInit</span>();</span><br><span class="line">    <span class="built_in">Xil_ExceptionRegisterHandler</span>(XIL_EXCEPTION_ID_INT,</span><br><span class="line">            (Xil_ExceptionHandler) XScuGic_InterruptHandler,</span><br><span class="line">            (<span class="type">void</span> *) int_ins_ptr);</span><br><span class="line">    <span class="built_in">Xil_ExceptionEnable</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使能DMA中断</span></span><br><span class="line">    <span class="built_in">XAxiDma_IntrEnable</span>(&amp;axidma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);</span><br><span class="line">    <span class="built_in">XAxiDma_IntrEnable</span>(&amp;axidma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数禁用DMA引擎的中断</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">disable_intr_system</span><span class="params">(XScuGic * int_ins_ptr, u16 tx_intr_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        u16 rx_intr_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">XScuGic_Disconnect</span>(int_ins_ptr, tx_intr_id);</span><br><span class="line">    <span class="built_in">XScuGic_Disconnect</span>(int_ins_ptr, rx_intr_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4.实验结果"></a>4.实验结果</h2><ul>
<li><p>终端显示</p>
<p><img src="/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%20DMA%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002154115335.png" alt="image-20231002154115335" style="zoom:50%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号处理之时域处理</title>
    <url>/2023/10/02/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%97%B6%E5%9F%9F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>本节主要介绍了数字信号处理中的一些时域上的处理，包括序列信号的线性时不变系统、线性卷积、Z变换等</p>
<span id="more"></span>
<h1 id="数字信号的理解"><a href="#数字信号的理解" class="headerlink" title="数字信号的理解"></a>数字信号的理解</h1><ul>
<li>模拟信号：时域连续和幅度连续</li>
<li>数字信号：时域和幅度均离散</li>
<li>时域连续信号：时域连续、幅度连续或离散</li>
<li>时域离散信号：时域离散、幅度连续或离散</li>
<li>时域离散就意味着：<ul>
<li>$x[n]$中$n$一定要是整数</li>
</ul>
</li>
<li>幅度离散并不要求幅度值一定是整数，只要是有限的状态值就可以了</li>
</ul>
<hr>
<h1 id="序列的基本概念"><a href="#序列的基本概念" class="headerlink" title="序列的基本概念"></a>序列的基本概念</h1><h2 id="1-任何序列都可以用单位样本序列-delta-n-来表示"><a href="#1-任何序列都可以用单位样本序列-delta-n-来表示" class="headerlink" title="1.任何序列都可以用单位样本序列$\delta (n)$来表示"></a>1.任何序列都可以用单位样本序列$\delta (n)$来表示</h2><script type="math/tex; mode=display">
x(n)=\sum_{m=-\infty}^{\infty}x(m)\delta(n-m)</script><h2 id="2-正弦序列的周期性"><a href="#2-正弦序列的周期性" class="headerlink" title="2.正弦序列的周期性"></a>2.正弦序列的周期性</h2><ul>
<li><p>正弦序列$sin(mn)$不一定是周期信号</p>
</li>
<li><p>若想要$sin(mn)$为周期信号，那么需满足</p>
<script type="math/tex; mode=display">
sin(mn)=sin[m(n+N)](N只能是整数)</script></li>
<li><p>则需满足：</p>
<script type="math/tex; mode=display">
mN = 2\pi k</script><script type="math/tex; mode=display">
N=\frac{2\pi k}{m}</script></li>
<li><p>而$N$需满足为整数，$k$也是整数，那么只有当$m$为$\pi$的倍数时，N才是整数，此时正弦序列$sin(mn)$才是周期信号</p>
</li>
</ul>
<h2 id="3-数字域频率"><a href="#3-数字域频率" class="headerlink" title="3.数字域频率"></a>3.数字域频率</h2><ul>
<li><p>数字域频率为：</p>
<script type="math/tex; mode=display">
w_0=\Omega_0T_s=\frac{\Omega_0}{f_s}=2\pi\frac{f_0}{f_s}=\frac{2\pi}{N}</script><script type="math/tex; mode=display">
其中:\Omega_0为模拟角频率(rad/s),\quad w_0为数字角频率(rad)\\
T_s为采样间隔(s),\quad f_s为采样频率(Hz),\quad f_0为模拟频率(Hz)\\
N=T_0\times f_s,其中T_0为原始模拟信号的周期</script></li>
<li><p>推导过程：</p>
<ul>
<li>连续时间正弦信号：$x_a(t)=cos(\Omega_0t+\phi)$</li>
<li>令$t=nT$，$T$为采样间隔</li>
<li>则$x_a(t)|_{t=nT}=cos(\Omega nT+\phi)=x_a(nT)$</li>
<li>将$x_a(nT)$简记为$x(n)$</li>
<li>$\Omega_0 T$记为$w_0$</li>
<li>则离散时间正弦序列为：$x(n)=cos(w_0n+\phi)$</li>
</ul>
</li>
</ul>
<hr>
<h1 id="线性时不变系统"><a href="#线性时不变系统" class="headerlink" title="线性时不变系统"></a>线性时不变系统</h1><ul>
<li>线性特性：<ul>
<li>$x(n)$做为一个整体只能是一次方，可以对$x(n)$乘以其它值；不能出现完全与$x(n)$无关的项；$x(n)$中的自变量$n$可以任意变换；</li>
<li>线性是针对$x(n)$来讨论的</li>
</ul>
</li>
<li>时不变特性：<ul>
<li>n必须作为$x(n)$（不能对$x(n)$乘以带$n$的系数，比如$sin(wn)$）中的自变量，不能对$n$进行乘法运算，可进行加减常数运算</li>
<li>时不变是针对$n$来讨论的</li>
</ul>
</li>
<li>线性时不变特性：<ul>
<li>$FIR$滤波：$y(n)=b_0x(n)+b_1x(n-1)+…b_rx(n-r)$的形式，其中$n-1,n-2..$也可为$n+1,n+2..$</li>
<li>$IIR$滤波：$y(n)+a_1y(n-1)+…=b_0x(n)+b_1x(n-1)+…b_rx(n-r)$的形式（需要满足$y(n)=0,n&lt;0$）</li>
</ul>
</li>
<li>对于线性时不变系统因果稳定性的判定：<ul>
<li>因果性：$h(n)=0,n&lt;0$</li>
<li>稳定性：$\sum|h(n)|&lt;\infty$</li>
</ul>
</li>
<li><strong>系统的作用不过是改变正弦信号的幅度和相位</strong></li>
</ul>
<hr>
<h1 id="线性卷积"><a href="#线性卷积" class="headerlink" title="线性卷积"></a>线性卷积</h1><p><img src="/2023/10/02/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%97%B6%E5%9F%9F%E5%A4%84%E7%90%86/image-20231004202820105.png" alt="image-20231004202820105" style="zoom: 80%;"></p>
<ul>
<li><p>首先，定义系统对输入是单位脉冲序列的响应为单位脉冲响应，即：</p>
<script type="math/tex; mode=display">
输入\delta (n)\rightarrow 输出h(n)</script></li>
<li><p>其次，我们知道，任何一个序列信号都可以由单位脉冲序列表示，即：</p>
<script type="math/tex; mode=display">
x(n)=\sum_{m=-\infty}^{\infty}x(m)\delta(n-m)</script></li>
<li><p>此外，对于一个线性系统：</p>
<script type="math/tex; mode=display">
\because \delta(n)\rightarrow h(n)\\
\therefore a\delta(n)\rightarrow ah(n)\\
\therefore a\delta(n-n_0)\rightarrow ah(n-n_0)</script></li>
<li><p>那么$y(n)$就是$x(n)$经过线性系统的结果：</p>
<script type="math/tex; mode=display">
\because x(n)=\cdots x(-1)\delta(n+1)+x(0)\delta(n)+x(1)\delta(n-1)+\cdots\\
\therefore y(n)=\cdots x(-1)h(n+1)+x(0)h(n)+x(1)h(n-1)+\cdots</script></li>
<li><p>所以最终$y(n)$的结果是：</p>
<script type="math/tex; mode=display">
y(n)=\sum_{m=-\infty}^{\infty}x(m)h(n-m)</script></li>
<li><p>而我们称卷积为：</p>
<script type="math/tex; mode=display">
y(n)=x(n)*h(n)=\sum_{m=-\infty}^{\infty}x(m)h(n-m)</script><ul>
<li>其中，$*$称为卷积运算</li>
<li>卷积满足交换律：$x(n)<em>h(n)=h(n)</em>x(n)$</li>
</ul>
</li>
<li><p>所以系统输出$y(n)$就是输入$x(n)$与单位脉冲响应$h(n)$的卷积结果</p>
</li>
</ul>
<h2 id="1-卷积的意义"><a href="#1-卷积的意义" class="headerlink" title="1.卷积的意义"></a>1.卷积的意义</h2><ul>
<li><p><strong>卷积是系统的工作方式：翻转、移位、相乘相加</strong></p>
</li>
<li><p>举个例子：</p>
<ul>
<li><p>若$h(n)=[1,2,3,4]$，即$h(n)=\delta(n)+2\delta(n-1)+3\delta(n-2)+4\delta(n-3)$</p>
</li>
<li><p>若$x(n)=[1,1,1,1]$</p>
</li>
<li><p>那么$y(n)=\sum_{m=-\infty}^{\infty}x(m)h(n-m)$，有：</p>
<script type="math/tex; mode=display">
y(0)=\sum_{m=-\infty}^{\infty}x(m)h(-m)\\
y(1)=\sum_{m=-\infty}^{\infty}x(m)h(1-m)\\
y(2)=\sum_{m=-\infty}^{\infty}x(m)h(2-m)\\
......</script></li>
<li><p>则可视化的运算如下：</p>
<p>|          |      |      | $x(n)$ | 1    | 1    | 1    | 1    |      |      |      |           |<br>| ———— | —— | —— | ——— | —— | —— | —— | —— | —— | —— | —— | ————- |<br>| $h(n)$   | 4    | 3    | 2      | 1    |      |      |      |      |      |      | $y(0)=1$  |<br>| $h(1-n)$ |      | 4    | 3      | 2    | 1    |      |      |      |      |      | $y(1)=3$  |<br>| $h(2-n)$ |      |      | 4      | 3    | 2    | 1    |      |      |      |      | $y(2)=6$  |<br>| $h(3-n)$ |      |      |        | 4    | 3    | 2    | 1    |      |      |      | $y(3)=10$ |<br>| $h(4-n)$ |      |      |        |      | 4    | 3    | 2    | 1    |      |      | $y(4)=9$  |<br>| $h(5-n)$ |      |      |        |      |      | 4    | 3    | 2    | 1    |      | $y(5)=7$  |<br>| $h(6-n)$ |      |      |        |      |      |      | 4    | 3    | 2    | 1    | $y(6)=4$  |</p>
</li>
</ul>
</li>
<li><p><strong>线性卷积的长度是$len[x(n)]+len[h(n)]-1$</strong></p>
</li>
</ul>
<h2 id="2-MATLAB实现举例"><a href="#2-MATLAB实现举例" class="headerlink" title="2.MATLAB实现举例"></a>2.MATLAB实现举例</h2><ul>
<li><p>特定的卷积核，对某些特定信号有的滤波作用</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;                      <span class="comment">%清屏</span></span><br><span class="line">clear all;                <span class="comment">%清变量</span></span><br><span class="line"></span><br><span class="line">fs=<span class="number">200</span>;                   <span class="comment">%采样频率为200Hz</span></span><br><span class="line">hn=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">4</span>);             <span class="comment">%系统hn</span></span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:<span class="number">1</span>;               <span class="comment">%时间序列</span></span><br><span class="line">xn1=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">50</span>*t);       <span class="comment">%50Hz正弦信号</span></span><br><span class="line">xn2=<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">5</span>*t);        <span class="comment">%5Hz正弦信号</span></span><br><span class="line">xn=xn1+xn2;               <span class="comment">%叠加信号</span></span><br><span class="line"></span><br><span class="line">yn=conv(xn,hn);           <span class="comment">%卷积运算获得系统输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line">subplot(<span class="number">411</span>);</span><br><span class="line"><span class="built_in">plot</span>(t,xn1);title(<span class="string">&#x27;50Hz正弦信号&#x27;</span>);</span><br><span class="line">subplot(<span class="number">412</span>);</span><br><span class="line"><span class="built_in">plot</span>(t,xn2);title(<span class="string">&#x27;5Hz正弦信号&#x27;</span>);</span><br><span class="line">subplot(<span class="number">413</span>);</span><br><span class="line"><span class="built_in">plot</span>(t,xn);title(<span class="string">&#x27;输入信号&#x27;</span>);</span><br><span class="line">subplot(<span class="number">414</span>);</span><br><span class="line"><span class="built_in">plot</span>(t,yn(<span class="number">1</span>:<span class="built_in">length</span>(xn)));title(<span class="string">&#x27;输出信号&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/10/02/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%97%B6%E5%9F%9F%E5%A4%84%E7%90%86/LinearConv.bmp" alt="LinearConv" style="zoom: 67%;"></p>
<ul>
<li><p>观察到输出信号中50Hz的正弦信号被滤除了</p>
</li>
<li><p>其原因是采样频率200Hz是正弦信号50Hz的4倍，在一个周期内采样了4个点</p>
<p><img src="/2023/10/02/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%97%B6%E5%9F%9F%E5%A4%84%E7%90%86/image-20231004212620824.png" alt="image-20231004212620824" style="zoom:50%;"></p>
</li>
<li><p>而这四个点正好对应这四个位置</p>
<p><img src="/2023/10/02/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%97%B6%E5%9F%9F%E5%A4%84%E7%90%86/image-20231004213058396.png" alt="image-20231004213058396" style="zoom: 33%;"></p>
</li>
<li><p><strong>相当于是$0,1,0,-1,0,1,0,-1,…$这一串数接受$1,1,1,1$的检阅</strong></p>
<p><img src="/2023/10/02/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%97%B6%E5%9F%9F%E5%A4%84%E7%90%86/image-20231004214850605.png" alt="image-20231004214850605" style="zoom:50%;"></p>
<ul>
<li>只有在起始和末尾绿色部分才会有值</li>
<li>在中间红色部分滑动时是将滑窗中的4个数相加，和均为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Z变换"><a href="#Z变换" class="headerlink" title="Z变换"></a>Z变换</h1><h2 id="1-Z变换的定义"><a href="#1-Z变换的定义" class="headerlink" title="1.Z变换的定义"></a>1.Z变换的定义</h2><ul>
<li><p>双边Z变换：</p>
<script type="math/tex; mode=display">
X(z)=\sum_{n=-\infty}^{\infty}x(n)Z^{-n}</script></li>
<li><p>单边Z变换：</p>
<script type="math/tex; mode=display">
X(z)=\sum_{n=0}^{+\infty}x(n)Z^{-n}\quad or\quad \sum_{n=-\infty}^{0}x(n)Z^{-n}</script></li>
<li><p>左边序列、右边序列、因果序列：</p>
<ul>
<li><p>左边序列：当$n<N$时有非零值，而在$n>N$时$x(n)$为0</N$时有非零值，而在$n></p>
</li>
<li><p>右边序列：当$n\ge N$时有非零值，而在$n&lt;N$时$x(n)$为0</p>
<ul>
<li>若$N=0$，则称此序列为因果序列，即$x(n)=0,n&lt;0$</li>
</ul>
</li>
<li><p>对于因果序列，有以下关系：</p>
<script type="math/tex; mode=display">
因果序列\rightarrow |Z|>a</script></li>
</ul>
</li>
</ul>
<h2 id="2-Z的收敛域"><a href="#2-Z的收敛域" class="headerlink" title="2.Z的收敛域"></a>2.Z的收敛域</h2><ul>
<li><p>因为要求Z变换有解，所以需要满足：</p>
<script type="math/tex; mode=display">
|\sum_{n=-\infty}^{\infty}x(n)Z^{-n}|<+\infty</script></li>
<li><p>等比数列求和公式：</p>
<script type="math/tex; mode=display">
\frac{a_0-a_nq}{1-q}</script><ul>
<li>若想要其有界，需满足等比因子$|q|&lt;1$</li>
</ul>
</li>
<li><p>而Z的表达式其实是：</p>
<script type="math/tex; mode=display">
Z=re^{jw}</script></li>
<li><p>那么：</p>
<script type="math/tex; mode=display">
\begin{aligned}
X(z) &=\sum_{n=-\infty}^{\infty}x(n)Z^{-n}\\
&=\sum_{n=-\infty}^{\infty}x(n)r^{-n}e^{-jwn}
\end{aligned}</script></li>
<li><p>所以，求Z的收敛域主要看$r$</p>
</li>
</ul>
<h2 id="3-Z变换的常用性质"><a href="#3-Z变换的常用性质" class="headerlink" title="3.Z变换的常用性质"></a>3.Z变换的常用性质</h2><ul>
<li><p>时移特性：</p>
<script type="math/tex; mode=display">
x(n)\leftrightarrow X(z)\\
x(n-n_0)\leftrightarrow X(z)Z^{-n_0}</script></li>
<li><p>卷积特性：</p>
<script type="math/tex; mode=display">
x_1(n)*x_2(n)\leftrightarrow X_1(z)\cdot X_2(z)</script></li>
<li><p>对于因果稳定的系统：</p>
<ul>
<li>$H(Z)$的收敛域一定包括单位圆（稳定性）</li>
<li>$H(Z)$的所有极点一定在单位圆内（因为因果系统是$|Z|&gt;a$，而又要求稳定，即收敛域需包含单位圆，故极点需在单位圆内，这样能使得$|Z|&gt;极点,极点&lt;1$）</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1W94y1R7J9/?spm_id_from=333.788&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">数字信号处理基本概念（已完结）_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之AXI（基于PYNQ-Z2开发板）</title>
    <url>/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节对AXI接口的进行了基本介绍</p>
<span id="more"></span> 
<h1 id="AXI接口简介"><a href="#AXI接口简介" class="headerlink" title="AXI接口简介"></a>AXI接口简介</h1><ul>
<li><p><strong>AXI 的英文全称是 Advanced eXtensible Interface，即高级可扩展接口</strong>。它是 ARM 公司所提出的 AMBA （Advanced Microcontroller Bus Architecture）协议的一部分。通信协议就是指双方进行信息传递所遵循的规则和约定</p>
<ul>
<li>AMBA：高级微控制器总线架构：是1996年首次引入的一组微控制器总线；开放的片内互联的总线标准，能在多主机设计中实现多个控制器和外围设备之间的连接和管理</li>
</ul>
</li>
<li><p><strong>AXI三种类型</strong>：</p>
<ul>
<li><strong>AXI4（AXI4—Full）</strong>：用于高性能的存储器映射需求；（<strong>存储器映射：主机对从机进行读写操作时，指定一个目标地址，这个地址对应系统存储空间的地址，表示对该空间进行读写操作</strong>）</li>
<li><strong>AXI4—Lite</strong>：简化版的AXI4接口，用于低吞吐率存储器映射的通信。</li>
<li><strong>AXI4—Stream</strong>（AXI4-ST）：用于高速的流数据通信</li>
</ul>
</li>
<li><p><strong>AXI的工作方式</strong>：</p>
<ul>
<li><p>AXI4和AXI4—Lite包含5个独立的通道</p>
<ul>
<li>读地址通道</li>
<li>读数据通道：读数据通道由从机发送给主机，包含了读数据和读响应的信息，读响应的信号用于表示读传输是否操作完成</li>
<li>写地址通道</li>
<li>写数据通道：写数据通道由主机发送给从机，包含了写数据。然后通过WSTRB信号表示当前数据的哪个字节有效</li>
<li>写响应通道：写响应通道由从机发送给主机，用于表示当前写操作是否完成</li>
</ul>
</li>
<li><p>AXI4：由于读写地址通道是分离的，所以支持双向同时传输；突发长度最大256</p>
</li>
<li>AXI—Lite：和AXI4比较类似，但是不支持突发传输（一致连续的传输，若突发8次传输，即连续传输8个数据）</li>
<li>AXI4—Stream：只有一个单一数据通道，和AXI4的写数据通道比较类似，突发长度不受限制。</li>
<li>AXI InterConnect 和AXI SmartConnect：这两个IP核都用于连接单/多个存储器映射的AXI Master和单/多个存储器映射的AXI Slave</li>
</ul>
<p><img src="/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002022912018.png" alt="image-20231002022912018" style="zoom:50%;"></p>
<p><img src="/2023/10/02/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BAXI%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002022934168.png" alt="image-20231002022934168" style="zoom:50%;"></p>
</li>
<li><p><strong>握手机制</strong>：</p>
<ul>
<li>所有的五个通道都是通过相同的VALID/READY握手处理来传输地址、数据和控制信息</li>
<li>双向握手的机制意味着主机和从机之间传输数据时，都可以控制传输的速率，只有当VALID和READY同时为高电平时，传输才会发生</li>
<li>信息源端使用VALLD信号表示当前通道地址、数据和控制信息什么时候有效，目的端使用READY信号表示什么时候可以接收信息，读数据通道和写数据通道都包含一个LAST信号，用于表示传输的最后一个数据</li>
</ul>
</li>
</ul>
<hr>
<h1 id="AXI4接口之DDR读写实验"><a href="#AXI4接口之DDR读写实验" class="headerlink" title="AXI4接口之DDR读写实验"></a>AXI4接口之DDR读写实验</h1>]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之BRAM（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节通过基于BRAM的PS与PL数据交互实验，简单演示了BRAM的使用</p>
<span id="more"></span> 
<h1 id="基于BRAM的PS与PL数据交互实验"><a href="#基于BRAM的PS与PL数据交互实验" class="headerlink" title="基于BRAM的PS与PL数据交互实验"></a>基于BRAM的PS与PL数据交互实验</h1><ul>
<li><p>实验任务：PS将串口接收到的数据写入BRAM（是FPGA内部的一个片上存储资源），然后从BRAM中读出数据，并通过串口打印出来；与此同时，PL从BRAM中同样读出数据，并通过ILA来观察读出的数据与串口打印的数据是否一致</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230929013337035.png" alt="image-20230929013337035" style="zoom: 25%;"></p>
</li>
</ul>
<h2 id="1-Vivado中的相关配置"><a href="#1-Vivado中的相关配置" class="headerlink" title="1.Vivado中的相关配置"></a>1.Vivado中的相关配置</h2><ul>
<li><p>ZYNQ PS的配置：直接点击auto自动配置</p>
</li>
<li><p>AXI BRAM controller的配置：</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231001222224779.png" alt="image-20231001222224779" style="zoom: 50%;"></p>
</li>
<li><p>产生一个Block RAM的IP核：</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231001222648098.png" alt="image-20231001222648098" style="zoom: 67%;"></p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231001222753654.png" alt="image-20231001222753654" style="zoom:50%;"></p>
</li>
<li><p>自动连线：</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231001223031999.png" alt="image-20231001223031999" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-自定义pl-bram-rd的ip核添加"><a href="#2-自定义pl-bram-rd的ip核添加" class="headerlink" title="2.自定义pl_bram_rd的ip核添加"></a>2.自定义pl_bram_rd的ip核添加</h2><ul>
<li><p>参考这篇文章的配置<a href="https://ssy1938010014.github.io/2023/09/21/ZYNQ嵌入式之IP核（基于PYNQ-Z2开发板）/">ZYNQ嵌入式之IP核（基于PYNQ-Z2开发板）</a>以及正点原子编写的源代码程序</p>
</li>
<li><p>注意：在添加bram_rd源代码时，不能只将其复制到对应ip核的hdl文件夹下，还需要点击添加源文件将文件添加进入工程</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231001230715617.png" alt="image-20231001230715617" style="zoom:50%;"></p>
</li>
<li><p>同时还会遇到端口中没有更新的情况，解决方法参考正点原子视频的<a href="https://www.bilibili.com/video/BV1Hq4y1u7qH?p=61&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">第15.2讲 基于BRAM的PS和PL数据交互（第二讲）</a>15:23处，其实就是将pl_bram_rd_v1_0.v文件打几个空格再保存后，端口就会更新了</p>
</li>
<li><p>根据正点原子视频的<a href="https://www.bilibili.com/video/BV1Hq4y1u7qH?p=61&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">第15.2讲 基于BRAM的PS和PL数据交互（第二讲）</a>16:00处开始封装一个ram接口</p>
</li>
<li><p>设置BRAM的存储深度：</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231001233913958.png" alt="image-20231001233913958"></p>
</li>
<li><p>最终的Block框图如下：</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231001234210103.png" alt="image-20231001234210103"></p>
</li>
</ul>
<h2 id="3-ILA观测信号的添加"><a href="#3-ILA观测信号的添加" class="headerlink" title="3.ILA观测信号的添加"></a>3.ILA观测信号的添加</h2><ul>
<li><p>综合后点击set up debug</p>
</li>
<li><p>添加观测信号</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002000918153.png" alt="image-20231002000918153"></p>
</li>
<li><p>然后ctrl+s保存xdc文件</p>
</li>
</ul>
<h2 id="4-Vitis中的代码编写"><a href="#4-Vitis中的代码编写" class="headerlink" title="4.Vitis中的代码编写"></a>4.Vitis中的代码编写</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xbram_hw.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pl_bram_rd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PL_BRAM_START			PL_BRAM_RD_S00_AXI_SLV_REG0_OFFSET	<span class="comment">//RAM读开始寄存器地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PL_BRAM_START_ADDR		PL_BRAM_RD_S00_AXI_SLV_REG1_OFFSET	<span class="comment">//RAM起始寄存器地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PL_BRAM_LEN				PL_BRAM_RD_S00_AXI_SLV_REG2_OFFSET	<span class="comment">//PL读 RAM的深度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	PL_BRAM_BASE			XPAR_PL_BRAM_RD_0_S00_AXI_BASEADDR	<span class="comment">//PL_RAM_RD基地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> START_ADDR			0	<span class="comment">//RAM起始地址范围:0~1023</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BRAM_DATA_BYTE		4	<span class="comment">//BRAM数据字节个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch_data[<span class="number">1024</span>];		<span class="comment">//写入BRAM的字符数组</span></span><br><span class="line"><span class="type">int</span>  ch_data_len;		<span class="comment">//写入BRAM的字符个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> wr_cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> read_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Please input data to read and write Bram !\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch_data);			<span class="comment">//用户输入字符串</span></span><br><span class="line">		ch_data_len = <span class="built_in">strlen</span>(ch_data);	<span class="comment">//计算字符串的长度</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将字符串写入BRAM，每次循环向 BRAM中写入 1 个字符</span></span><br><span class="line">		<span class="keyword">for</span>(i = START_ADDR*BRAM_DATA_BYTE; i&lt;(START_ADDR + ch_data_len)*BRAM_DATA_BYTE; i+=BRAM_DATA_BYTE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">XBram_WriteReg</span>(XPAR_BRAM_0_BASEADDR,i,ch_data[wr_cnt]);</span><br><span class="line">			wr_cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//配置PL_BRAM_RD起始地址</span></span><br><span class="line">		<span class="built_in">PL_BRAM_RD_mWriteReg</span>(PL_BRAM_BASE,PL_BRAM_START_ADDR,START_ADDR*BRAM_DATA_BYTE);</span><br><span class="line">		<span class="comment">//配置PL_BRAM_RD长度</span></span><br><span class="line">		<span class="built_in">PL_BRAM_RD_mWriteReg</span>(PL_BRAM_BASE,PL_BRAM_LEN,ch_data_len*BRAM_DATA_BYTE);</span><br><span class="line">		<span class="comment">//配置PL_BRAM_RD开始读信号,产生一个上升沿</span></span><br><span class="line">		<span class="built_in">PL_BRAM_RD_mWriteReg</span>(PL_BRAM_BASE,PL_BRAM_START,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">PL_BRAM_RD_mWriteReg</span>(PL_BRAM_BASE,PL_BRAM_START,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从 BRAM 中读出数据，循环从 BRAM 中读出数据</span></span><br><span class="line">		<span class="keyword">for</span>(i = START_ADDR*BRAM_DATA_BYTE; i&lt;(START_ADDR + ch_data_len)*BRAM_DATA_BYTE; i+=BRAM_DATA_BYTE)</span><br><span class="line">		&#123;</span><br><span class="line">			read_data = <span class="built_in">XBram_ReadReg</span>(XPAR_BRAM_0_BASEADDR,i);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;BRAM address is %d\t,Read data is %c\n&quot;</span>,i/BRAM_DATA_BYTE,read_data);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-实验结果"><a href="#5-实验结果" class="headerlink" title="5.实验结果"></a>5.实验结果</h2><ul>
<li><p>串口打印：</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002010115177.png" alt="image-20231002010115177" style="zoom: 67%;"></p>
</li>
<li><p>ILA：</p>
<p><img src="/2023/09/29/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BBRAM%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20231002010038782.png" alt="image-20231002010038782"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之SD卡（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/28/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BSD%E5%8D%A1%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节主要通过Xilinx SDK自带的FATFS库中的示例，演示了SD卡的读写流程</p>
<span id="more"></span> 
<h1 id="SD卡读写TXT文本实验"><a href="#SD卡读写TXT文本实验" class="headerlink" title="SD卡读写TXT文本实验"></a>SD卡读写TXT文本实验</h1><ul>
<li>实验任务：通过Xilinx SDK自带的FATFS库，完成对TF卡中TXT文本读写的功能，并将读写测试结果通过串口打印出来</li>
</ul>
<h2 id="1-Vivado中的相关配置"><a href="#1-Vivado中的相关配置" class="headerlink" title="1.Vivado中的相关配置"></a>1.Vivado中的相关配置</h2><p><img src="/2023/09/28/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BSD%E5%8D%A1%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230928180317821.png" alt="image-20230928180317821"></p>
<ul>
<li>通过查看用户手册可知CD信号连接到了PS MIO47的引脚</li>
</ul>
<p><img src="/2023/09/28/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BSD%E5%8D%A1%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230928180438940.png" alt="image-20230928180438940" style="zoom: 50%;"></p>
<ul>
<li>虽然但是，实验是基于pynq-z2的boards的，自动配置时已经将这些都配置好了</li>
</ul>
<h2 id="2-Vitis中添加xilffs库"><a href="#2-Vitis中添加xilffs库" class="headerlink" title="2.Vitis中添加xilffs库"></a>2.Vitis中添加xilffs库</h2><p><img src="/2023/09/28/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BSD%E5%8D%A1%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230929004159457.png" alt="image-20230929004159457"></p>
<p><img src="/2023/09/28/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BSD%E5%8D%A1%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230929004246281.png" alt="image-20230929004246281"></p>
<ul>
<li>然后再重新编译一下工程就可以了</li>
</ul>
<h2 id="3-Vitis中的代码编写"><a href="#3-Vitis中的代码编写" class="headerlink" title="3.Vitis中的代码编写"></a>3.Vitis中的代码编写</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xil_printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ff.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xdevcfg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_NAME <span class="string">&quot;ZDYZ.txt&quot;</span>                <span class="comment">//定义文件名</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> src_str[<span class="number">30</span>] = <span class="string">&quot;www.openedv.com&quot;</span>; <span class="comment">//定义文本内容</span></span><br><span class="line"><span class="type">static</span> FATFS fatfs;                         <span class="comment">//文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化文件系统</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">platform_init_fs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FRESULT status;</span><br><span class="line">	TCHAR *Path = <span class="string">&quot;0:/&quot;</span>;</span><br><span class="line">	BYTE work[FF_MAX_SS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册一个工作区(挂载分区文件系统)</span></span><br><span class="line">    <span class="comment">//在使用任何其它文件函数之前，必须使用f_mount函数为每个使用卷注册一个工作区</span></span><br><span class="line">	status = <span class="built_in">f_mount</span>(&amp;fatfs, Path, <span class="number">1</span>);  <span class="comment">//挂载SD卡</span></span><br><span class="line">	<span class="keyword">if</span> (status != FR_OK) &#123;</span><br><span class="line">		<span class="built_in">xil_printf</span>(<span class="string">&quot;Volume is not FAT formated; formating FAT\r\n&quot;</span>);</span><br><span class="line">		<span class="comment">//格式化SD卡</span></span><br><span class="line">		status = <span class="built_in">f_mkfs</span>(Path, FM_FAT32, <span class="number">0</span>, work, <span class="keyword">sizeof</span> work);</span><br><span class="line">		<span class="keyword">if</span> (status != FR_OK) &#123;</span><br><span class="line">			<span class="built_in">xil_printf</span>(<span class="string">&quot;Unable to format FATfs\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//格式化之后，重新挂载SD卡</span></span><br><span class="line">		status = <span class="built_in">f_mount</span>(&amp;fatfs, Path, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (status != FR_OK) &#123;</span><br><span class="line">			<span class="built_in">xil_printf</span>(<span class="string">&quot;Unable to mount FATfs\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载SD(TF)卡</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sd_mount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FRESULT status;</span><br><span class="line">    <span class="comment">//初始化文件系统（挂载SD卡，如果挂载不成功，则格式化SD卡）</span></span><br><span class="line">    status = <span class="built_in">platform_init_fs</span>();</span><br><span class="line">    <span class="keyword">if</span>(status)&#123;</span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;ERROR: f_mount returned %d!\n&quot;</span>,status);</span><br><span class="line">        <span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡写数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sd_write_data</span><span class="params">(<span class="type">char</span> *file_name,u32 src_addr,u32 byte_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FIL fil;         <span class="comment">//文件对象</span></span><br><span class="line">    UINT bw;         <span class="comment">//f_write函数返回已写入的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开一个文件,如果不存在，则创建一个文件</span></span><br><span class="line">    <span class="built_in">f_open</span>(&amp;fil,file_name,FA_CREATE_ALWAYS | FA_WRITE);</span><br><span class="line">    <span class="comment">//移动打开的文件对象的文件读/写指针     0:指向文件开头</span></span><br><span class="line">    <span class="built_in">f_lseek</span>(&amp;fil, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//向文件中写入数据</span></span><br><span class="line">    <span class="built_in">f_write</span>(&amp;fil,(<span class="type">void</span>*) src_addr,byte_len,&amp;bw);</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="built_in">f_close</span>(&amp;fil);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡读数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sd_read_data</span><span class="params">(<span class="type">char</span> *file_name,u32 src_addr,u32 byte_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FIL fil;         <span class="comment">//文件对象</span></span><br><span class="line">    UINT br;         <span class="comment">//f_read函数返回已读出的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开一个只读的文件</span></span><br><span class="line">    <span class="built_in">f_open</span>(&amp;fil,file_name,FA_READ);</span><br><span class="line">    <span class="comment">//移动打开的文件对象的文件读/写指针     0:指向文件开头</span></span><br><span class="line">    <span class="built_in">f_lseek</span>(&amp;fil,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//从SD卡中读出数据</span></span><br><span class="line">    <span class="built_in">f_read</span>(&amp;fil,(<span class="type">void</span>*)src_addr,byte_len,&amp;br);</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="built_in">f_close</span>(&amp;fil);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status,len;</span><br><span class="line">    <span class="type">char</span> dest_str[<span class="number">30</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">sd_mount</span>();           <span class="comment">//挂载SD卡</span></span><br><span class="line">    <span class="keyword">if</span>(status != XST_SUCCESS)&#123;</span><br><span class="line">		<span class="built_in">xil_printf</span>(<span class="string">&quot;Failed to open SD card!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">xil_printf</span>(<span class="string">&quot;Success to open SD card!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">strlen</span>(src_str);         <span class="comment">//计算字符串长度</span></span><br><span class="line">    <span class="comment">//SD卡写数据</span></span><br><span class="line">    <span class="built_in">sd_write_data</span>(FILE_NAME,(u32)src_str,len);</span><br><span class="line">    <span class="comment">//SD卡读数据</span></span><br><span class="line">    <span class="built_in">sd_read_data</span>(FILE_NAME,(u32)dest_str,len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较写入的字符串和读出的字符串是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(src_str, dest_str) == <span class="number">0</span>)</span><br><span class="line">    	<span class="built_in">xil_printf</span>(<span class="string">&quot;src_str is equal to dest_str,SD card test success!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">xil_printf</span>(<span class="string">&quot;src_str is not equal to dest_str,SD card test failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>这里的话得创建一个空的C文件运行上述代码才能成功，如果创建的是空的C++文件运行上述代码则会报错，具体原因还未深究</strong></li>
</ul>
<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3.实验结果"></a>3.实验结果</h2><p><img src="/2023/09/28/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BSD%E5%8D%A1%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230928185013950.png" alt="image-20230928185013950"></p>
<ul>
<li>MicroSD卡中的内容</li>
</ul>
<p><img src="/2023/09/28/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BSD%E5%8D%A1%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230928185133652.png" alt="image-20230928185133652" style="zoom: 33%;"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之QSPI Flash（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/27/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BQSPI%20Flash%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节通过XIlinx官方的Flash示例程序演示了Flash的使用</p>
<span id="more"></span>
<h1 id="Flash简介"><a href="#Flash简介" class="headerlink" title="Flash简介"></a>Flash简介</h1><ul>
<li><p>Flash存储器（又称闪存）是一种非易失性存储器，具有操作方便、读写速度快等优点</p>
</li>
<li><p>一般用于存储操作系统和程序代码，或者用于数码相机、U盘、MP3播放器做数据存储</p>
</li>
<li><p>Flash的存储单元组织为<strong>块阵列</strong>：</p>
<ul>
<li>块是擦除操作的最小单位，擦除操作将块内的所有位，置为“1”</li>
<li>页是读和写操作的基本单位，在对页进行写操作之前，需要判断该页内所有的位是否为“1”，如果全部为“1”，可以进行写操作，否则，需要对整个块进行擦除操作</li>
<li>Flash的特性是只能从1翻转到0</li>
</ul>
</li>
<li><p>Flash的分类：</p>
<p><img src="/2023/09/27/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BQSPI%20Flash%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230927093742282.png" alt="image-20230927093742282" style="zoom:50%;"></p>
<p><img src="/2023/09/27/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BQSPI%20Flash%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230927094018734.png" alt="image-20230927094018734" style="zoom: 33%;"></p>
</li>
<li><p>SPI是串口外设接口的缩写，是一种高速的，全双工，同步的通信总线</p>
<ul>
<li>优点：支持全双工通信、通信简单、传输速率快</li>
<li>缺点：没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据可靠性上有一定的缺陷</li>
</ul>
</li>
<li><p>QSPI通信方式（Q是quad，代表有4根数据线）：主从模式</p>
<p><img src="/2023/09/27/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BQSPI%20Flash%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230927110305340.png" alt="image-20230927110305340" style="zoom:50%;"></p>
</li>
<li><p><strong>QSPI flash控制器是IO外设的一部分，在PS端</strong></p>
<p><img src="/2023/09/27/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BQSPI%20Flash%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230927111837475.png" alt="image-20230927111837475" style="zoom: 80%;"></p>
</li>
</ul>
<hr>
<h1 id="QSPI-Flash读写测试"><a href="#QSPI-Flash读写测试" class="headerlink" title="QSPI Flash读写测试"></a>QSPI Flash读写测试</h1><ul>
<li><p>实验任务：使用QSPI Flash控制器，先后对ZYNQ核心板上的QSPI Flash进行写、读操作。通过对比读出的数据是否等于写入的数据，从而验证读写操作是否正确</p>
<p><img src="/2023/09/27/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BQSPI%20Flash%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230927112722162.png" alt="image-20230927112722162" style="zoom: 67%;"></p>
</li>
</ul>
<h2 id="1-Vivado中的相关配置"><a href="#1-Vivado中的相关配置" class="headerlink" title="1.Vivado中的相关配置"></a>1.Vivado中的相关配置</h2><p><img src="/2023/09/27/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BQSPI%20Flash%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230928100235889.png" alt="image-20230928100235889"></p>
<p><img src="/2023/09/27/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BQSPI%20Flash%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230928100327932.png" alt="image-20230928100327932"></p>
<ul>
<li>然而，因为实验是基于pynq-z2的boards的，自动配置时已经将这些都配置好了</li>
</ul>
<h2 id="2-Vitis中的代码编写"><a href="#2-Vitis中的代码编写" class="headerlink" title="2.Vitis中的代码编写"></a>2.Vitis中的代码编写</h2><ul>
<li>使用Xilinx官方提供的历程</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span>	<span class="comment">/* SDK generated parameters */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xqspips.h&quot;</span>		<span class="comment">/* QSPI device driver */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xil_printf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QSPI_DEVICE_ID		XPAR_XQSPIPS_0_DEVICE_ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送到FLASH器件的指令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_STATUS_CMD	0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_CMD			0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_CMD			0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_DISABLE_CMD	0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_STATUS_CMD		0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ENABLE_CMD	0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_READ_CMD		0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUAL_READ_CMD		0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUAD_READ_CMD		0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BULK_ERASE_CMD		0xC7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SEC_ERASE_CMD		0xD8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ID				0x9F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FLASH BUFFER中各数据的偏移量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMAND_OFFSET		0 <span class="comment">// FLASH instruction</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDRESS_1_OFFSET	1 <span class="comment">// MSB byte of address to read or write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDRESS_2_OFFSET	2 <span class="comment">// Middle byte of address to read or write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDRESS_3_OFFSET	3 <span class="comment">// LSB byte of address to read or write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_OFFSET			4 <span class="comment">// Start of Data for Read/Write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUMMY_OFFSET		4 <span class="comment">// Dummy byte offset for reads</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUMMY_SIZE			1 <span class="comment">// Number of dummy bytes for reads</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD_ID_SIZE			4 <span class="comment">// Read ID command + 3 bytes ID response</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BULK_ERASE_SIZE		1 <span class="comment">// Bulk Erase command size</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEC_ERASE_SIZE		4 <span class="comment">// Sector Erase command + Sector address</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERHEAD_SIZE		4 <span class="comment">// control information: command and address</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTOR_SIZE			0x10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_SECTORS			0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_PAGES			0x10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE			256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要写入的flash页数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_COUNT		16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要写入数据的FLASH地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_ADDRESS	0x00055000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIQUE_VALUE	0x05</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DATA		(PAGE_COUNT * PAGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlashErase</span><span class="params">(XQspiPs *QspiPtr, u32 Address, u32 ByteCount)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlashWrite</span><span class="params">(XQspiPs *QspiPtr, u32 Address, u32 ByteCount, u8 Command)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlashRead</span><span class="params">(XQspiPs *QspiPtr, u32 Address, u32 ByteCount, u8 Command)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FlashReadID</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlashQuadEnable</span><span class="params">(XQspiPs *QspiPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">QspiFlashPolledExample</span><span class="params">(XQspiPs *QspiInstancePtr, u16 QspiDeviceId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> XQspiPs QspiInstance;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">u8 ReadBuffer[MAX_DATA + DATA_OFFSET + DUMMY_SIZE];</span><br><span class="line">u8 WriteBuffer[PAGE_SIZE + DATA_OFFSET];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">xil_printf</span>(<span class="string">&quot;QSPI FLASH Polled Example Test \r\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* Run the Qspi Interrupt example.*/</span></span><br><span class="line">	<span class="built_in">QspiFlashPolledExample</span>(&amp;QspiInstance, QSPI_DEVICE_ID);</span><br><span class="line">	<span class="built_in">xil_printf</span>(<span class="string">&quot;Successfully ran QSPI FLASH Polled Example Test\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QspiFlashPolledExample</span><span class="params">(XQspiPs *QspiInstancePtr, u16 QspiDeviceId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 *BufferPtr;</span><br><span class="line">	u8 UniqueValue;</span><br><span class="line">	<span class="type">int</span> Count;</span><br><span class="line">	<span class="type">int</span> Page;</span><br><span class="line">	XQspiPs_Config *QspiConfig;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化QSPI驱动</span></span><br><span class="line">	QspiConfig = <span class="built_in">XQspiPs_LookupConfig</span>(QspiDeviceId);</span><br><span class="line">	<span class="built_in">XQspiPs_CfgInitialize</span>(QspiInstancePtr, QspiConfig, QspiConfig-&gt;BaseAddress);</span><br><span class="line">	<span class="comment">//初始化读写BUFFER</span></span><br><span class="line">	<span class="keyword">for</span> (UniqueValue = UNIQUE_VALUE, Count = <span class="number">0</span>; Count &lt; PAGE_SIZE;</span><br><span class="line">	     Count++, UniqueValue++) &#123;</span><br><span class="line">		WriteBuffer[DATA_OFFSET + Count] = (u8)(UniqueValue + Test);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(ReadBuffer, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(ReadBuffer));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置手动启动和手动片选模式</span></span><br><span class="line">	<span class="built_in">XQspiPs_SetOptions</span>(QspiInstancePtr, XQSPIPS_MANUAL_START_OPTION |</span><br><span class="line">			XQSPIPS_FORCE_SSELECT_OPTION |</span><br><span class="line">			XQSPIPS_HOLD_B_DRIVE_OPTION);</span><br><span class="line">	<span class="comment">//设置QSPI时钟的分频系数</span></span><br><span class="line">	<span class="built_in">XQspiPs_SetClkPrescaler</span>(QspiInstancePtr, XQSPIPS_CLK_PRESCALE_8);</span><br><span class="line">	<span class="comment">//片选信号置为有效</span></span><br><span class="line">	<span class="built_in">XQspiPs_SetSlaveSelect</span>(QspiInstancePtr);</span><br><span class="line">	<span class="comment">//读FLASH ID</span></span><br><span class="line">	<span class="built_in">FlashReadID</span>();</span><br><span class="line">	<span class="comment">//使能FLASH Quad模式</span></span><br><span class="line">	<span class="built_in">FlashQuadEnable</span>(QspiInstancePtr);</span><br><span class="line">	<span class="comment">//擦除FLASH</span></span><br><span class="line">	<span class="built_in">FlashErase</span>(QspiInstancePtr, TEST_ADDRESS, MAX_DATA);</span><br><span class="line">	<span class="comment">//向FLASH中写入数据</span></span><br><span class="line">	<span class="keyword">for</span> (Page = <span class="number">0</span>; Page &lt; PAGE_COUNT; Page++) &#123;</span><br><span class="line">		<span class="built_in">FlashWrite</span>(QspiInstancePtr, (Page * PAGE_SIZE) + TEST_ADDRESS,</span><br><span class="line">			   PAGE_SIZE, WRITE_CMD);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使用QUAD模式从FLASH中读出数据</span></span><br><span class="line">	<span class="built_in">FlashRead</span>(QspiInstancePtr, TEST_ADDRESS, MAX_DATA, QUAD_READ_CMD);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对比写入FLASH与从FLASH中读出的数据</span></span><br><span class="line">	BufferPtr = &amp;ReadBuffer[DATA_OFFSET + DUMMY_SIZE];</span><br><span class="line">	<span class="keyword">for</span> (UniqueValue = UNIQUE_VALUE, Count = <span class="number">0</span>; Count &lt; MAX_DATA;</span><br><span class="line">	     Count++, UniqueValue++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (BufferPtr[Count] != (u8)(UniqueValue + Test)) &#123;</span><br><span class="line">			<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	该函数写入连接到QSPI接口的串行FLASH。所有放入缓冲区的数据必须位于设备的同一页中，</span></span><br><span class="line"><span class="comment"> * 	页边界位于256字节边界上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlashWrite</span><span class="params">(XQspiPs *QspiPtr, u32 Address, u32 ByteCount, u8 Command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 WriteEnableCmd = &#123; WRITE_ENABLE_CMD &#125;;</span><br><span class="line">	u8 ReadStatusCmd[] = &#123; READ_STATUS_CMD, <span class="number">0</span> &#125;;  <span class="comment">/* must send 2 bytes */</span></span><br><span class="line">	u8 FlashStatus[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Send the write enable command to the FLASH so that it can be</span></span><br><span class="line"><span class="comment">	 * written to, this needs to be sent as a seperate transfer before</span></span><br><span class="line"><span class="comment">	 * the write</span></span><br><span class="line"><span class="comment">	 * 	发送write enable命令到FLASH，以便它可以被写入，这需要在写入之前作为单独的传输发送</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, &amp;WriteEnableCmd, <span class="literal">NULL</span>,</span><br><span class="line">				<span class="built_in">sizeof</span>(WriteEnableCmd));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Setup the write command with the specified address and data for the</span></span><br><span class="line"><span class="comment">	 * FLASH</span></span><br><span class="line"><span class="comment">	 * 	使用指定的地址和数据为FLASH设置写命令</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WriteBuffer[COMMAND_OFFSET]   = Command;</span><br><span class="line">	WriteBuffer[ADDRESS_1_OFFSET] = (u8)((Address &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	WriteBuffer[ADDRESS_2_OFFSET] = (u8)((Address &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">	WriteBuffer[ADDRESS_3_OFFSET] = (u8)(Address &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Send the write command, address, and data to the FLASH to be</span></span><br><span class="line"><span class="comment">	 * written, no receive buffer is specified since there is nothing to</span></span><br><span class="line"><span class="comment">	 * receive</span></span><br><span class="line"><span class="comment">	 * 	将写命令、地址和数据发送到要写的FLASH，没有指定接收缓冲区，因为没有什么可接收的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, WriteBuffer, <span class="literal">NULL</span>,</span><br><span class="line">				ByteCount + OVERHEAD_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wait for the write command to the FLASH to be completed, it takes</span></span><br><span class="line"><span class="comment">	 * some time for the data to be written</span></span><br><span class="line"><span class="comment">	 * 	等待向FLASH写入命令完成，数据写入需要一段时间</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Poll the status register of the FLASH to determine when it</span></span><br><span class="line"><span class="comment">		 * completes, by sending a read status command and receiving the</span></span><br><span class="line"><span class="comment">		 * status byte</span></span><br><span class="line"><span class="comment">		 * 	通过发送读取状态命令并接收状态字节，轮询FLASH的状态寄存器以确定何时完成</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, ReadStatusCmd, FlashStatus,</span><br><span class="line">					<span class="built_in">sizeof</span>(ReadStatusCmd));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the status indicates the write is done, then stop waiting,</span></span><br><span class="line"><span class="comment">		 * if a value of 0xFF in the status byte is read from the</span></span><br><span class="line"><span class="comment">		 * device and this loop never exits, the device slave select is</span></span><br><span class="line"><span class="comment">		 * possibly incorrect such that the device status is not being</span></span><br><span class="line"><span class="comment">		 * read</span></span><br><span class="line"><span class="comment">		 * 	如果状态指示写操作已经完成，那么停止等待，如果从设备读取状态字节中的0xFF值并且该循环永远不会退出，</span></span><br><span class="line"><span class="comment">		 * 	则设备从属选择可能不正确，因此没有读取设备状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((FlashStatus[<span class="number">1</span>] &amp; <span class="number">0x01</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	这个函数从连接到QSPI接口的串行FLASH中读取数据。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlashRead</span><span class="params">(XQspiPs *QspiPtr, u32 Address, u32 ByteCount, u8 Command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Setup the write command with the specified address and data for the</span></span><br><span class="line"><span class="comment">	 * FLASH</span></span><br><span class="line"><span class="comment">	 * 	使用指定的地址和数据为FLASH设置写命令</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WriteBuffer[COMMAND_OFFSET]   = Command;</span><br><span class="line">	WriteBuffer[ADDRESS_1_OFFSET] = (u8)((Address &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	WriteBuffer[ADDRESS_2_OFFSET] = (u8)((Address &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">	WriteBuffer[ADDRESS_3_OFFSET] = (u8)(Address &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((Command == FAST_READ_CMD) || (Command == DUAL_READ_CMD) ||</span><br><span class="line">	    (Command == QUAD_READ_CMD)) &#123;</span><br><span class="line">		ByteCount += DUMMY_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Send the read command to the FLASH to read the specified number</span></span><br><span class="line"><span class="comment">	 * of bytes from the FLASH, send the read command and address and</span></span><br><span class="line"><span class="comment">	 * receive the specified number of bytes of data in the data buffer</span></span><br><span class="line"><span class="comment">	 * 	向FLASH发送read命令，从FLASH中读取指定字节数，发送read命令和地址，从数据缓冲区中接收指定字节数的数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, WriteBuffer, ReadBuffer,</span><br><span class="line">				ByteCount + OVERHEAD_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	此功能擦除连接到QSPI接口的串行FLASH中的扇区。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlashErase</span><span class="params">(XQspiPs *QspiPtr, u32 Address, u32 ByteCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 WriteEnableCmd = &#123; WRITE_ENABLE_CMD &#125;;</span><br><span class="line">	u8 ReadStatusCmd[] = &#123; READ_STATUS_CMD, <span class="number">0</span> &#125;;  <span class="comment">/* must send 2 bytes */</span></span><br><span class="line">	u8 FlashStatus[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> Sector;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If erase size is same as the total size of the flash, use bulk erase</span></span><br><span class="line"><span class="comment">	 * command</span></span><br><span class="line"><span class="comment">	 * 	如果擦除大小等于flash的总大小，则使用bulk erase命令</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ByteCount == (NUM_SECTORS * SECTOR_SIZE)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Send the write enable command to the FLASH so that it can be</span></span><br><span class="line"><span class="comment">		 * written to, this needs to be sent as a seperate transfer</span></span><br><span class="line"><span class="comment">		 * before the erase</span></span><br><span class="line"><span class="comment">		 * 	如果擦除大小与flash的总大小相同，则使用bulk erase命令发送write enable命令到flash，</span></span><br><span class="line"><span class="comment">		 * 	以便写入，这需要在擦除之前作为单独的传输发送</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, &amp;WriteEnableCmd, <span class="literal">NULL</span>,</span><br><span class="line">				  <span class="built_in">sizeof</span>(WriteEnableCmd));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Setup the bulk erase command*/</span></span><br><span class="line">		WriteBuffer[COMMAND_OFFSET]   = BULK_ERASE_CMD;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Send the bulk erase command; no receive buffer is specified</span></span><br><span class="line"><span class="comment">		 * since there is nothing to receive</span></span><br><span class="line"><span class="comment">		 * 	发送批量擦除命令;没有指定接收缓冲区，因为没有要接收的东西</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, WriteBuffer, <span class="literal">NULL</span>,</span><br><span class="line">					BULK_ERASE_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Wait for the erase command to the FLASH to be completed*/</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Poll the status register of the device to determine</span></span><br><span class="line"><span class="comment">			 * when it completes, by sending a read status command</span></span><br><span class="line"><span class="comment">			 * and receiving the status byte</span></span><br><span class="line"><span class="comment">			 * 	通过发送读取状态命令和接收状态字节，轮询设备的状态寄存器以确定何时完成</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, ReadStatusCmd,</span><br><span class="line">						FlashStatus,</span><br><span class="line">						<span class="built_in">sizeof</span>(ReadStatusCmd));</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the status indicates the write is done, then stop</span></span><br><span class="line"><span class="comment">			 * waiting; if a value of 0xFF in the status byte is</span></span><br><span class="line"><span class="comment">			 * read from the device and this loop never exits, the</span></span><br><span class="line"><span class="comment">			 * device slave select is possibly incorrect such that</span></span><br><span class="line"><span class="comment">			 * the device status is not being read</span></span><br><span class="line"><span class="comment">			 * 	如果状态显示写操作完成，则停止等待;如果从设备中读取状态字节中的0xFF值，</span></span><br><span class="line"><span class="comment">			 * 	并且该循环从未退出，则设备从属选择可能不正确，因此没有读取设备状态</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> ((FlashStatus[<span class="number">1</span>] &amp; <span class="number">0x01</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the erase size is less than the total size of the flash, use</span></span><br><span class="line"><span class="comment">	 * sector erase command</span></span><br><span class="line"><span class="comment">	 * 	如果擦除的大小小于flash的总大小，则使用扇区擦除命令</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (Sector = <span class="number">0</span>; Sector &lt; ((ByteCount / SECTOR_SIZE) + <span class="number">1</span>); Sector++) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Send the write enable command to the SEEPOM so that it can be</span></span><br><span class="line"><span class="comment">		 * written to, this needs to be sent as a seperate transfer</span></span><br><span class="line"><span class="comment">		 * before the write</span></span><br><span class="line"><span class="comment">		 * 	将写启用命令发送到SEEPOM，以便可以写入，这需要在写入之前作为单独的传输发送</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, &amp;WriteEnableCmd, <span class="literal">NULL</span>,</span><br><span class="line">					<span class="built_in">sizeof</span>(WriteEnableCmd));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Setup the write command with the specified address and data</span></span><br><span class="line"><span class="comment">		 * for the FLASH</span></span><br><span class="line"><span class="comment">		 * 	使用指定的地址和数据为FLASH设置写命令</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WriteBuffer[COMMAND_OFFSET]   = SEC_ERASE_CMD;</span><br><span class="line">		WriteBuffer[ADDRESS_1_OFFSET] = (u8)(Address &gt;&gt; <span class="number">16</span>);</span><br><span class="line">		WriteBuffer[ADDRESS_2_OFFSET] = (u8)(Address &gt;&gt; <span class="number">8</span>);</span><br><span class="line">		WriteBuffer[ADDRESS_3_OFFSET] = (u8)(Address &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Send the sector erase command and address; no receive buffer</span></span><br><span class="line"><span class="comment">		 * is specified since there is nothing to receive</span></span><br><span class="line"><span class="comment">		 * 	发送扇区擦除命令和地址; 没有指定接收缓冲区，因为没有要接收的东西</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, WriteBuffer, <span class="literal">NULL</span>,</span><br><span class="line">					SEC_ERASE_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Wait for the sector erse command to the</span></span><br><span class="line"><span class="comment">		 * FLASH to be completed</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Poll the status register of the device to determine</span></span><br><span class="line"><span class="comment">			 * when it completes, by sending a read status command</span></span><br><span class="line"><span class="comment">			 * and receiving the status byte</span></span><br><span class="line"><span class="comment">			 * 	通过发送读取状态命令和接收状态字节，轮询设备的状态寄存器以确定何时完成</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, ReadStatusCmd,</span><br><span class="line">						FlashStatus,</span><br><span class="line">						<span class="built_in">sizeof</span>(ReadStatusCmd));</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the status indicates the write is done, then stop</span></span><br><span class="line"><span class="comment">			 * waiting, if a value of 0xFF in the status byte is</span></span><br><span class="line"><span class="comment">			 * read from the device and this loop never exits, the</span></span><br><span class="line"><span class="comment">			 * device slave select is possibly incorrect such that</span></span><br><span class="line"><span class="comment">			 * the device status is not being read</span></span><br><span class="line"><span class="comment">			 * 	如果状态指示写操作已经完成，那么停止等待，如果从设备读取状态字节中的0xFF值</span></span><br><span class="line"><span class="comment">			 * 	并且该循环永远不会退出，则设备从属选择可能不正确，因此没有读取设备状态</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> ((FlashStatus[<span class="number">1</span>] &amp; <span class="number">0x01</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Address += SECTOR_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该功能读取连接到SPI接口的串行FLASH ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FlashReadID</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Read ID in Auto mode.*/</span></span><br><span class="line">	WriteBuffer[COMMAND_OFFSET]   = READ_ID;</span><br><span class="line">	WriteBuffer[ADDRESS_1_OFFSET] = <span class="number">0x23</span>;		<span class="comment">/* 3 dummy bytes */</span></span><br><span class="line">	WriteBuffer[ADDRESS_2_OFFSET] = <span class="number">0x08</span>;</span><br><span class="line">	WriteBuffer[ADDRESS_3_OFFSET] = <span class="number">0x09</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">XQspiPs_PolledTransfer</span>(&amp;QspiInstance, WriteBuffer, ReadBuffer,</span><br><span class="line">				RD_ID_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">xil_printf</span>(<span class="string">&quot;FlashID=0x%x 0x%x 0x%x\n&quot;</span>, ReadBuffer[<span class="number">1</span>], ReadBuffer[<span class="number">2</span>],</span><br><span class="line">		   ReadBuffer[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该功能在连接到SPI接口的串行闪存中启用QUAD模式。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlashQuadEnable</span><span class="params">(XQspiPs *QspiPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 WriteEnableCmd = &#123;WRITE_ENABLE_CMD&#125;;</span><br><span class="line">	u8 ReadStatusCmd[] = &#123;READ_STATUS_CMD, <span class="number">0</span>&#125;;</span><br><span class="line">	u8 QuadEnableCmd[] = &#123;WRITE_STATUS_CMD, <span class="number">0</span>&#125;;</span><br><span class="line">	u8 FlashStatus[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ReadBuffer[<span class="number">1</span>] == <span class="number">0x9D</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, ReadStatusCmd,</span><br><span class="line">					FlashStatus,</span><br><span class="line">					<span class="built_in">sizeof</span>(ReadStatusCmd));</span><br><span class="line"></span><br><span class="line">		QuadEnableCmd[<span class="number">1</span>] = FlashStatus[<span class="number">1</span>] | <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, &amp;WriteEnableCmd, <span class="literal">NULL</span>,</span><br><span class="line">				  <span class="built_in">sizeof</span>(WriteEnableCmd));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">XQspiPs_PolledTransfer</span>(QspiPtr, QuadEnableCmd, <span class="literal">NULL</span>,</span><br><span class="line">					<span class="built_in">sizeof</span>(QuadEnableCmd));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之PS-XADC（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/26/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BPS-XADC%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节简单演示了PL JATG接口读取XADC数据以及通过PS-XADC接口读取XADC数据的简单实例</p>
<span id="more"></span>
<h1 id="XADC简介"><a href="#XADC简介" class="headerlink" title="XADC简介"></a>XADC简介</h1><ul>
<li>Xilinx模拟混合信号模块，简称XADC，是一个硬核，即PL部分的硬核。它具有 JTAG 和 DRP 接口，用于访问 7 系列 FPGA 中的 XADC 状态和控制寄存器。 Zynq-7000 SoC 器件添加了第三个接口，即 <strong>PS-XADC 接口，供 PS 软件控制 XADC</strong></li>
<li>XADC有两个独立的12位ADC可配置为同时对两个外部输入模拟通道进行采样</li>
<li>模拟输入可支持1MSPS采样率下500 KHz的信号带宽</li>
</ul>
<h1 id="通过PL-JATG读取XADC数据"><a href="#通过PL-JATG读取XADC数据" class="headerlink" title="通过PL JATG读取XADC数据"></a>通过PL JATG读取XADC数据</h1><ul>
<li><p>vivado中的配置跟hello world一致</p>
<p><img src="/2023/09/26/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BPS-XADC%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230926120452482.png" alt="image-20230926120452482"></p>
</li>
</ul>
<hr>
<h1 id="通过PS-XADC获取XADC数据"><a href="#通过PS-XADC获取XADC数据" class="headerlink" title="通过PS XADC获取XADC数据"></a>通过PS XADC获取XADC数据</h1><ul>
<li>实验任务：通过PS-XADC接口，读取XADC测量的芯片温度、供电电压等信息，并通过串口打印出来</li>
</ul>
<h2 id="1-Vivado中的相关配置"><a href="#1-Vivado中的相关配置" class="headerlink" title="1.Vivado中的相关配置"></a>1.Vivado中的相关配置</h2><ul>
<li><p>与hello world实验一样</p>
<p><img src="/2023/09/26/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BPS-XADC%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230926121924206.png" alt="image-20230926121924206" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-Vitis中的代码编写"><a href="#2-Vitis中的代码编写" class="headerlink" title="2.Vitis中的代码编写"></a>2.Vitis中的代码编写</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xparameters.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xadcps.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xstatus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sleep.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XADC_DEVICE_ID 		XPAR_XADCPS_0_DEVICE_ID	<span class="comment">//PS XADC器件ID</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">XAdcPolledPrintfExample</span><span class="params">(u16 XAdcDeviceId)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">XAdcFractionToInt</span><span class="params">(<span class="type">float</span> FloatNum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> XAdcPs XAdcInst;		<span class="comment">//XADC驱动实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)		<span class="comment">//	每5S打印一次</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;======================================&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">XAdcPolledPrintfExample</span>(XADC_DEVICE_ID);</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;************************************************************&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">5000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">XAdcPolledPrintfExample</span><span class="params">(u16 XAdcDeviceId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XAdcPs_Config *ConfigPtr;</span><br><span class="line">	u32 TempRawData;		<span class="comment">//温度		原始数据</span></span><br><span class="line">	u32 VccPintRawData;		<span class="comment">//PS 内核电压	原始数据</span></span><br><span class="line">	u32 VccPauxRawData;		<span class="comment">//PS 辅助电压	原始数据</span></span><br><span class="line">	u32 VccPdroRawData;		<span class="comment">//PS DDR电压	原始数据</span></span><br><span class="line"></span><br><span class="line">	u32 VccintRawData;		<span class="comment">//PL 内核电压	原始数据</span></span><br><span class="line">	u32 VccauxRawData;		<span class="comment">//PL 辅助电压	原始数据</span></span><br><span class="line">	u32 VccdroRawData;		<span class="comment">//PL BRAM电压	原始数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> TempData;			<span class="comment">//温度</span></span><br><span class="line">	<span class="type">float</span> VccPintData;		<span class="comment">//PS 内核电压</span></span><br><span class="line">	<span class="type">float</span> VccPauxData;		<span class="comment">//PS 辅助电压</span></span><br><span class="line">	<span class="type">float</span> MaxData;</span><br><span class="line">	<span class="type">float</span> MinData;</span><br><span class="line">	<span class="type">float</span> VccintData;			<span class="comment">//PL 内核电压</span></span><br><span class="line">	<span class="type">float</span> VccauxData;			<span class="comment">//PL 辅助电压</span></span><br><span class="line">	<span class="type">float</span> vccBRAM;			<span class="comment">//PL BRAM电压</span></span><br><span class="line"></span><br><span class="line">	XAdcPs *XAdcInstPtr = &amp;XAdcInst;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化XADC驱动</span></span><br><span class="line">	ConfigPtr = <span class="built_in">XAdcPs_LookupConfig</span>(XAdcDeviceId);</span><br><span class="line">	<span class="built_in">XAdcPs_CfgInitialize</span>(XAdcInstPtr, ConfigPtr,</span><br><span class="line">				ConfigPtr-&gt;BaseAddress);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*	设置XADC操作模式为“默认安全模式”</span></span><br><span class="line"><span class="comment">	 * 	在该模式下，XADC 会自动监测片上温度和电压传感器的数据，并将结果保存在状态寄存器中，</span></span><br><span class="line"><span class="comment">	 * 	此时 XADC的操作与其他任何控制寄存器的设置无关	 */</span></span><br><span class="line">	<span class="built_in">XAdcPs_SetSequencerMode</span>(XAdcInstPtr, XADCPS_SEQ_MODE_SAFE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取原始温度传感器数据，并转换成温度信息</span></span><br><span class="line">	TempRawData = <span class="built_in">XAdcPs_GetAdcData</span>(XAdcInstPtr, XADCPS_CH_TEMP);</span><br><span class="line">	TempData = <span class="built_in">XAdcPs_RawToTemperature</span>(TempRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;芯片当前温度为: %0d.%03d ℃.\r\n&quot;</span>, (<span class="type">int</span>)(TempData), <span class="built_in">XAdcFractionToInt</span>(TempData));</span><br><span class="line"></span><br><span class="line">	TempRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr, XADCPS_MAX_TEMP);</span><br><span class="line">	MaxData = <span class="built_in">XAdcPs_RawToTemperature</span>(TempRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;芯片最高温度为： %0d.%03d ℃. \r\n&quot;</span>, (<span class="type">int</span>)(MaxData), <span class="built_in">XAdcFractionToInt</span>(MaxData));</span><br><span class="line"></span><br><span class="line">	TempRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr, XADCPS_MIN_TEMP);</span><br><span class="line">	MinData = <span class="built_in">XAdcPs_RawToTemperature</span>(TempRawData &amp; <span class="number">0xFFF0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;芯片最低温度为： %0d.%03d ℃. \r\n&quot;</span>, (<span class="type">int</span>)(MinData), <span class="built_in">XAdcFractionToInt</span>(MinData));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取VCCPINT传感器数据，并转换成电压信息</span></span><br><span class="line">	VccPintRawData = <span class="built_in">XAdcPs_GetAdcData</span>(XAdcInstPtr, XADCPS_CH_VCCPINT);</span><br><span class="line">	VccPintData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccPintRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n当前VCCPINT为： %0d.%03d V. \r\n&quot;</span>, (<span class="type">int</span>)(VccPintData), <span class="built_in">XAdcFractionToInt</span>(VccPintData));</span><br><span class="line"></span><br><span class="line">	VccPintRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr, XADCPS_MAX_VCCPINT);</span><br><span class="line">	MaxData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccPintRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最大VCCPINT为： %0d.%03d V. \r\n&quot;</span>, (<span class="type">int</span>)(MaxData), <span class="built_in">XAdcFractionToInt</span>(MaxData));</span><br><span class="line"></span><br><span class="line">	VccPintRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr, XADCPS_MIN_VCCPINT);</span><br><span class="line">	MinData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccPintRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最小VCCPINT为： %0d.%03d V. \r\n&quot;</span>, (<span class="type">int</span>)(MinData), <span class="built_in">XAdcFractionToInt</span>(MinData));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取VCCPAUX传感器数据，并转换成电压信息</span></span><br><span class="line">	VccPauxRawData = <span class="built_in">XAdcPs_GetAdcData</span>(XAdcInstPtr, XADCPS_CH_VCCPAUX);</span><br><span class="line">	VccPauxData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccPauxRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n当前VCCPAUX为： %0d.%03d V. \r\n&quot;</span>, (<span class="type">int</span>)(VccPauxData), <span class="built_in">XAdcFractionToInt</span>(VccPauxData));</span><br><span class="line"></span><br><span class="line">	VccPauxRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr, XADCPS_MAX_VCCPAUX);</span><br><span class="line">	MaxData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccPauxRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最大VCCPAUX为： %0d.%03d V. \r\n&quot;</span>, (<span class="type">int</span>)(MaxData), <span class="built_in">XAdcFractionToInt</span>(MaxData));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	VccPauxRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr, XADCPS_MIN_VCCPAUX);</span><br><span class="line">	MinData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccPauxRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最小VCCPAUX为： %0d.%03d V. \r\n&quot;</span>, (<span class="type">int</span>)(MinData), <span class="built_in">XAdcFractionToInt</span>(MinData));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取VCCPDRO传感器数据，并转换成电压信息</span></span><br><span class="line">	VccPdroRawData = <span class="built_in">XAdcPs_GetAdcData</span>(XAdcInstPtr, XADCPS_CH_VCCPDRO);</span><br><span class="line">	VccPintData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccPdroRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n当前VCCPDDRO为： %0d.%03d V. \r\n&quot;</span>, (<span class="type">int</span>)(VccPintData), <span class="built_in">XAdcFractionToInt</span>(VccPintData));</span><br><span class="line"></span><br><span class="line">	VccPdroRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr, XADCPS_MAX_VCCPDRO);</span><br><span class="line">	MaxData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccPdroRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最大VCCPDDRO为： %0d.%03d V. \r\n&quot;</span>, (<span class="type">int</span>)(MaxData), <span class="built_in">XAdcFractionToInt</span>(MaxData));</span><br><span class="line"></span><br><span class="line">	VccPdroRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr, XADCPS_MIN_VCCPDRO);</span><br><span class="line">	MinData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccPdroRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最小VCCPDDRO为： %0d.%03d V. \r\n&quot;</span>, (<span class="type">int</span>)(MinData), <span class="built_in">XAdcFractionToInt</span>(MinData));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取VCCINT传感器数据，并转换成电压信息</span></span><br><span class="line">	VccintRawData = <span class="built_in">XAdcPs_GetAdcData</span>(XAdcInstPtr, XADCPS_CH_VCCINT);</span><br><span class="line">	VccintData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccintRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n当前VCCINT为： %0d.%03d V. \r\n&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)(VccintData), <span class="built_in">XAdcFractionToInt</span>(VccintData));</span><br><span class="line"></span><br><span class="line">	VccintRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr,</span><br><span class="line">			XADCPS_MAX_VCCINT);</span><br><span class="line">	MaxData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccintRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最大VCCINT为： %0d.%03d V. \r\n&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)(MaxData), <span class="built_in">XAdcFractionToInt</span>(MaxData));</span><br><span class="line"></span><br><span class="line">	VccintRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr,</span><br><span class="line">			XADCPS_MIN_VCCINT);</span><br><span class="line">	MinData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccintRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最小VCCINT为： %0d.%03d V. \r\n&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)(MinData), <span class="built_in">XAdcFractionToInt</span>(MinData));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取VCCAUX传感器数据，并转换成电压信息</span></span><br><span class="line">	VccauxRawData = <span class="built_in">XAdcPs_GetAdcData</span>(XAdcInstPtr, XADCPS_CH_VCCAUX);</span><br><span class="line">	VccauxData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccauxRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n当前VCCAUX为： %0d.%03d V. \r\n&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)(VccauxData), <span class="built_in">XAdcFractionToInt</span>(VccauxData));</span><br><span class="line"></span><br><span class="line">	VccauxRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr,</span><br><span class="line">			XADCPS_MAX_VCCAUX);</span><br><span class="line">	MaxData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccauxRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最大VCCAUX为： %0d.%03d V. \r\n&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)(MaxData), <span class="built_in">XAdcFractionToInt</span>(MaxData));</span><br><span class="line"></span><br><span class="line">	VccauxRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr,</span><br><span class="line">			XADCPS_MIN_VCCAUX);</span><br><span class="line">	MinData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccauxRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最小VCCAUX为： %0d.%03d V. \r\n&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)(MinData), <span class="built_in">XAdcFractionToInt</span>(MinData));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取VCCBRAM传感器数据，并转换成电压信息</span></span><br><span class="line">	VccdroRawData = <span class="built_in">XAdcPs_GetAdcData</span>(XAdcInstPtr, XADCPS_CH_VBRAM);</span><br><span class="line">	vccBRAM = <span class="built_in">XAdcPs_RawToVoltage</span>(VccdroRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n当前VCCBRAM为： %0d.%03d V. \r\n&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)(vccBRAM), <span class="built_in">XAdcFractionToInt</span>(vccBRAM));</span><br><span class="line"></span><br><span class="line">	VccdroRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr,</span><br><span class="line">			XADCPS_MAX_VBRAM);</span><br><span class="line">	MaxData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccdroRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最大VCCBRAM为： %0d.%03d V. \r\n&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)(MaxData), <span class="built_in">XAdcFractionToInt</span>(MaxData));</span><br><span class="line"></span><br><span class="line">	VccdroRawData = <span class="built_in">XAdcPs_GetMinMaxMeasurement</span>(XAdcInstPtr,</span><br><span class="line">			XADCPS_MIN_VBRAM);</span><br><span class="line">	MinData = <span class="built_in">XAdcPs_RawToVoltage</span>(VccdroRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最小VCCBRAM为： %0d.%03d V. \r\n&quot;</span>,</span><br><span class="line">			(<span class="type">int</span>)(MinData), <span class="built_in">XAdcFractionToInt</span>(MinData));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">XAdcFractionToInt</span><span class="params">(<span class="type">float</span> FloatNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> Temp;</span><br><span class="line"></span><br><span class="line">	Temp = FloatNum;</span><br><span class="line">	<span class="keyword">if</span> (FloatNum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		Temp = -(FloatNum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>( ((<span class="type">int</span>)((Temp -(<span class="type">float</span>)((<span class="type">int</span>)Temp)) * (<span class="number">1000.0f</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3.实验结果"></a>3.实验结果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connected to COM4 at 115200</span><br><span class="line">======================================</span><br><span class="line">芯片当前温度为: 39.036 ℃.</span><br><span class="line"></span><br><span class="line">芯片最高温度为： 39.505 ℃. </span><br><span class="line"></span><br><span class="line">芯片最低温度为： 37.529 ℃. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当前VCCPINT为： 1.021 V. </span><br><span class="line"></span><br><span class="line">最大VCCPINT为： 1.024 V. </span><br><span class="line"></span><br><span class="line">最小VCCPINT为： 1.020 V. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当前VCCPAUX为： 1.797 V. </span><br><span class="line"></span><br><span class="line">最大VCCPAUX为： 1.800 V. </span><br><span class="line"></span><br><span class="line">最小VCCPAUX为： 1.795 V. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当前VCCPDDRO为： 1.493 V. </span><br><span class="line"></span><br><span class="line">最大VCCPDDRO为： 1.496 V. </span><br><span class="line"></span><br><span class="line">最小VCCPDDRO为： 1.486 V. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当前VCCINT为： 1.023 V. </span><br><span class="line"></span><br><span class="line">最大VCCINT为： 1.025 V. </span><br><span class="line"></span><br><span class="line">最小VCCINT为： 1.022 V. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当前VCCAUX为： 1.797 V. </span><br><span class="line"></span><br><span class="line">最大VCCAUX为： 1.800 V. </span><br><span class="line"></span><br><span class="line">最小VCCAUX为： 1.795 V. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当前VCCBRAM为： 1.023 V. </span><br><span class="line"></span><br><span class="line">最大VCCBRAM为： 1.025 V. </span><br><span class="line"></span><br><span class="line">最小VCCBRAM为： 1.022 V. </span><br><span class="line"></span><br><span class="line">************************************************************</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之定时器（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/26/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节主要通过定时器中断控制LED亮灭来简单演示定时器的使用</p>
<span id="more"></span>
<h1 id="定时器的基本概念"><a href="#定时器的基本概念" class="headerlink" title="定时器的基本概念"></a>定时器的基本概念</h1><ul>
<li>每个Cortex-A9处理器都有一个<strong>私有的32位定时器（提供常规的记时记数以及输出PWM）和一个32位的看门狗定时器（实现监控和监视，当系统发生灾难性故障的时候，让程序能重启，恢复正常状态）</strong></li>
<li>每个处理器都共享一个64位的定时器</li>
<li>这些定时器的频率总是CPU频率的一半</li>
<li>在系统层面来说，还有一个24位的看门狗定时器和两个三重定时器（对信号的脉冲宽度进行计数）</li>
</ul>
<hr>
<h1 id="定时器中断实验"><a href="#定时器中断实验" class="headerlink" title="定时器中断实验"></a>定时器中断实验</h1><ul>
<li>实验任务：通过定时器的中断，每1s控制一次PL LED灯的亮灭</li>
</ul>
<h2 id="1-Vivado中的配置"><a href="#1-Vivado中的配置" class="headerlink" title="1.Vivado中的配置"></a>1.Vivado中的配置</h2><ul>
<li>与配置EMIO实验一样</li>
</ul>
<h2 id="2-Vitis中的代码编写"><a href="#2-Vitis中的代码编写" class="headerlink" title="2.Vitis中的代码编写"></a>2.Vitis中的代码编写</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xparameters.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xgpiops.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xscutimer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xscugic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************参数声明**********************/</span></span><br><span class="line"><span class="comment">/*GPIO相关参数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_DEVICE_ID	XPAR_XGPIOPS_0_DEVICE_ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMIO54_LED0	54 <span class="comment">//PL端的第54个pin分配给LED0</span></span></span><br><span class="line">XGpioPs Gpio; <span class="comment">//GPIO设备的驱动程序实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器相关参数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_DEVICE_ID		XPAR_XSCUTIMER_0_DEVICE_ID <span class="comment">//定时器器件ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_IRPT_INTR		XPAR_SCUTIMER_INTR <span class="comment">//定时器中断ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_LOAD_VALUE	0x135EFB82 <span class="comment">//定时器的装载值</span></span></span><br><span class="line"><span class="comment">/*想要延时1s： 时钟为1/2的CPU时钟，即为650/2=325MHz。</span></span><br><span class="line"><span class="comment">    先计算时钟周期：1s/325M=3.077ns</span></span><br><span class="line"><span class="comment">  1s对应数字：1s/3.077ns =0x135EFB83 （因为从0开始计数，则在0x135EFB83的结果上-1，即为0x135EFB82）   */</span></span><br><span class="line">XScuTimer TimerInstance; <span class="comment">//Cortex A9私有定时器的实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断相关参数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTC_DEVICE_ID		XPAR_SCUGIC_0_DEVICE_ID <span class="comment">//中断控制器的ID</span></span></span><br><span class="line">XScuGic IntcInstance;  <span class="comment">//中断控制器的实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************函数声明**********************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gpio_init</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_init</span><span class="params">(XScuTimer *TimerInstancePtr,u16 TimerDeviceId)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_intr_init</span><span class="params">(XScuGic *IntcInstancePtr,XScuTimer *TimerInstancePtr,u16 TimerIntrId)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_intr_handler</span><span class="params">(<span class="type">void</span> *CallBackRef)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************主函数入口**********************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">gpio_init</span>();</span><br><span class="line">	<span class="built_in">timer_init</span>(&amp;TimerInstance, TIMER_DEVICE_ID);</span><br><span class="line">	<span class="built_in">timer_intr_init</span>(&amp;IntcInstance, &amp;TimerInstance, TIMER_IRPT_INTR);</span><br><span class="line">	<span class="built_in">XScuTimer_Start</span>(&amp;TimerInstance);<span class="comment">//开启定时器</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gpio_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XGpioPs_Config * ConfigPtr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//配置器件的ID，查找器件的配置信息</span></span><br><span class="line">	ConfigPtr = <span class="built_in">XGpioPs_LookupConfig</span>(GPIO_DEVICE_ID);</span><br><span class="line">	<span class="comment">//初始化GPIO驱动</span></span><br><span class="line">	<span class="built_in">XGpioPs_CfgInitialize</span>(&amp;Gpio, ConfigPtr, ConfigPtr-&gt;BaseAddr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置GPIO的方向（0：输入/1：输出）</span></span><br><span class="line">	<span class="built_in">XGpioPs_SetDirectionPin</span>(&amp;Gpio,EMIO54_LED0, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置输出使能（1：关闭/1：打开）</span></span><br><span class="line">	<span class="built_in">XGpioPs_SetOutputEnablePin</span>(&amp;Gpio, EMIO54_LED0, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//XGpioPs_WritePin(&amp;Gpio, EMIO54_LED0, led_value);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_init</span><span class="params">(XScuTimer *TimerInstancePtr,u16 TimerDeviceId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XScuTimer_Config *ConfigPtr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化私有定时器</span></span><br><span class="line">	ConfigPtr = <span class="built_in">XScuTimer_LookupConfig</span>(TimerDeviceId);</span><br><span class="line">	<span class="built_in">XScuTimer_CfgInitialize</span>(TimerInstancePtr, ConfigPtr, ConfigPtr-&gt;BaseAddr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//配置计数器初始值</span></span><br><span class="line">	<span class="built_in">XScuTimer_LoadTimer</span>(TimerInstancePtr, TIMER_LOAD_VALUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使能自动装载模式</span></span><br><span class="line">	<span class="built_in">XScuTimer_EnableAutoReload</span>(TimerInstancePtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器中断初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_intr_init</span><span class="params">(XScuGic *IntcInstancePtr,XScuTimer *TimerInstancePtr,u16 TimerIntrId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XScuGic_Config *IntcConfig;</span><br><span class="line"></span><br><span class="line">	IntcConfig = <span class="built_in">XScuGic_LookupConfig</span>(INTC_DEVICE_ID);</span><br><span class="line">	<span class="built_in">XScuGic_CfgInitialize</span>(IntcInstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中断异常处理</span></span><br><span class="line">	<span class="built_in">Xil_ExceptionInit</span>();</span><br><span class="line">	<span class="built_in">Xil_ExceptionRegisterHandler</span>(XIL_EXCEPTION_ID_IRQ_INT,</span><br><span class="line">					(Xil_ExceptionHandler)XScuGic_InterruptHandler,</span><br><span class="line">					IntcInstancePtr);</span><br><span class="line">	<span class="built_in">Xil_ExceptionEnable</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置定时器的中断处理函数</span></span><br><span class="line">	<span class="built_in">XScuGic_Connect</span>(IntcInstancePtr, TimerIntrId,</span><br><span class="line">					(Xil_ExceptionHandler)timer_intr_handler,</span><br><span class="line">					(<span class="type">void</span> *)TimerInstancePtr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使能中断控制器</span></span><br><span class="line">	<span class="built_in">XScuGic_Enable</span>(IntcInstancePtr, TimerIntrId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使能定时器中断</span></span><br><span class="line">	<span class="built_in">XScuTimer_EnableInterrupt</span>(TimerInstancePtr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器中断处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_intr_handler</span><span class="params">(<span class="type">void</span> *CallBackRef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> led_status = <span class="number">1</span>;</span><br><span class="line">	XScuTimer *TimerInstancePtr = (XScuTimer *) CallBackRef;</span><br><span class="line">	<span class="comment">//进入中断之后清除中断</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">XScuTimer_IsExpired</span>(TimerInstancePtr))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//向MIO引脚写入高低电平,只看最低位是0还是1</span></span><br><span class="line">		<span class="built_in">XScuTimer_ClearInterruptStatus</span>(TimerInstancePtr); <span class="comment">//每次进入中断后清除中断</span></span><br><span class="line">		<span class="built_in">XGpioPs_WritePin</span>(&amp;Gpio, EMIO54_LED0, led_status);</span><br><span class="line">		led_status = ~led_status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之UART控制器（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/25/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BUART%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节主要以串口UART中断实验为例，简单演示了串口的使用</p>
<span id="more"></span> 
<h1 id="UART串口中断实验"><a href="#UART串口中断实验" class="headerlink" title="UART串口中断实验"></a>UART串口中断实验</h1><ul>
<li><p>实验任务：使用UART控制器，完成串口中断数据环回的功能</p>
<p><img src="/2023/09/25/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BUART%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230925143504262.png" alt="image-20230925143504262" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="1-Vivado中的相关配置"><a href="#1-Vivado中的相关配置" class="headerlink" title="1.Vivado中的相关配置"></a>1.Vivado中的相关配置</h2><ul>
<li>与hello world中的配置一样</li>
</ul>
<h2 id="2-Vitis中的代码编写"><a href="#2-Vitis中的代码编写" class="headerlink" title="2.Vitis中的代码编写"></a>2.Vitis中的代码编写</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xparameters.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xuartps.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xscugic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xuartps_hw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************参数声明**********************/</span></span><br><span class="line"><span class="comment">/*串口UART相关参数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeviceId  			XPAR_PS7_UART_0_DEVICE_ID		<span class="comment">//串口设备ID</span></span></span><br><span class="line">XUartPs  Uart_Inst;											<span class="comment">//串口驱动程序实例</span></span><br><span class="line"><span class="comment">/*串口UART中断相关参数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTR_DEVICE_ID		XPAR_SCUGIC_0_DEVICE_ID	<span class="comment">//中断控制器的器件ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_INT_IRQ_ID		XPAR_XUARTPS_0_INTR				<span class="comment">//串口中断ID</span></span></span><br><span class="line">XScuGic ScuGic_Inst;										<span class="comment">//中断控制器驱动程序实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************函数声明**********************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uart_init</span><span class="params">(XUartPs* Uart_Inst)</span></span>; <span class="comment">//串口UART初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uart_intr_init</span><span class="params">(XScuGic* intr, XUartPs* Uart_Inst)</span></span>; 	<span class="comment">//中断初始化程序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UartIntr_Handler</span><span class="params">(XUartPs * CallbackRef)</span></span>; <span class="comment">//中断服务函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//串口初始化函数</span></span><br><span class="line">	<span class="built_in">uart_init</span>(&amp;Uart_Inst);</span><br><span class="line">	<span class="comment">//中断初始化程序</span></span><br><span class="line">	<span class="built_in">uart_intr_init</span>(&amp;ScuGic_Inst, &amp;Uart_Inst);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口UART初始化程序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uart_init</span><span class="params">(XUartPs* Uart_Inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XUartPs_Config *Config;</span><br><span class="line">	<span class="comment">//查找配置信息</span></span><br><span class="line">	Config = <span class="built_in">XUartPs_LookupConfig</span>(DeviceId);</span><br><span class="line">	<span class="comment">//对UART控制器进行初始化</span></span><br><span class="line">	<span class="built_in">XUartPs_CfgInitialize</span>(Uart_Inst, Config, Config-&gt;BaseAddress);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置UART的工作模式</span></span><br><span class="line">	<span class="built_in">XUartPs_SetOperMode</span>(Uart_Inst, XUARTPS_OPER_MODE_NORMAL);</span><br><span class="line">	<span class="comment">//设置接收FIFO的触发阈值，每接收1个字节的数据即产生中断，故第二个参数填1</span></span><br><span class="line">	<span class="built_in">XUartPs_SetFifoThreshold</span>(Uart_Inst, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//设置波特率：115200</span></span><br><span class="line">	<span class="built_in">XUartPs_SetBaudRate</span>(Uart_Inst, <span class="number">115200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断初始化程序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uart_intr_init</span><span class="params">(XScuGic* intr, XUartPs* Uart_Inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XScuGic_Config *IntcConfig; <span class="comment">//中断控制器的配置信息</span></span><br><span class="line">	<span class="comment">//初始化中断控制器的驱动</span></span><br><span class="line">	IntcConfig = <span class="built_in">XScuGic_LookupConfig</span>(INTR_DEVICE_ID);</span><br><span class="line">	<span class="built_in">XScuGic_CfgInitialize</span>(intr, IntcConfig, IntcConfig-&gt;CpuBaseAddress);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置并打开中断异常处理功能</span></span><br><span class="line">	<span class="comment">//初始化ARM处理器异常句柄</span></span><br><span class="line">	<span class="built_in">Xil_ExceptionInit</span>();</span><br><span class="line">	<span class="comment">//来给IRQ异常注册处理程序</span></span><br><span class="line">	<span class="built_in">Xil_ExceptionRegisterHandler</span>(XIL_EXCEPTION_ID_INT,</span><br><span class="line">					(Xil_ExceptionHandler) XScuGic_InterruptHandler,</span><br><span class="line">					(<span class="type">void</span> *)intr);</span><br><span class="line">	<span class="built_in">Xil_ExceptionEnable</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关联中断ID和中断处理函数</span></span><br><span class="line">	<span class="built_in">XScuGic_Connect</span>(intr, UART_INT_IRQ_ID,</span><br><span class="line">				(Xil_ExceptionHandler)UartIntr_Handler,</span><br><span class="line">				(<span class="type">void</span> *)Uart_Inst);</span><br><span class="line">	<span class="comment">//设置触发类型，RX FIFO trigger interrupt</span></span><br><span class="line">	<span class="built_in">XUartPs_SetInterruptMask</span>(Uart_Inst, XUARTPS_IXR_RXOVR);<span class="comment">//触发类型</span></span><br><span class="line">	<span class="comment">//使能串口UART中断</span></span><br><span class="line">	<span class="built_in">XScuGic_Enable</span>(intr, UART_INT_IRQ_ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UartIntr_Handler</span><span class="params">(XUartPs * CallbackRef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 IsrStatus;</span><br><span class="line">	u32 read_data = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//获取中断状态寄存器的值</span></span><br><span class="line">	IsrStatus = <span class="built_in">XUartPs_ReadReg</span>(CallbackRef-&gt;Config.BaseAddress,  XUARTPS_IMR_OFFSET);<span class="comment">//读取掩码</span></span><br><span class="line"></span><br><span class="line">	IsrStatus &amp;= <span class="built_in">XUartPs_ReadReg</span>(CallbackRef-&gt;Config.BaseAddress, XUARTPS_ISR_OFFSET);<span class="comment">//读取状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//XUARTPS_IXR_RXOVR是接收中断触发阈值的位</span></span><br><span class="line">	<span class="keyword">if</span>(IsrStatus &amp; XUARTPS_IXR_RXOVR)</span><br><span class="line">	&#123;</span><br><span class="line">		read_data = <span class="built_in">XUartPs_RecvByte</span>(CallbackRef-&gt;Config.BaseAddress); <span class="comment">//读取接收到的一个字节的数据</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">XUartPs_WriteReg</span>(CallbackRef-&gt;Config.BaseAddress, XUARTPS_ISR_OFFSET, XUARTPS_IXR_RXOVR); <span class="comment">//清除中断状态位</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收到什么，发送什么</span></span><br><span class="line">	<span class="built_in">XUartPs_SendByte</span>(CallbackRef-&gt;Config.BaseAddress,read_data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3.实验结果"></a>3.实验结果</h2><p><img src="/2023/09/25/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BUART%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230925160225125.png" alt="image-20230925160225125"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之程序固化（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/25/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节主要演示了如何将ZYNQ的程序固化</p>
<span id="more"></span> 
<h1 id="Vivado中的相关配置"><a href="#Vivado中的相关配置" class="headerlink" title="Vivado中的相关配置"></a>Vivado中的相关配置</h1><ul>
<li><p>配置flash</p>
<p><img src="/2023/09/25/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230925124855066.png" alt="image-20230925124855066"></p>
</li>
<li><p>需要从SD卡启动程序，则还需要配置SD卡</p>
<p><img src="/2023/09/25/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230925125108246.png" alt="image-20230925125108246"></p>
</li>
<li><p>然而，因为实验是基于pynq-z2的boards的，自动配置时已经将这些都配置好了</p>
</li>
</ul>
<hr>
<h1 id="Vitis中的相关配置"><a href="#Vitis中的相关配置" class="headerlink" title="Vitis中的相关配置"></a>Vitis中的相关配置</h1><p><img src="/2023/09/25/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230925131626973.png" alt="image-20230925131626973"></p>
<p><img src="/2023/09/25/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230925131724147.png" alt="image-20230925131724147"></p>
<hr>
<h1 id="SD卡的使用"><a href="#SD卡的使用" class="headerlink" title="SD卡的使用"></a>SD卡的使用</h1><ul>
<li><p>将生成的BIN文件拷贝到SD卡中，再将SD卡插到板子上，就可以使用了</p>
<p><img src="/2023/09/25/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%9B%BA%E5%8C%96%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230925132001213.png" alt="image-20230925132001213"></p>
</li>
<li><p>对了，记得把跳帽接到SD引脚上</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之IP核（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节主要介绍了Vivado中自定义IP核的创建，以及IP核如何与PS建立联系，并以一个呼吸灯实验为例作为演示</p>
<span id="more"></span> 
<h1 id="自定义IP核的创建与编辑"><a href="#自定义IP核的创建与编辑" class="headerlink" title="自定义IP核的创建与编辑"></a>自定义IP核的创建与编辑</h1><h2 id="1-IP核的创建"><a href="#1-IP核的创建" class="headerlink" title="1.IP核的创建"></a>1.IP核的创建</h2><ul>
<li><p>创建管理IP核的工程</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923105815914.png" alt="image-20230923105815914"></p>
</li>
<li><p>创建并封装一个新的ip</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923105917271.png" alt="image-20230923105917271"></p>
</li>
<li><p>创建AXI4外设：<strong>当verilog代码需要跟PS做一些数据交互的时候选这个</strong></p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923110134425.png" alt="image-20230923110134425"></p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923110245443.png" alt="image-20230923110245443"></p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923110453477.png" alt="image-20230923110453477"></p>
</li>
</ul>
<h2 id="2-IP核的编辑"><a href="#2-IP核的编辑" class="headerlink" title="2.IP核的编辑"></a>2.IP核的编辑</h2><ul>
<li><p>在IP的封装包内对其进行编辑</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923110841775.png" alt="image-20230923110841775"></p>
</li>
<li><p>创建breath_LED的verilog设计文件并将其保存在对应目录下</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923111939491.png" alt="image-20230923111939491"></p>
</li>
<li><p>编写呼吸灯模块代码并在ip核中例化</p>
<ul>
<li><p>模块添加：</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923135247006.png" alt="image-20230923135247006"></p>
</li>
<li><p>添加参数和自定义的输入或输出端口</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923135433196.png" alt="image-20230923135433196"></p>
</li>
<li><p>端口连线</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923135833161.png" alt="image-20230923135833161"></p>
</li>
<li><p>在IP的顶层文件中添加参数和端口的例化</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923140115533.png" alt="image-20230923140115533"></p>
</li>
<li><p>同样也需要在顶层文件中添加自定义的输入或输出端口和相关参数</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923140423292.png" alt="image-20230923140423292"></p>
</li>
</ul>
</li>
</ul>
<h2 id="3-IP核的封装"><a href="#3-IP核的封装" class="headerlink" title="3.IP核的封装"></a>3.IP核的封装</h2><ul>
<li><p>Identification：</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923140851598.png" alt="image-20230923140851598"></p>
</li>
<li><p>Compatibility：</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923140956297.png" alt="image-20230923140956297"></p>
</li>
<li><p>File Groups：可以预览 IP 核包含的相关源码文件，在源码工程中包含的所有Verilog源码或者仿真测试脚本，也都会出现在这里，被集成到IP核中</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923141550784.png" alt="image-20230923141550784"></p>
</li>
<li><p>Customization Parameters：配置相关参数</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923141502191.png" alt="image-20230923141502191" style="zoom: 67%;"></p>
</li>
</ul>
<h2 id="4-IP核的添加"><a href="#4-IP核的添加" class="headerlink" title="4.IP核的添加"></a>4.IP核的添加</h2><p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923142522060.png" alt="image-20230923142522060"></p>
<hr>
<h1 id="自定义IP核的应用-呼吸灯"><a href="#自定义IP核的应用-呼吸灯" class="headerlink" title="自定义IP核的应用-呼吸灯"></a>自定义IP核的应用-呼吸灯</h1><ul>
<li><p>实验任务：通过自定义一个LED ip核，来控制PL LED呈呼吸灯效果，并且PS可以通过AXI接口来控制呼吸灯的开关和呼吸的频率</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923105200759.png" alt="image-20230923105200759"></p>
</li>
</ul>
<h2 id="1-Vivado中的block-design"><a href="#1-Vivado中的block-design" class="headerlink" title="1.Vivado中的block design"></a>1.Vivado中的block design</h2><ul>
<li><p>直接加载zynq芯片与breath_led的IP核，点击自动配置与自动连线，最终block design的设计图如下：</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923144504423.png" alt="image-20230923144504423"></p>
</li>
<li><p>led的管脚分配</p>
<p><img src="/2023/09/21/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BIP%E6%A0%B8%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230923145121578.png" alt="image-20230923145121578"></p>
</li>
</ul>
<h2 id="2-Vitis中代码编写"><a href="#2-Vitis中代码编写" class="headerlink" title="2.Vitis中代码编写"></a>2.Vitis中代码编写</h2><ul>
<li>LED灯先快闪5s之后，休息1s，开始慢闪</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xparameters.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;breath_led_ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xil_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sleep.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_IP_BASEADDR	XPAR_BREATH_LED_IP_0_S01_AXI_BASEADDR <span class="comment">//呼吸灯IP核的基地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLV_REG0_OFFSET	BREATH_LED_IP_S01_AXI_SLV_REG0_OFFSET <span class="comment">//寄存器地址0的偏移量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLV_REG1_OFFSET BREATH_LED_IP_S01_AXI_SLV_REG1_OFFSET <span class="comment">//寄存器地址1的偏移量</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> freq_flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(freq_flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">BREATH_LED_IP_mWriteReg</span>(LED_IP_BASEADDR, SLV_REG1_OFFSET, <span class="number">0x800000ef</span>);</span><br><span class="line">			freq_flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">BREATH_LED_IP_mWriteReg</span>(LED_IP_BASEADDR, SLV_REG1_OFFSET, <span class="number">0x8000001f</span>);</span><br><span class="line">			freq_flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">BREATH_LED_IP_mWriteReg</span>(LED_IP_BASEADDR, SLV_REG0_OFFSET, <span class="number">0x00000001</span>); <span class="comment">//打开呼吸灯开关</span></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">BREATH_LED_IP_mWriteReg</span>(LED_IP_BASEADDR, SLV_REG0_OFFSET, <span class="number">0x00000000</span>); <span class="comment">//关闭呼吸灯开关</span></span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="由于自定义IP导入Vitis，会出现一个bug"><a href="#由于自定义IP导入Vitis，会出现一个bug" class="headerlink" title="由于自定义IP导入Vitis，会出现一个bug"></a>由于自定义IP导入Vitis，会出现一个bug</h1><ul>
<li><p>解决办法参考：</p>
<ul>
<li>第一步：<a href="https://www.taterli.com/8656/">解决Vitis导入自制IP导致无法构建Platform – TaterLi 个人博客</a></li>
<li>第二步：<a href="https://blog.csdn.net/ly2lj/article/details/129259674">makefile:39: package] Error 1-CSDN博客</a></li>
</ul>
</li>
<li><p>我的makefile文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">COMPILER=</span><br><span class="line">ARCHIVER=</span><br><span class="line">CP=cp</span><br><span class="line">COMPILER_FLAGS=</span><br><span class="line">EXTRA_COMPILER_FLAGS=</span><br><span class="line">LIB=libxil.a</span><br><span class="line"></span><br><span class="line">RELEASEDIR=../../../lib</span><br><span class="line">INCLUDEDIR=../../../<span class="keyword">include</span></span><br><span class="line">INCLUDES=-I./. -I$&#123;INCLUDEDIR&#125;</span><br><span class="line"></span><br><span class="line">INCLUDEFILES=<span class="variable">$(<span class="built_in">wildcard</span> *.h)</span></span><br><span class="line">LIBSOURCES=<span class="variable">$(<span class="built_in">wildcard</span> *.c *.cpp)</span></span><br><span class="line">OUTS = <span class="variable">$(<span class="built_in">addsuffix</span> .o, $(<span class="built_in">basename</span> $(<span class="built_in">wildcard</span> *.c)</span>))</span><br><span class="line"></span><br><span class="line">OBJECTS = <span class="variable">$(<span class="built_in">addsuffix</span> .o, $(<span class="built_in">basename</span> $(<span class="built_in">wildcard</span> *.c *.cpp)</span>))</span><br><span class="line">ASSEMBLY_OBJECTS = <span class="variable">$(<span class="built_in">addsuffix</span> .o, $(<span class="built_in">basename</span> $(<span class="built_in">wildcard</span> *.S)</span>))</span><br><span class="line"></span><br><span class="line"><span class="section">libs:</span></span><br><span class="line">	echo <span class="string">&quot;Compiling breath_led_ip...&quot;</span></span><br><span class="line">	<span class="variable">$(COMPILER)</span> <span class="variable">$(COMPILER_FLAGS)</span> <span class="variable">$(EXTRA_COMPILER_FLAGS)</span> <span class="variable">$(INCLUDES)</span> <span class="variable">$(LIBSOURCES)</span></span><br><span class="line">	<span class="variable">$(ARCHIVER)</span> -r $&#123;RELEASEDIR&#125;/$&#123;LIB&#125; $&#123;OUTS&#125;</span><br><span class="line">	make clean</span><br><span class="line"></span><br><span class="line"><span class="section">include:</span></span><br><span class="line">	$&#123;CP&#125; <span class="variable">$(INCLUDEFILES)</span> <span class="variable">$(INCLUDEDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf $&#123;OUTS&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>雷达原理之雷达信号波形及其处理方法</title>
    <url>/2023/09/14/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BF%A1%E5%8F%B7%E6%B3%A2%E5%BD%A2%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本节主要介绍了雷达信号的数学表示、模糊函数与雷达分辨率的关系、线性调频脉冲信号及其压缩处理、多脉冲积累的处理方法</p>
<span id="more"></span>
<h1 id="雷达信号的数学表示"><a href="#雷达信号的数学表示" class="headerlink" title="雷达信号的数学表示"></a>雷达信号的数学表示</h1><ul>
<li><p>雷达的发射信号一般是除初相外其余参量均已知的确知信号</p>
</li>
<li><p>回波信号则是与噪声、干扰叠加的随机信号</p>
</li>
<li><p>信号可以用时间的实函数$s(t)$表示，称为实信号，其特点具有有限的能量或有限的功率</p>
</li>
<li><p><strong>能量有限的信号称为能量信号</strong>，描述能量信号的频谱特性通常采用<strong>能量谱密度（ESD）函数</strong></p>
<script type="math/tex; mode=display">
|S(w)|^2 = |\int_{-\infty}^{\infty}s(t)e^{-jwt}dt|^2</script><ul>
<li>其中$s(t)$代表信号</li>
</ul>
</li>
<li><p><strong>能量无限但功率有限的信号，称为功率信号</strong>，对于功率信号，<strong>功率谱密度（PSD）函数</strong>定义为：</p>
<script type="math/tex; mode=display">
R_s(w) = \int_{-\infty}^{\infty}r_s(t)e^{-jwt}dt</script><ul>
<li>其中$r_s(t) = \int_{-\infty}^{\infty}s^*(\tau)s(t+\tau)d\tau$为信号$s(t)$的自相关函数</li>
</ul>
</li>
<li><p>按照信号的频率组成，可将信号划分为低通信号（Low Pass）信号和带通（Band Pass）信号。<strong>通常所用的雷达信号，其带宽比载波小很多，称为窄带（通）信号</strong></p>
<ul>
<li><p>一个实带通信号可表示为：</p>
<script type="math/tex; mode=display">
x(t) =a(t)cos(2\pi f_0t +\phi_x(t))</script><ul>
<li>其中：<strong>$a(t)$为信号的幅度调制或包络，$\phi_x(t)$为相位调制项，$f_0$为载频</strong></li>
<li>对于低分辨雷达，在一个波位上发射的多个脉冲的目标回波的包络$a(t)$通常近似认为不变</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>信号$x(t)$的频率调制函数$f_m(t)$和瞬时频率$f_i(t)$分别为</strong>：</p>
<script type="math/tex; mode=display">
f_m(t) = \frac1{2\pi}\frac{d}{dt}\phi_x(t)</script><script type="math/tex; mode=display">
f_i(t) = \frac1{2\pi}\frac d{dt}(2\pi f_0t + \phi_x(t)) = f_0 + f_m(t)</script></li>
<li><p><strong>实信号具有对称的双边频谱</strong></p>
</li>
<li>对于窄带信号来说，由于其带宽远小于载频，两个边带频谱互不重叠，此时<strong>用一个边带频谱就能完全确定信号波形</strong>。为了简化信号和系统的而分析，<strong>通常采用具有单边频谱的复信号</strong></li>
<li>常用的复信号白哦是，即实信号的复信号表示有两种：希尔伯特（Hilbert）变换法和指数表示法，对于窄带信号来说，这两种表示方法是近似相同的</li>
</ul>
<h2 id="1-希尔伯特（Hilbert）变换表示法"><a href="#1-希尔伯特（Hilbert）变换表示法" class="headerlink" title="1. 希尔伯特（Hilbert）变换表示法"></a>1. 希尔伯特（Hilbert）变换表示法</h2><ul>
<li><p>一般地，复信号可表示为：</p>
<script type="math/tex; mode=display">
s(t) = x(t)+ jy(t)</script><ul>
<li>如果要求复信号具有单边频谱，那么就要对虚部有所限制</li>
</ul>
</li>
<li><p>如果实信号$x(t)\Leftrightarrow X(f)$（$X(f)$为信号$x(t)$的傅里叶变换），定义其复解析信号为：</p>
<script type="math/tex; mode=display">
s_a(t)\Leftrightarrow S_a(f) = 2X(f)\cdot U(f)=\begin{cases}
2X(f),\quad f\ge 0\\
0, \quad f<0\\
\end{cases}</script><ul>
<li><p>其中$U(f)$为频域的阶跃函数，利用傅里叶变换的性质可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
s_a(t) &= 2(\frac12\delta(t) - \frac1{j2\pi t})\bigotimes x(t)\\
&=\int_{-\infty}^{\infty}x(\tau)\delta(t-\tau)d\tau-\frac1{j\pi}\int_{-\infty}^{\infty}\frac{x(\tau)}{t-\tau}d\tau\\
&=x(t)+j\hat x(t)
\end{aligned}</script><ul>
<li><strong>其中，$\hat x(t) = \frac 1\pi \int_{-\infty}^{\infty}\frac{x(\tau)}{t-\tau}d\tau$为$x(t)$的Hilbert变换式</strong></li>
<li>这样，复信号的频谱就可以满足使得原始实信号的负频分量相抵消，而正频分量加倍</li>
</ul>
</li>
</ul>
</li>
<li><p>实信号$x(t)$的能量和<strong>复解析信号</strong>$s_a(t)$的能量分别为：</p>
<script type="math/tex; mode=display">
E = \int_{-\infty}^{\infty}x^2(t)dt = \int_{-\infty}^{\infty}|X(f)|^2df\\
E_a = \int_{-\infty}^{\infty}|s_a(t)|^2dt = 2\int_{-\infty}^{\infty}x^2(t)dt = 2E</script></li>
</ul>
<h2 id="2-指数表示法"><a href="#2-指数表示法" class="headerlink" title="2. 指数表示法"></a>2. 指数表示法</h2><ul>
<li><p>复解析信号在推导信号的一般特性时是有效的表示方式，但在分析具体信号时又极不方便，故常采用指数形式的复信号来代替复解析信号</p>
</li>
<li><p><strong>实信号用指数形式的复信号实部表示为</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x(t) &= a(t)cos(2\pi f_0 t+\phi_x(t))\\
&= Re[s_e(t)]\\
&= \frac12[s_e(t)+s_e^*(t)]
\end{aligned}</script><ul>
<li>其中，<strong>$s_e(t) = a(t)e^{j[2\pi f_0 t+\phi_xt]} = u(t)e^{j2\pi f_0 t}$为实信号的复指数形式，而$u(t) = a(t)e^{j\phi_x(t)}$为复信号的复包络</strong></li>
</ul>
</li>
<li><p>窄带实信号、复信号和复包络之间的关系：</p>
<p><img src="/2023/09/14/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BF%A1%E5%8F%B7%E6%B3%A2%E5%BD%A2%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/image-20230916203121991.png" alt="image-20230916203121991"></p>
<p><img src="/2023/09/14/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BF%A1%E5%8F%B7%E6%B3%A2%E5%BD%A2%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/image-20230916203248410.png" alt="image-20230916203248410"></p>
</li>
</ul>
<hr>
<h1 id="模糊函数与雷达分辨率"><a href="#模糊函数与雷达分辨率" class="headerlink" title="模糊函数与雷达分辨率"></a>模糊函数与雷达分辨率</h1><h2 id="1-模糊函数"><a href="#1-模糊函数" class="headerlink" title="1. 模糊函数"></a>1. 模糊函数</h2><ul>
<li><p>模糊函数最初是为了<strong>研究雷达分辨率</strong>而提出的，两个目标距离和速度上的差异是刚好可以用来相关函数模拟的，越相似相关函数越大，说明两个目标越难以区分</p>
</li>
<li><p>利用一对二维变量$(\tau, f_d)$来描述模糊函数，假设目标1和目标2的时延分别为$d$和$d+\tau$，多普勒频移分别为$f$和$f+f_d$，且功率相同</p>
<p><img src="/2023/09/14/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BF%A1%E5%8F%B7%E6%B3%A2%E5%BD%A2%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/image-20230916235359143.png" alt="image-20230916235359143" style="zoom: 80%;"></p>
<ul>
<li><p>雷达的<strong>发射信号</strong>通常为窄带信号，用复信号可表示为：</p>
<script type="math/tex; mode=display">
s_t(t) = u(t)e^{j2\pi f_0 t}</script></li>
<li><p><strong>目标1的回波信号可</strong>表示为：</p>
<script type="math/tex; mode=display">
s_{r1}(t) = u(t-d)e^{j2\pi (f_0+f) (t-d)}</script></li>
<li><p><strong>则目标2的回波信号</strong>可表示为：</p>
<script type="math/tex; mode=display">
s_{r2}(t) = s_{r1}(t-(d+\tau)) = u(t-(d+\tau))e^{j2\pi(f_0+(f+f_d))(t-(d+\tau))}</script></li>
</ul>
</li>
<li><p>在分析分辨力时，通常利用积分方差来描述，具体来说就是当<strong>积分方差越大时，两个目标就越好区分</strong></p>
<script type="math/tex; mode=display">
\varepsilon^2 = \int_{-\infty}^{\infty}|s_{r1}(t) -s_{r2}(t) |^2dt</script><ul>
<li>设$y_1 = X_R + jX_I, y_2 = X_R’+jX_I’$</li>
<li>$|y_1-y_2|^2 = X_R^2+X_R’^2-2X_RX_R’+X_I^2+X_I’^2-2X_IX_I’^2$<ul>
<li>其中：$X_R^2+X_I^2 = |y_1|^2, X_R’^2+X_I’^2=|y_2|^2$</li>
<li>$y_1y_2* = X_RX_R’-jX_RX_I’+jX_IX_R’+X_IX_I’$</li>
</ul>
</li>
<li>故：$|y_1-y_2|^2 = |y_1|^2+|y_2|^2-2Re|y_1y_2^*|$</li>
</ul>
</li>
<li><p>故<strong>积分方差</strong>为：</p>
<script type="math/tex; mode=display">
\varepsilon^2 = 2\{2E-2Re[e^{-j2\pi(f_0+f)\tau}\int_{-\infty}^{\infty}u(t)u^*(t+\tau)e^{j2\pi f_d t}dt]\}</script></li>
<li><p>定义$\chi(\tau,f_d)$为：</p>
<script type="math/tex; mode=display">
\chi(\tau,f_d)= \int_{-\infty}^{\infty}u(t)u^*(t+\tau)e^{j2\pi f_d t}dt</script></li>
<li><p>则<strong>模糊函数</strong>为：</p>
<script type="math/tex; mode=display">
|\chi(\tau,f_d)|=|\int_{-\infty}^{\infty}u(t)u^*(t+\tau)e^{j2\pi f_d t}dt|</script><ul>
<li><strong>$|\chi(\tau,f_d)|$式决定相邻目标距离-速度联合分辨率的唯一因素</strong></li>
<li>有的文献也把$|\chi(\tau,f_d)|^2$当作模糊函数</li>
</ul>
</li>
<li><p>由上述分析可得：</p>
<script type="math/tex; mode=display">
\varepsilon^2 = 2\{2E-2Re[e^{j2\pi(f_0+f)\tau}\int_{-\infty}^{\infty}u(t)u^*(t+\tau)e^{j2\pi f_d t}dt]\}\ge2[2E-|\chi(\tau,f_d)|]\ge 0</script><ul>
<li><p><strong>故$|\chi(\tau, f_d)|$的最大值为$2E$，此时两个目标重叠在一起，距离和速度一样</strong></p>
</li>
<li><p>那么就意味着$\tau = 0，f_d =0$，即：</p>
<script type="math/tex; mode=display">
|\chi(\tau, f_d)|\le|\chi(0,0)| = 2E</script></li>
<li><p><strong>能够引起$\varepsilon^2 $被滤波器检出，那么这两个目标也就可以分开了。如果保持不$f_d$变，最小的$\tau$值引起的$\varepsilon^2 $能被滤波器检出，此时$\tau$对应的就是距离分辨率。同理多普勒分辨率</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-分辨率"><a href="#2-分辨率" class="headerlink" title="2. 分辨率"></a>2. 分辨率</h2><h3 id="2-1-距离分辨率"><a href="#2-1-距离分辨率" class="headerlink" title="2.1 距离分辨率"></a>2.1 距离分辨率</h3><ul>
<li><p>假设两个目标在同一角度但处在不同距离上，在不考虑相邻目标的多普勒频移（$f_d = 0$）时，有：</p>
<script type="math/tex; mode=display">
\varepsilon^2\ge 2(2E-|\chi(\tau, 0)|)</script></li>
<li><p>此时，信号的<strong>距离模糊函数</strong>为：</p>
<script type="math/tex; mode=display">
|\chi(\tau,0)|=|\int_{-\infty}^{\infty}u(t)u^*(t+\tau)dt|</script></li>
<li><p>当$\tau = 0$时，$|\chi(\tau,0)|$有最大值，距离分辨率由$|\chi(\tau,0)|^2$的大小来衡量</p>
</li>
<li><p><strong>当$\tau\neq 0$时，$|\chi(\tau,0)|$随$\tau$增大而下降的越快，距离分辨性能越好</strong></p>
</li>
<li><p><strong>时延分辨率为</strong>：</p>
<script type="math/tex; mode=display">
\Delta\tau = \frac{\int_{-\infty}^{\infty}|\chi(\tau,0)|^2d\tau}{|\chi(0,0)|^2}</script><ul>
<li><p>根据Parseval定理，上式可重写为：</p>
<script type="math/tex; mode=display">
\Delta\tau = 2\pi\frac{\int_{-\infty}^{\infty}|U(w)|^4dw}{[\int_{-\infty}^{\infty}|U(w)|^2dw]^2}=\frac1B</script></li>
<li><p>$B$为信号的有效带宽</p>
</li>
</ul>
</li>
<li><p>因此，时延分辨率对应的<strong>距离分辨率</strong>为：</p>
<script type="math/tex; mode=display">
\Delta R = \frac{c\Delta\tau}{2}=\frac{c}{2B}</script></li>
<li><p>只要信号具有大的持续带宽就能获得高的距离分辨率，而不必具有很窄的脉冲宽度</p>
</li>
</ul>
<h3 id="2-2-速度分辨率"><a href="#2-2-速度分辨率" class="headerlink" title="2.2 速度分辨率"></a>2.2 速度分辨率</h3><ul>
<li><p>与距离分辨率类似，信号的速度分辨率取决于<strong>速度模糊函数</strong>：</p>
<script type="math/tex; mode=display">
|\chi(0,f_d)|=\int_{-\infty}^{\infty}|u(t)|^2e^{j2\pi f_d t}dt</script></li>
<li><p>则<strong>多普勒分辨率</strong>$\Delta f_d$为：</p>
<script type="math/tex; mode=display">
\Delta f_d = \frac{\int_{-\infty}^{\infty}|\chi(0,f_d)|^2d\tau}{|\chi(0,0)|^2}=\frac{\int_{-\infty}^{\infty}|u(t)|^4dt}{[\int_{-\infty}^{\infty}|u(t)|^2dt]^2}=\frac1{\tau'}</script><ul>
<li>式中：$\tau’$是脉冲宽度</li>
</ul>
</li>
<li><p>则相应的速度分辨率$\Delta v$为：</p>
<script type="math/tex; mode=display">
\Delta v = \frac{c\Delta f_d}{2f_0} = \frac{c}{2f_0\tau'}=\frac{\lambda}{2\tau'}</script></li>
</ul>
<h3 id="2-3-距离-速度联合分辨率"><a href="#2-3-距离-速度联合分辨率" class="headerlink" title="2.3 距离-速度联合分辨率"></a>2.3 距离-速度联合分辨率</h3><ul>
<li><p>定义<strong>模糊面积</strong>$AA$作为距离-速度联合分辨常数：</p>
<script type="math/tex; mode=display">
AA=\frac{\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}|\chi(\tau,f_d)|^2d\tau df_d}{|\chi(0,0)|^2}</script><ul>
<li><strong>只要信号能量一定，模糊面积即为定值1</strong></li>
<li>这就说明了时延和多普勒联合分辨率的限制，无论怎么使时延$\tau$或多普勒$f_d$分辨率的某一方减小，其结果都将带来另一方的增大，这就是<strong>雷达模糊原理</strong></li>
<li>设计雷达信号时，只能在模糊原理的约束下通过改变模糊曲面的形状，使之与特定的目标环境相匹配</li>
</ul>
</li>
</ul>
<hr>
<h1 id="线性调频（LFM-or-Chirp）脉冲信号"><a href="#线性调频（LFM-or-Chirp）脉冲信号" class="headerlink" title="线性调频（LFM or Chirp）脉冲信号"></a>线性调频（LFM or Chirp）脉冲信号</h1><ul>
<li>线性调频信号是一种脉冲压缩信号，它是在匹配滤波理论的基础上提出的</li>
<li><p>这种信号的突出<strong>优点</strong>是匹配滤波器对回波信号的多普勒频率不敏感，<strong>即使回波信号有较大的多普勒频移，匹配滤波器仍能起到脉冲压缩的作用</strong></p>
</li>
<li><p><strong>线性调频矩形脉冲信号的表达式</strong>写为：</p>
<script type="math/tex; mode=display">
s(t) = u(t)e^{j2\pi f_0 t} = \frac1{\sqrt{T}}rect(\frac t{\sqrt{T}}) e^{j(2\pi f_0 t+\pi \mu t^2)}</script><ul>
<li><p>其中，信号的复包络为：</p>
<script type="math/tex; mode=display">
u(t) =\frac1{\sqrt{T}}rect(\frac t{\sqrt{T}})e^{j\pi \mu t^2}</script><script type="math/tex; mode=display">
rect(\frac t{\sqrt{T}}) = \begin{cases}
1,\quad |t|\le \frac T2\\
0,\quad |t|> \frac T2\\
\end{cases}\\</script><ul>
<li>$T$为脉冲宽度，$\mu=\frac BT$为调频斜率，$B$为调频带宽，也称频偏</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>信号的瞬时频率</strong>为：</p>
<script type="math/tex; mode=display">
f_i(t)=\frac1{2\pi}\frac d{dt}[2\pi f_0 t+\pi \mu t^2]=f_0+\mu t</script><p><img src="/2023/09/14/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BF%A1%E5%8F%B7%E6%B3%A2%E5%BD%A2%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/image-20230917133322131.png" alt="image-20230917133322131" style="zoom:80%;"></p>
</li>
<li><p>线性调频信号的频谱由信号的复包络完全决定</p>
</li>
<li><p><strong>当$BT\gg1$时，信号95%以上的能量集中在$-\frac B2\sim \frac B2$的范围，频谱接近于矩形</strong></p>
<p><img src="/2023/09/14/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BF%A1%E5%8F%B7%E6%B3%A2%E5%BD%A2%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/image-20230917133954885.png" alt="image-20230917133954885" style="zoom: 80%;"></p>
</li>
</ul>
<hr>
<h1 id="线性调频脉冲信号的压缩处理"><a href="#线性调频脉冲信号的压缩处理" class="headerlink" title="线性调频脉冲信号的压缩处理"></a>线性调频脉冲信号的压缩处理</h1><ul>
<li><p>雷达系统为了满足提高探测距离和距离分辨率的双重要求，就要求采用<strong>大时宽 带宽 积 信号</strong>。脉冲压缩处理将<strong>发射的宽脉冲信号压缩成窄脉冲信号，它既可以发射宽脉冲以提高平均功率和雷达的检测能力，又能保持窄脉冲的距离分辨率</strong></p>
</li>
<li><p>假设雷达发射线性调频脉冲信号，可表示为：</p>
<script type="math/tex; mode=display">
s_1(t)= rect(\frac{t}{T_e})cos(2\pi f_0 t + \pi \mu t^2)</script><ul>
<li><p>式中，$rect(\frac{t}{T_e})=1,|t|\le \frac12 T_e$，$T_e$为发射脉冲宽度，$f_0$为中心载频，$\mu = \frac B{T_e}$为调频斜率，$B$为调频带宽</p>
</li>
<li><p><strong>该信号的复包络及其离散信号（采样间隔为$T_s$)为：</strong></p>
<script type="math/tex; mode=display">
s(t)\approx rect(\frac{t}{T_e})e^{j\pi\mu t^2}</script><script type="math/tex; mode=display">
s(n)\approx rect(\frac{nT_s}{T_e})e^{j\pi\mu(nT_s)^2}</script></li>
</ul>
</li>
<li><p>假设目标初始距离$R_0$对应的时延为$t_0$，即$t_0 = \frac{2R_0}{c}$，目标的径向速度为$v$，若不考虑幅度的衰减，则接收信号及其相对于发射信号的时延分别为：</p>
<script type="math/tex; mode=display">
s_{r1}(t) = s_1(t-\Delta(t))</script><script type="math/tex; mode=display">
\Delta(t) = t_0 = \frac{2v}{c}(t-t_0)</script><p>则有：</p>
<script type="math/tex; mode=display">
s_{r1}(t) = s_1(t-t_0+\frac{2v}c(t-t_0))=s_1(\gamma(t-t_0))</script><p>其中：</p>
<script type="math/tex; mode=display">
\gamma = 1+\frac{2v}c</script></li>
</ul>
<p>这一部分暂时还没完全整明白，等整明白了再来记录</p>
<ul>
<li>匹配滤波器的压缩比？？</li>
<li>为什么脉冲压缩对多普勒频率不敏感？</li>
<li><p>在频域和时域上的匹配滤波到底有个啥区别？</p>
</li>
<li><p><a href="https://www.cnblogs.com/kinologic/p/14105907.html">【雷达原理】脉冲压缩-匹配滤波的自己理解与参考资料 - KinoLogic - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
<h1 id="多脉冲积累的处理方法"><a href="#多脉冲积累的处理方法" class="headerlink" title="多脉冲积累的处理方法"></a>多脉冲积累的处理方法</h1><h2 id="1-多脉冲积累的概念"><a href="#1-多脉冲积累的概念" class="headerlink" title="1.多脉冲积累的概念"></a>1.多脉冲积累的概念</h2><ul>
<li><p>因为雷达单个脉冲的回波能量是有限的，通常不采用单个接收脉冲来进行检测判决</p>
</li>
<li><p>在判决之前，先对一个波位的多个脉冲串进行处理，以提高信噪比</p>
</li>
<li><p>这种基于多个脉冲串而非单个脉冲的处理方法称为积累</p>
</li>
<li><p><strong>从时域上来说，积累是将一个波位内连续的M个重复周期同一距离单元的回波信号叠加起来（或加权叠加）</strong></p>
<p><img src="/2023/09/14/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BF%A1%E5%8F%B7%E6%B3%A2%E5%BD%A2%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/image-20230918140907536.png" alt="image-20230918140907536"></p>
<ul>
<li>上述数据矩阵的<strong>横坐标为距离单元，由快时间采样</strong>得到；<strong>纵坐标</strong>为<strong>每个脉冲重复周期</strong>，在雷达中经常称其为<strong>慢时间</strong>采样</li>
</ul>
</li>
<li><p>积累分相干积累和非相干积累：</p>
<ul>
<li><strong>相干积累</strong>是在包络检波器之前进行，<strong>利用接收脉冲之间的相位关系，可以获得信号幅度的叠加</strong>。这种积累起可以把所有的雷达回波能量直接相加</li>
<li>非相干积累是在包络检波以后进行，也称之为检波后积累或视频积累。由于信号在包络检波后失去了相位信息而只保留下幅度信息，所以检波后积累就不需要信号间有严格的相位关系，因此称为非相干积累</li>
</ul>
</li>
</ul>
<h2 id="2-相干积累的处理方法"><a href="#2-相干积累的处理方法" class="headerlink" title="2.相干积累的处理方法"></a>2.相干积累的处理方法</h2><ul>
<li><p>由于运动目标的回波包括多普勒频率$f_d$，当脉冲雷达的每个脉冲重复周期$T_r$相等，如果忽略目标回波的幅度起伏，则对目标所在距离单元的信号在每个$T_r$采样时，就可以看作是<strong>对频率为$f_d$的正弦波的采样</strong>，这时，第$i$个脉冲重复周期对目标的采样值可以表示为：</p>
<script type="math/tex; mode=display">
x(i) = a \cdot exp(j2\pi f_d i T_r),i=0,1,...,M-1</script><ul>
<li>式中$M$表示在一个波位（半功率波束宽度）内发射的脉冲数</li>
<li><strong>若$M$不是2的幂，则通过补零到2的幂（即$N = 2^n \ge M$）</strong>，因为相干累加通常采用$FFT$的处理方法实现</li>
<li><strong>上图中包括$L$个距离单元，则需要进行$L$次$2^n$点的$FFT$处理</strong></li>
</ul>
</li>
<li><p>于是目标所在距离单元、所在多普勒通道的输出为：</p>
<script type="math/tex; mode=display">
x(k) = a\frac{sin[\pi(f_dT_rN-k)]}{sin[\frac{\pi}{N}(f_dT_rN-k)]}e^{j\frac{N-1}{2}\frac{2\pi}{N}(f_d T_rN-k)}</script><ul>
<li><strong>上式只有当$f_d=\frac{k}{T_rN}=\frac{k}{N}f_r$时才出现峰值</strong></li>
</ul>
</li>
<li><p><strong>相干积累的特点</strong>：</p>
<ul>
<li>$M$个脉冲进行相干积累的信噪比改善可以达到单个脉冲的$M$倍</li>
<li>也就是说，若要达到同样的检测性能，对单个脉冲的检测因子可以减低为$\frac1M$</li>
<li>因此，相干脉冲有利于降低发射功率或提高检测性能</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之GPIO（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节主要介绍了ZYNQ7020中的GPIO，并以按键电灯实例演示了GPIO之EMIO、中断、AXI的用法</p>
<span id="more"></span>
<h1 id="ZYNQ与PYNQ的区别"><a href="#ZYNQ与PYNQ的区别" class="headerlink" title="ZYNQ与PYNQ的区别"></a>ZYNQ与PYNQ的区别</h1><ul>
<li>PYNQ是Xilinx的一个开源项目名称，ZYNQ是Xilinx的一个芯片系列。PYNQ-Z2平台用的芯片就是Xilinx的ZYNQ芯片。所以PYNQ的意思就是PYTHON Pruduct on ZYNQ</li>
<li>PYNQ全称为Python Productivity for Zynq，即在Zynq全可编程ARM&amp;FPGA融合处理架构的基础上，添加了对Python的支持</li>
</ul>
<hr>
<h1 id="ZYNQ的基本组成"><a href="#ZYNQ的基本组成" class="headerlink" title="ZYNQ的基本组成"></a>ZYNQ的基本组成</h1><ul>
<li>Zynq-7000 SoC的主要组成部分：<ul>
<li>Processing System（PS）：<ul>
<li>Application processor unit（APU）</li>
<li>Memory interfaces</li>
<li>I/O peripherals（IOP）</li>
<li>Interconnect（通信互连）</li>
</ul>
</li>
<li>Programmable Logic（PL）</li>
</ul>
</li>
</ul>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230912143428606.png" alt="image-20230912143428606" style="zoom: 80%;"></p>
<hr>
<h1 id="GPIO的简介"><a href="#GPIO的简介" class="headerlink" title="GPIO的简介"></a>GPIO的简介</h1><ul>
<li>GPIO是一个外设，用来对器件的引脚作<strong>观测</strong>（input）以及<strong>控制</strong>（output）</li>
<li><p><strong>MIO（Multisue I/O）</strong>，将来自PS外设和静态存储器接口的访问<strong>多路复用</strong>到PS的引脚上，与外部器件访问</p>
</li>
<li><p><strong>EMIO是PS和PL之间的一个接口</strong>，EMIO是扩展的MIO，当PS的引脚不够用时，可以通过EMIO来进行扩展，从而使用PL的引脚</p>
</li>
<li><p>GPIO可以独立且动态地编程，作为输入/输出以及中断模式</p>
</li>
<li><p>GPIO被分成了4个Bank，总共有118个pins</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230912152039276.png" alt="image-20230912152039276" style="zoom: 50%;"></p>
<ul>
<li>Bank0的32位控制MIO引脚的[31:0]</li>
<li>Bank1的22位控制MIO引脚的[53:32] （Bank1被限制为22位，是因为MIO总共只有54个pins）</li>
<li>Bank2的32位控制EMIO信号的[31:0]</li>
<li>Bank3的32位控制EMIO信号的[63:32]</li>
</ul>
</li>
<li><p>软件通过一组<strong>存储映射</strong>的寄存器来控制GPIO，GPIO控制外设的<strong>本质都是读取寄存器</strong></p>
</li>
<li><p><strong>寄存器组（控制Bank0与Bank1）</strong>：</p>
<ul>
<li>DATA_RO：用来反映器件引脚的状态</li>
<li>DATA（32bit）：在GPIO被配置成输出的时候，该寄存器可以控制输出的数值。如果用其来读取，只能读取到上一次的输入数据</li>
<li>MASK_DATA_LSW：屏蔽DATA中低16位的某些位</li>
<li>MASK_DATA_MSW：屏蔽DATA中高16位的某些位</li>
<li>DIRM：Direction Mode，用于控制I/O引脚是作为输入还是输出。0：关闭输出驱动；1：使能输出驱动</li>
<li>OEN：Output Enable，当I/O被配置成输出时，该寄存器用于打开/关闭输出使能</li>
</ul>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230912160107464.png" alt="image-20230912160107464" style="zoom: 50%;"></p>
</li>
<li><p>MIO[8:7]在系统复位过程中作为VMODE引脚（作为输入），用于配置MIO Bank的电压。复位结束后，MIO[8:7]只能作为输出引脚</p>
</li>
</ul>
<hr>
<h1 id="GPIO之EMIO按键控制LED实验"><a href="#GPIO之EMIO按键控制LED实验" class="headerlink" title="GPIO之EMIO按键控制LED实验"></a>GPIO之EMIO按键控制LED实验</h1><h2 id="1-Vivado配置"><a href="#1-Vivado配置" class="headerlink" title="1.Vivado配置"></a>1.Vivado配置</h2><ul>
<li><p>在hello world的实验基础上，添加EMIO的设置</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230919172215091.png" alt="image-20230919172215091" style="zoom: 67%;"></p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230919172405627.png" alt="image-20230919172405627"></p>
</li>
<li><p>给GPIO_0口添加引脚：单击GPIO_0，按快捷键<strong>ctrl+t</strong>即可实现</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230919172628794.png" alt="image-20230919172628794" style="zoom:50%;"></p>
</li>
<li><p>生成顶层文件</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230920145113467.png" alt="image-20230920145113467" style="zoom:50%;"></p>
</li>
<li><p><strong>在IO引脚配置页面将EMIO链接到KEY和LED的端口</strong></p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230919173043947.png" alt="image-20230919173043947"></p>
</li>
<li><p><strong>最后生成bit stream文件</strong></p>
</li>
<li><p><strong>在导出硬件时记得选上</strong>：</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230919173216883.png" alt="image-20230919173216883"></p>
</li>
</ul>
<h2 id="2-Vitis代码编写"><a href="#2-Vitis代码编写" class="headerlink" title="2.Vitis代码编写"></a>2.Vitis代码编写</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xparameters.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;xgpiops.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_DEVICE_ID	XPAR_XGPIOPS_0_DEVICE_ID</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMIO54_KEY0	54 <span class="comment">//PL端的第54个pin分配给KEY0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMIO55_LED0	55 <span class="comment">//PL端的第55个pin分配给LED0</span></span></span><br><span class="line"></span><br><span class="line">XGpioPs_Config * ConfigPtr;</span><br><span class="line">XGpioPs Gpio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;GPIO EMIO TEST !&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//配置器件的ID，查找器件的配置信息</span></span><br><span class="line">	ConfigPtr = <span class="built_in">XGpioPs_LookupConfig</span>(GPIO_DEVICE_ID);</span><br><span class="line">	<span class="comment">//初始化GPIO驱动</span></span><br><span class="line">	<span class="built_in">XGpioPs_CfgInitialize</span>(&amp;Gpio, ConfigPtr, ConfigPtr-&gt;BaseAddr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置GPIO的方向（0：输入/1：输出）</span></span><br><span class="line">	<span class="built_in">XGpioPs_SetDirectionPin</span>(&amp;Gpio,EMIO54_KEY0, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">XGpioPs_SetDirectionPin</span>(&amp;Gpio,EMIO55_LED0, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置输出使能（1：关闭/1：打开）</span></span><br><span class="line">	<span class="built_in">XGpioPs_SetOutputEnablePin</span>(&amp;Gpio, EMIO55_LED0, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> key_num;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//通过KEY点亮LED</span></span><br><span class="line">		key_num = <span class="built_in">XGpioPs_ReadPin</span>(&amp;Gpio, EMIO54_KEY0);</span><br><span class="line">		<span class="built_in">XGpioPs_WritePin</span>(&amp;Gpio, EMIO55_LED0, key_num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3.实验结果"></a>3.实验结果</h2><p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/QQ%E5%9B%BE%E7%89%8720230919231606.jpg" alt="QQ图片20230919231606" style="zoom: 80%;"></p>
<hr>
<h1 id="GPIO之EMIO中断按键控制LED实验"><a href="#GPIO之EMIO中断按键控制LED实验" class="headerlink" title="GPIO之EMIO中断按键控制LED实验"></a>GPIO之EMIO中断按键控制LED实验</h1><ul>
<li><p>实验要求：按键按下LED亮，再按下LED熄灭</p>
</li>
<li><p>Vivado中的配置与EMIO按键控制LED实验一致</p>
</li>
<li><p>Vitis中代码的编写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xgpiops.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xscugic.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************参数声明**********************/</span></span><br><span class="line"><span class="comment">/*中断相关参数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_INTERRUPT_ID	XPAR_XGPIOPS_0_INTR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTC_DEVICE_ID		XPAR_SCUGIC_SINGLE_DEVICE_ID</span></span><br><span class="line">XScuGic Intc;</span><br><span class="line"><span class="comment">/*普通GPIO相关参数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_DEVICE_ID	XPAR_XGPIOPS_0_DEVICE_ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMIO54_KEY0	54 <span class="comment">//PL端的第54个pin分配给KEY0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMIO55_LED0	55 <span class="comment">//PL端的第55个pin分配给LED0</span></span></span><br><span class="line">XGpioPs_Config * ConfigPtr;</span><br><span class="line">XGpioPs Gpio;</span><br><span class="line"><span class="comment">/*其他过程变量*/</span></span><br><span class="line">u32 key_press = <span class="number">0</span>;</span><br><span class="line">u32 led_value = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/***********************函数声明**********************/</span></span><br><span class="line"><span class="comment">/*中断相关函数*/</span></span><br><span class="line"><span class="comment">//配置中断函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetupInterruptSystem</span><span class="params">(XScuGic *GicInstancePtr, XGpioPs *Gpio,u16 GpioIntrId)</span></span>;</span><br><span class="line"><span class="comment">//中断服务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntrHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************主程序**********************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//配置器件的ID，查找器件的配置信息</span></span><br><span class="line">	ConfigPtr = <span class="built_in">XGpioPs_LookupConfig</span>(GPIO_DEVICE_ID);</span><br><span class="line">	<span class="comment">//初始化GPIO驱动</span></span><br><span class="line">	<span class="built_in">XGpioPs_CfgInitialize</span>(&amp;Gpio, ConfigPtr, ConfigPtr-&gt;BaseAddr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置GPIO的方向（0：输入/1：输出）</span></span><br><span class="line">	<span class="built_in">XGpioPs_SetDirectionPin</span>(&amp;Gpio,EMIO54_KEY0, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">XGpioPs_SetDirectionPin</span>(&amp;Gpio,EMIO55_LED0, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置输出使能（1：关闭/1：打开）</span></span><br><span class="line">	<span class="built_in">XGpioPs_SetOutputEnablePin</span>(&amp;Gpio, EMIO55_LED0, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置中断系统</span></span><br><span class="line">	<span class="built_in">SetupInterruptSystem</span>(&amp;Intc, &amp;Gpio,GPIO_INTERRUPT_ID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(key_press)</span><br><span class="line">		&#123;</span><br><span class="line">			led_value = ~led_value;</span><br><span class="line">			</span><br><span class="line">			key_press = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//清除之前的中断状态</span></span><br><span class="line">			<span class="built_in">XGpioPs_IntrClearPin</span>(&amp;Gpio, EMIO54_KEY0);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//将led_vaule的值写入LED</span></span><br><span class="line">			<span class="built_in">XGpioPs_WritePin</span>(&amp;Gpio, EMIO55_LED0, led_value);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//延时消抖200ms</span></span><br><span class="line">			 <span class="built_in">usleep</span>(<span class="number">200000</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//重新打开中断</span></span><br><span class="line">			<span class="built_in">XGpioPs_IntrEnablePin</span>(&amp;Gpio, EMIO54_KEY0);</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置中断</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetupInterruptSystem</span><span class="params">(XScuGic *GicInstancePtr, XGpioPs *Gpio,u16 GpioIntrId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	XScuGic_Config *IntcConfig; <span class="comment">/* Instance of the interrupt controller */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找GIC器件配置信息，并进行初始化</span></span><br><span class="line">	IntcConfig = <span class="built_in">XScuGic_LookupConfig</span>(INTC_DEVICE_ID);</span><br><span class="line">	<span class="built_in">XScuGic_CfgInitialize</span>(GicInstancePtr, IntcConfig,</span><br><span class="line">					IntcConfig-&gt;CpuBaseAddress);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化ARM处理器异常句柄</span></span><br><span class="line">	<span class="built_in">Xil_ExceptionInit</span>();</span><br><span class="line">	<span class="comment">//来给IRQ异常注册处理程序</span></span><br><span class="line">	<span class="built_in">Xil_ExceptionRegisterHandler</span>(XIL_EXCEPTION_ID_INT,</span><br><span class="line">				(Xil_ExceptionHandler)XScuGic_InterruptHandler,</span><br><span class="line">				GicInstancePtr);</span><br><span class="line">	<span class="comment">//使能处理器中断</span></span><br><span class="line">	<span class="built_in">Xil_ExceptionEnableMask</span>(XIL_EXCEPTION_IRQ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//关联中断处理函数</span></span><br><span class="line">	<span class="built_in">XScuGic_Connect</span>(GicInstancePtr, GpioIntrId,</span><br><span class="line">				(Xil_ExceptionHandler)IntrHandler,</span><br><span class="line">				(<span class="type">void</span> *)Gpio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置引脚中断触发类型，下降沿触发</span></span><br><span class="line">	<span class="built_in">XGpioPs_SetIntrTypePin</span>(Gpio, EMIO54_KEY0, XGPIOPS_IRQ_TYPE_EDGE_FALLING);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为GPIO器件使能中断</span></span><br><span class="line">	<span class="built_in">XScuGic_Enable</span>(GicInstancePtr, GpioIntrId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开中断使能信号</span></span><br><span class="line">	<span class="built_in">XGpioPs_IntrEnablePin</span>(Gpio, EMIO54_KEY0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断服务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntrHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Interrupt detected !\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">	key_press = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//关闭中断使能信号</span></span><br><span class="line">	<span class="built_in">XGpioPs_IntrDisablePin</span>(&amp;Gpio, EMIO54_KEY0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实验结果：虽然实现了按键控制LED的来回跳变，<strong>但总是在手松开时才开始跳变，原因依旧存疑</strong></p>
</li>
</ul>
<hr>
<h1 id="AXI-GPIO控制LED实验"><a href="#AXI-GPIO控制LED实验" class="headerlink" title="AXI_GPIO控制LED实验"></a>AXI_GPIO控制LED实验</h1><ul>
<li>实验要求：按键按下LED亮，再按下LED熄灭</li>
</ul>
<h2 id="1-AXI的简介"><a href="#1-AXI的简介" class="headerlink" title="1.AXI的简介"></a>1.AXI的简介</h2><ul>
<li>AXI（高级可扩展接口）是一种高性能、低功耗的总线协议，用于在不同的硬件模块之间进行通信</li>
<li>PS和PL之间的连接通常使用AXI接口，以实现数据传输和控制信号的交换。这种连接方式可以实现高速数据传输和灵活的系统集成，使得PS和PL之间可以进行有效的通信和协作</li>
</ul>
<h2 id="2-Vivado配置"><a href="#2-Vivado配置" class="headerlink" title="2.Vivado配置"></a>2.Vivado配置</h2><ul>
<li><p>选择axi gpio</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921133747826.png" alt="image-20230921133747826"></p>
</li>
<li><p>用几个引脚GPIO width就选几个</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921133842345.png" alt="image-20230921133842345"></p>
</li>
<li><p>zynq和EMIO实验那样配置好之后，再添加下面配置</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921134458158.png" alt="image-20230921134458158"></p>
</li>
<li><p>选择自动连线时，gpio一定要选择custom</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921134209456.png" alt="image-20230921134209456"></p>
</li>
<li><p>最终block设计如下：</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921135309192.png" alt="image-20230921135309192"></p>
</li>
<li><p>引脚的配置如下：</p>
<p><img src="/2023/09/12/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8BGPIO%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921134640038.png" alt="image-20230921134640038"></p>
</li>
</ul>
<h2 id="3-Vitis代码编写"><a href="#3-Vitis代码编写" class="headerlink" title="3.Vitis代码编写"></a>3.Vitis代码编写</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xspips.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xil_printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleep.h&quot;</span></span></span><br><span class="line">XSpiPs Spi0;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SpiPs_RecvByte(BaseAddress) \</span></span><br><span class="line"><span class="meta">		(u8)XSpiPs_In32((BaseAddress) + XSPIPS_RXD_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SpiPs_SendByte(BaseAddress, Data) \</span></span><br><span class="line"><span class="meta">		XSpiPs_Out32((BaseAddress) + XSPIPS_TXD_OFFSET, (Data))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spi0_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpiRead</span><span class="params">(u8 *ReadBuffer, <span class="type">int</span> ByteCount)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpiWrite</span><span class="params">(u8 *Sendbuffer, <span class="type">int</span> ByteCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ReadBuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> WriteBuffer[<span class="number">1024</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> Status;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">xil_printf</span>(<span class="string">&quot;SPI Selftest Example \r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Status = <span class="built_in">spi0_init</span>();</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		<span class="built_in">xil_printf</span>(<span class="string">&quot;SPI Selftest Example Failed\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SpiWrite</span>(WriteBuffer,<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">SpiRead</span>(ReadBuffer,<span class="number">10</span>);</span><br><span class="line">		<span class="comment">//xil_printf(&quot;read back \n&quot;);</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">xil_printf</span>(<span class="string">&quot;%d,&quot;</span>,ReadBuffer[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">xil_printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">memset</span>(ReadBuffer, <span class="number">0x00</span>, <span class="number">1024</span>);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">xil_printf</span>(<span class="string">&quot;Successfully ran SPI Selftest Example\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpiRead</span><span class="params">(u8 *ReadBuffer, <span class="type">int</span> ByteCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> Count;</span><br><span class="line">	u32 StatusReg;</span><br><span class="line"></span><br><span class="line">	StatusReg = <span class="built_in">XSpiPs_ReadReg</span>(Spi0.Config.BaseAddress,</span><br><span class="line">					XSPIPS_SR_OFFSET);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Polling the Rx Buffer for Data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		StatusReg = <span class="built_in">XSpiPs_ReadReg</span>(Spi0.Config.BaseAddress,</span><br><span class="line">					XSPIPS_SR_OFFSET);</span><br><span class="line">	&#125;<span class="keyword">while</span>(!(StatusReg &amp; XSPIPS_IXR_RXNEMPTY_MASK));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reading the Rx Buffer</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span>(Count = <span class="number">0</span>; Count &lt; ByteCount; Count++)&#123;</span><br><span class="line">		ReadBuffer[Count] = <span class="built_in">SpiPs_RecvByte</span>(</span><br><span class="line">				Spi0.Config.BaseAddress);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpiWrite</span><span class="params">(u8 *Sendbuffer, <span class="type">int</span> ByteCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 StatusReg;</span><br><span class="line">	<span class="type">int</span> TransCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	StatusReg = <span class="built_in">XSpiPs_ReadReg</span>(Spi0.Config.BaseAddress,</span><br><span class="line">				XSPIPS_SR_OFFSET);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((ByteCount &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		(TransCount &lt; XSPIPS_FIFO_DEPTH)) &#123;</span><br><span class="line">		<span class="built_in">SpiPs_SendByte</span>(Spi0.Config.BaseAddress,</span><br><span class="line">				*Sendbuffer);</span><br><span class="line">		Sendbuffer++;</span><br><span class="line">		++TransCount;</span><br><span class="line">		ByteCount--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wait for the transfer to finish by polling Tx fifo status.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		StatusReg = <span class="built_in">XSpiPs_ReadReg</span>(</span><br><span class="line">				Spi0.Config.BaseAddress,</span><br><span class="line">					XSPIPS_SR_OFFSET);</span><br><span class="line">	&#125; <span class="keyword">while</span> ((StatusReg &amp; XSPIPS_IXR_TXOW_MASK) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spi0_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> Status;</span><br><span class="line">	XSpiPs_Config *SpiConfig;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the SPI device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SpiConfig = <span class="built_in">XSpiPs_LookupConfig</span>(XPAR_XSPIPS_0_DEVICE_ID);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == SpiConfig) &#123;</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Status = <span class="built_in">XSpiPs_CfgInitialize</span>(&amp;Spi0, SpiConfig, SpiConfig-&gt;BaseAddress);</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Perform a self-test to check hardware build.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Status = <span class="built_in">XSpiPs_SelfTest</span>(&amp;Spi0);</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">xil_printf</span>(<span class="string">&quot;%s self test succ\r\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	Status = <span class="built_in">XSpiPs_SetOptions</span>(&amp;Spi0, XSPIPS_MASTER_OPTION);</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		<span class="built_in">xil_printf</span>(<span class="string">&quot;%s XSpiPs_SetOptions fail\n&quot;</span>, __func__);</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	Status = <span class="built_in">XSpiPs_SetClkPrescaler</span>(&amp;Spi0, XSPIPS_CLK_PRESCALE_64);</span><br><span class="line">	<span class="keyword">if</span> (Status != XST_SUCCESS) &#123;</span><br><span class="line">		<span class="built_in">xil_printf</span>(<span class="string">&quot;%s XSpiPs_SetClkPrescaler fail\n&quot;</span>, __func__);</span><br><span class="line">		<span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">XSpiPs_Enable</span>(&amp;Spi0);</span><br><span class="line">	<span class="built_in">xil_printf</span>(<span class="string">&quot;spi 0 config finish\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.cnblogs.com/beihaixingchen/p/13920817.html">PYNQ-Z2学习资源整理 - beihaixingchen - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV1tE411i7MD?p=2&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">02.PYNQ入门_哔哩哔哩_bilibili</a>（Jupyter notebook部分）</li>
<li><p><a href="https://blog.csdn.net/www_haha__/category_12376091.html?spm=1001.2014.3001.5482（基于PYNQ-Z2学习的ZYNQ笔记）">https://blog.csdn.net/www_haha__/category_12376091.html?spm=1001.2014.3001.5482（基于PYNQ-Z2学习的ZYNQ笔记）</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_32134427/article/details/109289843">vivado2020.1 vitis_vivado 2020 sdk_丁点的沙砾的博客-CSDN博客</a>（用vitis实现hello word）</p>
</li>
<li><a href="https://blog.csdn.net/yueqiu693/article/details/122721692">Vitis开发（一）：Vivado启动vitis_vivado vitis_俩个圆的博客-CSDN博客</a>（解决lanch vitis IDE报错的问题）</li>
<li><a href="https://xilinx.eetrend.com/content/2019/100042625.html">ZYNQ开发（二）GPIO配置 | 电子创新网赛灵思社区 (eetrend.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ZYNQ嵌入式之hello_word简单示例（基于PYNQ-Z2开发板）</title>
    <url>/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/</url>
    <content><![CDATA[<p>本节主要了ZYNQ嵌入式系统开发的流程，并以hello world实例作为简单演示</p>
<span id="more"></span>
<h1 id="ZYNQ嵌入式系统开发流程"><a href="#ZYNQ嵌入式系统开发流程" class="headerlink" title="ZYNQ嵌入式系统开发流程"></a>ZYNQ嵌入式系统开发流程</h1><p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921135446231.png" alt="image-20230921135446231" style="zoom: 67%;"></p>
<h1 id="Vivado的相关配置"><a href="#Vivado的相关配置" class="headerlink" title="Vivado的相关配置"></a>Vivado的相关配置</h1><ul>
<li>添加zynq芯片并点击自动配置</li>
</ul>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921135727546.png" alt="image-20230921135727546"></p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921135837894.png" alt="image-20230921135837894" style="zoom:50%;"></p>
<ul>
<li><p>去掉本次实验不需要用到的M AXI GP0</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921140039379.png" alt="image-20230921140039379"></p>
</li>
<li><p>去掉本次实验不需要用到的FCLK_CLK0</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921141722902.png" alt="image-20230921141722902"></p>
</li>
<li><p>去掉本次实验不需要用到的FCLK_RESET0_N</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921142157840.png" alt="image-20230921142157840"></p>
</li>
<li><p>生成顶层文件</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921142404439.png" alt="image-20230921142404439"></p>
</li>
<li><p>导出硬件</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921142518319.png" alt="image-20230921142518319" style="zoom: 50%;"></p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921142629056.png" alt="image-20230921142629056" style="zoom: 50%;"></p>
</li>
</ul>
<h1 id="Vitis的相关配置"><a href="#Vitis的相关配置" class="headerlink" title="Vitis的相关配置"></a>Vitis的相关配置</h1><ul>
<li><p>在vivado中打开vitis（或者直接打开vitis）</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921142839899.png" alt="image-20230921142839899" style="zoom:50%;"></p>
</li>
<li><p>选择vitis工程的文件夹</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921143202809.png" alt="image-20230921143202809" style="zoom: 50%;"></p>
</li>
<li><p>点击创建application</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921143259191.png" alt="image-20230921143259191" style="zoom:50%;"></p>
</li>
<li><p>选择硬件平台</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921143502322.png" alt="image-20230921143502322" style="zoom:50%;"></p>
</li>
<li><p>添加app的名字</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921143646976.png" alt="image-20230921143646976"></p>
</li>
<li><p>一路next之后选择一个空的C++文件</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921143737181.png" alt="image-20230921143737181"></p>
</li>
<li><p>添加C++文件</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921143909850.png" alt="image-20230921143909850" style="zoom: 67%;"></p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921144008898.png" alt="image-20230921144008898" style="zoom:50%;"></p>
</li>
<li><p>在main.cpp添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello ssy!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调出串口终端的窗口：</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921144236932.png" alt="image-20230921144236932" style="zoom: 50%;"></p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921144321706.png" alt="image-20230921144321706" style="zoom:50%;"></p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921144455592.png" alt="image-20230921144455592" style="zoom:50%;"></p>
</li>
</ul>
<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921230729442.png" alt="image-20230921230729442" style="zoom: 67%;"></p>
<h1 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h1><ul>
<li><p>如果按照正常的zynq手动配置（即只配置ddr和uart）pynq板，最终打印不出东西</p>
</li>
<li><p>解决办法是，在网上下载pynq-z2的board file，以完成自动配置</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921144922992.png" alt="image-20230921144922992"></p>
</li>
<li><p>弄好之后创建工程时可以在board中选择板子</p>
<p><img src="/2023/09/11/ZYNQ%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8Bhello_word%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8EPYNQ-Z2%E5%BC%80%E5%8F%91%E6%9D%BF%EF%BC%89/image-20230921145118544.png" alt="image-20230921145118544" style="zoom:50%;"></p>
</li>
<li><p>虽然这样能解决问题，但依旧不明白手动配置为什么不行，可能pynq和zynq的配置还是有差别吧</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ZYNQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之常用特性补充</title>
    <url>/2023/09/05/Python%E4%B9%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>本文主要补充了Python中常用的一些特性补充，其中包括数据类型相关的，函数相关的，面向对象编程的，IO输入输出的以及内建模块</p>
<span id="more"></span>
<h1 id="数据类型相关的特性"><a href="#数据类型相关的特性" class="headerlink" title="数据类型相关的特性"></a>数据类型相关的特性</h1><ul>
<li>关于<code>tuple</code></li>
<li><code>dict</code>也可以使用for循环迭代</li>
<li>Python内置的<code>enumerate</code>函数可以把list变成索引-元素对</li>
<li>列表生成式</li>
<li>生成器<code>generator</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">1</span>, <span class="string">&#x27;tuple&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>) <span class="comment">#打印时逗号会被认为是空格</span></span><br><span class="line"><span class="comment">#1.关于tuple</span></span><br><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># t[0] = 4</span></span><br><span class="line"><span class="comment"># print(t) #此时会报错，tuple中的元素不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">2</span>, <span class="string">&#x27;dict&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#2.dict也可以使用for循环迭代</span></span><br><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.keys(): <span class="comment">#若只有d，则默认是d.keys()</span></span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">3</span>, <span class="string">&#x27;enumerate&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#3.Python内置的enumerate函数可以把list变成索引-元素对</span></span><br><span class="line"><span class="keyword">for</span> idx, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(d):</span><br><span class="line">    <span class="built_in">print</span>(idx, value)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">4</span>, <span class="string">&#x27;列表生成式&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#4.列表生成式</span></span><br><span class="line">L_list = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)] <span class="comment">#列表生成式可以用一行语句代替利用循环生成的list</span></span><br><span class="line"><span class="built_in">print</span>(L_list)</span><br><span class="line"></span><br><span class="line">L_choose = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>] <span class="comment">#for循环后面还可以加上if判断条件，对for遍历出来的数进行筛选</span></span><br><span class="line"><span class="built_in">print</span>(L_choose)</span><br><span class="line"></span><br><span class="line">L_ifelse = [x * x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line"><span class="built_in">print</span>(L_ifelse) <span class="comment">#在一个列表生成式中，for前面的if...else是表达式，而for后面的if是筛选条件，不能带else</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">5</span>, <span class="string">&#x27;生成器generator&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#5.生成器generator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">odd</span>(): <span class="comment">#如果函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 1&#x27;</span>) <span class="comment">#generator函数和普通函数的执行流程不一样，</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>         <span class="comment">#普通函数是顺序执行，遇到return语句或者最后一句函数语句就返回</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 2&#x27;</span>) <span class="comment">#generator的函数，在每次调用next()的时候执行，遇到yield语句返回，</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>         <span class="comment">#再次执行时从上次返回的yield语句处继续执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">o = odd() <span class="comment">#调用一个generator函数将返回一个generator，即生成一个generator对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(o))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(o))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(o))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>): <span class="comment">#在循环过程中不断调用yield，就会不断中断</span></span><br><span class="line">    <span class="built_in">print</span>(n)     <span class="comment">#要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------- 1 tuple -------------------------</span><br><span class="line">(1, 2, 3)</span><br><span class="line">------------------------- 2 dict -------------------------</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">(&#x27;a&#x27;, 1)</span><br><span class="line">(&#x27;b&#x27;, 2)</span><br><span class="line">(&#x27;c&#x27;, 3)</span><br><span class="line">------------------------- 3 enumerate -------------------------</span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">------------------------- 4 列表生成式 -------------------------</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br><span class="line">[-1, 4, -3, 16, -5, 36, -7, 64, -9, 100]</span><br><span class="line">------------------------- 5 生成器generator -------------------------</span><br><span class="line">step 1</span><br><span class="line">1</span><br><span class="line">step 2</span><br><span class="line">3</span><br><span class="line">step 3</span><br><span class="line">5</span><br><span class="line">**********</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="函数式编程的相关特性"><a href="#函数式编程的相关特性" class="headerlink" title="函数式编程的相关特性"></a>函数式编程的相关特性</h1><ul>
<li>关于<code>map</code></li>
<li>关于<code>lambda</code></li>
<li>关于函数的参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">1</span>, <span class="string">&#x27;map&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#1.关于map</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">r = <span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]) <span class="comment">#map()函数接收两个参数，一个是函数，一个是Iterable</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(r)) <span class="comment">#map将传入的函数以此作用到序列的每个元素，并把结果作为新的Iterator返回</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">2</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#2.关于lambda</span></span><br><span class="line">L = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]) <span class="comment">#关键字lambda表示匿名函数，冒号前面的x表示函数参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(L)) <span class="comment">#匿名函数只能有一个表达式，不用写return，返回值就是该表达式的结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">3</span>, <span class="string">&#x27;函数的参数&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#3.关于函数的参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a, b, c = <span class="number">0</span>, *args, city, job, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;arg = &#x27;</span>, args, <span class="string">&#x27;city =&#x27;</span>, city, <span class="string">&#x27;job =&#x27;</span>,job, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a, b, c = <span class="number">0</span>, *, d, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;d = &#x27;</span>, d, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, city = <span class="string">&#x27;xm&#x27;</span>, job = <span class="string">&#x27;ic&#x27;</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, c = <span class="number">3</span>, city = <span class="string">&#x27;xm&#x27;</span>, job = <span class="string">&#x27;ic&#x27;</span>) <span class="comment">#一旦使用名字来赋值传参，那么后面的参数传递都需要使用名字来传参</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, city = <span class="string">&#x27;xm&#x27;</span>, job = <span class="string">&#x27;ic&#x27;</span>, x = <span class="number">99</span>, y =<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125; <span class="comment">#通过list(tuple)或dict，可以调用上述函数</span></span><br><span class="line">f2(*args, **kw) <span class="comment">#对于任意函数，都可以使用func(*arg, **kw)的形式调用它，无论它的参数是如何定义的</span></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line"><span class="comment">#3.1 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</span></span><br><span class="line"><span class="comment">#3.2 可变参数允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple，写法为*args</span></span><br><span class="line"><span class="comment">#3.3 关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装成dict，写法为**kw</span></span><br><span class="line"><span class="comment">#3.4 就相当于*args接收list或者tuple，**kw接收字典</span></span><br><span class="line"><span class="comment">#3.5 命名关键字参数与必选参数与默认参数之间需要跟着一个特征分隔符*，即*后面的参数被视为命名关键字参数，其传参时需要写出名字</span></span><br><span class="line"><span class="comment">#3.6 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不需要用特殊分隔符*了</span></span><br><span class="line"><span class="comment">###############</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------- 1 map -------------------------</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">------------------------- 2 lambda -------------------------</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">------------------------- 3 函数的参数 -------------------------</span><br><span class="line">a = 1 b = 2 c = 0 arg =  () city = xm job = ic kw = &#123;&#125;</span><br><span class="line">a = 1 b = 2 c = 3 arg =  () city = xm job = ic kw = &#123;&#125;</span><br><span class="line">a = 1 b = 2 c = 3 arg =  (4, 5) city = xm job = ic kw = &#123;&#x27;x&#x27;: 99, &#x27;y&#x27;: 100&#125;</span><br><span class="line">a = 1 b = 2 c = 8 d =  88 kw = &#123;&#x27;x&#x27;: &#x27;#&#x27;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="1-基础内容"><a href="#1-基础内容" class="headerlink" title="1.基础内容"></a>1.基础内容</h2><ul>
<li>类与实例</li>
<li>访问限制</li>
<li>继承和多态</li>
<li>获取对象信息<code>isinstance()</code>，<code>__len__()</code></li>
<li>实例属性和类属性</li>
<li><a href="https://www.zhihu.com/question/49136398">(2 封私信 / 35 条消息) if <strong>name</strong> == ‘<strong>main</strong>‘ 如何正确理解? - 知乎 (zhihu.com)</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">1</span>, <span class="string">&#x27;类与实例&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#1.类与实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>): <span class="comment">#class声明一个类，后面跟着的是类名，如果没有合适的类继承，那么就继承object类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %.2f&#x27;</span> % (self.name, self.score))</span><br><span class="line"></span><br><span class="line">base = Student(<span class="string">&#x27;ssy&#x27;</span>, <span class="number">100</span>) <span class="comment">#通过类名()创建出Student实例，变量base是指向Student的一个实例</span></span><br><span class="line">base.print_score()</span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#1.1 __init__方法的第一个参数永远是self，表示创建出的实例本身</span></span><br><span class="line"><span class="comment">#1.2 和普通函数相比，在类中定义函数只是有一点不同，就是第一个参数永远是实例变量self，并且调用时，不用传递参数</span></span><br><span class="line"><span class="comment">#1.3 在类中将封装数据的函数称为类的方法</span></span><br><span class="line"><span class="comment">#1.4 与静态语言不同，python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称可能不同</span></span><br><span class="line"><span class="comment">#1.5 可以用object.变量 = xxx来对实例对象绑定数据</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">2</span>, <span class="string">&#x27;访问限制&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#2.访问限制</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2</span>(<span class="title class_ inherited__">object</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %.2f&#x27;</span> % (self.__name, self.__score))  </span><br><span class="line"></span><br><span class="line">base2 = Student2(<span class="string">&#x27;ssy&#x27;</span>, <span class="number">100</span>) <span class="comment">#通过类名()创建出Student实例，变量base是指向Student的一个实例</span></span><br><span class="line">base2.print_score()</span><br><span class="line"><span class="comment">#print(base2.__name) #会报错，因为加上了属性名称前加上了__（两个下划线），代表变量是个私有变量，不能被外部访问了</span></span><br><span class="line">base2.__name = <span class="string">&#x27;wcf&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(base2.__name) <span class="comment">#表面上看似成功设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量</span></span><br><span class="line"><span class="built_in">print</span>(base2._Student2__name) <span class="comment">#内部的变量__name已经被外部的Python解释器自动改成了_Student2__name，而外部代码给base2新增了__name变量</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#2.1 在class内部，可以有属性和方法，而外部代码可以通过调用实例变量的方法来操作数据，通过object.变量 = xxx</span></span><br><span class="line"><span class="comment">#2.2 在Python中，实例的变量名如果以__开头，就变成了一个私有变量，只有内部可以访问，外部不能访问</span></span><br><span class="line"><span class="comment">#2.3 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。</span></span><br><span class="line"><span class="comment">#2.4 不能直接访问__name是因为__name已经被外部的Python解释器自动改成了_Student2__name</span></span><br><span class="line"><span class="comment">#2.5 所以仍然可以通过_Student2__name来访问__name</span></span><br><span class="line"><span class="comment">#2.6 但强烈建议不要这么干，因为不同版本的Python解释器可以会把__name改成不同的变量名</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">3</span>, <span class="string">&#x27;继承和多态&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#3.继承和多态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal is running!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>): <span class="comment">#对Dog来说，Animal就是它的父类；对于Animal来说，Dog就是它的子类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Dog is running!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cat is running!&quot;</span>)</span><br><span class="line"></span><br><span class="line">ani = Animal()</span><br><span class="line">dog = Dog()</span><br><span class="line">cat = Cat()</span><br><span class="line">ani.run()</span><br><span class="line">dog.run()</span><br><span class="line">cat.run()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Otherani</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Other Animal is running!&quot;</span>)</span><br><span class="line"></span><br><span class="line">oth = Otherani()</span><br><span class="line">run_twice(ani)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">run_twice(dog)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">run_twice(cat)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">run_twice(oth)</span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#3.1 继承最大的好处就是子类获得了父类的全部功能</span></span><br><span class="line"><span class="comment">#3.2 当子类和父类都存在相同的run()方法时，子类的run()覆盖了父类的run()，在代码运行时，总会调用子类的run()</span></span><br><span class="line"><span class="comment">#3.3 这样，就得到了继承的好处--&gt;多态</span></span><br><span class="line"><span class="comment">#3.4 在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做父类，但反过来就不行，即Dog可以看成Animal，但Animal不能看成Dog</span></span><br><span class="line"><span class="comment">#3.5 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则将无法调用run()方法</span></span><br><span class="line"><span class="comment">#3.6 对于Python这样的动态语言来说，则不一定要传入Animal类型，只需要保证传入的对象有一个run()方法就可以了</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">4</span>, <span class="string">&#x27;获取对象信息&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#4.获取对象信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(ani, Animal)) <span class="comment">#使用isinstance()判断数据类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(ani, Dog))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(dog, Dog))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(cat, Cat))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(cat, Animal))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(ani)) <span class="comment">#使用dir(object)查看一个对象的所有属性和方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="string">&#x27;ssy&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">dog = MyDog()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The length of MyDog is:&quot;</span>, <span class="built_in">len</span>(dog))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The length of MyDog is:&quot;</span>, dog.__len__())</span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#4.1 类似__xxx__的属性和方法在Python中都有特殊的用途</span></span><br><span class="line"><span class="comment">#4.2 比如__len__方法返回长度，在Python中如果调用len()函数试图获取一个对象的长度，</span></span><br><span class="line"><span class="comment">#4.3 实际上在len()函数的内部，它自动去调用该对象的__len__()方法</span></span><br><span class="line"><span class="comment">#4.4 如果自己写一个类，也想用len(object)的话，就自己写一个__len__()方法</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">5</span>, <span class="string">&#x27;实例属性和类属性&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#5.实例属性和类属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myobj</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&quot;ssy&quot;</span></span><br><span class="line">m1 = Myobj()</span><br><span class="line">m2 = Myobj()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;m1.name:&#x27;</span>, m1.name) <span class="comment">#打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Myobj.name:&#x27;</span>, Myobj.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;m2.name:&#x27;</span>, m2.name)</span><br><span class="line">m1.name = <span class="string">&#x27;wcf&#x27;</span></span><br><span class="line">Myobj.name = <span class="string">&#x27;ybl&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;New m1.name:&#x27;</span>, m1.name) <span class="comment">#由于实例属性优先级高于类属性，所以它会屏蔽掉类的name属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;New Myobj.name:&#x27;</span>, Myobj.name) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;m2.name:&#x27;</span>, m2.name)</span><br><span class="line"><span class="keyword">del</span> m1.name <span class="comment">#删除实例的name属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After del, m1.name:&#x27;</span>, m1.name)</span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#5.1 由于Python是动态语言，根据类创建的实例可以任意绑定属性</span></span><br><span class="line"><span class="comment">#5.2 给实例绑定属性的方法是通过实例变量，或者通过self变量</span></span><br><span class="line"><span class="comment">#5.3 但如果Myobj类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有</span></span><br><span class="line"><span class="comment">###########################</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------- 1 类与实例 -------------------------</span><br><span class="line">ssy: 100.00</span><br><span class="line">------------------------- 2 访问限制 -------------------------</span><br><span class="line">ssy: 100.00</span><br><span class="line">wcf</span><br><span class="line">ssy</span><br><span class="line">------------------------- 3 继承和多态 -------------------------</span><br><span class="line">Animal is running!</span><br><span class="line">Dog is running!</span><br><span class="line">Cat is running!</span><br><span class="line">********************</span><br><span class="line">Animal is running!</span><br><span class="line">Animal is running!</span><br><span class="line">********************</span><br><span class="line">Dog is running!</span><br><span class="line">Dog is running!</span><br><span class="line">********************</span><br><span class="line">Cat is running!</span><br><span class="line">Cat is running!</span><br><span class="line">********************</span><br><span class="line">Other Animal is running!</span><br><span class="line">Other Animal is running!</span><br><span class="line">------------------------- 4 获取对象信息 -------------------------</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;run&#x27;]</span><br><span class="line">[&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getitem__&#x27;, &#x27;__getnewargs__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__mod__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__rmod__&#x27;, &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;capitalize&#x27;, &#x27;casefold&#x27;, &#x27;center&#x27;, &#x27;count&#x27;, &#x27;encode&#x27;, &#x27;endswith&#x27;, &#x27;expandtabs&#x27;, &#x27;find&#x27;, &#x27;format&#x27;, &#x27;format_map&#x27;, &#x27;index&#x27;, &#x27;isalnum&#x27;, &#x27;isalpha&#x27;, &#x27;isascii&#x27;, &#x27;isdecimal&#x27;, &#x27;isdigit&#x27;, &#x27;isidentifier&#x27;, &#x27;islower&#x27;, &#x27;isnumeric&#x27;, &#x27;isprintable&#x27;, &#x27;isspace&#x27;, &#x27;istitle&#x27;, &#x27;isupper&#x27;, &#x27;join&#x27;, &#x27;ljust&#x27;, &#x27;lower&#x27;, &#x27;lstrip&#x27;, &#x27;maketrans&#x27;, &#x27;partition&#x27;, &#x27;removeprefix&#x27;, &#x27;removesuffix&#x27;, &#x27;replace&#x27;, &#x27;rfind&#x27;, &#x27;rindex&#x27;, &#x27;rjust&#x27;, &#x27;rpartition&#x27;, &#x27;rsplit&#x27;, &#x27;rstrip&#x27;, &#x27;split&#x27;, &#x27;splitlines&#x27;, &#x27;startswith&#x27;, &#x27;strip&#x27;, &#x27;swapcase&#x27;, &#x27;title&#x27;, &#x27;translate&#x27;, &#x27;upper&#x27;, &#x27;zfill&#x27;]</span><br><span class="line">The length of MyDog is: 100</span><br><span class="line">The length of MyDog is: 100</span><br><span class="line">------------------------- 5 实例属性和类属性 -------------------------</span><br><span class="line">m1.name: ssy</span><br><span class="line">Myobj.name: ssy</span><br><span class="line">m2.name: ssy</span><br><span class="line">New m1.name: wcf</span><br><span class="line">New Myobj.name: ybl</span><br><span class="line">m2.name: ybl</span><br><span class="line">After del, m1.name: ybl</span><br></pre></td></tr></table></figure>
<h2 id="2-高级编程"><a href="#2-高级编程" class="headerlink" title="2.高级编程"></a>2.高级编程</h2><ul>
<li><code>__slots__</code></li>
<li><code>@property</code></li>
<li>定制类<ul>
<li><code>__str__</code></li>
<li><code>__iter__</code></li>
<li><code>__getitem__</code></li>
</ul>
</li>
<li>使用枚举类<code>Enum</code><ul>
<li><code>@unique</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">1</span>, <span class="string">&#x27;__slots__&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#1.__slots__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">s = Student()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age</span>): <span class="comment">#定义一个函数作为实例方法</span></span><br><span class="line">    self.age = age</span><br><span class="line"></span><br><span class="line">s.set_age = MethodType(set_age, s) <span class="comment">#给实例绑定一个方法</span></span><br><span class="line">s.set_age(<span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(s.age)</span><br><span class="line"></span><br><span class="line">s2 = Student()</span><br><span class="line"><span class="comment"># s2.set_age(20) #此时报错，给一个实例绑定的方法，对另一个实例是不起作用的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>) <span class="comment">#用tuple定义允许绑定的属性名称</span></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.name = <span class="string">&#x27;ssy&#x27;</span></span><br><span class="line">s.age = <span class="string">&#x27;22&#x27;</span></span><br><span class="line"><span class="comment"># s.score = 100 #此时报错，因为score没有放到__slots__中，不能被绑定此属性</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#1.1 __slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</span></span><br><span class="line"><span class="comment">#1.2 除非在子类中也定义__slots__，这样子类实例允许定义的属性就是自身的__slots__加上父类的__slots__</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">2</span>, <span class="string">&#x27;@property&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#2.@property</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, score</span>):</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property </span><span class="comment">#方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @score.setter </span><span class="comment">#@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100 !&#x27;</span>)</span><br><span class="line">        self.__score = value</span><br><span class="line">    </span><br><span class="line">s = Student(<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(s.score)</span><br><span class="line">s.score = <span class="number">80</span></span><br><span class="line"><span class="built_in">print</span>(s.score)</span><br><span class="line"><span class="comment"># s.score = 999 #此时会报错，因为score超出规定范围了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">3</span>, <span class="string">&#x27;定制类&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#3.定制类</span></span><br><span class="line"><span class="comment">#3.1 __str__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#&quot;</span>*<span class="number">25</span>, <span class="string">&#x27;3.1&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&quot;#&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="comment">#不写__str__则打印结果为&lt;__main__.Student object at 0x000001ABEEEA3D00&gt;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s)&#x27;</span> % self.name </span><br><span class="line">    </span><br><span class="line">s = Student(<span class="string">&#x27;ssy&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.2 __iter__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#&quot;</span>*<span class="number">25</span>, <span class="string">&#x27;3.2&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&quot;#&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>): <span class="comment">#如果一个类想要被用于for...in循环，类似list或tuple那样，就必须实现一个__iter__()方法</span></span><br><span class="line">        <span class="keyword">return</span> self <span class="comment">#该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):<span class="comment">#直到遇到StopIteration错误时退出循环</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b </span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.3 __getitem__</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#&quot;</span>*<span class="number">25</span>, <span class="string">&#x27;3.3&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&quot;#&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>): <span class="comment">#Fib实例虽然能作用于for循环，但想要像list那样按照下标取出元素，需要用__getitem__()方法</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = b, a + b </span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">f = Fib()</span><br><span class="line"><span class="built_in">print</span>(f[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(f[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(f[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(f[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(f[<span class="number">4</span>])  </span><br><span class="line"><span class="built_in">print</span>(f[<span class="number">5</span>]) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">4</span>, <span class="string">&#x27;使用枚举类Enum&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#3.使用枚举类Enum</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value) <span class="comment">#value属性是自动赋给成员的int常量，默认从1开始计数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@unique </span><span class="comment">#@unique装饰器可以帮助检查保证没有重复值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weekday</span>(<span class="title class_ inherited__">Enum</span>): <span class="comment">#若需要更准确地控制枚举类型，可以从Enum派生出自定义类 </span></span><br><span class="line">    Sun = <span class="number">0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">day1 = Weekday.Mon <span class="comment">#访问这些枚举类型可以有若干种方法</span></span><br><span class="line"><span class="built_in">print</span>(day1)</span><br><span class="line"><span class="built_in">print</span>(Weekday.Tue)</span><br><span class="line"><span class="built_in">print</span>(Weekday[<span class="string">&#x27;Tue&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(Weekday.Tue.value)</span><br><span class="line"><span class="built_in">print</span>(day1 == Weekday.Mon)</span><br><span class="line"><span class="built_in">print</span>(day1 == Weekday.Tue)</span><br><span class="line"><span class="built_in">print</span>(Weekday(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(day1 == Weekday(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Weekday.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------- 1 __slots__ -------------------------</span><br><span class="line">25</span><br><span class="line">------------------------- 2 @property -------------------------</span><br><span class="line">60</span><br><span class="line">80</span><br><span class="line">------------------------- 3 定制类 -------------------------</span><br><span class="line">######################### 3.1 __str__ #########################</span><br><span class="line">Student object (name: ssy)</span><br><span class="line">######################### 3.2 __iter__ #########################</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">######################### 3.3 __getitem__ #########################</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">------------------------- 4 使用枚举类Enum -------------------------</span><br><span class="line">Jan =&gt; Month.Jan , 1</span><br><span class="line">Feb =&gt; Month.Feb , 2</span><br><span class="line">Mar =&gt; Month.Mar , 3</span><br><span class="line">Apr =&gt; Month.Apr , 4</span><br><span class="line">May =&gt; Month.May , 5</span><br><span class="line">Jun =&gt; Month.Jun , 6</span><br><span class="line">Jul =&gt; Month.Jul , 7</span><br><span class="line">Aug =&gt; Month.Aug , 8</span><br><span class="line">Sep =&gt; Month.Sep , 9</span><br><span class="line">Oct =&gt; Month.Oct , 10</span><br><span class="line">Nov =&gt; Month.Nov , 11</span><br><span class="line">Dec =&gt; Month.Dec , 12</span><br><span class="line">Weekday.Mon</span><br><span class="line">Weekday.Tue</span><br><span class="line">Weekday.Tue</span><br><span class="line">2</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">Weekday.Mon</span><br><span class="line">True</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><ul>
<li>文件读写：也请参考我之前的文章<a href="https://ssy1938010014.github.io/2022/10/24/Python基础之文件的读写/">Python基础之文件的读写</a></li>
<li>操作文件和目录<ul>
<li><code>os.name</code></li>
<li><code>os.path.abspath(&#39;.&#39;)</code></li>
<li><code>os.path.join</code></li>
<li><code>os.mkdir</code></li>
<li><code>os.rename</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">1</span>, <span class="string">&#x27;文件读写&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#1.文件读写</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;filetest.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">25</span>*<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filetest.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read(<span class="number">13</span>)) <span class="comment">#会将换行符也读入</span></span><br><span class="line">    <span class="built_in">print</span>(f.readline()) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">25</span>*<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filetest.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.readlines()) <span class="comment">#一次读取所有内容并按行返回list</span></span><br><span class="line">    f.seek(<span class="number">0</span>) <span class="comment">#改变当前文件操作指针的位置，0(代表回到文件开头)，1（代表当前位置），2（代表回到文件结尾）</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        <span class="built_in">print</span>(line.strip()) <span class="comment">#把末尾的&#x27;\n&#x27;删掉</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">25</span>*<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filetest.txt&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines([<span class="string">&#x27;You are my sunshine\n&#x27;</span>, <span class="string">&#x27;IC Design&#x27;</span>])</span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        <span class="built_in">print</span>(line.strip()) <span class="comment">#把末尾的&#x27;\n&#x27;删掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line"><span class="comment">#1.1 文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用</span></span><br><span class="line"><span class="comment">#1.2 Python引入了with语句来自动帮我们调用close()</span></span><br><span class="line"><span class="comment">#1.3 read(size)用法，每次读取size个字节</span></span><br><span class="line"><span class="comment">###############</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">2</span>, <span class="string">&#x27;操作文件和目录&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#2.操作文件和目录</span></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="built_in">print</span>(os.name) <span class="comment">#os.name获取操作系统的类型：如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;.&#x27;</span>)) <span class="comment">#查看当前目录所在的绝对路径</span></span><br><span class="line">test= os.path.join(<span class="string">&#x27;D:\App_Data_File\VScode_Project\Python\python_for_some_easy_error&#x27;</span>, <span class="string">&#x27;OStest&#x27;</span>) <span class="comment">#把多个部分合成一个路径</span></span><br><span class="line"><span class="built_in">print</span>(test)</span><br><span class="line">os.mkdir(test) <span class="comment">#创建一个目录</span></span><br><span class="line">os.rmdir(test) <span class="comment">#删除一个目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#os.rename(&#x27;test.py&#x27;, &#x27;OStest.py&#x27;) #对文件重命名</span></span><br><span class="line"><span class="comment">#os.remove(&#x27;OStest.py&#x27;) #删掉文件</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------- 1 文件读写 -------------------------</span><br><span class="line">hello, world</span><br><span class="line">hello, ssy</span><br><span class="line">hello, xmu</span><br><span class="line"></span><br><span class="line">#########################</span><br><span class="line">hello, world</span><br><span class="line"></span><br><span class="line">hello, ssy</span><br><span class="line"></span><br><span class="line">#########################</span><br><span class="line">[&#x27;hello, world\n&#x27;, &#x27;hello, ssy\n&#x27;, &#x27;hello, xmu\n&#x27;]</span><br><span class="line">hello, world</span><br><span class="line">hello, ssy</span><br><span class="line">hello, xmu</span><br><span class="line">#########################</span><br><span class="line">hello, world</span><br><span class="line">hello, ssy</span><br><span class="line">hello, xmu</span><br><span class="line">You are my sunshine</span><br><span class="line">IC Design</span><br><span class="line">------------------------- 2 操作文件和目录 -------------------------</span><br><span class="line">nt</span><br><span class="line">D:\App_Data_File\VScode_Project\Python\python_for_some_easy_error</span><br><span class="line">D:\App_Data_File\VScode_Project\Python\python_for_some_easy_error\OStest</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="常用的内建模块"><a href="#常用的内建模块" class="headerlink" title="常用的内建模块"></a>常用的内建模块</h1><ul>
<li>datetime</li>
<li>argparse</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">1</span>, <span class="string">&#x27;datetime&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#1.datetime</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">now = datetime.now() <span class="comment">#获取当前日期和时间</span></span><br><span class="line"><span class="built_in">print</span>(now)</span><br><span class="line">dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">54</span>) <span class="comment">#用指定日期时间创建datetime</span></span><br><span class="line"><span class="built_in">print</span>(dt)</span><br><span class="line">cday = datetime.strptime(<span class="string">&#x27;2015-6-1 18:19:59&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(cday) <span class="comment">#将字符串转化为datetime</span></span><br><span class="line"><span class="built_in">print</span>(now.strftime(<span class="string">&#x27;%a, %b %d %H:%M&#x27;</span>)) <span class="comment">#将datetime转化为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(now) <span class="comment">#对时间进行加减运算</span></span><br><span class="line"><span class="built_in">print</span>(now + timedelta(hours=<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(now - timedelta(days=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(now + timedelta(days=<span class="number">2</span>, hours=<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">25</span>, <span class="number">2</span>, <span class="string">&#x27;argparse&#x27;</span>, <span class="string">&quot;-&quot;</span>*<span class="number">25</span>)</span><br><span class="line"><span class="comment">#2.argparse</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 定义一个ArgumentParser实例:</span></span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        prog=<span class="string">&#x27;backup&#x27;</span>, <span class="comment"># 程序名</span></span><br><span class="line">        description=<span class="string">&#x27;Backup MySQL database.&#x27;</span>, <span class="comment"># 描述</span></span><br><span class="line">        epilog=<span class="string">&#x27;Copyright(r), 2023&#x27;</span> <span class="comment"># 说明信息</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 定义位置参数:</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--outfile&#x27;</span>, default=<span class="string">&#x27;./parsertest&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;The position of output file&#x27;</span>)</span><br><span class="line">    <span class="comment"># 定义关键字参数:</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--host&#x27;</span>, default=<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line">    <span class="comment"># 此参数必须为int类型:</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--port&#x27;</span>, default=<span class="string">&#x27;3306&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>) <span class="comment">#默认的参数类型是str类型，如果需要一个整数参数，需要设置type=int</span></span><br><span class="line">    <span class="comment"># choices：参数值只能从几个选项里面选择</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--arch&#x27;</span>, choices=[<span class="string">&#x27;alexnet&#x27;</span>, <span class="string">&#x27;vgg&#x27;</span>])</span><br><span class="line">    <span class="comment"># 允许用户输入简写的-u:</span></span><br><span class="line">    <span class="comment"># parser.add_argument(&#x27;-u&#x27;, &#x27;--user&#x27;, required=True) #required: 表示这个参数是否一定需要设置；-u表示允许用户输入简写-u</span></span><br><span class="line">    <span class="comment"># parser.add_argument(&#x27;-p&#x27;, &#x27;--password&#x27;, required=True) #如果设置了required=True,则在实际运行的时候不设置该参数将报错：python normal_ku.py -u ssy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析参数:</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    args.u = <span class="string">&#x27;ssy&#x27;</span></span><br><span class="line">    args.p = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">    args.arch = <span class="string">&#x27;vgg&#x27;</span></span><br><span class="line">    <span class="comment"># 打印参数:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;parsed args:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;outfile = <span class="subst">&#123;args.outfile&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;host = <span class="subst">&#123;args.host&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;port = <span class="subst">&#123;args.port&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;port = <span class="subst">&#123;args.arch&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(f&#x27;user = &#123;args.user&#125;&#x27;)</span></span><br><span class="line">    <span class="comment"># print(f&#x27;password = &#123;args.password&#125;&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------- 1 datetime -------------------------</span><br><span class="line">2023-09-07 19:06:04.071888</span><br><span class="line">2015-04-19 12:20:54</span><br><span class="line">2015-06-01 18:19:59</span><br><span class="line">Thu, Sep 07 19:06</span><br><span class="line">2023-09-07 19:06:04.071888</span><br><span class="line">2023-09-08 05:06:04.071888</span><br><span class="line">2023-09-06 19:06:04.071888</span><br><span class="line">2023-09-10 07:06:04.071888</span><br><span class="line">------------------------- 2 argparse -------------------------</span><br><span class="line">parsed args:</span><br><span class="line">outfile = ./parsertest</span><br><span class="line">host = localhost</span><br><span class="line">port = 3306</span><br><span class="line">port = vgg</span><br><span class="line">user = ssy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>浪漫的Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Verdi之基本使用</title>
    <url>/2023/08/30/Verdi%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文主要介绍了Synopsys中波形查看工具Verdi的基本使用，重点在于VCS与verdi联动时生成fsdb波形文件的方法</p>
<span id="more"></span>
<h1 id="生成fsdb波形文件"><a href="#生成fsdb波形文件" class="headerlink" title="生成fsdb波形文件"></a>生成fsdb波形文件</h1><h2 id="1-基于SV系统函数的方法"><a href="#1-基于SV系统函数的方法" class="headerlink" title="1.基于SV系统函数的方法"></a>1.基于SV系统函数的方法</h2><h3 id="1-1-filelist-f"><a href="#1-1-filelist-f" class="headerlink" title="1.1 filelist.f"></a>1.1 filelist.f</h3><ul>
<li><p>与vcs自带的vpd文件保存方法类似，需要在filelist中先定义一个宏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Macro define</span><br><span class="line">//+define+DUMP_VPD</span><br><span class="line">+define+FSDB</span><br><span class="line"></span><br><span class="line">//Source file</span><br><span class="line">./counter.sv</span><br><span class="line"></span><br><span class="line">//Testbench</span><br><span class="line">./counter_tb.sv</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-Makefile"><a href="#1-2-Makefile" class="headerlink" title="1.2 Makefile"></a>1.2 Makefile</h3><ul>
<li><p>makefile中是vcs+verdi的联合使用相关的配置</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: clean comp sim verdi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if you want to delete simv, recommend simv_* to rename</span></span><br><span class="line">sim_name = simv_counter</span><br><span class="line"></span><br><span class="line"><span class="comment">#set a new vpd file name</span></span><br><span class="line">vpd_name = +vpdfile+$&#123;sim_name&#125;.vpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#Code coverage command</span></span><br><span class="line">CM = -cm line+cond+fsm+branch+tgl</span><br><span class="line">CM_NAME = -cm_name $&#123;sim_name&#125;</span><br><span class="line">CM_DIR = -cm_dir ./$&#123;sim_name&#125;.vdb</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf ./csrc *.daidir *.log simv* *.key *.vpd ./DVEfiles *.vdb</span><br><span class="line">	rm -rf verdiLog *.fsdb *.bak *.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">## VCS and Verdi</span></span><br><span class="line"><span class="section">comp:</span></span><br><span class="line">	vcs -full64 -cpp g++ -cc gcc -LDFLAGS -no-pie -LDFLAGS -Wl,--no-as-needed -CFLAGS -fPIE \</span><br><span class="line">		-sverilog +v2k -timescale=1ns/1ps \</span><br><span class="line">		-debug_acc+all \</span><br><span class="line">		-fsdb \</span><br><span class="line">		-o $&#123;sim_name&#125; \</span><br><span class="line">		-l compile.log \</span><br><span class="line">		-f filelist.f \</span><br><span class="line"></span><br><span class="line"><span class="section">sim:</span></span><br><span class="line">	./$&#123;sim_name&#125; -l sim.log </span><br><span class="line"></span><br><span class="line"><span class="section">verdi:</span></span><br><span class="line">	verdi -sv -f filelist.f -ssf *.fsdb &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">## ONLY VCS</span></span><br><span class="line"><span class="comment">#comp:</span></span><br><span class="line"><span class="comment">#	vcs -full64 -cpp g++ -cc gcc -LDFLAGS -no-pie -LDFLAGS -Wl,--no-as-needed -CFLAGS -fPIE \</span></span><br><span class="line">		-sverilog +v2k -timescale=1ns/1ps \</span><br><span class="line">		-debug_acc+all \</span><br><span class="line">		$&#123;vpd_name&#125; \</span><br><span class="line">		$&#123;CM&#125; \</span><br><span class="line">		$&#123;CM_NAME&#125; \</span><br><span class="line">		$&#123;CM_DIR&#125; \</span><br><span class="line">		-o $&#123;sim_name&#125; \</span><br><span class="line">		-l compile.log \</span><br><span class="line">		-f filelist.f \</span><br><span class="line"></span><br><span class="line"><span class="comment">#sim:</span></span><br><span class="line"><span class="comment">#	./$&#123;sim_name&#125; \</span></span><br><span class="line">	$&#123;vpd_name&#125; \</span><br><span class="line">	$&#123;CM&#125; $&#123;CM_NAME&#125; $&#123;CM_DIR&#125; \</span><br><span class="line">	-l sim.log \</span><br><span class="line"></span><br><span class="line"><span class="comment">#show the coverage</span></span><br><span class="line"><span class="section">cov:</span></span><br><span class="line">	dve -full64 -covdir *.vdb &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>在comp中：<ul>
<li><code>-fsdb</code> #表示支持fsdb相应操作</li>
</ul>
</li>
<li>在sim中：<ul>
<li><code>-ssf *.fsdb</code> #启动verdi并自动加载fsdb类型的波形</li>
<li>如果语言使用的是SV，则一定要加上<code>-sv</code>，否则某些变量的波形会加载不出来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-Testbench中的相关设置"><a href="#1-3-Testbench中的相关设置" class="headerlink" title="1.3 Testbench中的相关设置"></a>1.3 Testbench中的相关设置</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//dump Verdi file</span><br><span class="line">`ifdef FSDB</span><br><span class="line">    initial begin</span><br><span class="line">        $fsdbDumpfile(&quot;count.fsdb&quot;); //count.fsdb is the name of .fsdb file</span><br><span class="line">        $fsdbDumpvars(0, counter_tb);</span><br><span class="line">    end</span><br><span class="line">`endif </span><br></pre></td></tr></table></figure>
<ul>
<li>其中<code>$fsdbDumpvars()</code>的使用方法与<code>vcdplusmemon()</code>类似</li>
</ul>
<h2 id="2-基于ucli-tcl接口的方法"><a href="#2-基于ucli-tcl接口的方法" class="headerlink" title="2.基于ucli/tcl接口的方法"></a>2.基于ucli/tcl接口的方法</h2><h3 id="2-1-添加ucli、tcl接口"><a href="#2-1-添加ucli、tcl接口" class="headerlink" title="2.1 添加ucli、tcl接口"></a>2.1 添加ucli、tcl接口</h3><ul>
<li>即编写tcl脚本：fsdb_vcs.tcl</li>
</ul>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">global</span> env</span><br><span class="line">fsdbDumpfile <span class="string">&quot;env(demo_name).fsdb&quot;</span></span><br><span class="line">fsdbDumpvars <span class="number">0</span> <span class="string">&quot;counter_tb&quot;</span></span><br><span class="line">run <span class="number">20</span>ns</span><br><span class="line">fsdbDumpoff</span><br><span class="line">run <span class="number">10</span>ns</span><br><span class="line">fsdbDumpon</span><br><span class="line">run</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Makefile"><a href="#2-2-Makefile" class="headerlink" title="2.2 Makefile"></a>2.2 Makefile</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: clean comp sim verdi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if you want to delete simv, recommend simv_* to rename</span></span><br><span class="line">sim_name = simv_counter</span><br><span class="line"></span><br><span class="line"><span class="comment">#set a new vpd file name</span></span><br><span class="line">vpd_name = +vpdfile+$&#123;sim_name&#125;.vpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#Code coverage command</span></span><br><span class="line">CM = -cm line+cond+fsm+branch+tgl</span><br><span class="line">CM_NAME = -cm_name $&#123;sim_name&#125;</span><br><span class="line">CM_DIR = -cm_dir ./$&#123;sim_name&#125;.vdb</span><br><span class="line"></span><br><span class="line"><span class="comment">## Verdi ucli/tcl def</span></span><br><span class="line"><span class="keyword">export</span> demo_name = $&#123;sim_name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf ./csrc *.daidir *.log simv* *.key *.vpd ./DVEfiles *.vdb</span><br><span class="line">	rm -rf verdiLog *.fsdb *.bak *.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">## VCS and Verdi</span></span><br><span class="line"><span class="comment">#comp:</span></span><br><span class="line"><span class="comment">#	vcs -full64 -cpp g++ -cc gcc -LDFLAGS -no-pie -LDFLAGS -Wl,--no-as-needed -CFLAGS -fPIE \</span></span><br><span class="line">		-sverilog +v2k -timescale=1ns/1ps \</span><br><span class="line">		-debug_acc+all \</span><br><span class="line">		-fsdb \</span><br><span class="line">		-o $&#123;sim_name&#125; \</span><br><span class="line">		-l compile.log \</span><br><span class="line">		-f filelist.f</span><br><span class="line"></span><br><span class="line"><span class="comment">#sim:</span></span><br><span class="line"><span class="comment">#	./$&#123;sim_name&#125; -l sim.log </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ucli/tcl comp set</span></span><br><span class="line"><span class="section">comp:</span></span><br><span class="line">	vcs -full64 -cpp g++ -cc gcc -LDFLAGS -no-pie -LDFLAGS -Wl,--no-as-needed -CFLAGS -fPIE \</span><br><span class="line">		-sverilog +v2k -timescale=1ns/1ps \</span><br><span class="line">		-debug_acc+all \</span><br><span class="line">		-LDFLAGS \</span><br><span class="line">		-rdynamic \</span><br><span class="line">		-P $&#123;VERDI_HOME&#125;/share/PLI/VCS/LINUX64/novas.tab \</span><br><span class="line">		   $&#123;VERDI_HOME&#125;/share/PLI/VCS/LINUX64/pli.a \</span><br><span class="line">		-o $&#123;sim_name&#125; \</span><br><span class="line">		-l compile.log \</span><br><span class="line">		-f filelist.f</span><br><span class="line"></span><br><span class="line"><span class="section">sim:</span></span><br><span class="line">	./$&#123;sim_name&#125; \</span><br><span class="line">	-ucli -i ./fsdb_vcs.tcl \</span><br><span class="line">	+fsdb+autoflush \</span><br><span class="line">	-l sim.log</span><br><span class="line"></span><br><span class="line"><span class="section">verdi:</span></span><br><span class="line">	verdi -sv -f filelist.f -ssf *.fsdb &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">## ONLY VCS</span></span><br><span class="line"><span class="comment">#comp:</span></span><br><span class="line"><span class="comment">#	vcs -full64 -cpp g++ -cc gcc -LDFLAGS -no-pie -LDFLAGS -Wl,--no-as-needed -CFLAGS -fPIE \</span></span><br><span class="line">		-sverilog +v2k -timescale=1ns/1ps \</span><br><span class="line">		-debug_acc+all \</span><br><span class="line">		$&#123;vpd_name&#125; \</span><br><span class="line">		$&#123;CM&#125; \</span><br><span class="line">		$&#123;CM_NAME&#125; \</span><br><span class="line">		$&#123;CM_DIR&#125; \</span><br><span class="line">		-o $&#123;sim_name&#125; \</span><br><span class="line">		-l compile.log \</span><br><span class="line">		-f filelist.f</span><br><span class="line"></span><br><span class="line"><span class="comment">#sim:</span></span><br><span class="line"><span class="comment">#	./$&#123;sim_name&#125; \</span></span><br><span class="line">	$&#123;vpd_name&#125; \</span><br><span class="line">	$&#123;CM&#125; $&#123;CM_NAME&#125; $&#123;CM_DIR&#125; \</span><br><span class="line">	-l sim.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#show the coverage</span></span><br><span class="line"><span class="section">cov:</span></span><br><span class="line">	dve -full64 -covdir *.vdb &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其中：</p>
<ul>
<li>-debug_acc+all可以使能ucli命令</li>
<li>+fsdb+autoflush为边仿真边dump波形</li>
</ul>
</li>
<li><p>最终演示结果如下：</p>
<p><img src="/2023/08/30/Verdi%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20230830215205548.png" alt="image-20230830215205548"></p>
</li>
</ul>
<hr>
<h1 id="gui界面的操作"><a href="#gui界面的操作" class="headerlink" title="gui界面的操作"></a>gui界面的操作</h1><ul>
<li><p>使用<code>make comp</code>、<code>make sim</code>、<code>make verd</code>i操作后，可得到如下gui界面</p>
<p><img src="/2023/08/30/Verdi%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20230830152004283.png" alt="image-20230830152004283"></p>
</li>
<li><p>基本操作：</p>
<ul>
<li><p>信号选择：</p>
<ul>
<li>模块波形：选择某一模块，按ctrl+4或直接拖拽</li>
<li>某一信号波形：代码界面中选择某一信号，按ctrl+w或者直接拖拽</li>
</ul>
</li>
<li><p>查看波形：</p>
<ul>
<li>全局波形，按f键或点击100%按钮</li>
<li>缩小波形：按z键</li>
<li>放大波形：鼠标左键拖选放大范围</li>
<li>显示结构：按h键</li>
<li>删除信号：按delete键</li>
</ul>
</li>
<li><p>标记时间节点：</p>
<ul>
<li><p>按shift+M，再按照如下示例操作</p>
<p><img src="/2023/08/30/Verdi%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20230830202328178.png" alt="image-20230830202328178"></p>
</li>
</ul>
</li>
<li><p>鼠标左键控制黄色cursor，鼠标中键控制白色cursor</p>
<p><img src="/2023/08/30/Verdi%E4%B9%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20230830202553237.png" alt="image-20230830202553237"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1Tt4y1u7TY/?spm_id_from=333.337.search-card.all.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">新新新手Icer练习（七）：VCS+verdi 干货（包括Makefile脚本编写、verdi操作）_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Verdi</tag>
      </tags>
  </entry>
  <entry>
    <title>VCS之基本操作</title>
    <url>/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>本文主要介绍了Synopsys仿真工具VCS的基本使用，包括如何编译与仿真，makefile文件的编写、以及代码覆盖率</p>
<span id="more"></span>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="1-源代码"><a href="#1-源代码" class="headerlink" title="1.源代码"></a>1.源代码</h2><ul>
<li><p>counter.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`timescale  1ns/1ps</span><br><span class="line"></span><br><span class="line">module counter(</span><br><span class="line">    input clk,</span><br><span class="line">    input rst,</span><br><span class="line">    output logic [5:0] count</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always @(posedge clk or negedge rst) begin</span><br><span class="line">    if(!rst)</span><br><span class="line">        count &lt;= 0;</span><br><span class="line">    else </span><br><span class="line">        count &lt;= count + 6&#x27;b1;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-Testbench"><a href="#2-Testbench" class="headerlink" title="2.Testbench"></a>2.Testbench</h2><ul>
<li><p>counter_tb.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`timescale  1ns/1ps</span><br><span class="line"></span><br><span class="line">module counter_tb();</span><br><span class="line">    </span><br><span class="line">    logic clk;</span><br><span class="line">    logic rst;</span><br><span class="line">    wire [5:0] count;</span><br><span class="line"></span><br><span class="line">    counter u1(clk, rst, count);</span><br><span class="line"></span><br><span class="line">    always #(5) begin</span><br><span class="line">        clk = ~clk;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    initial begin</span><br><span class="line">        clk = 0;</span><br><span class="line">        rst = 0;</span><br><span class="line"></span><br><span class="line">        #20;</span><br><span class="line">        rst = 1;</span><br><span class="line">        #50;</span><br><span class="line">        if(count != 5)</span><br><span class="line">            $display(&quot;Failure 1: the counter should be 5 but it is %d&quot;, count);</span><br><span class="line">        else</span><br><span class="line">            $display(&quot;You gotta the right result! It is five!&quot;);</span><br><span class="line">        $finish;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-filelist"><a href="#3-filelist" class="headerlink" title="3.filelist"></a>3.filelist</h2><ul>
<li><p>filelist.f：将需要编译的文件都放在这个文件夹下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./counter.sv</span><br><span class="line">./counter_tb.sv</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-Makefile"><a href="#4-Makefile" class="headerlink" title="4.Makefile"></a>4.Makefile</h2><ul>
<li><p>将编译相关的一些指令集成在Makefile文件中</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: clean comp sim</span></span><br><span class="line"></span><br><span class="line">sim_name = simv <span class="comment">#recommend simv_* to rename</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf ./csrc *.daidir *.log simv* *.key</span><br><span class="line"></span><br><span class="line"><span class="section">comp:</span></span><br><span class="line">	vcs -full64 -cpp g++ -cc gcc -LDFLAGS -no-pie -LDFLAGS -Wl,--no-as-needed -CFLAGS -fPIE \</span><br><span class="line">		-sverilog +v2k -timescale=1ns/1ps \</span><br><span class="line">		-debug_acc+all \</span><br><span class="line">		-o $&#123;sim_name&#125; \</span><br><span class="line">		-l compile.log \</span><br><span class="line">		-f filelist.f \</span><br><span class="line"></span><br><span class="line"><span class="section">sim:</span></span><br><span class="line">	./$&#123;sim_name&#125; -l sim.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译相关的常见指令：</p>
<ul>
<li><code>-full64</code> #以64位linux系统运行</li>
<li><code>-sverilog</code> #支持sv语法</li>
<li><code>+ v2k</code> #支持verilog2001特性</li>
<li><code>-debug_acc+all</code> #在仿真时，能使用调试功能</li>
<li><code>-f filelist.f</code> #指定包含源文件和编译时选项的路径名列表的文件</li>
<li><code>-o $&#123;sim_name&#125;</code> #更改编译输出文件的名称</li>
<li><code>-l compile.log</code> #输出编译日志</li>
</ul>
</li>
<li><p><code>make comp</code>后的结果：</p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826135356734.png" alt="image-20230826135356734"></p>
</li>
<li><p><code>make run</code>后的结果：</p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826135515122.png" alt="image-20230826135515122"></p>
</li>
<li><p><code>make clean</code>后的结果：</p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826135610278.png" alt="image-20230826135610278"></p>
</li>
</ul>
<hr>
<h1 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h1><h2 id="1-vcdpluson-的使用"><a href="#1-vcdpluson-的使用" class="headerlink" title="1.$vcdpluson()的使用"></a>1.$vcdpluson()的使用</h2><ul>
<li><p>调用<code>$vcdpluson()</code>记录仿真过程中的波形</p>
<ul>
<li><p><code>$vcdpluson()</code> 或者<code>$vcdpluson(0, counter_tb)</code>记录counter_tb及其所有子模块的波形</p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826183314771.png" alt="image-20230826183314771" style="zoom:67%;"></p>
</li>
<li><p><code>$vcdpluson(1, counter_tb)</code> 只记录counter_tb层的波形</p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826183552241.png" alt="image-20230826183552241" style="zoom:67%;"></p>
</li>
<li><p><code>$vcdpluson(2, counter_tb)</code> 记录 counter_tb层及其下一子层的波形</p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826201418663.png" alt="image-20230826201418663" style="zoom: 67%;"></p>
</li>
<li><p><code>$vcdpluson(counter, counter_tb);</code>也可以通过打出模块名的方式记录波形</p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826202001555.png" alt="image-20230826202001555" style="zoom:67%;"></p>
</li>
</ul>
</li>
<li><p>想要使用这个功能，需要在Testbench中加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//dump vpd file</span><br><span class="line">initial begin</span><br><span class="line">`ifdef DUMP_VPD</span><br><span class="line">    //$vcdpluson();</span><br><span class="line">    $vcdpluson(1, counter_tb); //only save 1-layer wave message</span><br><span class="line">    // $vcdplusmemon();</span><br><span class="line">`endif</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>filelist.f也应该修改，加上宏定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Macro define</span><br><span class="line">+define+DUMP_VPD</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Makefile</strong>文件也要做适当修改，完成的Makefile文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: clean comp sim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if you want to delete simv, recommend simv_* to rename</span></span><br><span class="line">sim_name = simv_counter</span><br><span class="line"></span><br><span class="line"><span class="comment">#set a new vpd file name</span></span><br><span class="line">vpd_name = +vpdfile+$&#123;sim_name&#125;.vpd</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf ./csrc *.daidir *.log simv* *.key *.vpd ./DVEfiles</span><br><span class="line"></span><br><span class="line"><span class="section">comp:</span></span><br><span class="line">	vcs -full64 -cpp g++ -cc gcc -LDFLAGS -no-pie -LDFLAGS -Wl,--no-as-needed -CFLAGS -fPIE \</span><br><span class="line">		-sverilog +v2k -timescale=1ns/1ps \</span><br><span class="line">		-debug_acc+all \</span><br><span class="line">		$&#123;vpd_name&#125; \</span><br><span class="line">		-o $&#123;sim_name&#125; \</span><br><span class="line">		-l compile.log \</span><br><span class="line">		-f filelist.f \</span><br><span class="line"></span><br><span class="line"><span class="section">sim:</span></span><br><span class="line">	./$&#123;sim_name&#125; $&#123;vpd_name&#125; -l sim.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<strong>仿真完成后</strong>会生成simv_counter.vpd波形文件</p>
<ul>
<li>可以使用<code>dve -vpd simv_counter.vpd &amp;</code>查看波形</li>
<li>或者使用<code>dve &amp;</code>打开gui界面后，再点击file处加载vpd文件</li>
</ul>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826203856375.png" alt="image-20230826203856375"></p>
</li>
</ul>
<h2 id="2-vcdplusmemon-的使用"><a href="#2-vcdplusmemon-的使用" class="headerlink" title="2.$vcdplusmemon()的使用"></a>2.$vcdplusmemon()的使用</h2><ul>
<li><p>VCS默认是不会记录数组波形的</p>
</li>
<li><p>若通过<code>$readmemh</code>读取文件中的数据，在Testbench中不添加<code>$vcdplusmemon()</code>时，读取的数据不会保存至vpd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//test readmemh</span><br><span class="line">logic [7:0] mem[0:15];</span><br><span class="line">integer i;</span><br><span class="line">initial begin</span><br><span class="line">    $readmemh(&quot;./data/src.txt&quot;, mem);</span><br><span class="line">    for(i = 0; i&lt;16; i = i + 1) begin</span><br><span class="line">        $display(&quot;mem[%2d] = %0h&quot;, i, mem[i]);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>src.txt</li>
</ul>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826213100490.png" alt="image-20230826213100490" style="zoom:50%;"></p>
<ul>
<li>打印相关信息</li>
</ul>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826211349689.png" alt="image-20230826211349689" style="zoom:50%;"></p>
<ul>
<li>下图说明通过readmem读取的数据未保存至vpd文件中</li>
</ul>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826211205796.png" alt="image-20230826211205796"></p>
</li>
</ul>
<ul>
<li><p>若在Testbench中加上<code>$vcdplusmemon()</code>，则能将数据保存至vpd文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//dump vpd file</span><br><span class="line"> initial begin</span><br><span class="line"> `ifdef DUMP_VPD</span><br><span class="line">     //$vcdpluson();</span><br><span class="line">     $vcdpluson(1, counter_tb); //only save 1-layer wave message</span><br><span class="line">     $vcdplusmemon();</span><br><span class="line"> `endif</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<ul>
<li>此时读取的数据被保存至vpd文件中</li>
</ul>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826212115924.png" alt="image-20230826212115924"></p>
</li>
</ul>
<h2 id="3-39-FILE-39-LINE-两个宏"><a href="#3-39-FILE-39-LINE-两个宏" class="headerlink" title="3.&#39;__FILE__, &#39;__LINE__两个宏"></a>3.<code>&#39;__FILE__,</code> <code>&#39;__LINE__</code>两个宏</h2><ul>
<li><p>执行仿真之后，由于有上面的宏，将显示出文件路径以及执行的行数</p>
</li>
<li><p>源代码与testbench：</p>
<ul>
<li><p>counter.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module counter(</span><br><span class="line">    input clk,</span><br><span class="line">    input rst,</span><br><span class="line">    output logic [5:0] count</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    always @(posedge clk or negedge rst) begin</span><br><span class="line">        if(!rst)</span><br><span class="line">            count &lt;= 0;</span><br><span class="line">        else </span><br><span class="line">            count &lt;= count + 6&#x27;b1;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    initial begin</span><br><span class="line">      $display(&quot;Hello Verilog! \t&quot;,`__FILE__,`__LINE__);</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
</li>
<li><p>counter_tb.sv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module counter_tb();</span><br><span class="line">    </span><br><span class="line">    logic clk;</span><br><span class="line">    logic rst;</span><br><span class="line">    wire [5:0] count;</span><br><span class="line"></span><br><span class="line">    counter u1(clk, rst, count);</span><br><span class="line"></span><br><span class="line">    always #(5) begin</span><br><span class="line">        clk = ~clk;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    initial begin</span><br><span class="line">        clk = 0;</span><br><span class="line">        rst = 0;</span><br><span class="line"></span><br><span class="line">        #20;</span><br><span class="line">        rst = 1;</span><br><span class="line">        #50;</span><br><span class="line">        if(count != 5)</span><br><span class="line">            $display(&quot;Failure 1: the counter should be 5 but it is %d&quot;, count);</span><br><span class="line">        else</span><br><span class="line">            $display(&quot;You gotta the right result! It is five!&quot;);</span><br><span class="line">        $finish;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    //dump vpd file</span><br><span class="line">    initial begin</span><br><span class="line">    `ifdef DUMP_VPD</span><br><span class="line">        //$vcdpluson();</span><br><span class="line">        $vcdpluson(1, counter_tb); //only save 1-layer wave message</span><br><span class="line">        $vcdplusmemon();</span><br><span class="line">    `endif</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    //test readmemh</span><br><span class="line">    logic [7:0] mem[0:15];</span><br><span class="line">    integer i;</span><br><span class="line">    initial begin</span><br><span class="line">        $readmemh(&quot;./data/src.txt&quot;, mem);</span><br><span class="line">        for(i = 0; i&lt;16; i = i + 1) begin</span><br><span class="line">            $display(&quot;mem[%2d] = %0h&quot;, i, mem[i]);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    initial begin</span><br><span class="line">      $display(&quot;Hello Verilog! \t&quot;,`__FILE__,`__LINE__);</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    initial begin</span><br><span class="line">      $display(&quot;Hello Verilog! \t&quot;,`__FILE__,`__LINE__);</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
</li>
</ul>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230826214450732.png" alt="image-20230826214450732" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="4-gui界面"><a href="#4-gui界面" class="headerlink" title="4.gui界面"></a>4.gui界面</h2><ul>
<li>若仅仅是想交互性的观察仿真波形，可在编译后使用<code>/simv_counter -gui &amp;</code> 来记载可视化界面</li>
</ul>
<hr>
<h1 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h1><ul>
<li>Line coverage：行覆盖率，是否每一行都执行并且代码是完整的。例：缺少else，default；但这不一定是错误，可能故意为之；二次检查</li>
<li>Toggle coverage：检查电路的每个节点是否都有 0 -&gt; 1 和 1 -&gt; 0 的跳变，但x-&gt;1,x-&gt;0不会检测，这种检查通常会使仿真变慢很多</li>
<li>Condition coverage：条件覆盖率：代码中有if语句，实际可能出现某种情况，但程序没有覆盖</li>
<li>FSM coverage：检测状态与状态之间是否都有跳转</li>
<li><p>path coverage：在always语句块和initial语句块中，有时会使用 if … else 和 case 语句，在电路结构上便会产生一系列的数据路径，检查这些路径的覆盖情况</p>
</li>
<li><p><strong>Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: clean comp sim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if you want to delete simv, recommend simv_* to rename</span></span><br><span class="line">sim_name = simv_counter</span><br><span class="line"></span><br><span class="line"><span class="comment">#set a new vpd file name</span></span><br><span class="line">vpd_name = +vpdfile+$&#123;sim_name&#125;.vpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#Code coverage command</span></span><br><span class="line">CM = -cm line+cond+fsm+branch+tgl</span><br><span class="line">CM_NAME = -cm_name $&#123;sim_name&#125;</span><br><span class="line">CM_DIR = -cm_dir ./$&#123;sim_name&#125;.vdb</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf ./csrc *.daidir *.log simv* *.key *.vpd ./DVEfiles $&#123;sim_name&#125; *.vdb</span><br><span class="line"></span><br><span class="line"><span class="section">comp:</span></span><br><span class="line">	vcs -full64 -cpp g++ -cc gcc -LDFLAGS -no-pie -LDFLAGS -Wl,--no-as-needed -CFLAGS -fPIE \</span><br><span class="line">		-sverilog +v2k -timescale=1ns/1ps \</span><br><span class="line">		-debug_acc+all \</span><br><span class="line">		$&#123;vpd_name&#125; \</span><br><span class="line">		$&#123;CM&#125; \</span><br><span class="line">		$&#123;CM_NAME&#125; \</span><br><span class="line">		$&#123;CM_DIR&#125; \</span><br><span class="line">		-o $&#123;sim_name&#125; \</span><br><span class="line">		-l compile.log \</span><br><span class="line">		-f filelist.f \</span><br><span class="line"></span><br><span class="line"><span class="section">sim:</span></span><br><span class="line">	./$&#123;sim_name&#125; \</span><br><span class="line">	$&#123;vpd_name&#125; \</span><br><span class="line">	$&#123;CM&#125; $&#123;CM_NAME&#125; $&#123;CM_DIR&#125; \</span><br><span class="line">	-l sim.log \</span><br><span class="line"></span><br><span class="line"><span class="comment">#show the coverage</span></span><br><span class="line"><span class="section">cov:</span></span><br><span class="line">	dve -full64 -covdir *.vdb &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>make cov</code>显示覆盖率的可视化页面（<strong>要在仿真之后查看</strong>）</p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230829164110384.png" alt="image-20230829164110384"></p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230829164228600.png" alt="image-20230829164228600"></p>
</li>
<li><p>还可以通过<strong>网页查看覆盖率报告</strong>：</p>
</li>
</ul>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230829165217506.png" alt="image-20230829165217506" style="zoom:50%;"></p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230829165441850.png" alt="image-20230829165441850" style="zoom:50%;"></p>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230829165531692.png" alt="image-20230829165531692" style="zoom: 50%;"></p>
<ul>
<li><p><strong>屏蔽覆盖率</strong>：</p>
<ul>
<li><p>针对某段code屏蔽覆盖率报告但不屏蔽综合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//VCS coverage off</span><br><span class="line">initial begin</span><br><span class="line">  $display(&quot;Hello Verilog! \t&quot;,`__FILE__,`__LINE__);</span><br><span class="line">end</span><br><span class="line">//VCS coverage on</span><br></pre></td></tr></table></figure>
<p><img src="/2023/08/25/VCS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20230829170245507.png" alt="image-20230829170245507" style="zoom: 67%;"></p>
</li>
<li><p>针对某段code屏蔽覆盖率报告且屏蔽综合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//synopsys translate_off</span><br><span class="line">initial begin</span><br><span class="line">  $display(&quot;Hello Verilog! \t&quot;,`__FILE__,`__LINE__);</span><br><span class="line">end</span><br><span class="line">//synopsys translate_on</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/127335447">VCS入门教程(一) - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/129034106">VCS入门教程(二) - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143164198">VCS入门教程(三) - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV1oF411Y7hh?p=6&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">【降噪版】6 Fast Gate-level verification_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VCS</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch之Transformer</title>
    <url>/2023/08/24/Pytorch%E4%B9%8BTransformer/</url>
    <content><![CDATA[<p>本节主要介绍了Transformer的基本框架，以及相关难以理解的细节</p>
<span id="more"></span>
<h1 id="Transformer的基本架构"><a href="#Transformer的基本架构" class="headerlink" title="Transformer的基本架构"></a>Transformer的基本架构</h1><p><img src="/2023/08/24/Pytorch%E4%B9%8BTransformer/image-20230824185446460.png" alt="image-20230824185446460" style="zoom: 67%;"></p>
<ul>
<li>Transformer总体框架可分为四个部分：<ul>
<li>输入部分</li>
<li>输出部分</li>
<li>编码器部分</li>
<li>解码器部分</li>
</ul>
</li>
</ul>
<h2 id="1-输入部分"><a href="#1-输入部分" class="headerlink" title="1.输入部分"></a>1.输入部分</h2><ul>
<li><p>源文本嵌入层及其位置编码器</p>
</li>
<li><p>目标文本嵌入层及其位置编码器</p>
<p><img src="/2023/08/24/Pytorch%E4%B9%8BTransformer/image-20230824185730961.png" alt="image-20230824185730961"></p>
</li>
</ul>
<h2 id="2-输出部分"><a href="#2-输出部分" class="headerlink" title="2.输出部分"></a>2.输出部分</h2><ul>
<li><p>线性层</p>
</li>
<li><p>softmax层</p>
<p><img src="/2023/08/24/Pytorch%E4%B9%8BTransformer/image-20230824185805336.png" alt="image-20230824185805336"></p>
</li>
</ul>
<h2 id="3-编码器部分"><a href="#3-编码器部分" class="headerlink" title="3.编码器部分"></a>3.编码器部分</h2><ul>
<li><p>由N个编码器堆叠而成</p>
</li>
<li><p>每个编码器层由两个子层连接结构组成</p>
</li>
<li><p>第一个子层连接结构包括一个多头自注意力层和规范化层以及一个残差连接</p>
</li>
<li><p>第二个子层连接结构包括一个前馈全连接子层和规范化层以及一个残差连接</p>
<p><img src="/2023/08/24/Pytorch%E4%B9%8BTransformer/image-20230824190116917.png" alt="image-20230824190116917"></p>
</li>
</ul>
<h2 id="4-解码器部分"><a href="#4-解码器部分" class="headerlink" title="4.解码器部分"></a>4.解码器部分</h2><ul>
<li><p>由N个编码器堆叠而成</p>
</li>
<li><p>每个编码器层由三个子层连接结构组成</p>
</li>
<li><p>第一个子层连接结构包括一个多头自注意力层和规范化层以及一个残差连接</p>
</li>
<li><p>第一个子层连接结构包括一个多头注意力层和规范化层以及一个残差连接</p>
</li>
<li><p>第三个子层连接结构包括一个前馈全连接子层和规范化层以及一个残差连接</p>
<p><img src="/2023/08/24/Pytorch%E4%B9%8BTransformer/image-20230824190320460.png" alt="image-20230824190320460"></p>
</li>
</ul>
<hr>
<h1 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h1><ul>
<li><p>位置编码器的作用：因为在Transformer的编码器结构中，并没有针对词汇位置信息的处理，因此需要在embedding层后加入位置编码器，将词汇位置不同而可能产生不同语义的信息加入到词嵌入张量中，以弥补位置信息的缺失</p>
</li>
<li><p>根据视频中所述公式计算：<a href="https://www.bilibili.com/video/BV1yG411Z78H/?spm_id_from=333.337.search-card.all.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">transformer计算位置编码的过程示例_哔哩哔哩_bilibili</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment">#关于word embedding，以序列建模为例</span></span><br><span class="line"><span class="comment">#考虑source sentence和target sentence</span></span><br><span class="line"><span class="comment">#构建序列，序列的字符以其在词表中的索引形式表示</span></span><br><span class="line">batch_size = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#单词表的大小</span></span><br><span class="line">max_num_src_words = <span class="number">8</span></span><br><span class="line">max_num_tgt_words = <span class="number">8</span></span><br><span class="line">model_dim = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#序列的最大长度</span></span><br><span class="line">max_src_seq_len = <span class="number">5</span></span><br><span class="line">max_tgt_seq_len = <span class="number">5</span></span><br><span class="line">max_position_len = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">src_len = torch.tensor([<span class="number">2</span>, <span class="number">4</span>], dtype = torch.int32)</span><br><span class="line">tgt_len = torch.tensor([<span class="number">4</span>, <span class="number">3</span>], dtype = torch.int32)</span><br><span class="line"></span><br><span class="line"><span class="comment">#单词索引构成的句子</span></span><br><span class="line">src_seq = torch.cat([torch.unsqueeze(F.pad(torch.randint(<span class="number">0</span>, max_num_src_words, (L,)), (<span class="number">0</span>, max_src_seq_len - L)), <span class="number">0</span>) </span><br><span class="line">                     <span class="keyword">for</span> L <span class="keyword">in</span> src_len])</span><br><span class="line">tgt_seq = torch.cat([torch.unsqueeze(F.pad(torch.randint(<span class="number">0</span>, max_num_tgt_words, (L,)), (<span class="number">0</span>, max_tgt_seq_len - L)), <span class="number">0</span>) </span><br><span class="line">                     <span class="keyword">for</span> L <span class="keyword">in</span> src_len])</span><br><span class="line"></span><br><span class="line"><span class="comment">#构造embedding</span></span><br><span class="line">src_embedding_table = nn.Embedding(max_num_src_words, model_dim, padding_idx = <span class="number">7</span>)</span><br><span class="line">tgt_embedding_table = nn.Embedding(max_num_tgt_words, model_dim, padding_idx = <span class="number">7</span>)</span><br><span class="line">src_embedding = src_embedding_table(src_seq)</span><br><span class="line">tgt_embedding = tgt_embedding_table(tgt_seq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(src_embedding)</span></span><br><span class="line"><span class="comment"># print(tgt_embedding)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#构造position embedding</span></span><br><span class="line">pos_mat = torch.arange(max_position_len).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">i_mat_even = torch.<span class="built_in">pow</span>(<span class="number">10000</span>, torch.arange(<span class="number">0</span>, model_dim, <span class="number">2</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)/model_dim)</span><br><span class="line">i_mat_odd = torch.<span class="built_in">pow</span>(<span class="number">10000</span>, torch.arange(<span class="number">1</span>, model_dim, <span class="number">2</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)/model_dim)</span><br><span class="line">pe_embedding_table = torch.zeros(max_position_len, model_dim)</span><br><span class="line">pe_embedding_table[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(pos_mat / i_mat_even)</span><br><span class="line">pe_embedding_table[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(pos_mat / i_mat_odd)</span><br><span class="line"></span><br><span class="line">pe_embedding = nn.Embedding(max_position_len, model_dim)</span><br><span class="line">pe_embedding.weight = nn.Parameter(pe_embedding_table, requires_grad = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">src_pos = torch.cat([torch.unsqueeze(torch.arange(<span class="built_in">max</span>(src_len)), <span class="number">0</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> src_len]).to(torch.int32)</span><br><span class="line">tgt_pos = torch.cat([torch.unsqueeze(torch.arange(<span class="built_in">max</span>(tgt_len)), <span class="number">0</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> tgt_len]).to(torch.int32)</span><br><span class="line"></span><br><span class="line">src_pe_embedding = pe_embedding(src_pos) <span class="comment">#只与句子中词的位置有关</span></span><br><span class="line">tgt_pe_embedding = pe_embedding(tgt_pos)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(src_pe_embedding)</span><br><span class="line"><span class="built_in">print</span>(tgt_pe_embedding)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[[0.0000e+00, 1.0000e+00, 0.0000e+00, 1.0000e+00, 0.0000e+00,</span><br><span class="line">          1.0000e+00, 0.0000e+00],</span><br><span class="line">         [8.4147e-01, 9.6423e-01, 7.1906e-02, 9.9981e-01, 5.1794e-03,</span><br><span class="line">          1.0000e+00, 3.7276e-04],</span><br><span class="line">         [9.0930e-01, 8.5948e-01, 1.4344e-01, 9.9925e-01, 1.0359e-02,</span><br><span class="line">          1.0000e+00, 7.4552e-04],</span><br><span class="line">         [1.4112e-01, 6.9325e-01, 2.1423e-01, 9.9832e-01, 1.5538e-02,</span><br><span class="line">          9.9999e-01, 1.1183e-03]],</span><br><span class="line"></span><br><span class="line">        [[0.0000e+00, 1.0000e+00, 0.0000e+00, 1.0000e+00, 0.0000e+00,</span><br><span class="line">          1.0000e+00, 0.0000e+00],</span><br><span class="line">         [8.4147e-01, 9.6423e-01, 7.1906e-02, 9.9981e-01, 5.1794e-03,</span><br><span class="line">          1.0000e+00, 3.7276e-04],</span><br><span class="line">         [9.0930e-01, 8.5948e-01, 1.4344e-01, 9.9925e-01, 1.0359e-02,</span><br><span class="line">          1.0000e+00, 7.4552e-04],</span><br><span class="line">         [1.4112e-01, 6.9325e-01, 2.1423e-01, 9.9832e-01, 1.5538e-02,</span><br><span class="line">          9.9999e-01, 1.1183e-03]]])</span><br><span class="line">tensor([[[0.0000e+00, 1.0000e+00, 0.0000e+00, 1.0000e+00, 0.0000e+00,</span><br><span class="line">          1.0000e+00, 0.0000e+00],</span><br><span class="line">         [8.4147e-01, 9.6423e-01, 7.1906e-02, 9.9981e-01, 5.1794e-03,</span><br><span class="line">          1.0000e+00, 3.7276e-04],</span><br><span class="line">         [9.0930e-01, 8.5948e-01, 1.4344e-01, 9.9925e-01, 1.0359e-02,</span><br><span class="line">          1.0000e+00, 7.4552e-04],</span><br><span class="line">         [1.4112e-01, 6.9325e-01, 2.1423e-01, 9.9832e-01, 1.5538e-02,</span><br><span class="line">          9.9999e-01, 1.1183e-03]],</span><br><span class="line"></span><br><span class="line">        [[0.0000e+00, 1.0000e+00, 0.0000e+00, 1.0000e+00, 0.0000e+00,</span><br><span class="line">          1.0000e+00, 0.0000e+00],</span><br><span class="line">         [8.4147e-01, 9.6423e-01, 7.1906e-02, 9.9981e-01, 5.1794e-03,</span><br><span class="line">          1.0000e+00, 3.7276e-04],</span><br><span class="line">         [9.0930e-01, 8.5948e-01, 1.4344e-01, 9.9925e-01, 1.0359e-02,</span><br><span class="line">          1.0000e+00, 7.4552e-04],</span><br><span class="line">         [1.4112e-01, 6.9325e-01, 2.1423e-01, 9.9832e-01, 1.5538e-02,</span><br><span class="line">          9.9999e-01, 1.1183e-03]]])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="多头自注意机制的结构及其原理"><a href="#多头自注意机制的结构及其原理" class="headerlink" title="多头自注意机制的结构及其原理"></a>多头自注意机制的结构及其原理</h1><ul>
<li><p>注意力的基本结构：</p>
<p><img src="/2023/08/24/Pytorch%E4%B9%8BTransformer/image-20230903231429391.png" alt="image-20230903231429391" style="zoom:50%;"></p>
<ul>
<li><p>若Q、K来自不同输入，则是注意力机制，若Q、K输入来自同一输入，则是自注意力机制</p>
</li>
<li><p>其计算公式如下：</p>
<script type="math/tex; mode=display">
Z=softmax(\frac{Q\times K^T}{\sqrt{d_k}})\cdot V</script></li>
</ul>
</li>
<li><p>那么Q、K、V是如何计算得到的呢？</p>
<ul>
<li><p>假设以下计算均是针对自注意机制，同一输入分别与三个权重矩阵$W^Q,W^K,W^V$相乘，即可得到Q、K、V</p>
<p><img src="/2023/08/24/Pytorch%E4%B9%8BTransformer/image-20230903232947833.png" alt="image-20230903232947833" style="zoom: 33%;"></p>
</li>
<li><p>从图中可以很明显的看出来，<strong>全连接层</strong>能很好的实现这一过程</p>
</li>
</ul>
</li>
<li><p>那么$Q\times K^T$相乘又意味着什么呢？</p>
<ul>
<li><p>$softmax(\frac{Q\times K^T}{\sqrt{d_k}})$计算后的结果表示的是Q（约等于输入）中每个单词对K（约等于输入）中每个单词的相关性</p>
</li>
<li><p>不难发现，$Q\times K^T$后的维度变成了$(len\times len)$</p>
</li>
<li><p>所以我的理解是，首先通过全连接层将<strong>词向量维度</strong>变成<strong>K的维度</strong>，接着通过<strong>attention操作</strong>变到<strong>句长的维度</strong>，以便获取<strong>单词对单词之间相关性的权重矩阵</strong></p>
</li>
<li><p>最后，用这个权重矩阵对V进行加权求和，而这个V可以理解为一个初始答案，经过权重矩阵的训练之后，得到一个尽可能标准的答案，最终Z的最后两个维度为$(len\times d_v)$</p>
<p><img src="/2023/08/24/Pytorch%E4%B9%8BTransformer/image-20230903234454290.png" alt="image-20230903234454290" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>那么什么是多头注意力机制呢？</p>
<ul>
<li>就是用不同的矩阵与输入相乘，从而得到不同组的Q、K、V，以此获得更多空间维度的特征</li>
</ul>
<p><img src="/2023/08/24/Pytorch%E4%B9%8BTransformer/image-20230904000023238.png" alt="image-20230904000023238" style="zoom:50%;"></p>
<ul>
<li><p>其实现代码如下，值得细细品味：</p>
<ul>
<li>首先在<code>self.W_Q</code>的<code>nn.Linear</code>中，本来是将d_model维变到d_k维，但是由于是多头，故乘以了一个n_heads</li>
<li>其次在<code>self.linear</code>的<code>nn.Linear</code>中，需要将维度变回d_model，以便下一次堆叠计算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiHeadAttention, self).__init__()</span><br><span class="line">        <span class="comment">## 输入进来的QKV是相等的，我们会使用映射linear做一个映射得到参数矩阵Wq, Wk,Wv</span></span><br><span class="line">        self.W_Q = nn.Linear(d_model, d_k * n_heads)</span><br><span class="line">        self.W_K = nn.Linear(d_model, d_k * n_heads)</span><br><span class="line">        self.W_V = nn.Linear(d_model, d_v * n_heads)</span><br><span class="line">        self.linear = nn.Linear(n_heads * d_v, d_model)</span><br><span class="line">        self.layer_norm = nn.LayerNorm(d_model)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, attn_mask</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 这个多头分为这几个步骤，首先映射分头，然后计算atten_scores，然后计算atten_value;</span></span><br><span class="line">        <span class="comment">##输入进来的数据形状： Q: [batch_size x len_q x d_model], K: [batch_size x len_k x d_model], V: [batch_size x len_k x d_model]</span></span><br><span class="line">        residual, batch_size = Q, Q.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># (B, S, D) -proj-&gt; (B, S, D) -split-&gt; (B, S, H, W) -trans-&gt; (B, H, S, W)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">##下面这个就是先映射，后分头；一定要注意的是q和k分头之后维度是一致额，所以一看这里都是dk</span></span><br><span class="line">        q_s = self.W_Q(Q).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment"># q_s: [batch_size x n_heads x len_q x d_k]</span></span><br><span class="line">        k_s = self.W_K(K).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment"># k_s: [batch_size x n_heads x len_k x d_k]</span></span><br><span class="line">        v_s = self.W_V(V).view(batch_size, -<span class="number">1</span>, n_heads, d_v).transpose(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment"># v_s: [batch_size x n_heads x len_k x d_v]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## 输入进行的attn_mask形状是 batch_size x len_q x len_k，然后经过下面这个代码得到新的attn_mask : [batch_size x n_heads x len_q x len_k]，就是把pad信息重复了n个头上</span></span><br><span class="line">        attn_mask = attn_mask.unsqueeze(<span class="number">1</span>).repeat(<span class="number">1</span>, n_heads, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">##然后我们计算 ScaledDotProductAttention 这个函数，去7.看一下</span></span><br><span class="line">        <span class="comment">## 得到的结果有两个：context: [batch_size x n_heads x len_q x d_v], attn: [batch_size x n_heads x len_q x len_k]</span></span><br><span class="line">        context, attn = ScaledDotProductAttention()(q_s, k_s, v_s, attn_mask)</span><br><span class="line">        context = context.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(batch_size, -<span class="number">1</span>, n_heads * d_v) <span class="comment"># context: [batch_size x len_q x n_heads * d_v]</span></span><br><span class="line">        output = self.linear(context)</span><br><span class="line">        <span class="keyword">return</span> self.layer_norm(output + residual), attn <span class="comment"># output: [batch_size x len_q x d_model]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="两个输入与标签值的理解"><a href="#两个输入与标签值的理解" class="headerlink" title="两个输入与标签值的理解"></a>两个输入与标签值的理解</h1><ul>
<li>在训练时一个输入是input，另一个输入是掩码遮掩的标签值，经过网络训练后的结果与标签值比较，计算损失，以不断调整网络，详情见这篇文章：<a href="https://zhuanlan.zhihu.com/p/166608727">举个例子讲下transformer的输入输出细节及其他 - 知乎 (zhihu.com)</a></li>
<li>而在测试时，另一个输入需要选输入\<start>起始符，将网络得到的结果再输入，以此迭代，详情见这篇文章：<a href="https://wmathor.com/index.php/archives/1455/">Transformer的PyTorch实现 - mathor (wmathor.com)</a>中的测试部分</start></li>
</ul>
<hr>
<h1 id="BatchNorm与LayerNorm的区别"><a href="#BatchNorm与LayerNorm的区别" class="headerlink" title="BatchNorm与LayerNorm的区别"></a>BatchNorm与LayerNorm的区别</h1><ul>
<li>BN是针对不同batch下同一特征求均值和方差</li>
<li>LN是针对一个样本中所有单词求均值和方差</li>
<li>可以看下面两个视频帮助理解<ul>
<li><a href="https://www.bilibili.com/video/BV1Di4y1c7Zm?p=5&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">5.Batch Normal详解_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1Di4y1c7Zm?p=6&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">6.layer normal 详解_哔哩哔哩_bilibili</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="Transformer的示例代码"><a href="#Transformer的示例代码" class="headerlink" title="Transformer的示例代码"></a>Transformer的示例代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## from https://github.com/graykode/nlp-tutorial/tree/master/5-1.Transformer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_batch</span>(<span class="params">sentences</span>):</span><br><span class="line">    input_batch = [[src_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[<span class="number">0</span>].split()]]</span><br><span class="line">    output_batch = [[tgt_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[<span class="number">1</span>].split()]]</span><br><span class="line">    target_batch = [[tgt_vocab[n] <span class="keyword">for</span> n <span class="keyword">in</span> sentences[<span class="number">2</span>].split()]]</span><br><span class="line">    <span class="keyword">return</span> torch.LongTensor(input_batch), torch.LongTensor(output_batch), torch.LongTensor(target_batch)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_subsequent_mask</span>(<span class="params">seq</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    seq: [batch_size, tgt_len]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    attn_shape = [seq.size(<span class="number">0</span>), seq.size(<span class="number">1</span>), seq.size(<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># attn_shape: [batch_size, tgt_len, tgt_len]</span></span><br><span class="line">    subsequence_mask = np.triu(np.ones(attn_shape), k=<span class="number">1</span>)  <span class="comment"># 生成一个上三角矩阵</span></span><br><span class="line">    subsequence_mask = torch.from_numpy(subsequence_mask).byte()</span><br><span class="line">    <span class="keyword">return</span> subsequence_mask  <span class="comment"># [batch_size, tgt_len, tgt_len]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 7. ScaledDotProductAttention</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScaledDotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ScaledDotProductAttention, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, attn_mask</span>):</span><br><span class="line">        <span class="comment">## 输入进来的维度分别是 [batch_size x n_heads x len_q x d_k]  K： [batch_size x n_heads x len_k x d_k]  V: [batch_size x n_heads x len_k x d_v]</span></span><br><span class="line">        <span class="comment">##首先经过matmul函数得到的scores形状是 : [batch_size x n_heads x len_q x len_k]</span></span><br><span class="line">        scores = torch.matmul(Q, K.transpose(-<span class="number">1</span>, -<span class="number">2</span>)) / np.sqrt(d_k)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 然后关键词地方来了，下面这个就是用到了我们之前重点讲的attn_mask，把被mask的地方置为无限小，softmax之后基本就是0，对q的单词不起作用</span></span><br><span class="line">        scores.masked_fill_(attn_mask, -<span class="number">1e9</span>) <span class="comment"># Fills elements of self tensor with value where mask is one.</span></span><br><span class="line">        attn = nn.Softmax(dim=-<span class="number">1</span>)(scores)</span><br><span class="line">        context = torch.matmul(attn, V)</span><br><span class="line">        <span class="keyword">return</span> context, attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 6. MultiHeadAttention</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiHeadAttention, self).__init__()</span><br><span class="line">        <span class="comment">## 输入进来的QKV是相等的，我们会使用映射linear做一个映射得到参数矩阵Wq, Wk,Wv</span></span><br><span class="line">        self.W_Q = nn.Linear(d_model, d_k * n_heads)</span><br><span class="line">        self.W_K = nn.Linear(d_model, d_k * n_heads)</span><br><span class="line">        self.W_V = nn.Linear(d_model, d_v * n_heads)</span><br><span class="line">        self.linear = nn.Linear(n_heads * d_v, d_model)</span><br><span class="line">        self.layer_norm = nn.LayerNorm(d_model)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, Q, K, V, attn_mask</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 这个多头分为这几个步骤，首先映射分头，然后计算atten_scores，然后计算atten_value;</span></span><br><span class="line">        <span class="comment">##输入进来的数据形状： Q: [batch_size x len_q x d_model], K: [batch_size x len_k x d_model], V: [batch_size x len_k x d_model]</span></span><br><span class="line">        residual, batch_size = Q, Q.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># (B, S, D) -proj-&gt; (B, S, D) -split-&gt; (B, S, H, W) -trans-&gt; (B, H, S, W)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">##下面这个就是先映射，后分头；一定要注意的是q和k分头之后维度是一致额，所以一看这里都是dk</span></span><br><span class="line">        q_s = self.W_Q(Q).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment"># q_s: [batch_size x n_heads x len_q x d_k]</span></span><br><span class="line">        k_s = self.W_K(K).view(batch_size, -<span class="number">1</span>, n_heads, d_k).transpose(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment"># k_s: [batch_size x n_heads x len_k x d_k]</span></span><br><span class="line">        v_s = self.W_V(V).view(batch_size, -<span class="number">1</span>, n_heads, d_v).transpose(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment"># v_s: [batch_size x n_heads x len_k x d_v]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## 输入进行的attn_mask形状是 batch_size x len_q x len_k，然后经过下面这个代码得到新的attn_mask : [batch_size x n_heads x len_q x len_k]，就是把pad信息重复了n个头上</span></span><br><span class="line">        attn_mask = attn_mask.unsqueeze(<span class="number">1</span>).repeat(<span class="number">1</span>, n_heads, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">##然后我们计算 ScaledDotProductAttention 这个函数，去7.看一下</span></span><br><span class="line">        <span class="comment">## 得到的结果有两个：context: [batch_size x n_heads x len_q x d_v], attn: [batch_size x n_heads x len_q x len_k]</span></span><br><span class="line">        context, attn = ScaledDotProductAttention()(q_s, k_s, v_s, attn_mask)</span><br><span class="line">        context = context.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(batch_size, -<span class="number">1</span>, n_heads * d_v) <span class="comment"># context: [batch_size x len_q x n_heads * d_v]</span></span><br><span class="line">        output = self.linear(context)</span><br><span class="line">        <span class="keyword">return</span> self.layer_norm(output + residual), attn <span class="comment"># output: [batch_size x len_q x d_model]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 8. PoswiseFeedForwardNet</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoswiseFeedForwardNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(PoswiseFeedForwardNet, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv1d(in_channels=d_model, out_channels=d_ff, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.conv2 = nn.Conv1d(in_channels=d_ff, out_channels=d_model, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.layer_norm = nn.LayerNorm(d_model)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        residual = inputs <span class="comment"># inputs : [batch_size, len_q, d_model]</span></span><br><span class="line">        output = nn.ReLU()(self.conv1(inputs.transpose(<span class="number">1</span>, <span class="number">2</span>)))</span><br><span class="line">        output = self.conv2(output).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> self.layer_norm(output + residual)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 4. get_attn_pad_mask</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 比如说，我现在的句子长度是5，在后面注意力机制的部分，我们在计算出来QK转置除以根号之后，softmax之前，我们得到的形状</span></span><br><span class="line"><span class="comment">## len_input * len*input  代表每个单词对其余包含自己的单词的影响力</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 所以这里我需要有一个同等大小形状的矩阵，告诉我哪个位置是PAD部分，之后在计算计算softmax之前会把这里置为无穷大；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 一定需要注意的是这里得到的矩阵形状是batch_size x len_q x len_k，我们是对k中的pad符号进行标识，并没有对k中的做标识，因为没必要</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## seq_q 和 seq_k 不一定一致，在交互注意力，q来自解码端，k来自编码端，所以告诉模型编码这边pad符号信息就可以，解码端的pad信息在交互注意力层是没有用到的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_attn_pad_mask</span>(<span class="params">seq_q, seq_k</span>):</span><br><span class="line">    batch_size, len_q = seq_q.size()</span><br><span class="line">    batch_size, len_k = seq_k.size()</span><br><span class="line">    <span class="comment"># eq(zero) is PAD token</span></span><br><span class="line">    pad_attn_mask = seq_k.data.eq(<span class="number">0</span>).unsqueeze(<span class="number">1</span>)  <span class="comment"># batch_size x 1 x len_k, one is masking</span></span><br><span class="line">    <span class="keyword">return</span> pad_attn_mask.expand(batch_size, len_q, len_k)  <span class="comment"># batch_size x len_q x len_k</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 3. PositionalEncoding 代码实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositionalEncoding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, dropout=<span class="number">0.1</span>, max_len=<span class="number">5000</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PositionalEncoding, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 位置编码的实现其实很简单，直接对照着公式去敲代码就可以，下面这个代码只是其中一种实现方式；</span></span><br><span class="line">        <span class="comment">## 从理解来讲，需要注意的就是偶数和奇数在公式上有一个共同部分，我们使用log函数把次方拿下来，方便计算；</span></span><br><span class="line">        <span class="comment">## pos代表的是单词在句子中的索引，这点需要注意；比如max_len是128个，那么索引就是从0，1，2，...,127</span></span><br><span class="line">        <span class="comment">##假设我的demodel是512，2i那个符号中i从0取到了255，那么2i对应取值就是0,2,4...510</span></span><br><span class="line">        self.dropout = nn.Dropout(p=dropout)</span><br><span class="line"></span><br><span class="line">        pe = torch.zeros(max_len, d_model)</span><br><span class="line">        position = torch.arange(<span class="number">0</span>, max_len, dtype=torch.<span class="built_in">float</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        div_term = torch.exp(torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>).<span class="built_in">float</span>() * (-math.log(<span class="number">10000.0</span>) / d_model))</span><br><span class="line">        pe[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)<span class="comment">## 这里需要注意的是pe[:, 0::2]这个用法，就是从0开始到最后面，补长为2，其实代表的就是偶数位置</span></span><br><span class="line">        pe[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)<span class="comment">##这里需要注意的是pe[:, 1::2]这个用法，就是从1开始到最后面，补长为2，其实代表的就是奇数位置</span></span><br><span class="line">        <span class="comment">## 上面代码获取之后得到的pe:[max_len*d_model]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## 下面这个代码之后，我们得到的pe形状是：[max_len*1*d_model]</span></span><br><span class="line">        pe = pe.unsqueeze(<span class="number">0</span>).transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.register_buffer(<span class="string">&#x27;pe&#x27;</span>, pe)  <span class="comment">## 定一个缓冲区，其实简单理解为这个参数不更新就可以</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        x: [seq_len, batch_size, d_model]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        x = x + self.pe[:x.size(<span class="number">0</span>), :]</span><br><span class="line">        <span class="keyword">return</span> self.dropout(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 5. EncoderLayer ：包含两个部分，多头注意力机制和前馈神经网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(EncoderLayer, self).__init__()</span><br><span class="line">        self.enc_self_attn = MultiHeadAttention()</span><br><span class="line">        self.pos_ffn = PoswiseFeedForwardNet()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, enc_self_attn_mask</span>):</span><br><span class="line">        <span class="comment">## 下面这个就是做自注意力层，输入是enc_inputs，形状是[batch_size x seq_len_q x d_model] 需要注意的是最初始的QKV矩阵是等同于这个输入的，去看一下enc_self_attn函数 6.</span></span><br><span class="line">        enc_outputs, attn = self.enc_self_attn(enc_inputs, enc_inputs, enc_inputs, enc_self_attn_mask) <span class="comment"># enc_inputs to same Q,K,V</span></span><br><span class="line">        enc_outputs = self.pos_ffn(enc_outputs) <span class="comment"># enc_outputs: [batch_size x len_q x d_model]</span></span><br><span class="line">        <span class="keyword">return</span> enc_outputs, attn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2. Encoder 部分包含三个部分：词向量embedding，位置编码部分，注意力层及后续的前馈神经网络</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Encoder, self).__init__()</span><br><span class="line">        self.src_emb = nn.Embedding(src_vocab_size, d_model)  <span class="comment">## 这个其实就是去定义生成一个矩阵，大小是 src_vocab_size * d_model</span></span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model) <span class="comment">## 位置编码情况，这里是固定的正余弦函数，也可以使用类似词向量的nn.Embedding获得一个可以更新学习的位置编码</span></span><br><span class="line">        self.layers = nn.ModuleList([EncoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)]) <span class="comment">## 使用ModuleList对多个encoder进行堆叠，因为后续的encoder并没有使用词向量和位置编码，所以抽离出来；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs</span>):</span><br><span class="line">        <span class="comment">## 这里我们的 enc_inputs 形状是： [batch_size x source_len]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## 下面这个代码通过src_emb，进行索引定位，enc_outputs输出形状是[batch_size, src_len, d_model]</span></span><br><span class="line">        enc_outputs = self.src_emb(enc_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 这里就是位置编码，把两者相加放入到了这个函数里面，从这里可以去看一下位置编码函数的实现；3.</span></span><br><span class="line">        enc_outputs = self.pos_emb(enc_outputs.transpose(<span class="number">0</span>, <span class="number">1</span>)).transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">##get_attn_pad_mask是为了得到句子中pad的位置信息，给到模型后面，在计算自注意力和交互注意力的时候去掉pad符号的影响，去看一下这个函数 4.</span></span><br><span class="line">        enc_self_attn_mask = get_attn_pad_mask(enc_inputs, enc_inputs)</span><br><span class="line">        enc_self_attns = []</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            <span class="comment">## 去看EncoderLayer 层函数 5.</span></span><br><span class="line">            enc_outputs, enc_self_attn = layer(enc_outputs, enc_self_attn_mask)</span><br><span class="line">            enc_self_attns.append(enc_self_attn)</span><br><span class="line">        <span class="keyword">return</span> enc_outputs, enc_self_attns</span><br><span class="line"></span><br><span class="line"><span class="comment">## 10.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DecoderLayer, self).__init__()</span><br><span class="line">        self.dec_self_attn = MultiHeadAttention()</span><br><span class="line">        self.dec_enc_attn = MultiHeadAttention()</span><br><span class="line">        self.pos_ffn = PoswiseFeedForwardNet()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_outputs, dec_self_attn_mask, dec_enc_attn_mask</span>):</span><br><span class="line">        dec_outputs, dec_self_attn = self.dec_self_attn(dec_inputs, dec_inputs, dec_inputs, dec_self_attn_mask)</span><br><span class="line">        dec_outputs, dec_enc_attn = self.dec_enc_attn(dec_outputs, enc_outputs, enc_outputs, dec_enc_attn_mask)</span><br><span class="line">        dec_outputs = self.pos_ffn(dec_outputs)</span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attn, dec_enc_attn</span><br><span class="line"></span><br><span class="line"><span class="comment">## 9. Decoder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__()</span><br><span class="line">        self.tgt_emb = nn.Embedding(tgt_vocab_size, d_model)</span><br><span class="line">        self.pos_emb = PositionalEncoding(d_model)</span><br><span class="line">        self.layers = nn.ModuleList([DecoderLayer() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_layers)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, dec_inputs, enc_inputs, enc_outputs</span>): <span class="comment"># dec_inputs : [batch_size x target_len]</span></span><br><span class="line">        dec_outputs = self.tgt_emb(dec_inputs)  <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line">        dec_outputs = self.pos_emb(dec_outputs.transpose(<span class="number">0</span>, <span class="number">1</span>)).transpose(<span class="number">0</span>, <span class="number">1</span>) <span class="comment"># [batch_size, tgt_len, d_model]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## get_attn_pad_mask 自注意力层的时候的pad 部分</span></span><br><span class="line">        dec_self_attn_pad_mask = get_attn_pad_mask(dec_inputs, dec_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## get_attn_subsequent_mask 这个做的是自注意层的mask部分，就是当前单词之后看不到，使用一个上三角为1的矩阵</span></span><br><span class="line">        dec_self_attn_subsequent_mask = get_attn_subsequent_mask(dec_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 两个矩阵相加，大于0的为1，不大于0的为0，为1的在之后就会被fill到无限小</span></span><br><span class="line">        dec_self_attn_mask = torch.gt((dec_self_attn_pad_mask + dec_self_attn_subsequent_mask), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 这个做的是交互注意力机制中的mask矩阵，enc的输入是k，我去看这个k里面哪些是pad符号，给到后面的模型；注意哦，我q肯定也是有pad符号，但是这里我不在意的，之前说了好多次了哈</span></span><br><span class="line">        dec_enc_attn_mask = get_attn_pad_mask(dec_inputs, enc_inputs)</span><br><span class="line"></span><br><span class="line">        dec_self_attns, dec_enc_attns = [], []</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            dec_outputs, dec_self_attn, dec_enc_attn = layer(dec_outputs, enc_outputs, dec_self_attn_mask, dec_enc_attn_mask)</span><br><span class="line">            dec_self_attns.append(dec_self_attn)</span><br><span class="line">            dec_enc_attns.append(dec_enc_attn)</span><br><span class="line">        <span class="keyword">return</span> dec_outputs, dec_self_attns, dec_enc_attns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 1. 从整体网路结构来看，分为三个部分：编码层，解码层，输出层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Transformer, self).__init__()</span><br><span class="line">        self.encoder = Encoder()  <span class="comment">## 编码层</span></span><br><span class="line">        self.decoder = Decoder()  <span class="comment">## 解码层</span></span><br><span class="line">        self.projection = nn.Linear(d_model, tgt_vocab_size, bias=<span class="literal">False</span>) <span class="comment">## 输出层 d_model 是我们解码层每个token输出的维度大小，之后会做一个 tgt_vocab_size 大小的softmax</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, enc_inputs, dec_inputs</span>):</span><br><span class="line">        <span class="comment">## 这里有两个数据进行输入，一个是enc_inputs 形状为[batch_size, src_len]，主要是作为编码段的输入，一个dec_inputs，形状为[batch_size, tgt_len]，主要是作为解码端的输入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## enc_inputs作为输入 形状为[batch_size, src_len]，输出由自己的函数内部指定，想要什么指定输出什么，可以是全部tokens的输出，可以是特定每一层的输出；也可以是中间某些参数的输出；</span></span><br><span class="line">        <span class="comment">## enc_outputs就是主要的输出，enc_self_attns这里没记错的是QK转置相乘之后softmax之后的矩阵值，代表的是每个单词和其他单词相关性；</span></span><br><span class="line">        enc_outputs, enc_self_attns = self.encoder(enc_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## dec_outputs 是decoder主要输出，用于后续的linear映射； dec_self_attns类比于enc_self_attns 是查看每个单词对decoder中输入的其余单词的相关性；dec_enc_attns是decoder中每个单词对encoder中每个单词的相关性；</span></span><br><span class="line">        dec_outputs, dec_self_attns, dec_enc_attns = self.decoder(dec_inputs, enc_inputs, enc_outputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## dec_outputs做映射到词表大小</span></span><br><span class="line">        dec_logits = self.projection(dec_outputs) <span class="comment"># dec_logits : [batch_size x src_vocab_size x tgt_vocab_size]</span></span><br><span class="line">        <span class="keyword">return</span> dec_logits.view(-<span class="number">1</span>, dec_logits.size(-<span class="number">1</span>)), enc_self_attns, dec_self_attns, dec_enc_attns</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 句子的输入部分，</span></span><br><span class="line">    sentences = [<span class="string">&#x27;ich mochte ein bier P&#x27;</span>, <span class="string">&#x27;S i want a beer&#x27;</span>, <span class="string">&#x27;i want a beer E&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Transformer Parameters</span></span><br><span class="line">    <span class="comment"># Padding Should be Zero</span></span><br><span class="line">    <span class="comment">## 构建词表</span></span><br><span class="line">    src_vocab = &#123;<span class="string">&#x27;P&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;ich&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;mochte&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;ein&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;bier&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    src_vocab_size = <span class="built_in">len</span>(src_vocab)</span><br><span class="line"></span><br><span class="line">    tgt_vocab = &#123;<span class="string">&#x27;P&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;want&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;beer&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;S&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line">    tgt_vocab_size = <span class="built_in">len</span>(tgt_vocab)</span><br><span class="line"></span><br><span class="line">    src_len = <span class="number">5</span> <span class="comment"># length of source</span></span><br><span class="line">    tgt_len = <span class="number">5</span> <span class="comment"># length of target</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 模型参数</span></span><br><span class="line">    d_model = <span class="number">512</span>  <span class="comment"># Embedding Size</span></span><br><span class="line">    d_ff = <span class="number">2048</span>  <span class="comment"># FeedForward dimension</span></span><br><span class="line">    d_k = d_v = <span class="number">64</span>  <span class="comment"># dimension of K(=Q), V</span></span><br><span class="line">    n_layers = <span class="number">6</span>  <span class="comment"># number of Encoder of Decoder Layer</span></span><br><span class="line">    n_heads = <span class="number">8</span>  <span class="comment"># number of heads in Multi-Head Attention</span></span><br><span class="line"></span><br><span class="line">    model = Transformer()</span><br><span class="line"></span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    enc_inputs, dec_inputs, target_batch = make_batch(sentences)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs, enc_self_attns, dec_self_attns, dec_enc_attns = model(enc_inputs, dec_inputs)</span><br><span class="line">        loss = criterion(outputs, target_batch.contiguous().view(-<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#x27;</span>, <span class="string">&#x27;%04d&#x27;</span> % (epoch + <span class="number">1</span>), <span class="string">&#x27;cost =&#x27;</span>, <span class="string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(loss))</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV188411H71g/?spm_id_from=333.337.search-card.all.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">这是B站目前讲的最好的【Transformer实战】教程！带你从零详细解读Transformer模型 一次学到饱！——人工智能、深度学习、神经网络_哔哩哔哩_bilibili</a>（只适合学习基本架构部分）</li>
<li><a href="https://www.bilibili.com/video/BV1cP4y1V7GF/?spm_id_from=333.788&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">19、Transformer模型Encoder原理精讲及其PyTorch逐行实现_哔哩哔哩_bilibili</a>（位置编码以及mask的细节可以看这个视频）</li>
<li><a href="https://blog.csdn.net/qq_41139677/article/details/125252352">【深度学习】Transformer中的mask机制超详细讲解_Articoder的博客-CSDN博客</a>（mask的理解还可参考这篇文章）</li>
<li><a href="https://zhuanlan.zhihu.com/p/146707216">pytorch 中矩阵乘法总结 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/HW140701/article/details/126341289">Pytorch - masked_fill方法参数详解与使用_HW140701的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/jorg_zhao/article/details/105295686">PyTorch碎片：F.pad的图文透彻理解_pytorch f.pad_柚有所思的博客-CSDN博客</a></li>
<li><a href="https://www.bilibili.com/video/BV1ng4y1K7GZ/?spm_id_from=333.788&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">Transformer 原理详解_哔哩哔哩_bilibili</a>（将transformer的原理细节可视化展示出来了，入门推荐）</li>
<li><a href="https://www.bilibili.com/video/BV1dR4y1E7aL/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">2.Decoder代码解读_哔哩哔哩_bilibili</a>（看完上一个视频的原理详解后，可以看这个视频结合代码进一步理解模型）</li>
<li><a href="https://www.bilibili.com/video/BV1mk4y1q7eK?p=2&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">Transformer的PyTorch实现_哔哩哔哩_bilibili</a></li>
<li><a href="https://blog.csdn.net/watermelon1123/article/details/89954224">Pytorch中nn.ModuleList和nn.Sequential的用法和区别_modulelist是什么作用_叫我西瓜超人的博客-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>SV之线程控制与通信</title>
    <url>/2023/08/23/SV%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>本节主要介绍了SystemVerilog中线程控制与相关通信的方法</p>
<span id="more"></span>
<h1 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a>线程的控制</h1><ul>
<li><code>fork……join</code>需要所有并行线程都结束才会继续执行</li>
<li><code>fork……join_any</code>其中任意一个线程结束就继续执行</li>
<li><code>fork……join_none</code>不等待子线程，直接继续执行</li>
<li>在Fork/Join结构之后，加一句<code>wait fork</code>，会阻塞后续语句，直到fork出来的进程都执行完；如果加一句<code>disable fork</code>，则是直接结束掉fork出来的进程，后续语句往下执行。</li>
</ul>
<hr>
<h1 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h1><h2 id="1-事件event"><a href="#1-事件event" class="headerlink" title="1.事件event"></a>1.事件event</h2><ul>
<li><p>使用<code>@</code>操作符或者<code>wait()</code> 等待事件被触发</p>
</li>
<li><p>使用-<code>&gt;</code>操作符触发事件</p>
<ul>
<li><strong>使用@等待某个事件发生时产生竞争的情况</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`timescale 1ns/10fs</span><br><span class="line"> </span><br><span class="line">module event_test();</span><br><span class="line">  event a;    //使用关键字event来声明一个事件a</span><br><span class="line"> </span><br><span class="line">  initial begin</span><br><span class="line">    #50ns;</span><br><span class="line">    -&gt;a;</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  initial begin</span><br><span class="line">    #50ns;</span><br><span class="line">    @a; //第一个进程在50ns后触发了事件a，第二个进程在50ns的时候等待a，有可能等的到，有可能等不到，产生竞争</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用wait(event_a.triggered) 等待event</strong>：Systemverilog 引入了<strong>triggered()</strong>函数，<strong>用于检测某个事件是否已被触发过，包括正在触发</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module event_test();</span><br><span class="line">  event a;    //使用关键字event来声明一个事件a</span><br><span class="line"> </span><br><span class="line">  initial begin</span><br><span class="line">    #50;</span><br><span class="line">    -&gt;a;</span><br><span class="line">    $display(&quot;Event a is being triggered!&quot;);</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  initial begin</span><br><span class="line">    #20;</span><br><span class="line">    wait(a.triggered); //使用wait来等待事件a，这种方式是一定可以等到a的</span><br><span class="line">    $display(&quot;#20 a.triggered!&quot;);</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  initial begin</span><br><span class="line">    #50;</span><br><span class="line">    wait(a.triggered); //使用wait来等待事件a，这种方式是一定可以等到a的，这是和使用@来等待的区别</span><br><span class="line">    $display(&quot;#50 a.triggered!&quot;);</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  initial begin</span><br><span class="line">    #60;</span><br><span class="line">    wait(a.triggered); //使用wait来等待事件a，a會被trigger一次，並且並且發生在wait之前，永遠等不到</span><br><span class="line">    $display(&quot;#60 a.triggered!&quot;);  //不會被打印</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-旗语semaphore"><a href="#2-旗语semaphore" class="headerlink" title="2.旗语semaphore"></a>2.旗语semaphore</h2><ul>
<li><p>使用旗语可以<strong>实现对同一资源的访问控制</strong></p>
</li>
<li><p>旗语有三种基本操作：</p>
<ul>
<li>new：可以创建一个带单个或者多个钥匙的旗语</li>
<li>get：可以获取一个或多个钥匙</li>
<li>put：可以返回一个或多个钥匙</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">program automatic test(bus_ifc.TB bus);</span><br><span class="line">    semaphore sem;              //创建一个旗语</span><br><span class="line">    initial</span><br><span class="line">    begin</span><br><span class="line">        sem = new(1);           //分配一个钥匙</span><br><span class="line">        fork</span><br><span class="line">            sequencer();</span><br><span class="line">            sequencer();</span><br><span class="line">        join</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    task sequencer;</span><br><span class="line">        repeat($urandom()%10)   @bus.cb;    //等待0~9个周期</span><br><span class="line">        sendTrans();                        //执行总线事务</span><br><span class="line">    endtask</span><br><span class="line">    </span><br><span class="line">    task sendTrans;</span><br><span class="line">        sem.get(1);                         //获取总线钥匙</span><br><span class="line">        @bus.cb;                            </span><br><span class="line">        bus.cb.addr &lt;= t.addr;</span><br><span class="line">        ...</span><br><span class="line">        sem.put(1);                         //返回总线钥匙</span><br><span class="line">    endtask</span><br><span class="line">endprogram</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-信箱mailbox"><a href="#3-信箱mailbox" class="headerlink" title="3.信箱mailbox"></a>3.信箱mailbox</h2><ul>
<li><p>mailbox是一种对象，因此也需要使用new()来例化</p>
</li>
<li><p>使用<code>put()</code>可以把数据放入mailbox，使用<code>get()</code>可从信箱移除数据</p>
</li>
<li><p>如果信箱为满，则put()会阻塞；如果信箱为空，则get()会阻塞</p>
</li>
<li><p>maibox的存取方法put()和get()是<strong>阻塞方法</strong>，即使用时方法不一定立即返回</p>
</li>
<li><p><code>peek()</code>可以获取对信箱里数据的拷贝而不移除它</p>
</li>
<li><p><strong>mailbox只能够用作FIFO</strong></p>
</li>
<li><p>在线程之间做数据通信或者内部数据缓存时可以考虑使用此方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">program automatic bounded;</span><br><span class="line">    mailbox mbx;</span><br><span class="line">    initial begin</span><br><span class="line">        mbx=new(1); //容量为1</span><br><span class="line">        fork</span><br><span class="line">            //Producer线程</span><br><span class="line">            for(inti=1; i&lt;4; i++) begin</span><br><span class="line">            $display(&quot;Producer: before put(%0d)&quot;, i);</span><br><span class="line">            mbx.put(i);</span><br><span class="line">            $display(&quot;Producer: after put(%0d)&quot;, i);</span><br><span class="line">            end</span><br><span class="line">            //consumer线程</span><br><span class="line">            repeat(3) begin</span><br><span class="line">                int j;</span><br><span class="line">                #1ns mbx.get(j);</span><br><span class="line">                $display(&quot;Consumer: after get(%0d)&quot;, j);</span><br><span class="line">            end</span><br><span class="line">        join</span><br><span class="line">    end</span><br><span class="line">endprogram</span><br><span class="line"></span><br><span class="line">//测试结果</span><br><span class="line">// Producer: before put(1)</span><br><span class="line">// Producer: after put(1)</span><br><span class="line">// Producer: before put(2)</span><br><span class="line">// Consumer: after get(1)</span><br><span class="line">// Producer: after put(2)</span><br><span class="line">// Producer: before put(3)</span><br><span class="line">// Consumer: after get(2)</span><br><span class="line">// Producer: after put(3)</span><br><span class="line">// Consumer: after get(3)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/404698267">SystemVerilog | 多线程，从概念到编程框架 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.wenhui.space/docs/07-ic-verify/training/sv-study-note-five/#fork-dot-dot-dot-join">SV学习笔记（五） – Wenhui’s Rotten Pen</a></li>
<li><a href="https://blog.csdn.net/m0_56242485/article/details/124260107">Systemverilog中关于@和wait的区别_verilog @ wait_借问众神明.的博客-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV之随机约束</title>
    <url>/2023/08/22/SV%E4%B9%8B%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<p>本节主要介绍了SystemVerilog中产生随机数的方法以及约束块的使用</p>
<span id="more"></span>
<h1 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h1><ul>
<li><p>任何类中的整形（bit/byte/int）变量、定长数组，动态数组、关联数组和队列都可以声明为rand/randc，可以对动态数组和队列的长度加以约束，非组合型结构体可以声明为rand</p>
</li>
<li><p><strong>只能用类这个“载体”去容纳变量以及它们之间的约束关系</strong></p>
</li>
<li><p>module里面不能用rand</p>
</li>
<li><p>对于rand修饰符，表示在可生成的范围内，每个值得可能性是相同的</p>
</li>
<li><p>对于randc修饰符，它的值将会随机并且遍历其可取值范围，即<strong>取出后的数不放回，等全部取出后再在取值范围内重新抽取</strong></p>
</li>
<li><p>产生随机数的方式：</p>
<ul>
<li>通过系统函数<code>std::randomize(var)</code>产生随机数并赋予变量</li>
<li><code>var = $urandom()</code> //可以产生一个32位的无符号随机数</li>
<li><code>var = $urandom_range(maxval, minval = 0)</code> // 可以生成在maxval与minval之间的数</li>
<li><code>.randomize()</code>的数据类型只能是类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//类中存放一些随机数</span><br><span class="line">class packet;</span><br><span class="line">	rand bit [31:0] src, dst, data[4];</span><br><span class="line">	rand bit [7:0] kind;</span><br><span class="line">	constraint cstr&#123;</span><br><span class="line">		src &gt; 10;</span><br><span class="line">		src &lt; 15;</span><br><span class="line">	&#125;</span><br><span class="line">	function void print();</span><br><span class="line">		$display(&quot;src is %0d\n dst is %0d\n kind is %0d\n data is &amp;p&quot;, src, dst, kind, data);</span><br><span class="line">	endfuntion</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">module tb;</span><br><span class="line">	packet p;</span><br><span class="line">	initial begin</span><br><span class="line">		p = new();</span><br><span class="line">		$display(&quot;before randomize&quot;);</span><br><span class="line">		p.print();</span><br><span class="line">        p.randomize(); //使用.randomize()随机化类中的变量</span><br><span class="line">		$display(&quot;after randomize&quot;);</span><br><span class="line">		p.print();</span><br><span class="line">	end</span><br><span class="line">endmodule</span><br><span class="line"></span><br><span class="line">//结构体中存放一些随机数</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    rand bit [31:0] src;</span><br><span class="line">    rand bit [31:0] dst;</span><br><span class="line">    rand bit [31:0] data[4];</span><br><span class="line">    rand bit [7:0] kind;</span><br><span class="line">&#125; packet_t;</span><br><span class="line">        </span><br><span class="line">module tb2;</span><br><span class="line">    packet_t pkt;</span><br><span class="line">    initial begin</span><br><span class="line">        $display(&quot;before randomized packet struct:: src %0d\n kind is %0d\n kind is %0d\n data is %p&quot;, pkt.src, pkt.dst, pkt.kind, pkt.data);</span><br><span class="line">        std::randomize(pkt) with &#123;src &gt; 10; src &lt; 15&#125; //in-line constraint 内联约束</span><br><span class="line">        $display(&quot;before randomized packet struct:: src %0d\n kind is %0d\n kind is %0d\n data is %p&quot;, pkt.src, pkt.dst, pkt.kind, pkt.data);</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="约束块"><a href="#约束块" class="headerlink" title="约束块"></a>约束块</h1><ul>
<li><p>约束块支持整形通过<code>constraint</code>操作符来设置它们的可取值范围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class set_rand;</span><br><span class="line">    rand integer x, y, z;</span><br><span class="line">    constraint c1 &#123;x inside &#123;3, 5, [9:15], [24:32], [y:2*y], z&#125;;&#125;</span><br><span class="line">    </span><br><span class="line">    rand integer a, b, c;</span><br><span class="line">    constraint c2 &#123;a inside &#123;b,  c&#125;;&#125;</span><br><span class="line">    </span><br><span class="line">    integer fives[4] = &#x27;&#123;5, 10, 15, 20&#125;;</span><br><span class="line">    rand integer v;</span><br><span class="line">    constraint c3 &#123;v inside &#123;fives&#125;;&#125;</span><br><span class="line">    </span><br><span class="line">    //unique可以用来约束一组变量，使得其在随机后变量之间不会有相同的数值</span><br><span class="line">    rand byte a[5];</span><br><span class="line">    rand byte b;</span><br><span class="line">    rand byte excluded;</span><br><span class="line">    constraint u &#123;unique &#123;b, a[2:3], exclude&#125;;&#125;//这里a[2]、a[3]、b和excluded在随机之后将包含不相同的数值</span><br><span class="line">    constraint exclusion &#123;excluded == 5;&#125;</span><br><span class="line">    </span><br><span class="line">    //使用-&gt;操作符来表示条件约束</span><br><span class="line">    bit [3:0] a, b;</span><br><span class="line">    constraint c &#123;(a == 0) -&gt; (b &lt; 10)&#125; //表示如果a等于0，那么b就随机取小于10的数</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>权重分布</strong>：</p>
<ul>
<li><p>对于<code>:=</code>操作符，它们表示每一个值的权重是相同的</p>
</li>
<li><p>对于<code>:/</code>操作符，它们表示权重会平均分配到每一个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x dist &#123;[100:102] := 1, 200 := 2, 300 := 5&#125; //x在100，101，102，200和300的权重是1-1-1-2-5</span><br><span class="line">x dist &#123;[100:102] :/1, 200 := 2, 300 := 5&#125; //x在100，101，102，200和300的权重是1/3-1/3-1/3-2-5</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>软约束</strong>：<ul>
<li>在没有soft描述约束时，称为硬约束，带有<code>soft</code>描述的约束是软约束</li>
<li>硬约束的父类子类，若对同一变量：<strong>约束同名则覆盖，若不同名则取交集；此外，硬约束可以覆盖软约束</strong></li>
<li>若都是软约束，则遵循最近的软约束</li>
</ul>
</li>
</ul>
<hr>
<h1 id="随机控制与约束控制"><a href="#随机控制与约束控制" class="headerlink" title="随机控制与约束控制"></a>随机控制与约束控制</h1><h2 id="1-随机控制"><a href="#1-随机控制" class="headerlink" title="1.随机控制"></a>1.随机控制</h2><ul>
<li><p><code>rand_mode()</code>可以用来使能(1)或禁止(0)随机变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class packet;</span><br><span class="line">	rand bit [31:0] src, dst, data[4];</span><br><span class="line">	rand bit [7:0] kind;</span><br><span class="line">	...</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">Packet packet_a = new();</span><br><span class="line">packet_a.rand_mode(0); //禁止类中所有随机变量</span><br><span class="line"></span><br><span class="line">packet_a.src.rand_mode(1);//使能某个随机变量</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-约束控制"><a href="#2-约束控制" class="headerlink" title="2.约束控制"></a>2.约束控制</h2><ul>
<li>类似的，约束中使用<code>constraint_mode()</code>来使能或禁止约束块</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV之数组</title>
    <url>/2023/08/21/SV%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>本节主要介绍了SystemVerilog中非组合型与组合型数组的基本概念、动态数组、队列、关联数组等相关内容</p>
<span id="more"></span>
<h1 id="非组合型与组合型"><a href="#非组合型与组合型" class="headerlink" title="非组合型与组合型"></a>非组合型与组合型</h1><h2 id="1-非组合型（unpacked）"><a href="#1-非组合型（unpacked）" class="headerlink" title="1.非组合型（unpacked）"></a>1.非组合型（unpacked）</h2><ul>
<li><p>SV将Verilog这种声明数组的方式称之为非组合型声明，即数组中成员之间存储数据都是相互独立的</p>
</li>
<li><p>非组合型数组：在内存中<strong>非连续存放</strong>的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wire [7: 0] table [3:0];</span><br></pre></td></tr></table></figure>
<p><img src="/2023/08/21/SV%E4%B9%8B%E6%95%B0%E7%BB%84/image-20230819214226718.png" alt="image-20230819214226718"></p>
</li>
</ul>
<h2 id="2-组合型（packed）"><a href="#2-组合型（packed）" class="headerlink" title="2.组合型（packed）"></a>2.组合型（packed）</h2><ul>
<li><p>组合型数组：在内存中<strong>连续存放</strong>的数组</p>
</li>
<li><p>很多SV仿真器在存放数组元素时使用32bit的字边界，所有byte、shortint、int都是存在一个字中，而longint则存放到两个字中，logic也是存放到两个字中</p>
</li>
<li><p><strong>维数在数组名左边意味着packed即告诉编译器要打包的意思，而在右边意味着unpacked即告诉编译器要不用打包的意思</strong></p>
</li>
<li><p><strong>有当数组中的全部元素都packed时，才被成为组合数组，若只有低维packed，而高维没有仍旧是非组合数组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logic [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] data; //<span class="number">2</span>-D packed array</span><br></pre></td></tr></table></figure>
<p><img src="/2023/08/21/SV%E4%B9%8B%E6%95%B0%E7%BB%84/image-20230821134129052.png" alt="image-20230821134129052"></p>
</li>
<li><p>组合型也可以用来定义结构体的存储方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct packed&#123;</span><br><span class="line">	logic [7:0] crc;</span><br><span class="line">	logic [63:0] data;</span><br><span class="line">&#125;data_word;</span><br><span class="line">data_word [7:0] darray;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合型数组和其数组片段也可以灵活选择，用来拷贝和赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logic [3:0][7:0] data; //二维组合型数组</span><br><span class="line"></span><br><span class="line">wire [31:0] out = data; //将全部数组赋值</span><br><span class="line">wire sign = data[3][7]; //选择一个bit赋值</span><br><span class="line">wire [3:0] nib = data[0][3:0]; //选择部分切片赋值</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="数组的初始化与拷贝"><a href="#数组的初始化与拷贝" class="headerlink" title="数组的初始化与拷贝"></a>数组的初始化与拷贝</h1><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><ul>
<li><p>组合型数组初始化时，同向量初始化一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logic [3:0][7:0] a = 32&#x27;h0;</span><br><span class="line">logic [3:0][7:0] b = &#123;16&#x27;hz, 16&#x27;h0&#125;;</span><br><span class="line">logic [3:0][7:0] c = &#123;16&#123;2&#x27;b01&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非组合型数组初始化时，对每一维以数组的方式进行初始化，<strong>需要通过<code>&#39;&#123;&#125;</code>来对数组的每一个维度进行赋值</strong>（因为非组合数组中的每一个元素的都是独立的数据，因此必须维数与每一个维数中的元素个数都相等时，才可以赋值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int d [0:1][0:3] = &#x27;&#123;&#x27;&#123;7, 3, 0, 5&#125;, &#x27;&#123;2, 0, 1, 6&#125;&#125;;</span><br><span class="line">//d[0][0] = 7;</span><br><span class="line">//d[0][1] = 3;</span><br><span class="line">//d[0][2] = 0;</span><br><span class="line">//d[0][3] = 5;</span><br><span class="line">//d[1][0] = 2;</span><br><span class="line">//d[1][1] = 0;</span><br><span class="line">//d[1][2] = 1;</span><br><span class="line">//d[1][3] = 6;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-拷贝"><a href="#2-拷贝" class="headerlink" title="2.拷贝"></a>2.拷贝</h2><ul>
<li>对于<strong>组合型数组</strong>，由于数组会被视为向量，因此<strong>当赋值左右两侧操作数的大小和维度不相同时，也可以做赋值</strong>。如果当尺寸不相同时，则会通过截取或者扩展右侧操作数的方式来对左侧操作数赋值</li>
<li>对于<strong>非组合型数组</strong>，在发生数组间拷贝时，则要求<strong>左右两侧操作数的维度和大小必须严格一致</strong></li>
<li><strong>非组合型数组无法直接赋值给组合型数组，同样，组合型数组也无法直接赋值给非组合型数组</strong></li>
</ul>
<hr>
<h1 id="foreach循环结构"><a href="#foreach循环结构" class="headerlink" title="foreach循环结构"></a>foreach循环结构</h1><ul>
<li><p>SV添加foreach循环来对一维或者多维数组进行循环索引，而不需要指定该数组的维度大小</p>
</li>
<li><p>foreach循环结构中的变量无需声明</p>
</li>
<li><p>foreach循环结构中的变量是只读的，其作用域只在此循环结构中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum [1:8][1:3];</span><br><span class="line">foreach (sum[i, j]) begin</span><br><span class="line">	sum[i][j] = i + j;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h1><ul>
<li><p><code>$dimensions(array_name)</code> //用来返回数组的维度</p>
</li>
<li><p><code>$left(array_name, dimension)</code> //返回指定维度的最左索引值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logic [1:2][7:0] word [0:3][4:1];</span><br><span class="line">$left(word, 1) //会返回0</span><br><span class="line">$left(word, 2) //会返回4</span><br><span class="line">$left(word, 3) //会返回1</span><br><span class="line">$left(word, 4) //会返回7</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$size(array_name, dimension)</code> //返回指定维度的尺寸大小</p>
</li>
<li><p><code>$bits(array_name)</code> //返回数组存储的bit数目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wire [3:0][7:0] a [0:15]; //$bits(a) 将返回512</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><ul>
<li><p>动态数组的声明：<code>[data_type] [identifier_name] [];</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit [7:0] stack[]; //动态数组，每个元素代表一个byte</span><br><span class="line">string names[]; //动态数组，每个元素代表一个string</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态数组的操作与非组合型数组一致</p>
</li>
<li><p><strong>内存分配和初始化</strong>：</p>
<ul>
<li><p>使用new()方法，分配了内存但没有对内存进行初始化</p>
</li>
<li><p>利用列表直接进行初始化，其中隐含了内存分配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//declaration</span><br><span class="line">bit [7:0] d_array1[];</span><br><span class="line">int d_array2[];</span><br><span class="line"> </span><br><span class="line">//memory allocation</span><br><span class="line">d_array1 = new[4]; //dynamic array of 4 elements</span><br><span class="line">d_array2 = new[6]; //dynamic array of 6 elements</span><br><span class="line"> </span><br><span class="line">//array initialization</span><br><span class="line">d_array1 = &#x27;&#123;0,1,2,3&#125;;</span><br><span class="line">foreach(d_array2[j]) d_array2[j] = j;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>容量扩张</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Change the length of the array after declaration/initialization</span><br><span class="line">d_array1 = new[10]; //dynamic array of 10 elements</span><br><span class="line">// 以上语句中d_array1被重新分配了10个地址空间，d_array1中原有的数据被扔掉了</span><br></pre></td></tr></table></figure>
<ul>
<li>用以下形式调用new()的话可以在扩充容量的同时保留d_array1中原有的数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Allocate 6 new elements and retain values of 4 elements.</span><br><span class="line">d_array1 = new[10](d_array1);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态数组的复制</strong>：动态数组的复制的语法形式与上一节的扩容且保留原数据的调用方法相同，只不过生成的内存块赋给新的一个变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d_array2 = new[d_array1.size()](d_array1); //创建了d_array1的一个副本</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态数组的删除</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d_array2.delete(); //删除所有元素</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul>
<li>声明： <code>[$]</code> ，队列元素的标号从0到$</li>
<li>队列不需要用new[ ]去创建内存空间，一开始其所占空间为0</li>
<li><p>结合了链表和数组的优点，可以在任何地方添加或删除元素，并通过索引实现对任一元素的访问</p>
</li>
<li><p><strong>队列中的元素是连续存储的，故不需要使用单引号 ’ { }方式赋值，用{}就行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int q2[$] = &#123;3, 4&#125;, q[$] = &#123;0, 2, 3&#125;;</span><br><span class="line">initial begin</span><br><span class="line">    q.insert(1, j); //在下标1插入j(1)，则q=&#123;0, 1, 2, 3&#125;</span><br><span class="line">    q.delete(1); //删除元素1，q=&#123;0, 2, 3&#125;</span><br><span class="line">    q.push_front(6); //在队首插入一个元素，q=&#123;6, 0, 2, 3&#125;</span><br><span class="line">    j = q.pop_back(); //在队尾取出一个元素，q=&#123;6, 0, 2&#125;，j = 3</span><br><span class="line">    q.push_back(8); //在队尾插入一个元素，q=&#123;6, 0, 2, 8&#125;</span><br><span class="line">    j = q.pop_front(); //在队首取出一个元素，q=&#123;0, 2, 8&#125;，j = 6</span><br><span class="line">    q.delete(); //删除整个队列</span><br><span class="line">end </span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h1><ul>
<li>关联数组实际上<strong>是一种查找表</strong>，内存空间直到被使用时才会分配，<strong>每个数据项都会有一个特定的“键（索引）”，索引的类型不局限于整型</strong></li>
<li><p>相对于一般的数组，关联数组的内存空间利用会更加充分，因为它是<strong>稀疏的</strong>，无需一开始就分配很大的内存空间</p>
</li>
<li><p><strong>关联数组也是一种unpacked数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit [63:0] assoc[int],idx = 1;</span><br><span class="line">repeat (64) begin       //对稀疏分布的元素进行初始化</span><br><span class="line">    assoc[idx] = idx; //assoc[1] = 1</span><br><span class="line">    idx = idx &lt;&lt; 1; //assoc[2] = 2,assoc[3] =4,...</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">forrach (assoc[i]) //使用foreach遍历数组</span><br><span class="line">    $display(&quot;assoc[%h] = %h&quot;,i,assoc[i]);</span><br><span class="line"> </span><br><span class="line">//找到并删除第一个元素</span><br><span class="line">assoc.first(idx);</span><br><span class="line">assoc.delete(idx);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关联数组的一些方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num()  //返回数组长度</span><br><span class="line">delete()  //删除指定元素或者所有元素</span><br><span class="line">exists()  //检查是否元素存在，存在返回1，否则返回0</span><br><span class="line">first()  //将指定的索引变量赋值为数组第一个索引的值</span><br><span class="line">last()  //将指定的索引变量赋值为数组最后一个索引的值  </span><br><span class="line">next()  //索引变量被赋值为下一个条目的索引</span><br><span class="line">prev()  //索引变量被赋值为上一个条目的索引</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="数组中的相关方法"><a href="#数组中的相关方法" class="headerlink" title="数组中的相关方法"></a>数组中的相关方法</h1><h2 id="1-缩减方法"><a href="#1-缩减方法" class="headerlink" title="1.缩减方法"></a>1.缩减方法</h2><ul>
<li><p>基本的数组缩减方法就是把一个数组缩减成一个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte b[$] = &#123;2, 3, 4, 5&#125;;</span><br><span class="line">int w;</span><br><span class="line">w = b.sum(); //14 = 2 + 3 + 4 + 5</span><br><span class="line">w = b.product(); //120 = 2 * 3 * 4 * 5</span><br><span class="line">w = b.and(); //0000_0000 = 2 &amp; 3 &amp; 4 &amp; 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-定位方法"><a href="#2-定位方法" class="headerlink" title="2.定位方法"></a>2.定位方法</h2><ul>
<li><p>对于非合并数组，可以使用数组定位方法，其返回值将是一个队列而非一个数据成员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int f[6] = &#x27;&#123;1, 6, 2, 6, 8, 6&#125;; //定长数组</span><br><span class="line">int d[] = &#x27;&#123;2, 4, 6, 8, 10&#125;; //动态数组</span><br><span class="line">int q[$] = &#123;1, 3, 5, 7&#125;, tq[$];</span><br><span class="line"></span><br><span class="line">tq = q.min(); //&#123;1&#125;</span><br><span class="line">tq = d.max(); //&#123;10&#125;</span><br><span class="line">tq = f.unique(); //&#123;1, 6, 2, 8&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-排序方法"><a href="#3-排序方法" class="headerlink" title="3.排序方法"></a>3.排序方法</h2><ul>
<li><p>可以通过排序方法改变数组中元素的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int d[] = &#x27;&#123;9, 1, 8, 3, 4, 4&#125;;</span><br><span class="line">d.reverse(); //&#x27;&#123;4, 4, 3, 8, 1, 9&#125;</span><br><span class="line">d.sort();    //&#x27;&#123;1, 3, 4, 4, 8, 9&#125;</span><br><span class="line">d.rsort();   //&#x27;&#123;9, 8, 4, 4, 3, 1&#125;</span><br><span class="line">d.shuffle(); //&#x27;&#123;9, 4, 3, 8, 1, 4&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://blog.csdn.net/weixin_42033596/article/details/115611818">Systemverilog中的组合数组与非组合数组详解_沧月九流的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_42419590/article/details/121127845">一文看懂组合型/非组合型数组_组合型数组 非组合型数组_数字IC小白的日常修炼的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/chenxy_bwave/article/details/120526790">SystemVerilog: 动态数组_systemverilog 动态数组_笨牛慢耕的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/357879325">SystemVerilog动态数组与关联数组 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.cnblogs.com/Alfred-HOO/articles/16099886.html">【IEEE_SV-7.9】关联数组方法汇总 - SOC验证工程师 - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV之类的封装与继承</title>
    <url>/2023/08/21/SV%E4%B9%8B%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>本节主要介绍了SystemVerilog中类的封装与继承的基本内容、虚方法以及包的使用。</p>
<span id="more"></span>
<h1 id="类的概述"><a href="#类的概述" class="headerlink" title="类的概述"></a>类的概述</h1><ul>
<li><strong>类的三要素：封装、继承、多态（虚方法）</strong></li>
<li>类是一种可以包含数据和方法的类型</li>
<li>OOP(Object-Oriented Programming)术语：<ul>
<li>类（class）：包括成员变量和成员方法</li>
<li>对象（object）：类在例化后的实例</li>
<li>句柄（handle）：指向对象的指针，通过句柄可以索引对象的变量和方法</li>
<li>原型（prototype）：程序的声明部分，包含程序名、返回类型和参数列表</li>
</ul>
</li>
</ul>
<p><img src="/2023/08/21/SV%E4%B9%8B%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%A7%E6%89%BF/image-20230821173617016.png" alt="image-20230821173617016"></p>
<hr>
<h1 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h1><h2 id="1-句柄的使用"><a href="#1-句柄的使用" class="headerlink" title="1.句柄的使用"></a>1.句柄的使用</h2><ul>
<li><p>当<strong>句柄指向一个对象时</strong>， SystemVerilog不会释放该对象的内存空间（<strong>对象的创建</strong>）</p>
</li>
<li><p>如果<strong>没有句柄指向个对象，</strong> Systemverilog将释放该对象的内存空间（<strong>对象的销毁</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transaction t1, t2; //声明两个句柄</span><br><span class="line">t1 = new();//创建一个对象，并将t1指向该对象</span><br><span class="line">t2 = new();//创建一个对象，并将t2指向该对象</span><br><span class="line">t1 = t2;   //将t2的值赋予t1,这时t1和t2指向同一对象，t1之前指向的对象被释放</span><br><span class="line">t1.display();//调用对象的成员方法</span><br><span class="line">t1.addr = 32&#x27;h42;//给对象成员赋值</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-静态变量和静态方法"><a href="#2-静态变量和静态方法" class="headerlink" title="2.静态变量和静态方法"></a>2.静态变量和静态方法</h2><ul>
<li><strong>静态变量</strong>：<ul>
<li>class内部声明的变量默认为动态变量，其生命周期始于对象创建，终于对象销毁</li>
<li>使用static声明class内部的变量时，其为静态变量。其生命周期始于编译阶段，贯穿于整个仿真阶段</li>
<li>静态变量的引用：<strong>使用类名直接引用（<code>Transaction::count</code>）或者通过例化对象引用(<code>tr.count</code>)</strong></li>
</ul>
</li>
<li><strong>静态方法：静态方法内可以声明并使用动态变量，但不能使用类的动态成员变量</strong></li>
</ul>
<h2 id="3-类的成员"><a href="#3-类的成员" class="headerlink" title="3.类的成员"></a>3.类的成员</h2><ul>
<li><p>类中的成员默认是<code>public</code>,子类和外部均可访问</p>
</li>
<li><p>但如果指明了类型为<code>protected</code>,那么只有<strong>该类或者子类可以访问</strong></p>
</li>
<li><p>如果访问类型为<code>local</code>，那么只有该类可以访问成员，<strong>子类和外部均不可访问</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class clock;</span><br><span class="line">  local bit is_summer = 0;</span><br><span class="line">  local bit nclock = 6;</span><br><span class="line">  function int get_clock();</span><br><span class="line">  ...</span><br><span class="line">  endfunction</span><br><span class="line">endclass</span><br><span class="line"> </span><br><span class="line">clock ck;</span><br><span class="line">initial begin</span><br><span class="line">  ck = new();</span><br><span class="line">  $display(&quot;now time is %0d&quot;,ck.get_clock);//成功访问</span><br><span class="line">  ck.set_summer(1);</span><br><span class="line">  $display(&quot;now time is %0d&quot;,ck.nclock); //报错，外部句柄不能访问local变量</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-this"><a href="#4-this" class="headerlink" title="4.this"></a>4.this</h2><ul>
<li><p>this是用来明确索引当前所在对象的成员</p>
</li>
<li><p>this只可以用来在类的非静态成员、约束和覆盖组中使用</p>
</li>
<li><p>this可以明确所指向变量的作用域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Demo;</span><br><span class="line">	integer x;</span><br><span class="line">	function new (integer x);</span><br><span class="line">		this.x = x; //说明这时this.x代表成员变量integer x</span><br><span class="line">	endfunction</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-浅拷贝与深拷贝"><a href="#5-浅拷贝与深拷贝" class="headerlink" title="5.浅拷贝与深拷贝"></a>5.浅拷贝与深拷贝</h2><ul>
<li><p>浅拷贝：<strong>new复制创建了一个新的对象，原对象的值被盲目的抄写到目的对象中，但如果类中包含了一个指向另一个类的句柄，那么只有最高一级的对象被new操作符复制，下层的对象不会被复制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b2 = new b1</span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝：<strong>当使用深复制时，所有的变量都会被复制，包括下层的对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b2.copy(b1);       //深复制，其中一个改变，不会影响另外一个</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><ul>
<li><p>子类继承父类的所有数据成员和方法</p>
</li>
<li><p>子类可以添加新的数据成员或者方法</p>
</li>
<li><p>子类可以通过<code>super</code>操作符引用父类中的方法和成员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LinkedPacket extends Packet;</span><br><span class="line">	LinkedPacket next;</span><br><span class="line">	function LinkedPacked get_next();</span><br><span class="line">		get_next = next;</span><br><span class="line">	endfunction</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>extends</code>，LinkedPacket继承于其父类Packet</p>
</li>
<li><p>当子类成员与父类成员同名，<strong>必须</strong>使用<code>super</code>来指定访问其父类成员</p>
</li>
<li><p>当父类的new没有参数时，子类也会自动先调用父类的new，当父类的new有参数时，需加上<code>super.new(参数列表)</code>使得子类先调用父类的new</p>
</li>
<li><p>子类句柄赋值给父类之后，<strong>被赋值的父类句柄只能指向整个子类中属于父类的部分</strong></p>
</li>
</ul>
<hr>
<h1 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h1><ul>
<li><p>通过在父类里定义虚方法(virtual task or function)，可以在当父类句柄调用一个方法时候，<strong>前提是若是这个句柄指向了子类对象</strong>，则<strong>调用的方法为子类的方法而不是父类的方法</strong></p>
</li>
<li><p>使用系统函数<code>$cast</code>将父类句柄转化为子类句柄,，使其可以访问子类的变量</p>
</li>
</ul>
<hr>
<h1 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h1><ul>
<li>为了使得可以在多个模块（硬件）或者类（软件）之间共享用户定义的数据类型，SV添加了包</li>
<li>通过<code>package endpackage</code>关键字来定义包</li>
<li>可以通过<code>package_name::var</code>来索引包中的变量</li>
<li>也可以通过<code>import package_name::var</code>在module中导入包中的变量</li>
<li>或者通过<code>import package_name::*</code>，这代表当在module中找不到对应的变量时，就会在包中找</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://blog.csdn.net/m0_59670134/article/details/119190972">SV基础知识3—-Class类和Package_sv中类和包的区别_持续学习_ing的博客-CSDN博客</a></li>
<li><a href="https://www.bilibili.com/video/BV1k7411H7Jo?p=21&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">SV系统验证 第七周 类的继承-2_哔哩哔哩_bilibili</a></li>
<li><a href="https://blog.csdn.net/qq_41467882/article/details/121704198">System Verilog——虚方法的使用_虚方法systemverilog_ty_xiumud的博客-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch之文本情感分类</title>
    <url>/2023/08/17/Pytorch%E4%B9%8B%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>本节主要介绍了文本情感分析的基本概念以及相关代码示例</p>
<span id="more"></span>
<h1 id="情感分析基本概念"><a href="#情感分析基本概念" class="headerlink" title="情感分析基本概念"></a>情感分析基本概念</h1><ul>
<li><p>情感分析：计算机帮助用户快速获取、整理和分析相关评价信息，对带有情感色彩的主观性文本进行分析、处理、归纳和推理</p>
</li>
<li><p>情感分析包括情感分类、观点抽取、观点问答、观点摘要</p>
</li>
<li><p><strong>情感分类</strong>：指根据文本所表达的含义和情感信息将文本划分为褒扬的或贬义的两种或几种类型，是对文本作者倾向性和观点、态度的划分，也称为倾向性分析</p>
</li>
<li><p>情感分类的流程：</p>
<p><img src="/2023/08/17/Pytorch%E4%B9%8B%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E7%B1%BB/image-20230817144203264.png" alt="image-20230817144203264" style="zoom: 67%;"></p>
</li>
</ul>
<hr>
<h1 id="数据集下载与处理"><a href="#数据集下载与处理" class="headerlink" title="数据集下载与处理"></a>数据集下载与处理</h1><ul>
<li><p>原始数据下载地址：<a href="https://github.com/SophonPlus/ChineseNlpCorpus/blob/master/datasets/weibo_senti_100k/intro.ipynb">ChineseNlpCorpus/datasets/weibo_senti_100k/intro.ipynb at master · SophonPlus/ChineseNlpCorpus (github.com)</a></p>
</li>
<li><p>stopwords（句子中没啥含义的词，如的、那么等等）下载地址：<a href="https://github.com/goto456/stopwords/blob/master/hit_stopwords.txt">stopwords/hit_stopwords.txt at master · goto456/stopwords (github.com)</a></p>
</li>
<li><p>对原始数据进行相关处理，就可以得到相关字典，并且可以得到分词后的结果：data_processing.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">data_path = <span class="string">&quot;sources/weibo_senti_100k.csv&quot;</span></span><br><span class="line">data_list = <span class="built_in">open</span>(data_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).readlines()[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">data_stop_path = <span class="string">&quot;sources/hit_stopwords.txt&quot;</span></span><br><span class="line">stops_word = <span class="built_in">open</span>(data_stop_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).readlines()</span><br><span class="line">stops_word = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> stops_word] <span class="comment">#过滤掉字符串两端的空格与换行符</span></span><br><span class="line">stops_word.append(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">stops_word.append(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">#再添加空格与换行符</span></span><br><span class="line"></span><br><span class="line">voc_dict = &#123;&#125;</span><br><span class="line">min_seq = <span class="number">1</span></span><br><span class="line">top_n = <span class="number">1000</span> <span class="comment">#字典的最大长度</span></span><br><span class="line"></span><br><span class="line">UNK = <span class="string">&quot;&lt;UNK&gt;&quot;</span></span><br><span class="line">PAD = <span class="string">&quot;&lt;PAD&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">    label = item[<span class="number">0</span>]</span><br><span class="line">    content = item[<span class="number">2</span>:].strip() <span class="comment">#利用.strip()移除结尾的换行符</span></span><br><span class="line">    seg_list = jieba.cut(content, cut_all = <span class="literal">False</span>) <span class="comment">#利用jieba得到一个精确的分词结果</span></span><br><span class="line">    seg_res = []</span><br><span class="line">    <span class="keyword">for</span> seg_item <span class="keyword">in</span> seg_list: </span><br><span class="line">        <span class="keyword">if</span> seg_item <span class="keyword">in</span> stops_word:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        seg_res.append(seg_item)</span><br><span class="line">        <span class="keyword">if</span> seg_item <span class="keyword">in</span> voc_dict.keys():</span><br><span class="line">            voc_dict[seg_item] = voc_dict[seg_item] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            voc_dict[seg_item] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">voc_list = <span class="built_in">sorted</span>([_ <span class="keyword">for</span> _ <span class="keyword">in</span> voc_dict.items() <span class="keyword">if</span> _[<span class="number">1</span>] &gt; min_seq], </span><br><span class="line">                  key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>],</span><br><span class="line">                  reverse = <span class="literal">True</span>)[:top_n]</span><br><span class="line"></span><br><span class="line">voc_dict = &#123;word_count[<span class="number">0</span>]: idx <span class="keyword">for</span> idx, word_count <span class="keyword">in</span> <span class="built_in">enumerate</span>(voc_list)&#125;</span><br><span class="line"></span><br><span class="line">voc_dict.update(&#123;UNK: <span class="built_in">len</span>(voc_dict), PAD: <span class="built_in">len</span>(voc_dict) + <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">ff = <span class="built_in">open</span>(<span class="string">&quot;sources/dict.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> voc_dict.keys():</span><br><span class="line">    ff.writelines(<span class="string">&quot;&#123;&#125;,&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(item, voc_dict[item]))</span><br><span class="line">ff.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到的字典如下：</p>
<p><img src="/2023/08/17/Pytorch%E4%B9%8B%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E7%B1%BB/image-20230818142316767.png" alt="image-20230818142316767" style="zoom: 50%;"></p>
</li>
<li><p>处理原始数据生成数据集，将每个句子用一个数字向量表示：</p>
<ul>
<li>返回列表中第一个元素为标签（有batch_size个），</li>
<li>第二个元素为处理后的输入数据（即每个句子由一个序列表示，序列中的每个元素为一个数字，这个数字为词在字典词表中的位置）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[tensor([0, 0, 1, 1, 0, 0, 1, 1, 0, 0]), tensor([[  12,  453, 1000,  ..., 1001, 1001, 1001],</span><br><span class="line">        [   8, 1000,   37,  ..., 1001, 1001, 1001],</span><br><span class="line">        [1000, 1000, 1000,  ..., 1001, 1001, 1001],</span><br><span class="line">        ...,</span><br><span class="line">        [   8, 1000, 1000,  ..., 1001, 1001, 1001],</span><br><span class="line">        [1000, 1000, 1000,  ..., 1001, 1001, 1001],</span><br><span class="line">        [ 162, 1000,  243,  ..., 1001, 1001, 1001]], dtype=torch.int32)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>datasets.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">data_path, data_stop_path</span>):</span><br><span class="line">    data_list = <span class="built_in">open</span>(data_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).readlines()[<span class="number">1</span>:]</span><br><span class="line">    stops_word = <span class="built_in">open</span>(data_stop_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).readlines()</span><br><span class="line">    stops_word = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> stops_word] <span class="comment">#过滤掉字符串两端的空格与换行符</span></span><br><span class="line">    stops_word.append(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    stops_word.append(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">#再添加空格与换行符</span></span><br><span class="line"></span><br><span class="line">    data = []</span><br><span class="line">    max_len_seq = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">        label = item[<span class="number">0</span>]</span><br><span class="line">        content = item[<span class="number">2</span>:].strip() <span class="comment">#利用.strip()移除结尾的换行符</span></span><br><span class="line">        seg_list = jieba.cut(content, cut_all = <span class="literal">False</span>) <span class="comment">#利用jieba得到一个精确的分词结果</span></span><br><span class="line">        seg_res = []</span><br><span class="line">        <span class="keyword">for</span> seg_item <span class="keyword">in</span> seg_list: </span><br><span class="line">            <span class="keyword">if</span> seg_item <span class="keyword">in</span> stops_word:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            seg_res.append(seg_item)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(seg_res) &gt; max_len_seq:</span><br><span class="line">            max_len_seq = <span class="built_in">len</span>(seg_res) <span class="comment">#获取最长句子的长度</span></span><br><span class="line"></span><br><span class="line">        data.append([label, seg_res]) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data, max_len_seq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_dict</span>(<span class="params">voc_dict_path</span>): <span class="comment">#用于读取字典数据</span></span><br><span class="line">    voc_dict = &#123;&#125;</span><br><span class="line">    dict_list = <span class="built_in">open</span>(voc_dict_path).readlines()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> dict_list:</span><br><span class="line">        item = item.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        voc_dict[item[<span class="number">0</span>]] = <span class="built_in">int</span>(item[<span class="number">1</span>].strip()) <span class="comment">#将字符串转为整形</span></span><br><span class="line">    <span class="keyword">return</span> voc_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">text_ClS</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, voc_dict_path, data_path, data_stop_path</span>):</span><br><span class="line">        <span class="built_in">super</span>(text_ClS, self).__init__()</span><br><span class="line">        self.voc_dict = read_dict(voc_dict_path) <span class="comment">#加载字典</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#加载分词后的数据（包括标签和句子）以及句子中所含单词数的最大值</span></span><br><span class="line">        self.data_path = data_path</span><br><span class="line">        self.data_stop_path = data_stop_path</span><br><span class="line">        self.data, self.max_len_seq = load_data(self.data_path, self.data_stop_path)</span><br><span class="line"></span><br><span class="line">        np.random.shuffle(self.data) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        data = self.data[index]</span><br><span class="line">        label = <span class="built_in">int</span>(data[<span class="number">0</span>]) <span class="comment">#每一个index对应的标签</span></span><br><span class="line">        word_list = data[<span class="number">1</span>]  <span class="comment">#和句子</span></span><br><span class="line">        input_idx = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> word_list: <span class="comment">#获取每个词在字典中对应的编号</span></span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> self.voc_dict.keys():</span><br><span class="line">                input_idx.append(self.voc_dict[word])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                input_idx.append(self.voc_dict[<span class="string">&quot;&lt;UNK&gt;&quot;</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(input_idx) &lt; self.max_len_seq:</span><br><span class="line">            input_idx += [self.voc_dict[<span class="string">&quot;&lt;PAD&gt;&quot;</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.max_len_seq -<span class="built_in">len</span>(input_idx))]</span><br><span class="line">        </span><br><span class="line">        data_vector = np.array(input_idx) <span class="comment">#此时每个句子由一个序列表示，序列中的每个元素为一个数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> label, data_vector</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_loader</span>(<span class="params">dataset, config</span>):</span><br><span class="line">    <span class="keyword">return</span> DataLoader(dataset, batch_size = config.batch_size, shuffle = config.is_shuffle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="comment">#     data_path = &quot;sources/weibo_senti_100k.csv&quot;</span></span><br><span class="line"><span class="comment">#     data_stop_path = &quot;sources/hit_stopwords.txt&quot;</span></span><br><span class="line"><span class="comment">#     dict_path = &quot;sources/dict.txt&quot;   </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#     train_dataloader = data_loader(data_path, data_stop_path, dict_path)</span></span><br><span class="line"><span class="comment">#     # for i, batch in enumerate(train_dataloader):</span></span><br><span class="line"><span class="comment">#     #     print(batch)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="网络搭建"><a href="#网络搭建" class="headerlink" title="网络搭建"></a>网络搭建</h1><ul>
<li><p>词嵌入：<strong>将句子中单词在字典中的索引，用与之对应的词向量表示</strong></p>
<ul>
<li><p><a href="https://blog.csdn.net/weixin_43646592/article/details/119180298">基于Pytorch的torch.nn.embedding()实现词嵌入层_embidding 分页 大小_#苦行僧的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/371003610">Torch.nn.Embedding的用法 - 知乎 (zhihu.com)</a></p>
</li>
</ul>
</li>
<li><p>nn.LSTM相关参数解释：<a href="https://blog.csdn.net/baidu_38963740/article/details/117197619">pytorch中LSTM参数详解（一张图帮你更好的理解每一个参数）_pytorch lstm参数_xjtuwfj的博客-CSDN博客</a></p>
</li>
<li><p>models.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> configs <span class="keyword">import</span> Config</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.embeding = nn.Embedding(config.n_vocab, </span><br><span class="line">                                     config.embed_size, </span><br><span class="line">                                     padding_idx = config.n_vocab - <span class="number">1</span>)</span><br><span class="line">        self.lstm = nn.LSTM(config.embed_size,</span><br><span class="line">                            config.hidden_size,</span><br><span class="line">                            config.num_layers,</span><br><span class="line">                            bidirectional = <span class="literal">True</span>, </span><br><span class="line">                            batch_first = <span class="literal">True</span>,</span><br><span class="line">                            dropout = config.dropout)</span><br><span class="line">        self.maxpool = nn.MaxPool1d(config.pad_size)</span><br><span class="line">        self.fc = nn.Linear(config.hidden_size * <span class="number">2</span> + config.embed_size, config.num_classes)</span><br><span class="line">        <span class="comment">#由于LSTM层设置为双向的，因此每个时间步的输出包括正向和反向的隐藏状态，故需要*2</span></span><br><span class="line">        self.softmax = nn.Softmax(dim = <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        embed = self.embeding(x) <span class="comment">#[batchsize, seqlen, embed_size]</span></span><br><span class="line">        out, _ = self.lstm(embed)</span><br><span class="line">        out = torch.cat((embed, out), dim = <span class="number">2</span>)</span><br><span class="line">        out = F.relu(out)</span><br><span class="line">        out = out.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        out = self.maxpool(out).reshape(out.size()[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">        out = self.fc(out)</span><br><span class="line">        out = self.softmax(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="comment">#     cfg = Config()</span></span><br><span class="line"><span class="comment">#     model_textcls = Model(config = cfg)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相关配置数据文件configs.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.n_vocab = <span class="number">1002</span></span><br><span class="line">        self.embed_size = <span class="number">256</span></span><br><span class="line">        self.hidden_size = <span class="number">256</span></span><br><span class="line">        self.num_layers = <span class="number">3</span></span><br><span class="line">        self.dropout = <span class="number">0.8</span></span><br><span class="line">        self.num_classes = <span class="number">2</span></span><br><span class="line">        self.pad_size = <span class="number">32</span></span><br><span class="line">        self.batch_size =  <span class="number">128</span></span><br><span class="line">        self.is_shuffle = <span class="literal">True</span></span><br><span class="line">        self.learn_rate = <span class="number">0.001</span></span><br><span class="line">        self.num_epochs = <span class="number">100</span></span><br><span class="line">        self.devices = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="网络训练"><a href="#网络训练" class="headerlink" title="网络训练"></a>网络训练</h1><ul>
<li><p>train.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim </span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> data_loader, text_ClS</span><br><span class="line"><span class="keyword">from</span> configs <span class="keyword">import</span> Config</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">model_path = <span class="string">&quot;models&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_path): <span class="comment">#mkdir函数用于创建单级目录，makedirs函数用于创建多级目录</span></span><br><span class="line">    os.mkdir(model_path)</span><br><span class="line"></span><br><span class="line">cfg = Config()</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载数据</span></span><br><span class="line">data_path = <span class="string">&quot;sources/weibo_senti_100k.csv&quot;</span></span><br><span class="line">data_stop_path = <span class="string">&quot;sources/hit_stopwords.txt&quot;</span></span><br><span class="line">dict_path = <span class="string">&quot;sources/dict.txt&quot;</span>  </span><br><span class="line">dataset = text_ClS(dict_path, data_path, data_stop_path)</span><br><span class="line">train_dataloader = data_loader(dataset, cfg)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载模型</span></span><br><span class="line">cfg.pad_size = dataset.max_len_seq</span><br><span class="line">model_text_cls = Model(cfg)</span><br><span class="line">model_text_cls.to(cfg.devices)</span><br><span class="line"></span><br><span class="line"><span class="comment">#损失函数</span></span><br><span class="line">loss_func = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment">#优化器</span></span><br><span class="line">optimizer = optim.Adam(model_text_cls.parameters(), lr = cfg.learn_rate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(cfg.num_epochs):</span><br><span class="line">    <span class="keyword">for</span> i, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dataloader):</span><br><span class="line">        label, data = batch</span><br><span class="line">        data = torch.as_tensor(data).to(cfg.devices)</span><br><span class="line">        label = torch.as_tensor(label, dtype = torch.int64).to(cfg.devices)</span><br><span class="line"></span><br><span class="line">        pred = model_text_cls.forward(data)</span><br><span class="line">        loss_val = loss_func(pred, label)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;epoch is &#123;&#125;, step is &#123;&#125;, val is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch, i, loss_val))</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss_val.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>: <span class="comment">#每十个epoch存一次模型</span></span><br><span class="line">        torch.save(model_text_cls.state_dict(), <span class="string">&quot;model/&#123;&#125;.path&quot;</span>.<span class="built_in">format</span>(epoch))</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>SV之函数与任务</title>
    <url>/2023/08/16/SV%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>本节主要介绍了SystemVerilog中函数与任务的基础知识</p>
<span id="more"></span>
<h1 id="函数function"><a href="#函数function" class="headerlink" title="函数function"></a>函数function</h1><ul>
<li><p>任务的首要目的在于为运算表达式提供返回值</p>
</li>
<li><p><strong>函数定义时会在内部隐式定义一个变量（默认logic类型），该寄存器变量和函数同名并且位宽也一致</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function logic [15: 0] myfunc2;</span><br><span class="line">    input [7: 0] x;</span><br><span class="line">	input [7: 0] y;</span><br><span class="line">    myfunc1 = x * y -1;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><ul>
<li><p><strong>子程序中包含有延迟、时序或者事件控制结构时只能使用任务</strong></p>
</li>
<li><p><strong>若没有声明类型，那么默认是1bit的logic</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task mytask(input [7: 0] x, input [7: 0] y, output [15: 0] z);</span><br><span class="line">	z = x * y - 1;</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="函数与任务的区别"><a href="#函数与任务的区别" class="headerlink" title="函数与任务的区别"></a>函数与任务的区别</h1><ul>
<li><p>function不会消耗仿真时间，而task则可能会消耗仿真时间</p>
<p>| 函数                                                   | 任务                                                         |<br>| ——————————————————————————— | —————————————————————————————— |<br>| function无法调用task                                   | task可以调用function                                         |<br>| <strong>函数一定不能包含任何延迟、事件或者时序控制声明语句</strong> | <strong>任务可以包含延迟、事件或者时序控制声明语句</strong>               |<br>| 函数至少有一个输入变量，函数可以有多个输入变量         | 任务可以没有或者有多个输入、输出和双向变量                   |<br>| <strong>函数只能返回一个值</strong>，函数不能输出或者双向变量       | <strong>任务或者<code>function void function_name</code>没有返回值</strong>，任务可以通过输出或者双向变量传递多个值 |</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV之数据类型</title>
    <url>/2023/08/15/SV%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>本节主要介绍了SystemVerilog中的基本数据类型以及自定义数据类型</p>
<span id="more"></span>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li><p>SystemVerilog中的信号同时具有类型和数据类型</p>
</li>
<li><p><strong>类型</strong>表示信号是<strong>线网</strong>还是<strong>变量</strong>：</p>
<script type="math/tex; mode=display">
类型\begin{cases}
变量(var)：可以用连续赋值或者过程赋值\\
线网(wire)：只能用于连续赋值语句(assign)\\
\end{cases}\\</script></li>
<li><p><strong>数据类型</strong>表示变量和线网的值是<strong>二值逻辑</strong>还是<strong>四值逻辑</strong></p>
<script type="math/tex; mode=display">
数据类型\begin{cases}
四值逻辑：1、0、x、z\\
二值逻辑：1、0\\
\end{cases}\\</script></li>
<li><p>常见的二值逻辑与四值逻辑如下：</p>
<script type="math/tex; mode=display">
\begin{cases}
四值逻辑类型：logic、integer、reg、net-type(wire、tri)\\
二值逻辑类型：bit、byte、shortint、int、longint\\
\end{cases}\\</script></li>
<li><p>有符号类型与无符号类型的划分如下：</p>
<script type="math/tex; mode=display">
\begin{cases}
有符号类型：byte(8bit)、shortint(16bit)、int(32bit)、longint(64bit)、integer\\
无符号类型：bit、logic、reg、net-type(wire、tri)\\
\end{cases}\\</script></li>
<li><p>可以在有符号类型后添加<code>unsigned</code>来表示无符号类型，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte unsigned //等同于bit[7:0],表示的数值范围是[0, 255]</span><br></pre></td></tr></table></figure>
</li>
<li><p>需记住变量最常用的<strong>logic、bit都默认为无符号变量var</strong>，而所有的线网类型只能是四值逻辑类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logic [0: 7] array [0: 255]; //256个8bit数据组成的数组</span><br><span class="line">(var) logic [63: 0] addr;</span><br><span class="line">wire logic [63: 0] data;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>四值逻辑变量在仿真开始时初值为X，二值逻辑变量在仿真开始时初值为0</strong></p>
</li>
<li><p>如果四值逻辑与二值逻辑的数据类型之间发生默认转换，那么X和Z值将转换为0</p>
</li>
<li><p><strong>SV添加void类型来表示空类型，经常用在函数定义时表示不会返回数值</strong></p>
</li>
<li><p><strong>SV添加shortreal表示32位单精度浮点类型（同C语言的float）</strong></p>
</li>
<li><p><strong>未指定类型No type specified-未指定数据类型No data type specified时，默认类型端口为wire</strong></p>
</li>
<li><p>指定数据类型时，默认类型为wire（输入和输入输出端口）和var（输出端口）</p>
</li>
<li><p><strong>未指定数据类型No data type specified-所有端口的默认数据类型为logic（4态）</strong></p>
</li>
</ul>
<hr>
<h1 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h1><ul>
<li><p><strong>通过<code>typedef</code>来创建用户自定义类型</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int unsigned uint;</span><br><span class="line">uint a, b;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过<code>enum</code>来创建枚举类型</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum &#123;red, green, blue&#125; RGB</span><br></pre></td></tr></table></figure>
<ul>
<li><p>默认的枚举类型是int，在未赋值情况下默认第一个数为0</p>
</li>
<li><p>为了能够更准确地描述硬件，SV允许指明枚举类型的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum logic [1: 0] &#123;WAITE, LOAD, READY&#125; state</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个枚举类型数据被赋值，那么所附的值必须符合其数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enmu logic [2: 0] &#123;WAITE = 3&#x27;b001, LoAD = 3&#x27;b010, READY = 3&#x27;b100&#125; state</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>整形不能直接赋值给枚举类型</strong></p>
</li>
<li><p>枚举类型可以和typedef联合使用，来声明自定义类型，这使得可以用同一个枚举类型来声明多个变量或者线网</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum &#123;WAITE, LOAD, READY&#125; state_t;</span><br><span class="line">states_t state, next_state;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>通过<code>struct</code>来创建结构体类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	opcode_t opcode;</span><br><span class="line">	logic [23: 0] address;</span><br><span class="line">	bit error;</span><br><span class="line">&#125; Instruction_Word;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类似于枚举类型，结构体类型也可以伴随着typedef来实现自定义结构体类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	opcode_t opcode;</span><br><span class="line">	logic [23: 0] address;</span><br><span class="line">	bit error;</span><br><span class="line">&#125; instruction_Word_t;</span><br><span class="line">instruction_Word_t IW;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体类型默认也是变量类型，用户也可以显示声明其为var或者wire类型</p>
</li>
<li><p>结构体变量可以通过<code>.</code>索引对成员赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IW.a = 100;</span><br><span class="line">IW.opcode = 8&#x27;hFF;</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以通过<code>&#39;</code>和<code>&#123;&#125;</code>整体赋初值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IW = &#x27;&#123;100, 3, 8&#x27;hFF, 0&#125;; //位置对应赋值</span><br><span class="line">IW = &#x27;&#123;address:0, opcode:8&#x27;hFF, a:100, b:5&#125;; //名字索引赋值</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><ul>
<li><p>字符串类型变量的存储单元为byte类型</p>
</li>
<li><p>字符串结尾没有“空字符”即null字符“\0”</p>
</li>
<li><p>字符串最高位从0开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef logic [15: 0] r_t;</span><br><span class="line">r_t r;</span><br><span class="line">string b = &quot;&quot;; //相当于string b</span><br><span class="line">r = r_t&#x27;(a); //显示转换，将a转化为数据类型r_t并赋值给r</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串内建方法：</p>
<ul>
<li><p><code>str.len()</code> //返回字符串的长度</p>
</li>
<li><p><code>str.putc(i, c)</code> //将第i个字符替换成字符C，等同于stri[i]=c</p>
</li>
<li><p><code>str.getc(i)</code> //返回第i个字符</p>
</li>
<li><p><code>str.substr(i, j)</code> //将从第i个字符到第j个字符的字符串返回</p>
</li>
<li><p><code>str.&#123;atoi(), atohex(), atooct(), atobin()&#125;</code> //将字符串转变为十进制、十六进制、八进制或者二进制数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str = &quot;123&quot;;</span><br><span class="line">int i = str.atoi(); //将”123“转化为整数123</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV之设计特性与接口</title>
    <url>/2023/08/15/SV%E4%B9%8B%E8%AE%BE%E8%AE%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>本节主要介绍了SystemVerilog中比verilog更好用的相关特性以及在基础语言上扩展的接口。</p>
<span id="more"></span>
<h1 id="过程语句块新特性"><a href="#过程语句块新特性" class="headerlink" title="过程语句块新特性"></a>过程语句块新特性</h1><ul>
<li>always语句块被细分为了：<ul>
<li>组合逻辑语句块：<code>always_comb</code></li>
<li>锁存逻辑语句块：<code>always_latch</code></li>
<li>时序逻辑语句块：<code>always_ff</code></li>
</ul>
</li>
</ul>
<h2 id="1-过程语句块always-comb"><a href="#1-过程语句块always-comb" class="headerlink" title="1.过程语句块always_comb"></a>1.过程语句块always_comb</h2><ul>
<li><p>always_comb用来表示组合逻辑</p>
</li>
<li><p>always_comb可以自动嵌入敏感列表</p>
</li>
<li><p>always_comb可以禁止共享变量，即赋值左侧的变量无法被另一个过程块所赋值</p>
</li>
<li><p>always_comb在仿真0时刻会自动触发一次，无论在0时刻是否有敏感信号列表中的信号发生变化</p>
</li>
<li><p><strong>软件工具会检查该过程快，如果其所表示的不是组合逻辑，那么会发生警告</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">always_comb if (en) y=a; //此时软件工具会报警告</span><br></pre></td></tr></table></figure>
</li>
<li><p>Verilog @*的敏感列表声明方式不同于always_comb:</p>
<ul>
<li><p>always_comb会限制其他过程块对同一变量进行赋值</p>
</li>
<li><p>always_comb会将被调用函数中可能参与运算的其他信号也声明到敏感列表中</p>
<p><img src="/2023/08/15/SV%E4%B9%8B%E8%AE%BE%E8%AE%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20230815155051049.png" alt="image-20230815155051049"></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-过程语句块always-latch"><a href="#2-过程语句块always-latch" class="headerlink" title="2.过程语句块always_latch"></a>2.过程语句块always_latch</h2><ul>
<li><p>always_latch表示锁存逻辑，且自动插入敏感列表</p>
</li>
<li><p>EDA工具会检查always_latch过程块是否真正实现了锁存逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">always_latch</span><br><span class="line">if (enable) q &lt;= d;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-过程语句块always-ff"><a href="#3-过程语句块always-ff" class="headerlink" title="3.过程语句块always_ff"></a>3.过程语句块always_ff</h2><ul>
<li><p>always_ff用来表示时序逻辑</p>
</li>
<li><p>敏感列表必须指令posedge或者negedge</p>
</li>
<li><p>EDA工具也会检明always_ff过程块语句是否实现了时序逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">always_ff @(posedge clock, negedge resetN)</span><br><span class="line">	if (!resetN) q &lt;= 0;</span><br><span class="line">	else q &lt;= d;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h1><ul>
<li><p>SV可以通过<code>&#39;0，&#39;1，&#39;z和&#39;x</code>来分别填充0、1、z、和x，通过这种方法，代码会根据向量的宽度自动填充</p>
</li>
<li><p>SV添加了<code>inside</code>操作符，用来检查数值是否在一系列值的集合当中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logic [2: 0] a;</span><br><span class="line">if (a inside &#123;3&#x27;b001, 3&#x27;b010, 3&#x27;b100&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="增强的case语句"><a href="#增强的case语句" class="headerlink" title="增强的case语句"></a>增强的case语句</h1><ul>
<li><p><code>unique case</code>要求每次case选择必须只能满足一条case选项</p>
<p><img src="/2023/08/15/SV%E4%B9%8B%E8%AE%BE%E8%AE%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20230815161214746.png" alt="image-20230815161214746"></p>
</li>
<li><p><code>priority case</code>则表示必须至少有一个case选项满足要求，如果有多个case选项满足要求时，第一个满足的分支将会被执行</p>
</li>
</ul>
<hr>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li><p>接口不单单可以包含变量或者线网，它还可以封装模块之间通信的协议</p>
</li>
<li><p>接口无法例化module，但是接口可以例化接口</p>
</li>
<li><p>接口中可以进一步声明<code>modport</code>来约束不同模块连接时的信号方向</p>
</li>
<li><p><strong>接口信号必须采用非阻塞赋值来驱动</strong></p>
<p><img src="/2023/08/15/SV%E4%B9%8B%E8%AE%BE%E8%AE%A1%E7%89%B9%E6%80%A7%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20230815170109218.png" alt="image-20230815170109218"></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/431292026">System Verilog的接口（interface）（1） - 知乎 (zhihu.com)</a></p>
</li>
</ul>
<hr>
<h1 id="组合逻辑、锁存器、时序逻辑相关"><a href="#组合逻辑、锁存器、时序逻辑相关" class="headerlink" title="组合逻辑、锁存器、时序逻辑相关"></a>组合逻辑、锁存器、时序逻辑相关</h1><ul>
<li>为什么if不加else会生成锁存器？<a href="https://www.runoob.com/w3cnote/verilog-latch.html">6.5 Verilog 避免 Latch | 菜鸟教程 (runoob.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu之问题及其解决方法记录</title>
    <url>/2023/08/12/ubuntu%E4%B9%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文将记录在使用ubuntu过程中遇到的问题及其解决办法</p>
<span id="more"></span>
<h1 id="su-Authentication-failure报错"><a href="#su-Authentication-failure报错" class="headerlink" title="su: Authentication failure报错"></a>su: Authentication failure报错</h1><ul>
<li><p>su切换至root权限时报错<strong>su: Authentication failure</strong></p>
</li>
<li><p><strong>分析原因：</strong>可能是初次使用此命令，需要更新root密码。</p>
</li>
<li><p><strong>解决方法：</strong>执行<strong>sudo passwd root</strong>命令，完成后再次输入su即可切换权限</p>
<p><img src="/2023/08/12/ubuntu%E4%B9%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/image-20230812180046395.png" alt="image-20230812180046395"></p>
</li>
<li><p><a href="https://blog.csdn.net/TuringZGJ/article/details/108149880">su 报错su: Authentication failure_逐鹿艾缇的博客-CSDN博客</a></p>
</li>
</ul>
<hr>
<h1 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h1><ul>
<li><p>共享文件夹设置：在虚拟机设置中找到共享文件夹设置，且在Windows下D盘中创建一个共享文件夹<br><img src="/2023/08/12/ubuntu%E4%B9%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/image-20230812205925457.png" alt="image-20230812205925457" style="zoom:50%;"></p>
</li>
<li><p>关机后再开机，在开机页面：选择虚拟机再点击重新安装VMware Tools</p>
</li>
<li><p>进入桌面后创建一个VMwareTools文件夹</p>
</li>
<li><p>双击打开VMware Tools的文件，将VMwareTools-10.3.10-13959562.tar.gz这个文件复制到刚刚新建好的文件夹VMwareTools </p>
</li>
<li><p>在 VMware Tools 这个文件夹里，右击打开 terminal，解压压缩文件VMwareTools-10.3.10-13959562.tar.gz，使用命令：<code>tar -zxvf VMwareTools-10.3.10-13959562.tar.gz</code></p>
</li>
<li><p>解压出一个文件夹 vmware-tools-distrib，打开这个文件夹，右击打开 terminal，进入 root，然后输入<code>sudo ./vmware-install.pl</code>, 回车，运行这个文件</p>
</li>
<li><p>出现选项的地方直接回车，一路回车，最终安装完成</p>
</li>
<li><p>在 root 下输入下面的命令：<code>vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</code></p>
</li>
<li><p>进入目录/usr/local/bin 下，右击打开 terminal→进入 root→输入 <code>gedit mnt</code></p>
</li>
<li><p>进入文本编辑器的界面，输入下面的内容：</p>
<p><img src="/2023/08/12/ubuntu%E4%B9%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/image-20230812211117503.png" alt="image-20230812211117503"></p>
</li>
<li><p>在terminal输入<code>chmod u+x mnt</code></p>
</li>
<li><p>最后，以后每次用到共享文件夹时，只需要直接输入<code>/mnt/hgfs</code>，即可找到共享文件夹</p>
</li>
</ul>
<hr>
<h1 id="ubuntu磁盘扩容"><a href="#ubuntu磁盘扩容" class="headerlink" title="ubuntu磁盘扩容"></a>ubuntu磁盘扩容</h1><ul>
<li>问题描述：在home中创建文件夹时报错No space left on device</li>
<li>问题分析：vmware虚拟机磁盘空间不足</li>
<li>解决办法：磁盘扩容<ul>
<li><a href="https://blog.csdn.net/qq_44447544/article/details/128189713">Ubuntu22.04 磁盘扩容_ubuntu 22.04 lts 虚拟机 硬盘扩容_雪天鱼的博客-CSDN博客</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="ubuntu之gvim下载与相关配置"><a href="#ubuntu之gvim下载与相关配置" class="headerlink" title="ubuntu之gvim下载与相关配置"></a>ubuntu之gvim下载与相关配置</h1><ul>
<li><p><a href="https://blog.csdn.net/bigtree9527/article/details/128560670">Linux环境下Ubuntu系统中下载gvim及相关配置_ubuntu安装gvim_bigtree9527的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_45061010/article/details/120668601">ubuntu中vim简易配置_ubuntu vim配置_maosql的博客-CSDN博客</a></p>
</li>
<li><p>搜了各种资料，觉得vim还是很难用，决定转战vscode，打算在windows下的共享文件夹中创建文件，在windonws下使用vscode编辑SV代码，接下来需要在vscode中配置systemverilog的编辑条件</p>
<ul>
<li><p><strong>首先，安装如下插件</strong>：</p>
<p><img src="/2023/08/12/ubuntu%E4%B9%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/image-20230825200224520.png" alt="image-20230825200224520"></p>
</li>
<li><p><strong>其次，下载ctags</strong></p>
<ul>
<li><p><a href="https://github.com/universal-ctags/ctags-win32/releases/tag/v6.0.0">Release v6.0.0 · universal-ctags/ctags-win32 (github.com)</a></p>
<p><img src="/2023/08/12/ubuntu%E4%B9%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/image-20230825200614554.png" alt="image-20230825200614554"></p>
</li>
</ul>
</li>
<li><p><strong>接着，配置环境变量</strong>：将这个路径添加到系统环境变量中</p>
<p><img src="/2023/08/12/ubuntu%E4%B9%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/image-20230825200736729.png" alt="image-20230825200736729"></p>
<ul>
<li><p>首先输入“win+R”，打开运行框，然后在里面输入命令：control system，在打开的系统信息界面中，选择左侧菜单的“高级系统设置”，随后在打开的“系统属性”窗口选择下方的“环境变量”选项</p>
</li>
<li><p>接着如图所示操作：</p>
<p><img src="/2023/08/12/ubuntu%E4%B9%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/image-20230825201049324.png" alt="image-20230825201049324"></p>
</li>
</ul>
</li>
<li><p><strong>在vscode中配置插件</strong>：按如下图所示操作</p>
<p><img src="/2023/08/12/ubuntu%E4%B9%8B%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/image-20230825201348926.png" alt="image-20230825201348926"></p>
</li>
<li><p>最后重启vscode即可完成设置</p>
</li>
</ul>
</li>
<li><p>发现把文件直接放在共享文件夹中编译，会报错，故在ubuntu中安装vscode，其配置与windows中类似，参考此教程：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/456446138">Linux下使用VSCode+iVerilog进行Verilog开发 - 知乎 (zhihu.com)</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="Ubuntu安装VCS、Verdi参考"><a href="#Ubuntu安装VCS、Verdi参考" class="headerlink" title="Ubuntu安装VCS、Verdi参考"></a>Ubuntu安装VCS、Verdi参考</h1><ul>
<li><a href="https://blog.csdn.net/lum250/article/details/123755261">Ubuntu18.04 安装 synopsys2018 EDA工具（vcs、verdi）记录_synopsys installer 安装_lu-ming.xyz的博客-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数之二次型</title>
    <url>/2023/08/12/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E4%BA%8C%E6%AC%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>本节主要介绍了二次型矩阵与二次型标准化的方法</p>
<span id="more"></span>
<h1 id="二次型矩阵"><a href="#二次型矩阵" class="headerlink" title="二次型矩阵"></a>二次型矩阵</h1><ul>
<li><p>二次型到矩阵表达式的方法：</p>
<ul>
<li>平方项的系数直接做成主对角线元素</li>
<li>交叉项的系数除以2，放到两个对称的相应位置上</li>
</ul>
<p><img src="/2023/08/12/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E4%BA%8C%E6%AC%A1%E5%9E%8B/image-20230812101559338.png" alt="image-20230812101559338" style="zoom: 50%;"></p>
</li>
<li><p>则$f(x_1,x_2,x_3)=X^TAX$，其中矩阵A则称为二次型矩阵</p>
</li>
<li><p>二次型的矩阵一定都是对称的：$A^T=A$</p>
</li>
<li><p>标准型：只有平方项</p>
</li>
<li><p>线性替换：</p>
<script type="math/tex; mode=display">
f(x)=X^TAX(令X=CY)\\
=(CY)^TACY\\
=Y^T(C^TAC)Y</script></li>
<li><p><strong>$X=CY$称为线性替换，若使得$B=C^TAC$为对角形，那么线性替换后就变成以Y为变量的标准型</strong></p>
</li>
<li><p>线性替换后矩阵仍是对称的</p>
</li>
</ul>
<hr>
<h1 id="二次型化标准型"><a href="#二次型化标准型" class="headerlink" title="二次型化标准型"></a>二次型化标准型</h1><h2 id="1-配方法"><a href="#1-配方法" class="headerlink" title="1.配方法"></a>1.配方法</h2><p><img src="/2023/08/12/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E4%BA%8C%E6%AC%A1%E5%9E%8B/image-20230812110856494.png" alt="image-20230812110856494" style="zoom: 33%;"></p>
<h2 id="2-初等变换法"><a href="#2-初等变换法" class="headerlink" title="2.初等变换法"></a>2.初等变换法</h2><p><img src="/2023/08/12/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E4%BA%8C%E6%AC%A1%E5%9E%8B/image-20230812112500695.png" alt="image-20230812112500695" style="zoom:33%;"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数之特征值与特征向量</title>
    <url>/2023/08/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<p>本节主要介绍了矩阵的特征值与特征向量、相似矩阵、矩阵可对角化的条件以及实对称矩阵的对角化</p>
<span id="more"></span>
<h1 id="矩阵的特征值与特征向量"><a href="#矩阵的特征值与特征向量" class="headerlink" title="矩阵的特征值与特征向量"></a>矩阵的特征值与特征向量</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul>
<li><strong>A是n阶方阵，对于一个数$\lambda$，存在非零列向量，使得$A\alpha=\lambda\alpha$成立，那么$\lambda$为特征值，$\alpha$为对应$\lambda$的特征向量</strong></li>
<li>$\lambda$可以为0，但特征向量不能为0向量</li>
<li><strong>特征方程</strong>：$|\lambda E-A|=0$<ul>
<li><strong>通过求解特征方程计算$\lambda$，求出$\lambda$后带入$(\lambda E-A)\alpha=0$中求解齐次方程，而方程的基础解系就是特征向量</strong></li>
<li>若能证明两个矩阵的$|\lambda E-A|$相等，那么就说明这两个矩阵有相同的特征值</li>
</ul>
</li>
<li><strong>$\lambda$是A的特征值，$\alpha$是$\lambda$对应的特征向量，则$c\alpha$也是$\lambda$的特征向量$(c\ne 0)$</strong></li>
<li>一个特征向量只能对应一个特征值</li>
<li><p><strong>若$\alpha_1,\alpha_2$是$\lambda$的特征向量，则$c_1\alpha_1+c_2\alpha_2$也是$\lambda$的特征向量</strong></p>
</li>
<li><p><strong>上三角矩阵中，n阶对角线上的特征值就是主对角线上的n个元素</strong></p>
</li>
</ul>
<h2 id="2-基本性质"><a href="#2-基本性质" class="headerlink" title="2.基本性质"></a>2.基本性质</h2><ul>
<li><strong>$A$和$A^T$有相同的特征值，但其特征向量不一定相同</strong></li>
<li>若矩阵A有n个特征值$\lambda_1,\lambda_2,…,\lambda_n$，有：<ul>
<li>$\sum_{i=1}^{n}\lambda_i=\sum_{i=1}^na_{ii}$：<strong>特征值相加等于主对角线元素相加</strong></li>
<li>$\lambda_1\lambda_2…\lambda_n=|A|$：<strong>特征值相乘等于矩阵的行列式</strong></li>
</ul>
</li>
<li><strong>互不相同的特征值$\lambda_1,\lambda_2,…,\lambda_m$对应的特征向量$\alpha_1,\alpha_2,…,\alpha_m$线性无关</strong></li>
<li><strong>k重特征根对应的特征向量个数$\le k$</strong>（单根对应的特征向量就为1）</li>
<li>$k\lambda$是$kA$的特征值</li>
<li>$\lambda^k$是$A^k$的特征值</li>
<li>若$\lambda$是$A$的特征值，则：<ul>
<li>$\frac{1}{\lambda}是$$A^{-1}$的特征值</li>
<li>$\frac1{\lambda}|A|$是$A^*$的特征值</li>
</ul>
</li>
</ul>
<hr>
<h1 id="相似矩阵和矩阵可对角化的条件"><a href="#相似矩阵和矩阵可对角化的条件" class="headerlink" title="相似矩阵和矩阵可对角化的条件"></a>相似矩阵和矩阵可对角化的条件</h1><h2 id="1-相似矩阵"><a href="#1-相似矩阵" class="headerlink" title="1.相似矩阵"></a>1.相似矩阵</h2><ul>
<li><p>相似矩阵：若A、B为n阶方阵，若存在n阶可逆矩阵P，使得$P^{-1}AP=B$成立，则说明$A\sim B$（A相似于B）</p>
<ul>
<li>$A\sim A$</li>
<li>若$A\sim B$，则$B \sim A$</li>
<li>若$A\sim B,B\sim C$，则$A\sim C$</li>
</ul>
</li>
<li><p>相关性质：</p>
<ul>
<li>若$A\sim B$，则$A、B$具有相同的特征值，且$|A|=|B|$，特征值之和相等</li>
<li>若$A\sim B$，则$A可逆\Leftrightarrow B可逆$，$A^{-1}\sim B^{-1}$</li>
<li>若$A\sim B$，则$A^m\sim B^m$</li>
</ul>
</li>
</ul>
<h2 id="2-矩阵可角化条件"><a href="#2-矩阵可角化条件" class="headerlink" title="2.矩阵可角化条件"></a>2.矩阵可角化条件</h2><ul>
<li><p><strong>A相似于对角形矩阵（只在对角线有元素，其他位置为0）$\Leftrightarrow$A有n个线性无关的特征向量</strong></p>
</li>
<li><p>若A有n个不相同的特征根，则A相似于对角形</p>
</li>
<li><p>对角形矩阵为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
\lambda_{1} & 0 & \dots & 0\\
0 & \lambda_{2} & \dots & 0\\
\dots & \dots & \dots & \dots \\
0 & 0 & \dots & \lambda_{n}\\
\end{bmatrix}</script></li>
<li><p>可逆矩阵P为：</p>
<script type="math/tex; mode=display">
P=\begin{bmatrix}
\alpha_{1} & \alpha_{2} & \dots & \alpha_{n}
\end{bmatrix}</script></li>
<li><p><strong>A相似于对角形矩阵$\Leftrightarrow r_i$重根的基础解系有$r_i$个</strong></p>
<p><img src="/2023/08/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/image-20230811135014738.png" alt="image-20230811135014738" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h1 id="实对称矩阵的对角化"><a href="#实对称矩阵的对角化" class="headerlink" title="实对称矩阵的对角化"></a>实对称矩阵的对角化</h1><h2 id="1-向量的长度（范数、模）"><a href="#1-向量的长度（范数、模）" class="headerlink" title="1.向量的长度（范数、模）"></a>1.向量的长度（范数、模）</h2><ul>
<li><p>计算公式：</p>
<script type="math/tex; mode=display">
||\alpha||=\sqrt{(\alpha,\alpha)}</script><p>其中(,)表示进行内积运算</p>
</li>
<li><p>单位化（标准化）：使得模值为1</p>
<script type="math/tex; mode=display">
\frac1{||\alpha||}\alpha</script></li>
<li><p>相关性质</p>
<ul>
<li>$||\alpha||\ge 0$</li>
<li>$||\alpha||=0\Leftrightarrow \alpha=0$</li>
<li>$||k\alpha||=|k|\cdot||\alpha||$</li>
</ul>
</li>
<li><p><strong>柯西-施瓦茨不等式</strong>：</p>
<script type="math/tex; mode=display">
|(\alpha,\beta)|\le ||\alpha||\cdot||\beta||</script></li>
<li><p><strong>三角形不等式</strong>：</p>
<script type="math/tex; mode=display">
||\alpha+\beta||\le ||\alpha||+||\beta||</script></li>
</ul>
<h2 id="2-正交（垂直）"><a href="#2-正交（垂直）" class="headerlink" title="2.正交（垂直）"></a>2.正交（垂直）</h2><ul>
<li><p>定义：$(\alpha,\beta)=0$</p>
</li>
<li><p>正交向量组：<strong>不含零向量</strong>的一组$a_1,a_2,…,a_s$向量两两正交</p>
</li>
<li><p>标准正交向量组：</p>
<script type="math/tex; mode=display">
\begin{cases}
(\alpha_i,\alpha_i)=1\\
(\alpha_i,\alpha_j)=0
\end{cases}\\</script></li>
<li><p>定理：<strong>$a_1,a_2,…,a_s$是正交向量组，则$a_1,a_2,…,a_s$是线性无关的</strong></p>
</li>
</ul>
<h2 id="3-正交矩阵"><a href="#3-正交矩阵" class="headerlink" title="3.正交矩阵"></a>3.正交矩阵</h2><ul>
<li>定义：A为n阶方阵，若满足$A^T A=E$，则A为正交矩阵</li>
<li>相关性质：<ul>
<li>若A为正交矩阵，那么$|A|=1\,or\,-1$</li>
<li><strong>若A为正交矩阵，那么$A^{-1}=A^T$，且$A^{-1}$和$A^T$均为正交矩阵</strong></li>
<li>若A、B为正交矩阵，那么AB也为正交矩阵</li>
<li>若A为正交矩阵，$\alpha,\beta$为列向量，则$(A\alpha,A\beta)=(\alpha,\beta)$</li>
</ul>
</li>
<li>相关定理：A为正交矩阵$\Leftrightarrow$A的列（行）向量组是标准正交向量组</li>
</ul>
<h2 id="4-正交相似"><a href="#4-正交相似" class="headerlink" title="4.正交相似"></a>4.正交相似</h2><ul>
<li>A、B是同阶方阵，若存在正交矩阵P，使得$P^{-1}AP=B$成立，则称A正交相似于B</li>
</ul>
<h2 id="5-实对称矩阵"><a href="#5-实对称矩阵" class="headerlink" title="5.实对称矩阵"></a>5.实对称矩阵</h2><ul>
<li>实对称矩阵的定义：$A^T=A$</li>
<li><strong>定理：实对称A的不同特征值的特征向量正交</strong></li>
<li><strong>实对称矩阵一定能对角化</strong></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数之线性方程组</title>
    <url>/2023/08/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<p>本节主要介绍了非齐次线性方程与齐次线性方程的解法</p>
<span id="more"></span>
<h1 id="线性方程组有解判定"><a href="#线性方程组有解判定" class="headerlink" title="线性方程组有解判定"></a>线性方程组有解判定</h1><ul>
<li><p>若由如下方程组：</p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
x_1 + x_2 + x_3 &= 1\\
x_1 - x_2 - x_3 &= -3\\
2x_1 + 9x_2 + 10x_3 &= 11\\
\end{aligned}
\end{cases}</script></li>
<li><p>则系数矩阵为：</p>
<script type="math/tex; mode=display">
A=\begin{bmatrix}
1 & 1 & -1\\
1 & -1 & -1\\
2 & 9 & 10\\
\end{bmatrix}</script></li>
<li><p>增广矩阵为：</p>
<script type="math/tex; mode=display">
\bar A=\begin{bmatrix}
1 & 1 & -1 & 1\\
1 & -1 & -1 & -3\\
2 & 9 & 10 & 11\\
\end{bmatrix}</script></li>
<li><p>在方程组中，通常用m表示方程个数，n表示未知量的个数</p>
</li>
<li><p><strong>是否有解的判断方式</strong>：</p>
<ul>
<li>当$r(A)=r(\bar A)$时，方程组有解：<ul>
<li>若$r(A)=r(\bar A)=n$，则方程组有唯一解</li>
<li>若$r(A)=r(\bar A)&lt;n$，则方程组有无穷多解</li>
</ul>
</li>
<li>当$r(A)\ne r(\bar A)$时，方程组无解</li>
</ul>
</li>
</ul>
<hr>
<h1 id="齐次线性方程组"><a href="#齐次线性方程组" class="headerlink" title="齐次线性方程组"></a>齐次线性方程组</h1><ul>
<li>方程组$Ax=b$中，向量$b$为0向量，即$Ax=0$则称为齐次线性方程组</li>
<li><strong>齐次线性方程组一定有解，至少有零解</strong></li>
<li><strong>齐次线性方程组解的情况</strong>：<ul>
<li>有唯一零解$\Leftrightarrow r(A)=n$</li>
<li>有非零解$\Leftrightarrow r(A)&lt;n$</li>
<li><strong>方程个数m&lt;未知数个数n$\Leftrightarrow$有非零解</strong></li>
<li><strong>方程个数=未知数个数，有非零解$\Leftrightarrow |A|=0$</strong></li>
</ul>
</li>
<li>齐次方程中$Ax=0$，那么：<ul>
<li>若$\eta_1$和$\eta_2$是齐次方程组的解，那么$\eta_1+\eta_2$也是方程组的解</li>
<li>若$\eta$是$Ax=0$的解，那么$c\eta$也是方程组的解</li>
</ul>
</li>
</ul>
<hr>
<h1 id="方程组解的结构"><a href="#方程组解的结构" class="headerlink" title="方程组解的结构"></a>方程组解的结构</h1><h2 id="1-齐次线性方程的结构"><a href="#1-齐次线性方程的结构" class="headerlink" title="1.齐次线性方程的结构"></a>1.齐次线性方程的结构</h2><ul>
<li><p>齐次方程的基础解系：$\eta_1,\eta_2,…,\eta_s$需满足如下条件</p>
<ul>
<li>$\eta_1,\eta_2,…,\eta_s$线性无关</li>
<li>任何解都可以由$\eta_1,\eta_2,…,\eta_s$表示</li>
</ul>
<p><img src="/2023/08/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/image-20230810170229366.png" alt="image-20230810170229366" style="zoom: 50%;"></p>
</li>
<li><p>基础解系的个数$=n-r(A)$</p>
</li>
<li><strong>若$A_{m\times n}B_{n\times s}=0_{m\times s}$，则$r(A)+r(B)\le n$</strong></li>
</ul>
<h2 id="2-非齐次线性方程的结构"><a href="#2-非齐次线性方程的结构" class="headerlink" title="2.非齐次线性方程的结构"></a>2.非齐次线性方程的结构</h2><ul>
<li><p>对于非齐次线性方程组$Ax=b$：</p>
<ul>
<li>若$\alpha_1,\alpha_2$是$Ax=b$的解，$\alpha_1-\alpha_2$是$Ax=0$的解</li>
<li>若$\alpha_0$是$Ax=b$的解，$\eta$是$Ax=0$的解，那么$\alpha_0+\eta$也是$Ax=b$的解</li>
</ul>
</li>
<li><p><strong>非齐次线性方程解的结构=（$Ax=b$的一个特解）+（$Ax=0$的基础解系的线性组合）</strong></p>
<p><img src="/2023/08/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/image-20230810173523688.png" alt="image-20230810173523688" style="zoom:50%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch之卷积神经网络</title>
    <url>/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本节主要介绍了卷积神经网络的基本概念，并以cifar10图像分类任务为例，学习了VGGNET、RESNET、MobileNet、InceptionModule等常见网络的搭建。</p>
<span id="more"></span>
<h1 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h1><h2 id="1-torch-nn-Conv2d"><a href="#1-torch-nn-Conv2d" class="headerlink" title="1.torch.nn.Conv2d"></a>1.torch.nn.Conv2d</h2><ul>
<li>对图像和滤波矩阵做内积（逐个元素相乘再求和）的操作</li>
<li><p><code>torch.nn.Conv2d(in_channels,out_channels,kernel_size,stride=1,padding=0,dilation=1,groups=1,bias=True,padding_mode=&#39;zeros&#39;)</code></p>
<ul>
<li><strong>in_channels</strong>(int)：输入的特征维度</li>
<li><strong>out_channels</strong>(int)：输出的特征维度</li>
<li><strong>kernel_size</strong>(int or tuple)：卷积核大小</li>
<li><strong>stride</strong>(int or tuple)：卷积的步幅，默认值为1</li>
<li><strong>padding</strong>(int or tuple)：添加到输入两侧的零填充数量，默认值为0</li>
<li><strong>dilation</strong>(int or tuple)：内核元素之间的间距，默认值为1</li>
<li><strong>groups</strong>(int)：从输入通道到输出通道的阻塞连接数</li>
<li><strong>bias</strong>(bool)：默认值为True，如果为True，则向输出添加可学习的偏差</li>
<li><strong>padding_mode</strong>(str)：可选值为”zeros”、”reflect”、”replicate”、“circular”，默认值为”zeros”</li>
</ul>
</li>
<li><p>输入输出形状的关系：</p>
<script type="math/tex; mode=display">
H_{out}=[\frac{H_{in}+2\times padding[0]-dilation[0]\times(kernel\_size[0]-1)-1}{stride[0]}+1]</script><script type="math/tex; mode=display">
W_{out}=[\frac{W_{in}+2\times padding[1]-dilation[1]\times(kernel\_size[1]-1)-1}{stride[1]}+1]</script></li>
<li><p><strong>dilation：扩张操作，控制kernel点（卷积核点）的间距</strong></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230809175517005.png" alt="image-20230809175517005" style="zoom: 33%;"></p>
</li>
<li><p><strong>padding_mode：填充方式</strong></p>
<ul>
<li><a href="https://www.jianshu.com/p/a6da4ad8e8e7">PyTorch Conv2d中的四种填充模式解析 - 简书 (jianshu.com)</a></li>
</ul>
</li>
<li><p><strong>Same Padding</strong>：在stride为1的情况下，若想让输入输出尺寸一致，需要指定padding数为kerner_size的一半</p>
</li>
<li><p><strong>Full Padding</strong>：在stride为1的情况下，padding=kerner_size-1</p>
</li>
</ul>
<h2 id="2-torch-nn-ConvTranspose2d"><a href="#2-torch-nn-ConvTranspose2d" class="headerlink" title="2.torch.nn.ConvTranspose2d"></a>2.torch.nn.ConvTranspose2d</h2><ul>
<li><p><code>torch.nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1, padding_mode=&#39;zeros&#39;)</code></p>
</li>
<li><p><strong>在反卷积中，stride参数就是表示往输入图片每两个像素点中间填充0，而填充的数量就是 stride - 1</strong></p>
</li>
<li><p>输入与输出形状的关系：</p>
<script type="math/tex; mode=display">
H_{out}=(H_{in}-1)\times stride[0]-2\times padding[0]+dilation[0]\times(kernel\_size[0]-1)+out\_padding[0]+1</script><script type="math/tex; mode=display">
W_{out}=(W_{in}-1)\times stride[1]-2\times padding[1]+dilation[1]\times(kernel\_size[1]-1)+out\_padding[1]+1</script></li>
<li><p><strong>output_padding的作用就是：在输出图像右侧和下侧补值，用于弥补stride大于1带来的缺失</strong></p>
</li>
<li><p><strong>ConvTranspose2d可用于上采样</strong></p>
</li>
<li><p><a href="https://blog.51cto.com/u_11466419/5459142">反卷积通俗详细解析与nn.ConvTranspose2d重要参数解释_11456419的技术博客_51CTO博客</a></p>
</li>
</ul>
<h2 id="3-感受野"><a href="#3-感受野" class="headerlink" title="3.感受野"></a>3.感受野</h2><ul>
<li>使用两个3×3的卷积核级联与使用一个5×5的卷积核得到的感受野是一样的，但参数个数却少了<br><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107124918062.png" alt="image-20221107124918062" style="zoom:33%;"></li>
</ul>
<h2 id="4-常见的卷积层组合结构"><a href="#4-常见的卷积层组合结构" class="headerlink" title="4.常见的卷积层组合结构"></a>4.常见的卷积层组合结构</h2><ul>
<li><p>堆叠—跳连—并连</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230809190541362.png" alt="image-20230809190541362"></p>
</li>
</ul>
<h2 id="5-池化层"><a href="#5-池化层" class="headerlink" title="5.池化层"></a>5.池化层</h2><ul>
<li>对输入的特征图进行压缩：<ul>
<li>一方面使特征图变小，简化网络计算复杂度</li>
<li>一方面进行特征压缩，提取主要特征</li>
</ul>
</li>
<li><p>最大池化：<code>torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)</code></p>
<ul>
<li><strong>kernel_size</strong> ：表示做最大池化的窗口大小，可以是单个值，也可以是tuple元组</li>
<li><strong>stride</strong> ：步长，可以是单个值，也可以是tuple元组。<strong>如果不指定这个参数，那么默认步长跟最大池化窗口大小一致</strong>。如果指定了参数，那么将按照我们指定的参数进行滑动</li>
<li><strong>padding</strong> ：填充，可以是单个值，也可以是tuple元组</li>
<li><strong>dilation</strong> ：控制窗口中元素步幅</li>
<li><strong>return_indices</strong> ：布尔类型，返回最大值位置索引</li>
<li><strong>ceil_mode</strong> ：布尔类型，为True，用向上取整的方法，计算输出形状；默认是向下取整。</li>
</ul>
</li>
<li><p>输入与输出形状的关系：</p>
<script type="math/tex; mode=display">
H_{out}=[\frac{H_{in}+2\times padding[0]-dilation[0]\times(kernel\_size[0]-1)-1}{stride[0]}+1]</script><script type="math/tex; mode=display">
W_{out}=[\frac{W_{in}+2\times padding[1]-dilation[1]\times(kernel\_size[1]-1)-1}{stride[1]}+1]</script></li>
<li><p><a href="https://blog.csdn.net/weixin_38481963/article/details/109962715">torch.nn.MaxPool2d详解_Medlen的博客-CSDN博客</a></p>
</li>
</ul>
<hr>
<h1 id="激活层"><a href="#激活层" class="headerlink" title="激活层"></a>激活层</h1><ul>
<li>激活函数：为了增加网络的非线性，进而提升网络的表达能力</li>
<li><strong>卷积层后经常加上ReLU层去提高网络的非线性表达能力</strong></li>
<li><code>torch.nn.ReLU()</code></li>
</ul>
<hr>
<h1 id="BatchNorm层"><a href="#BatchNorm层" class="headerlink" title="BatchNorm层"></a>BatchNorm层</h1><ul>
<li>通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布中</li>
<li>Batchnorm是归一化的一种手段，它会减小图像之间的绝对差异，突出相对差异，加快训练速度</li>
<li>BN的缺点：<ul>
<li>batch_size较小的时候，效果差。BN的过程，使用整个batch中样本的均值和方差来模拟全部数据的均值和方差，在batch_size 较小的时候，效果肯定不好</li>
<li>BN在RNN中效果比较差</li>
</ul>
</li>
<li><code>nn.BatchNorm2d(num_features)</code></li>
</ul>
<hr>
<h1 id="Dropout层"><a href="#Dropout层" class="headerlink" title="Dropout层"></a>Dropout层</h1><ul>
<li>在不同的训练过程中随机扔掉一部分神经元</li>
<li>测试过程中不使用随机失活，所有的神经元都激活</li>
<li>为了防止或减轻过拟合而使用的函数，它一般用在全连接层</li>
<li><code>nn.dropout</code></li>
</ul>
<hr>
<h1 id="损失层"><a href="#损失层" class="headerlink" title="损失层"></a>损失层</h1><ul>
<li>损失层：设置一个损失函数用来比较网络的输出和目标值，通过最小化损失来驱动网络的训练</li>
<li>网络的损失通过前向操作计算，网络参数相对于损失函数的梯度则通过反向操作计算</li>
<li>分类问题损失函数：<ul>
<li><code>nn.BCELoss</code>(二分类问题)、<code>nn.CrossEntropyLoss</code>(多分类问题)等</li>
<li>用于分类或分割等问题中</li>
</ul>
</li>
<li>回归问题损失：<ul>
<li><code>nn.L1Loss</code>、<code>nn.MSELoss</code>、<code>nn.SmoothL1Los</code>s等</li>
<li><a href="https://zhuanlan.zhihu.com/p/83131026">PyTorch中的损失函数—L1Loss /L2Loss/SmoothL1Loss - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/zfhsfdhdfajhsr/article/details/115637954">【Pytorch基础】torch.nn.MSELoss损失函数_一穷二白到年薪百万的博客-CSDN博客</a></li>
<li>用于检测或回归问题中</li>
</ul>
</li>
</ul>
<hr>
<h1 id="学习率与优化器"><a href="#学习率与优化器" class="headerlink" title="学习率与优化器"></a>学习率与优化器</h1><ul>
<li>学习率作为监督学习以及深度学习中重要的超参，其决定着目标函数能否收敛到局部最小值以及何时收敛到最小值</li>
<li>合适的学习率能够使目标函数在合适的时间内收敛到局部最小值</li>
<li>torch.optim.lr_sheduler:<ul>
<li>ExponentialR</li>
<li>ReduceLROnPlateau</li>
<li>CyclicLR等</li>
</ul>
</li>
<li>优化器：<a href="https://ptorch.com/news/54.html">pytorch中使用torch.optim优化神经网络以及优化器的选择 - pytorch中文网 (ptorch.com)</a></li>
</ul>
<hr>
<h1 id="cifar10图像分类任务"><a href="#cifar10图像分类任务" class="headerlink" title="cifar10图像分类任务"></a>cifar10图像分类任务</h1><h2 id="1-读取cifar10数据集"><a href="#1-读取cifar10数据集" class="headerlink" title="1.读取cifar10数据集"></a>1.读取cifar10数据集</h2><ul>
<li><p>cifar10训练集包括5个batch，每个batch有10000个数据，每个数据又以字典的形式存储了图片所在的batch值，图片标签，图片数据（3072个数据，即$32\times 32\times 3$），图片名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict_keys([b&#x27;batch_label&#x27;, b&#x27;labels&#x27;, b&#x27;data&#x27;, b&#x27;filenames&#x27;])</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印每张图片标签、图片名称（<strong>注意这里名称是byte存储形式</strong>）、图片数据 nj</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230813215413389.png" alt="image-20230813215413389"></p>
</li>
<li><p>可视化图片数据$32\times 32\times 3$</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230813215723948.png" alt="image-20230813215723948"></p>
</li>
<li><p>每个类别存储在对应文件夹中：</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230813220124842.png" alt="image-20230813220124842" style="zoom:67%;"></p>
</li>
<li><p>最终图片存储形式：</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230813220102126.png" alt="image-20230813220102126" style="zoom: 50%;"></p>
</li>
<li><p>readcifar10.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#在cifar10官网拷贝cifar10数据解析函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unpickle</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fo:</span><br><span class="line">        <span class="built_in">dict</span> = pickle.load(fo, encoding=<span class="string">&#x27;bytes&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义10个label</span></span><br><span class="line">label_name = [<span class="string">&quot;airplane&quot;</span>,</span><br><span class="line">             <span class="string">&quot;automobile&quot;</span>,</span><br><span class="line">             <span class="string">&quot;bird&quot;</span>,</span><br><span class="line">             <span class="string">&quot;cat&quot;</span>,</span><br><span class="line">             <span class="string">&quot;deer&quot;</span>,</span><br><span class="line">             <span class="string">&quot;dog&quot;</span>,</span><br><span class="line">             <span class="string">&quot;frog&quot;</span>,</span><br><span class="line">             <span class="string">&quot;horse&quot;</span>,</span><br><span class="line">             <span class="string">&quot;ship&quot;</span>,</span><br><span class="line">             <span class="string">&quot;truck&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练图片数据存放的路径</span></span><br><span class="line">save_path = <span class="string">&quot;D:\\App_Data_File\\VScode_Project\\Python\\Pytorch\\Cifar10\\cifar10_batches_py\\TRAIN&quot;</span> <span class="comment">#将TRAIN改为TEST即可处理测试集中的内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> glob <span class="comment">#调用glob读取当前文件夹下匹配的文件</span></span><br><span class="line">train_list = glob.glob(<span class="string">&quot;D:\\App_Data_File\\VScode_Project\\Python\\Pytorch\\Cifar10\\cifar10_batches_py\\data_batch_*&quot;</span>)<span class="comment">#将data_batch_*改为test_batch*即可处理测试集中的内容</span></span><br><span class="line"><span class="comment">#print(train_list) #以列表的形式存储了五个文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> train_list:</span><br><span class="line">    <span class="comment">#print(l)</span></span><br><span class="line">    l_dict = unpickle(l)</span><br><span class="line">    <span class="comment">#print(l_dict)</span></span><br><span class="line">    <span class="comment">#print(l_dict.keys()) #打印字典的所有键值key</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> im_idx, im_data <span class="keyword">in</span> <span class="built_in">enumerate</span>(l_dict[<span class="string">b&#x27;data&#x27;</span>]):</span><br><span class="line">        <span class="comment">#print(im_idx)</span></span><br><span class="line">        <span class="comment">#print(im_data)</span></span><br><span class="line">        im_label = l_dict[<span class="string">b&#x27;labels&#x27;</span>][im_idx]</span><br><span class="line">        im_name = l_dict[<span class="string">b&#x27;filenames&#x27;</span>][im_idx]</span><br><span class="line">        <span class="comment">#print(im_label, im_name, im_data)   #打印每张图片标签、图片名称、图片数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#将数据转化为图片形式存储在TRAIN文件夹中</span></span><br><span class="line">        im_label_name = label_name[im_label]</span><br><span class="line">        im_data = np.array(im_data) <span class="comment">#将图片数据转化为np形式</span></span><br><span class="line">        im_data = im_data.reshape(<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>) <span class="comment">#将图片转化为32*32*3的格式</span></span><br><span class="line">        im_data = im_data.transpose(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#cv2.imshow(&#x27;im_data&#x27;, im_data) #可视化读取的图片数据</span></span><br><span class="line">        <span class="comment">#cv2.waitKey(0)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;&#123;&#125;\\&#123;&#125;&quot;</span>.<span class="built_in">format</span>(save_path, im_label_name)): <span class="comment">#对每一个类别创建一个文件夹</span></span><br><span class="line">            os.mkdir(<span class="string">&quot;&#123;&#125;\\&#123;&#125;&quot;</span>.<span class="built_in">format</span>(save_path, im_label_name)) <span class="comment">#如果不存在对应文件夹则创建文件夹</span></span><br><span class="line"></span><br><span class="line">        cv2.imwrite(<span class="string">&quot;&#123;&#125;\\&#123;&#125;\\&#123;&#125;&quot;</span>.<span class="built_in">format</span>(save_path, <span class="comment">#通过imwrite写入图片</span></span><br><span class="line">                                        im_label_name, </span><br><span class="line">                                        im_name.decode(<span class="string">&quot;utf-8&quot;</span>)),</span><br><span class="line">                                        im_data) <span class="comment">#.decode(&quot;utf-8&quot;)将byte型转化为字符串型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-自定义数据加载"><a href="#2-自定义数据加载" class="headerlink" title="2.自定义数据加载"></a>2.自定义数据加载</h2><ul>
<li>load_cifar10.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">label_name = [<span class="string">&quot;airplane&quot;</span>, <span class="string">&quot;automobile&quot;</span>, <span class="string">&quot;bird&quot;</span>,</span><br><span class="line">             <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;deer&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;frog&quot;</span>,</span><br><span class="line">             <span class="string">&quot;horse&quot;</span>, <span class="string">&quot;ship&quot;</span>, <span class="string">&quot;truck&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将字符串label转化为数字0~9</span></span><br><span class="line">label_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> idx, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(label_name):</span><br><span class="line">    label_dict[name] = idx</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">default_loader</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">return</span> Image.<span class="built_in">open</span>(path).convert(<span class="string">&quot;RGB&quot;</span>) <span class="comment">#如果不使用.convert(‘RGB’)进行转换的话，读出来的图像是RGBA四通道的，A通道为透明通道</span></span><br><span class="line"></span><br><span class="line">train_transform = transforms.Compose([</span><br><span class="line">    transforms.RandomCrop(<span class="number">28</span>),</span><br><span class="line">    transforms.RandomHorizontalFlip(),</span><br><span class="line">    transforms.ToTensor()</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">test_transform = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">28</span>,<span class="number">28</span>)),</span><br><span class="line">    transforms.ToTensor()</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># train_transform = transforms.Compose([ #Compose来拼接多个数据增强的方法</span></span><br><span class="line"><span class="comment">#     transforms.RandomResizedCrop((28,28)),</span></span><br><span class="line"><span class="comment">#     transforms.RandomHorizontalFlip(),</span></span><br><span class="line"><span class="comment">#     transforms.RandomVerticalFlip(),</span></span><br><span class="line"><span class="comment">#     transforms.RandomRotation(90),</span></span><br><span class="line"><span class="comment">#     transforms.RandomGrayscale(0.1),</span></span><br><span class="line"><span class="comment">#     transforms.ColorJitter(0.3, 0.3, 0.3, 0.3),</span></span><br><span class="line"><span class="comment">#     transforms.ToTensor()</span></span><br><span class="line"><span class="comment"># ])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(<span class="title class_ inherited__">Dataset</span>): <span class="comment">#自定义的数据加载的类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, im_list, transform = <span class="literal">None</span>, loader = default_loader</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyDataset, self).__init__()</span><br><span class="line">        imgs = []</span><br><span class="line">        <span class="keyword">for</span> im_item <span class="keyword">in</span> im_list:</span><br><span class="line">            im_label_name = im_item.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">2</span>] <span class="comment">#-2对应类别号</span></span><br><span class="line">            imgs.append([im_item, label_dict[im_label_name]]) <span class="comment">#得到图片的路径及其label</span></span><br><span class="line">        </span><br><span class="line">        self.imgs = imgs</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.loader = loader</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>): <span class="comment">#定义读取元素的方式</span></span><br><span class="line">        im_path, im_label = self.imgs[index]</span><br><span class="line">        im_data = self.loader(im_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            im_data = self.transform(im_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> im_data, im_label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>): <span class="comment">#返回样本的数量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.imgs)</span><br><span class="line">    </span><br><span class="line">im_train_list = glob.glob(<span class="string">&quot;D:\\App_Data_File\\VScode_Project\\Python\\Pytorch\\Cifar10\\cifar10_batches_py\\TRAIN\\*\\*.png&quot;</span>)</span><br><span class="line">im_test_list = glob.glob(<span class="string">&quot;D:\\App_Data_File\\VScode_Project\\Python\\Pytorch\\Cifar10\\cifar10_batches_py\\TEST\\*\\*.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">train_dataset = MyDataset(im_train_list, transform = train_transform)</span><br><span class="line"></span><br><span class="line">test_dataset = MyDataset(im_test_list, transform = test_transform)</span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(dataset = train_dataset,</span><br><span class="line">                          batch_size = <span class="number">128</span>,</span><br><span class="line">                          shuffle = <span class="literal">True</span>,</span><br><span class="line">                          num_workers = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">test_loader = DataLoader(dataset = test_dataset,</span><br><span class="line">                         batch_size = <span class="number">128</span>,</span><br><span class="line">                         shuffle = <span class="literal">False</span>,</span><br><span class="line">                         num_workers = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;num_of_train&quot;</span>, <span class="built_in">len</span>(train_dataset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;num_of_test&quot;</span>, <span class="built_in">len</span>(test_dataset))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_of_train 50000</span><br><span class="line">num_of_test 10000</span><br></pre></td></tr></table></figure>
<h2 id="3-VGGNET网络搭建与训练"><a href="#3-VGGNET网络搭建与训练" class="headerlink" title="3.VGGNET网络搭建与训练"></a>3.VGGNET网络搭建与训练</h2><ul>
<li>vggnet.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGGbase</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(VGGbase, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.conv1 = nn.Sequential(nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">                                   nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">                                   nn.ReLU())</span><br><span class="line">        self.max_pooling1 = nn.MaxPool2d(kernel_size = <span class="number">2</span>, stride = <span class="number">2</span>) <span class="comment">#此时输出图片大小为14*14</span></span><br><span class="line"></span><br><span class="line">        self.conv2_1 = nn.Sequential(nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">                                     nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">                                     nn.ReLU())</span><br><span class="line">        self.conv2_2 = nn.Sequential(nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">                                     nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">                                     nn.ReLU())</span><br><span class="line">        self.max_pooling2 = nn.MaxPool2d(kernel_size = <span class="number">2</span>, stride = <span class="number">2</span>) <span class="comment">#此时输出图片大小为7*7   </span></span><br><span class="line"></span><br><span class="line">        self.conv3_1 = nn.Sequential(nn.Conv2d(<span class="number">128</span>, <span class="number">256</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">                                     nn.BatchNorm2d(<span class="number">256</span>),</span><br><span class="line">                                     nn.ReLU())</span><br><span class="line">        self.conv3_2 = nn.Sequential(nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">                                     nn.BatchNorm2d(<span class="number">256</span>),</span><br><span class="line">                                     nn.ReLU())</span><br><span class="line">        self.max_pooling3 = nn.MaxPool2d(kernel_size = <span class="number">2</span>, stride = <span class="number">2</span>, padding = <span class="number">1</span>) <span class="comment">#补零输出后图片大小为4*4</span></span><br><span class="line"></span><br><span class="line">        self.conv4_1 = nn.Sequential(nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">                                     nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">                                     nn.ReLU())</span><br><span class="line">        self.conv4_2 = nn.Sequential(nn.Conv2d(<span class="number">512</span>, <span class="number">512</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">                                     nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">                                     nn.ReLU())  </span><br><span class="line">        self.max_pooling4 = nn.MaxPool2d(kernel_size = <span class="number">2</span>, stride = <span class="number">2</span>) <span class="comment">#此时输出图片大小为2*2</span></span><br><span class="line"></span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span> * <span class="number">4</span>, <span class="number">10</span>)              </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        batchsize = x.size(<span class="number">0</span>)</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.max_pooling1(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv2_1(out)</span><br><span class="line">        out = self.conv2_2(out)</span><br><span class="line">        out = self.max_pooling2(out)       </span><br><span class="line"></span><br><span class="line">        out = self.conv3_1(out)</span><br><span class="line">        out = self.conv3_2(out)</span><br><span class="line">        out = self.max_pooling3(out) </span><br><span class="line"></span><br><span class="line">        out = self.conv4_1(out)</span><br><span class="line">        out = self.conv4_2(out)</span><br><span class="line">        out = self.max_pooling4(out) </span><br><span class="line"></span><br><span class="line">        out = out.view(batchsize, -<span class="number">1</span>)</span><br><span class="line">        out = self.fc(out)</span><br><span class="line">        out = F.log_softmax(out, dim = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">VGGNet</span>():</span><br><span class="line">    <span class="keyword">return</span> VGGbase()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下（训练了6个epoch的结果）：</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230814204637731.png" alt="image-20230814204637731"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230814204651060.png" alt="image-20230814204651060"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230814204554305.png" alt="image-20230814204554305"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230814204604844.png" alt="image-20230814204604844"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230814204423334.png" alt="image-20230814204423334"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230814204523272.png" alt="image-20230814204523272"></p>
</li>
<li><p>用tensorboard可视化的输入图像：</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230814204834806.png" alt="image-20230814204834806">$\quad\quad\quad$<img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230814204904235.png" alt="image-20230814204904235"></p>
</li>
</ul>
<h2 id="4-RESNET网络搭建与训练"><a href="#4-RESNET网络搭建与训练" class="headerlink" title="4.RESNET网络搭建与训练"></a>4.RESNET网络搭建与训练</h2><ul>
<li>resnet.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channel, out_channel, stride = <span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(ResBlock, self).__init__()</span><br><span class="line">        self.layer = nn.Sequential( <span class="comment">#主干分支</span></span><br><span class="line">            nn.Conv2d(in_channel, out_channel, kernel_size = <span class="number">3</span>, stride = stride, padding = <span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(out_channel),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(out_channel, out_channel, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(out_channel)</span><br><span class="line">        )</span><br><span class="line">        self.shortcut = nn.Sequential()</span><br><span class="line">        <span class="keyword">if</span> in_channel != out_channel <span class="keyword">or</span> stride &gt; <span class="number">1</span>:</span><br><span class="line">            self.shortcut = nn.Sequential( <span class="comment">#跳连分支</span></span><br><span class="line">                nn.Conv2d(in_channel, out_channel, kernel_size = <span class="number">3</span>, stride = stride, padding = <span class="number">1</span>),</span><br><span class="line">                nn.BatchNorm2d(out_channel) <span class="comment">#保证相加时数据大小相同</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out1 = self.layer(x)</span><br><span class="line">        out2 = self.shortcut(x)</span><br><span class="line">        out = out1 + out2</span><br><span class="line">        out = F.relu(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_layer</span>(<span class="params">self, block, out_channel, stride, num_block</span>): <span class="comment">#定义多个层</span></span><br><span class="line">        layers_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_block):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                in_stride = stride <span class="comment">#每层只进行一次stride操作，也就是每次图片尺寸/stride</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                in_stride = <span class="number">1</span></span><br><span class="line">            layers_list.append(block(self.in_channel, out_channel, in_stride))</span><br><span class="line">            self.in_channel = out_channel</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ResBlock</span>):</span><br><span class="line">        self.in_channel = <span class="number">32</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet, self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">32</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.layer1 = self.make_layer(ResBlock, <span class="number">64</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.layer2 = self.make_layer(ResBlock, <span class="number">128</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.layer3 = self.make_layer(ResBlock, <span class="number">256</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.layer4 = self.make_layer(ResBlock, <span class="number">512</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.layer1(out)</span><br><span class="line">        out = self.layer2(out)</span><br><span class="line">        out = self.layer3(out)</span><br><span class="line">        out = self.layer4(out)</span><br><span class="line"></span><br><span class="line">        out = F.avg_pool2d(out, <span class="number">2</span>)</span><br><span class="line">        out = out.view(out.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        out = self.fc(out)</span><br><span class="line">        out = F.log_softmax(out, dim = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resnet</span>():</span><br><span class="line">    <span class="keyword">return</span> ResNet(ResBlock)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下（训练了6个epoch的结果）：</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815205510074.png" alt="image-20230815205510074"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815205522354.png" alt="image-20230815205522354"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815205551675.png" alt="image-20230815205551675"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815205607429.png" alt="image-20230815205607429"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815205619903.png" alt="image-20230815205619903"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815205628871.png" alt="image-20230815205628871"></p>
</li>
</ul>
<h2 id="5-MobileNet网路搭建与训练"><a href="#5-MobileNet网路搭建与训练" class="headerlink" title="5.MobileNet网路搭建与训练"></a>5.MobileNet网路搭建与训练</h2><ul>
<li><strong>深度可分卷积模型</strong></li>
</ul>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815204836730.png" alt="image-20230815204836730"></p>
<ul>
<li>dw中输入通道数等于输出通道数，卷积核的通道数为1，输入通道需要被分成in_channel组</li>
<li>pw的输入为dw的输出，卷积核的大小为1</li>
<li>MobileNet能压缩模型计算量</li>
<li>mobilenetv1.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#轻量级网络：压缩模型计算量</span></span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mobilenet</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">conv_dw_pw</span>(<span class="params">self, in_channel, out_channel, stride</span>):</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channel, in_channel, kernel_size = <span class="number">3</span>, stride = stride, </span><br><span class="line">                      padding = <span class="number">1</span>, groups = in_channel, bias = <span class="literal">False</span>), <span class="comment">#groups将输入与输出通道分组</span></span><br><span class="line">            nn.BatchNorm2d(in_channel),</span><br><span class="line">            nn.ReLU(), <span class="comment">#dw</span></span><br><span class="line">            </span><br><span class="line">            nn.Conv2d(in_channel, out_channel, kernel_size = <span class="number">1</span>, stride = <span class="number">1</span>, </span><br><span class="line">                      padding = <span class="number">0</span>, bias = <span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(out_channel),</span><br><span class="line">            nn.ReLU() <span class="comment">#pw</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(mobilenet, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">32</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.conv_dw_pw2 = self.conv_dw_pw(<span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>)</span><br><span class="line">        self.conv_dw_pw3 = self.conv_dw_pw(<span class="number">32</span>, <span class="number">64</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.conv_dw_pw4 = self.conv_dw_pw(<span class="number">64</span>, <span class="number">64</span>, <span class="number">1</span>)</span><br><span class="line">        self.conv_dw_pw5 = self.conv_dw_pw(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.conv_dw_pw6 = self.conv_dw_pw(<span class="number">128</span>, <span class="number">128</span>, <span class="number">1</span>)</span><br><span class="line">        self.conv_dw_pw7 = self.conv_dw_pw(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.conv_dw_pw8 = self.conv_dw_pw(<span class="number">256</span>, <span class="number">256</span>, <span class="number">1</span>)</span><br><span class="line">        self.conv_dw_pw9 = self.conv_dw_pw(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.conv_dw_pw2(out)</span><br><span class="line">        out = self.conv_dw_pw3(out)</span><br><span class="line">        out = self.conv_dw_pw4(out)</span><br><span class="line">        out = self.conv_dw_pw5(out)</span><br><span class="line">        out = self.conv_dw_pw6(out)</span><br><span class="line">        out = self.conv_dw_pw7(out)</span><br><span class="line">        out = self.conv_dw_pw8(out)</span><br><span class="line">        out = self.conv_dw_pw9(out)</span><br><span class="line">        </span><br><span class="line">        out = F.avg_pool2d(out, <span class="number">2</span>)</span><br><span class="line">        out = out.view(out.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        out = self.fc(out)</span><br><span class="line">        out = F.log_softmax(out, dim = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mobilenetv1_small</span>():</span><br><span class="line">    <span class="keyword">return</span> mobilenet()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下（训练了6个epoch的结果）：</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815221611203.png" alt="image-20230815221611203"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815221623192.png" alt="image-20230815221623192"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815221649154.png" alt="image-20230815221649154"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815221725125.png" alt="image-20230815221725125"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815221746554.png" alt="image-20230815221746554"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230815221755811.png" alt="image-20230815221755811"></p>
</li>
</ul>
<h2 id="6-InceptionModule网络搭建与训练"><a href="#6-InceptionModule网络搭建与训练" class="headerlink" title="6.InceptionModule网络搭建与训练"></a>6.InceptionModule网络搭建与训练</h2><ul>
<li><p><strong>使用1x1的卷积核实现降维操作(也间接增加了网络的深度)，以此来减小网络的参数量</strong></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816143945162.png" alt="image-20230816143945162"></p>
</li>
<li><p>inceptionModule.py</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn </span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ConvBNRelu</span>(<span class="params">in_channel, out_channel, kernel_size</span>):</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential( <span class="comment">#不改变图片形状，只改变通道维数（只对kernel_size为奇数成立）</span></span><br><span class="line">        nn.Conv2d(in_channel, out_channel, kernel_size = kernel_size, </span><br><span class="line">                  stride = <span class="number">1</span>, padding = kernel_size // <span class="number">2</span>),</span><br><span class="line">        nn.BatchNorm2d(out_channel),</span><br><span class="line">        nn.ReLU()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseInception</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channel, out_channel_list, reduce_channel_list</span>):</span><br><span class="line">        <span class="built_in">super</span>(BaseInception, self).__init__()</span><br><span class="line">        self.branch1_conv = ConvBNRelu(in_channel, out_channel_list[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.branch2_conv1 = ConvBNRelu(in_channel, reduce_channel_list[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">        self.branch2_conv2 = ConvBNRelu(reduce_channel_list[<span class="number">0</span>], out_channel_list[<span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        self.branch3_conv1 = ConvBNRelu(in_channel, reduce_channel_list[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">        self.branch3_conv2 = ConvBNRelu(reduce_channel_list[<span class="number">1</span>], out_channel_list[<span class="number">2</span>], <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        self.branch4_pool = nn.MaxPool2d(kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding = <span class="number">1</span>)</span><br><span class="line">        self.branch4_conv = ConvBNRelu(in_channel, out_channel_list[<span class="number">3</span>], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out1 = self.branch1_conv(x)</span><br><span class="line"></span><br><span class="line">        out2 = self.branch2_conv1(x)</span><br><span class="line">        out2 = self.branch2_conv2(out2)</span><br><span class="line"></span><br><span class="line">        out3 = self.branch3_conv1(x)</span><br><span class="line">        out3 = self.branch3_conv2(out3)</span><br><span class="line"></span><br><span class="line">        out4 = self.branch4_pool(x)</span><br><span class="line">        out4 = self.branch4_conv(out4)</span><br><span class="line"></span><br><span class="line">        out = torch.cat([out1, out2, out3, out4], dim = <span class="number">1</span>) <span class="comment">#cat是将通道数合并</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InceptionNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(InceptionNet, self).__init__()</span><br><span class="line">        self.block1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size = <span class="number">7</span>, stride = <span class="number">2</span>, padding = <span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        ) <span class="comment">#12*12</span></span><br><span class="line"></span><br><span class="line">        self.block2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">2</span>, padding = <span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        ) <span class="comment">#6*6</span></span><br><span class="line"></span><br><span class="line">        self.block3 = nn.Sequential(</span><br><span class="line">            BaseInception(in_channel = <span class="number">128</span>, out_channel_list = [<span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>],</span><br><span class="line">                                    reduce_channel_list = [<span class="number">16</span>, <span class="number">16</span>]),</span><br><span class="line">            nn.MaxPool2d(kernel_size = <span class="number">3</span>, stride = <span class="number">2</span>, padding = <span class="number">1</span>)</span><br><span class="line">        ) <span class="comment">#3*3</span></span><br><span class="line"></span><br><span class="line">        self.block4 = nn.Sequential(</span><br><span class="line">            BaseInception(in_channel = <span class="number">256</span>, out_channel_list = [<span class="number">96</span>, <span class="number">96</span>, <span class="number">96</span>, <span class="number">96</span>],</span><br><span class="line">                                    reduce_channel_list = [<span class="number">32</span>, <span class="number">32</span>]),</span><br><span class="line">            nn.MaxPool2d(kernel_size = <span class="number">3</span>, stride = <span class="number">2</span>, padding = <span class="number">1</span>)</span><br><span class="line">        ) <span class="comment">#2*2</span></span><br><span class="line"></span><br><span class="line">        self.fc = nn.Linear(<span class="number">96</span>*<span class="number">4</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = self.block1(x)</span><br><span class="line">        out = self.block2(out)</span><br><span class="line">        out = self.block3(out)</span><br><span class="line">        out = self.block4(out)</span><br><span class="line"></span><br><span class="line">        out = F.avg_pool2d(out, <span class="number">2</span>) <span class="comment">#1*1</span></span><br><span class="line">        out = out.view(out.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        out = self.fc(out)</span><br><span class="line">        out = F.log_softmax(out, dim = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">InceptionNetSmall</span>():</span><br><span class="line">    <span class="keyword">return</span> InceptionNet()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下（训练了6个epoch的结果）：</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816150820224.png" alt="image-20230816150820224"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816150828915.png" alt="image-20230816150828915"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816150854735.png" alt="image-20230816150854735"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816150904546.png" alt="image-20230816150904546"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816150920921.png" alt="image-20230816150920921"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816150934482.png" alt="image-20230816150934482"></p>
</li>
</ul>
<h2 id="7-pytorch中自带的ResNet18网络搭建与训练"><a href="#7-pytorch中自带的ResNet18网络搭建与训练" class="headerlink" title="7.pytorch中自带的ResNet18网络搭建与训练"></a>7.pytorch中自带的ResNet18网络搭建与训练</h2><ul>
<li>pytorch_resnet18.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pytorch中提供的resnet18网络</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">resnet18</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(resnet18, self).__init__()</span><br><span class="line">        self.model = models.resnet18(weights = models.ResNet18_Weights.IMAGENET1K_V1)</span><br><span class="line">        self.num_features = self.model.fc.in_features</span><br><span class="line">        self.model.fc = nn.Linear(self.num_features, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = self.model(x)</span><br><span class="line">        out = F.log_softmax(out, dim = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pytorch_resnet18</span>():</span><br><span class="line">    <span class="keyword">return</span> resnet18()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下（训练了6个epoch的结果）：</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816171416787.png" alt="image-20230816171416787"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816171440663.png" alt="image-20230816171440663"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816171456684.png" alt="image-20230816171456684"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816171507867.png" alt="image-20230816171507867"></p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816171521234.png" alt="image-20230816171521234"><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816171529364.png" alt="image-20230816171529364"></p>
</li>
</ul>
<h2 id="8-模型训练相关的代码"><a href="#8-模型训练相关的代码" class="headerlink" title="8.模型训练相关的代码"></a>8.模型训练相关的代码</h2><ul>
<li>train.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> vggnet <span class="keyword">import</span> VGGNet</span><br><span class="line"><span class="keyword">from</span> resnet <span class="keyword">import</span> resnet</span><br><span class="line"><span class="keyword">from</span> mobilenetv1 <span class="keyword">import</span> mobilenetv1_small</span><br><span class="line"><span class="keyword">from</span> inceptionModule <span class="keyword">import</span> InceptionNetSmall</span><br><span class="line"><span class="keyword">from</span> pytorch_resnet18 <span class="keyword">import</span> pytorch_resnet18</span><br><span class="line"><span class="keyword">from</span> load_cifar10 <span class="keyword">import</span> train_loader, test_loader, train_dataset, test_dataset</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tensorboardX</span><br><span class="line"></span><br><span class="line">model_path = <span class="string">&quot;models/pytorch_resnet18&quot;</span></span><br><span class="line">log_path = <span class="string">&quot;logs/pytorch_resnet18&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_path): <span class="comment">#mkdir函数用于创建单级目录，makedirs函数用于创建多级目录</span></span><br><span class="line">    os.makedirs(model_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(log_path):</span><br><span class="line">    os.makedirs(log_path)</span><br><span class="line">writer = tensorboardX.SummaryWriter(log_path)</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断是否存在GPU</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义训练样本的训练次数</span></span><br><span class="line">epoch_num = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义学习率的初始值</span></span><br><span class="line">lr = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将网络扔到device上去</span></span><br><span class="line"><span class="comment">#net = VGGNet().to(device)</span></span><br><span class="line"><span class="comment">#net = resnet().to(device)</span></span><br><span class="line"><span class="comment">#net = mobilenetv1_small().to(device)</span></span><br><span class="line">net = pytorch_resnet18().to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义损失函数</span></span><br><span class="line">loss_func = nn.NLLLoss() <span class="comment">#默认reduction=&#x27;mean&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr = lr)</span><br><span class="line">scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size = <span class="number">5</span>, gamma = <span class="number">0.9</span>) <span class="comment">#学习率更新函数，step_size表示每5个epoch更新学习率</span></span><br><span class="line"></span><br><span class="line">step_n_train = <span class="number">0</span></span><br><span class="line">step_n_test = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch_num):</span><br><span class="line">    <span class="comment">#训练集训练</span></span><br><span class="line">    net.train()</span><br><span class="line">    sum_loss = <span class="number">0</span></span><br><span class="line">    sum_correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        inputs, labels = data</span><br><span class="line">        inputs, labels = inputs.to(device), labels.to(device)</span><br><span class="line"></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = loss_func(outputs, labels)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算准确率</span></span><br><span class="line">        batch_size = outputs.size(<span class="number">0</span>)</span><br><span class="line">        _, pred = torch.<span class="built_in">max</span>(outputs, dim = <span class="number">1</span>)</span><br><span class="line">        correct = pred.eq(labels.data).cpu().<span class="built_in">sum</span>()</span><br><span class="line">        <span class="comment"># print(&quot;Train step &quot;, i, &quot; mini-batch loss is:&quot;, loss.item(), &quot;mini-batch correct is:&quot;, 100.0 * correct / batch_size)</span></span><br><span class="line"></span><br><span class="line">        writer.add_scalar(<span class="string">&quot;Train loss&quot;</span>, loss.item(), global_step = step_n_train)</span><br><span class="line">        writer.add_scalar(<span class="string">&quot;Train correct&quot;</span>, <span class="number">100.0</span> * correct.item() / batch_size, global_step = step_n_train)</span><br><span class="line">        </span><br><span class="line">        train_im = torchvision.utils.make_grid(inputs)</span><br><span class="line">        writer.add_image(<span class="string">&quot;train im&quot;</span>, train_im, global_step = step_n_train)</span><br><span class="line">        step_n_train = step_n_train + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#loss与准确率求和运算</span></span><br><span class="line">        sum_loss += loss.item()</span><br><span class="line">        sum_correct += correct.item()</span><br><span class="line"></span><br><span class="line">    train_loss = sum_loss * <span class="number">1.0</span> / (<span class="built_in">len</span>(train_dataset) // batch_size)</span><br><span class="line">    train_correct = sum_correct * <span class="number">100.0</span> / <span class="built_in">len</span>(train_dataset)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Train epoch is &quot;</span>, epoch + <span class="number">1</span>, <span class="string">&quot; epoch loss is:&quot;</span>, train_loss, </span><br><span class="line">          <span class="string">&quot;epoch correct is:&quot;</span>, train_correct)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#每个epoch之后保存模型参数</span></span><br><span class="line">    torch.save(net.state_dict(), <span class="string">&quot;&#123;&#125;/&#123;&#125;.path&quot;</span>.<span class="built_in">format</span>(model_path, epoch + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#每个epoch之后更新学习率</span></span><br><span class="line">    scheduler.step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;lr is &quot;</span>, optimizer.state_dict()[<span class="string">&quot;param_groups&quot;</span>][<span class="number">0</span>][<span class="string">&quot;lr&quot;</span>]) <span class="comment">#打印学习率的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#验证测试集</span></span><br><span class="line">    net.<span class="built_in">eval</span>()</span><br><span class="line">    sum_loss = <span class="number">0</span></span><br><span class="line">    sum_correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_loader):</span><br><span class="line">        inputs, labels = data</span><br><span class="line">        inputs, labels = inputs.to(device), labels.to(device)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            outputs = net(inputs)</span><br><span class="line">        loss = loss_func(outputs, labels)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#计算准确率</span></span><br><span class="line">        batch_size = outputs.size(<span class="number">0</span>)</span><br><span class="line">        _, pred = torch.<span class="built_in">max</span>(outputs, dim = <span class="number">1</span>)</span><br><span class="line">        correct = (pred == labels).cpu().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">        writer.add_scalar(<span class="string">&quot;Test loss&quot;</span>, loss.item(), global_step = step_n_test)</span><br><span class="line">        writer.add_scalar(<span class="string">&quot;Test correct&quot;</span>, <span class="number">100.0</span> * correct.item() / batch_size, global_step = step_n_test)</span><br><span class="line"></span><br><span class="line">        test_im = torchvision.utils.make_grid(inputs)</span><br><span class="line">        writer.add_image(<span class="string">&quot;test im&quot;</span>, test_im, global_step = step_n_test)</span><br><span class="line">        step_n_test = step_n_test + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#loss与准确率求和运算</span></span><br><span class="line">        sum_loss += loss.item()</span><br><span class="line">        sum_correct += correct.item()</span><br><span class="line"></span><br><span class="line">    test_loss = sum_loss * <span class="number">1.0</span> / (<span class="built_in">len</span>(test_dataset) // batch_size)</span><br><span class="line">    test_correct = sum_correct * <span class="number">100.0</span> / <span class="built_in">len</span>(test_dataset)</span><br><span class="line"></span><br><span class="line">    writer.add_scalar(<span class="string">&quot;Batch Test loss&quot;</span>, test_loss, global_step = epoch + <span class="number">1</span>)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;Batch Test correct&quot;</span>, test_correct, global_step = epoch + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test epoch is &quot;</span>, epoch + <span class="number">1</span>, <span class="string">&quot; epoch loss is:&quot;</span>, test_loss, </span><br><span class="line">          <span class="string">&quot;epoch correct is:&quot;</span>, test_correct)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>tensorboard可视化页面的使用</strong>：程序运行开始后，在终端中调用如下代码启动可视化页面，下面代码中路径为log文件夹所在位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=<span class="string">&quot;D:\App_Data_File\VScode_Project\Python\Pytorch\Cifar10\logs\InctionNetSmall&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-模型验证"><a href="#9-模型验证" class="headerlink" title="9.模型验证"></a>9.模型验证</h2><ul>
<li>test.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> load_cifar10</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pytorch_resnet18 <span class="keyword">import</span> pytorch_resnet18</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载测试数据</span></span><br><span class="line">test_data = load_cifar10.test_dataset</span><br><span class="line">test_loader = DataLoader(dataset = test_data, batch_size = <span class="number">128</span>, shuffle = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载训练好的模型及其参数</span></span><br><span class="line">net = pytorch_resnet18().to(device)</span><br><span class="line">net.load_state_dict(torch.load(<span class="string">&quot;D:\\App_Data_File\\VScode_Project\\Python\\Pytorch\\Cifar10\\models\\pytorch_resnet18\\11.path&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证模型</span></span><br><span class="line">loss_func = nn.NLLLoss() </span><br><span class="line">loss_test = <span class="number">0</span></span><br><span class="line">accuracy_test = <span class="number">0</span></span><br><span class="line"><span class="comment">#测试集</span></span><br><span class="line"><span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_loader):</span><br><span class="line">    images, labels = images.to(device), labels.to(device)</span><br><span class="line">    outputs = net(images)</span><br><span class="line">    <span class="comment">#计算每个batch的损失和</span></span><br><span class="line">    loss_test += loss_func(outputs, labels)</span><br><span class="line">    <span class="comment">#计算每个batch的正确率</span></span><br><span class="line">    _, pred = outputs.<span class="built_in">max</span>(<span class="number">1</span>) <span class="comment">#1表示在第一个维度上，即每张图对应输出10个值的那一行，pred是最大值的索引</span></span><br><span class="line">    accuracy_test += (pred == labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#可视化分析并显示结果</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(images.shape[<span class="number">0</span>]):</span><br><span class="line">        im_data = images[idx].numpy()</span><br><span class="line">        im_data = im_data.transpose(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">        im_label = labels[idx].numpy()</span><br><span class="line">        im_pred = pred[idx].numpy()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;label:&quot;</span>, im_label, <span class="string">&quot;,label_name:&quot;</span>, load_cifar10.label_name[im_label])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;pred&quot;</span>, im_pred, <span class="string">&quot;,pred_name:&quot;</span>, load_cifar10.label_name[im_pred])</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">30</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;imdata&quot;</span>, im_data)</span><br><span class="line">        cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">accuracy_test = accuracy_test / <span class="built_in">len</span>(test_data)</span><br><span class="line">loss_test = loss_test / (<span class="built_in">len</span>(test_data) // <span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果如下：</p>
<p><img src="/2023/08/09/Pytorch%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230816174656948.png" alt="image-20230816174656948" style="zoom: 67%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数之向量</title>
    <url>/2023/08/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<p>本节主要介绍了向量的基本概念、线性相关与线性无关、向量组的秩</p>
<span id="more"></span>
<h1 id="n维向量以及运算"><a href="#n维向量以及运算" class="headerlink" title="n维向量以及运算"></a>n维向量以及运算</h1><ul>
<li>向量：n个数$a_1,a_2,…,a_n$组成的有序数组（向量组），其中$a_1,a_2,…,a_n$称为分量，记作$\alpha、\beta、\gamma$</li>
<li><p><strong>定理</strong>：$k\alpha=0\Leftrightarrow k=0\,or\,\alpha=0$</p>
</li>
<li><p><strong>线性组合</strong>：$\beta,\alpha_1,\alpha_2,…,\alpha_n$是m维向量，若存在$k_1,k_2,…,k_n$使得下式成立：</p>
<script type="math/tex; mode=display">
\beta=k_1\alpha_1+k_2\alpha_2+...+k_n\alpha_n</script><p>则称$\beta$是$\alpha$向量们的线性组合，$k_1,k_2,…,k_n$为组合系数，系数可全取0</p>
</li>
<li><p>零向量可由任意向量组表示</p>
</li>
<li><p>向量组中任意向量可由向量组表示</p>
</li>
<li><p>任意向量都可由：$\epsilon_1=(1,0,…,0)、\epsilon_2=(0,1,…,0)、…、\epsilon_n=(0,0,…,1)$表示</p>
</li>
</ul>
<hr>
<h1 id="线性相关与线性无关"><a href="#线性相关与线性无关" class="headerlink" title="线性相关与线性无关"></a>线性相关与线性无关</h1><ul>
<li><p><strong>线性相关</strong>：$a_1,a_2,…,a_n$是n个m维向量，若存在一组不全为0的$k_1,k_2,…,k_n$系数，使得：</p>
<script type="math/tex; mode=display">
k_1\alpha_1+k_2\alpha_2+...+k_n\alpha_n=0</script><p>则$a_1,a_2,…,a_n$是线性相关</p>
</li>
<li><p><strong>线性无关</strong>：使得$k_1\alpha_1+k_2\alpha_2+…+k_n\alpha_n=0$的$k_1,k_2,…,k_n$系数只有全为0的情况</p>
</li>
<li><p>相关结论：</p>
<ul>
<li>向量组中两向量成比例，则线性相关</li>
<li>含零向量的向量组必线性相关</li>
<li>只有一个零向量必线性相关</li>
<li>任意一个非零向量必线性无关</li>
<li>若一个向量$\alpha$线性相关，则$\Leftrightarrow\alpha=0$</li>
<li>若$a_1,a_2,…,a_r$线性相关，则$a_1,a_2,…,a_r,a_{r+1},…,\alpha_s$也线性相关</li>
<li>整体向量组线性无关，则部分向量组也线性无关</li>
<li>线性无关的向量组，其接长向量组也线性无关</li>
<li>线性相关的向量组，其截短向量组也线性相关</li>
<li><strong>向量的个数等于向量的维数时，n个n维向量的$D\ne0\Leftrightarrow$线性无关，$D=0\Leftrightarrow$线性相关</strong></li>
<li>$\epsilon_1=(1,0,…,0)、\epsilon_2=(0,1,…,0)、…、\epsilon_n=(0,0,…,1)$线性无关</li>
</ul>
</li>
<li><p>相关定理：</p>
<ul>
<li>若$a_1,a_2,…,a_s$线性相关$\Leftrightarrow$至少一个向量可由其余向量表示</li>
<li>若$a_1,a_2,…,a_s$线性无关，$a_1,a_2,…,a_s,\beta$线性相关$\Leftrightarrow\beta$可由$a_1,a_2,…,a_s$唯一表示</li>
<li><strong>若m&gt;n（向量的个数大于向量的维数），m个n维向量一定相关</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h1><ul>
<li><p><strong>极大线性无关组</strong>：</p>
<p>若$a_1,a_2,\alpha_3,\alpha_4,a_5$中的部分组$\alpha_1,\alpha_2$线性无关且每个向量均可由$\alpha_1,\alpha_2$表示，则$\alpha_1,\alpha_2$为极大无关组</p>
</li>
<li><p><strong>向量组的秩：极大无关组含向量个数</strong></p>
<ul>
<li>$0\le r(a_1,a_2,…,a_s)\le min\{向量的个数，向量的维数\}$</li>
<li>$a_1,a_2,…,a_s$线性无关$\Leftrightarrow r=s$</li>
<li>$a_1,a_2,…,a_s$线性相关$\Leftrightarrow r&lt;s$</li>
</ul>
</li>
<li><p><strong>行秩</strong>：矩阵中的行向量组的秩</p>
</li>
<li><p><strong>列秩</strong>：矩阵中列向量组的秩</p>
</li>
<li><p><strong>定理：行秩=列秩=$r(A)$（矩阵的秩）</strong></p>
</li>
<li><p>$r(AB)\le min\{r(A),r(B)\}$</p>
</li>
<li><p>初等行变换不改变矩阵列向量组的线性关系</p>
<p><img src="/2023/08/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%90%91%E9%87%8F/image-20230810103558833.png" alt="image-20230810103558833" style="zoom: 33%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数之矩阵</title>
    <url>/2023/08/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>本节主要介绍了矩阵的基本概念、伴随矩阵、逆矩阵、分块矩阵、初等变换以及矩阵的秩</p>
<span id="more"></span>
<h1 id="矩阵概念"><a href="#矩阵概念" class="headerlink" title="矩阵概念"></a>矩阵概念</h1><ul>
<li><p>矩阵的定义：由一些数构成的$m\times n$的数表</p>
<script type="math/tex; mode=display">
A_{m\times n} = \begin{bmatrix}
a_{11} & a_{12} & \dots & a_{1n}\\
a_{21} & a_{21} & \dots & a_{2n}\\
\dots & \dots & \dots & \dots \\
a_{m1} & a_{m2} & \dots & a_{mn}\\
\end{bmatrix}</script></li>
<li><p><strong>矩阵和行列式的区别</strong>：</p>
<p>|      | 行列式            | 矩阵                     |<br>| —— | ————————- | ———————————— |<br>| 本质 | 一个数            | 数表                     |<br>| 符号 | | |             | [ ]或( )                 |<br>| 形状 | 行数=列数，是方形 | 行数$\neq$列数（也可等） |</p>
</li>
<li><p>方阵：矩阵中若行数=列数，则称为n阶方阵$A_{n\times n}\,or\,A_n$</p>
</li>
<li><p>单位阵$E$：主对角线上的数均为1，其余均为0，<strong>单位阵一定是方阵</strong></p>
</li>
<li><p>同形矩阵：行列数均相等的矩阵，<strong>两个矩阵相等的前提必须是同形矩阵</strong></p>
</li>
</ul>
<hr>
<h1 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h1><h2 id="1-矩阵加减法"><a href="#1-矩阵加减法" class="headerlink" title="1.矩阵加减法"></a>1.矩阵加减法</h2><ul>
<li>矩阵的加减法：将两个矩阵中对应的元素相加减，必须是同形矩阵才能相加减</li>
</ul>
<h2 id="2-矩阵乘法"><a href="#2-矩阵乘法" class="headerlink" title="2.矩阵乘法"></a>2.矩阵乘法</h2><ul>
<li>矩阵的数乘运算：<ul>
<li>一个数乘以一个矩阵，是这个数乘以这个矩阵的所有元素</li>
<li><strong>矩阵所有元素均有公因子，这个公因子朝外提一次</strong></li>
</ul>
</li>
<li><strong>矩阵的乘法</strong>：<ul>
<li>前提条件：第一个矩阵的列数=第二个矩阵的行数</li>
<li>结果矩阵形状：结果矩阵的行数=第一个矩阵的行数，结果矩阵的列数=第二个矩阵的列数</li>
<li><strong>矩阵$AB\ne BA$，$AB$有意义时，$BA$不一定有意义</strong></li>
<li>矩阵$AB$相乘时，称$A$左乘$B$，$B$右乘$A$</li>
<li><strong>若$AB=0$，并不意味着$A=0\,or\,B=0$</strong></li>
<li><strong>若$AB=AC，A\ne0$，并不意味着$B=C$</strong></li>
<li>与零矩阵相乘都等于0，但得注意必须是同形矩阵</li>
<li><strong>与单位阵$E$相乘：$AE=A，EB=B$</strong></li>
<li>结合率：$(AB)C=A(BC)$</li>
<li>分配律：$(A+B)C=AC+BC\quad C(A+B)=CA+CB$</li>
</ul>
</li>
</ul>
<h2 id="3-矩阵的幂"><a href="#3-矩阵的幂" class="headerlink" title="3.矩阵的幂"></a>3.矩阵的幂</h2><ul>
<li><p>矩阵的幂：</p>
<ul>
<li><p>求幂运算，A必须是方阵</p>
</li>
<li><p>$A^0=E$</p>
</li>
<li>$A^{k_1}A^{k_2}=A^{k_1+k_2}$</li>
<li>$(A^{k_1})^{k_2}=A^{k_1k_2}$</li>
<li>$(AB)^k\ne A^kB^k$</li>
<li>$(A+B)^2\ne A^2+2AB+B^2$</li>
<li>$(A+E)^2=A^2+2AE+E^2$</li>
</ul>
</li>
<li><p>矩阵的转置：</p>
<ul>
<li>行列交换</li>
<li>若$A_{m\times n}$，则$A^T=A_{n\times m}$</li>
<li>$((A)^T)^T=A$</li>
<li>$(A+B)^T=A^T+B^T$</li>
<li>$(kA)^T=kA^T$</li>
<li>$(AB)^T=B^TA^T$</li>
</ul>
</li>
</ul>
<hr>
<h1 id="特殊的矩阵"><a href="#特殊的矩阵" class="headerlink" title="特殊的矩阵"></a>特殊的矩阵</h1><h2 id="1-对角线矩阵"><a href="#1-对角线矩阵" class="headerlink" title="1.对角线矩阵"></a>1.对角线矩阵</h2><script type="math/tex; mode=display">
diag(a_1,a_2,\dots,a_n) = \begin{bmatrix}
a_{11} & 0 & \dots & 0\\
0 & a_{21} & \dots & 0\\
\dots & \dots & \dots & \dots \\
0 & 0 & \dots & a_{mn}\\
\end{bmatrix}</script><ul>
<li><p>对一个矩阵，左乘对角形矩阵，其结果相当于矩阵中每行元素乘以对角形矩阵中的数</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
k_1 & 0 & 0\\
0 & k_2 & 0\\
0 & 0 & k_3\\
\end{bmatrix}\begin{bmatrix}
1 & 2 & 3\\
2 & 2 & 2\\
8 & 8 & 8\\
\end{bmatrix}=\begin{bmatrix}
k_1 & 2k_1 & 3k_1\\
2k_2 & 2k_2 & 2k_2\\
8k_3 & 8k_3 & 8k_3\\
\end{bmatrix}</script></li>
<li><p>对一个矩阵，右乘对角形矩阵，其结果相当于矩阵中每列元素乘以对角形矩阵中的数</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 2 & 3\\
2 & 2 & 2\\
8 & 8 & 8\\
\end{bmatrix}\begin{bmatrix}
k_1 & 0 & 0\\
0 & k_2 & 0\\
0 & 0 & k_3\\
\end{bmatrix}=\begin{bmatrix}
k_1 & 2k_2 & 3k_3\\
2k_1 & 2k_2 & 2k_3\\
8k_1 & 8k_2 & 8k_3\\
\end{bmatrix}</script></li>
<li><p>对角形矩阵既是上三角矩阵又是下三角矩阵</p>
</li>
</ul>
<h2 id="2-对称矩阵"><a href="#2-对称矩阵" class="headerlink" title="2.对称矩阵"></a>2.对称矩阵</h2><ul>
<li><p>$a_{ij}=a_{ji}$：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 1 & -1\\
1 & 2 & 4\\
-1 & 4 & 3\\
\end{bmatrix}</script></li>
<li><p>若A、B是同阶对称，则：</p>
<ul>
<li>$A^T=A，B^T=B$</li>
<li>$(A+B)^T=A^T+B^T=A+B$</li>
<li>$(kA)^T=kA^T=kA$</li>
<li>$(AB)^T=B^TA^T=BA\neq AB$</li>
<li>若AB的结果依旧是对称矩阵，则A、B是可交换的</li>
</ul>
</li>
<li><p>反对称矩阵：</p>
<ul>
<li>主对角线全为0，$a_{ij}=-a_{ji}$<script type="math/tex; mode=display">
\begin{bmatrix}
0 & 1 & -3\\
-1 & 0 & -4\\
3 & 4 & 0\\
\end{bmatrix}</script></li>
</ul>
</li>
<li><p>$A^T=-A$</p>
</li>
</ul>
<hr>
<h1 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h1><ul>
<li><p>方阵的行列式：</p>
<script type="math/tex; mode=display">
方阵A=\begin{bmatrix}
2 & 2 & 2\\
3 & 3 & 3\\
1 & 1 & 1\\
\end{bmatrix}\quad 行列式|A|=\begin{vmatrix}
2 & 2 & 2\\
3 & 3 & 3\\
1 & 1 & 1\\
\end{vmatrix}</script><ul>
<li>方阵行列式的性质：<ul>
<li>$|A^T|=|A|$</li>
<li>$|kA|=k^n|A|$</li>
<li>$|AB|=|A||B|$</li>
</ul>
</li>
</ul>
</li>
<li><p>伴随矩阵：</p>
<script type="math/tex; mode=display">
A=\begin{bmatrix}
1 & 1 & 1\\
2 & 1 & 3\\
1 & 1 & 4\\
\end{bmatrix}</script></li>
</ul>
<ul>
<li><p>求所有元素的代数余子式</p>
<script type="math/tex; mode=display">
A_{11}=1\quad A_{12}=-5\quad A_{13}=1\\
A_{21}=3\quad A_{22}=3\quad A_{23}=0\\
A_{31}=2\quad A_{32}=-1\quad A_{33}=-1</script></li>
<li><p>按行求得代数余子式按列放，构成的矩阵$A^*$为伴随矩阵</p>
<script type="math/tex; mode=display">
A^*=\begin{bmatrix}
1 & -3 & 2\\
-5 & 3 & -1\\
1 & 0 & -1\\
\end{bmatrix}</script></li>
<li><p><strong>伴随矩阵的相关定理</strong>：</p>
<ul>
<li>对任意方阵A：$AA^<em>=A^</em>A=|A|E$</li>
<li>若方阵$|A|\ne 0$，则$|A^*|=|A|^{n-1}$</li>
</ul>
</li>
</ul>
<hr>
<h1 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul>
<li>定义：若A是n阶方阵，且存在n阶方阵B，使得$AB=BA=E$，则A可逆，称B为A的逆矩阵，即$B=A^{-1}$</li>
<li>相关性质：<ul>
<li>未必所有方阵均可逆</li>
<li>若存在逆矩阵，那么逆矩阵唯一</li>
</ul>
</li>
<li>相关定理：<strong>A可逆的充要条件为$|A|\ne 0$</strong>，则此时$A^{-1}=\frac{1}{|A|}A^*$</li>
<li>推论：若A、B是n阶方阵，存在$AB=E(BA=E)$，则A可逆，且$A^{-1}=B$</li>
</ul>
<h2 id="2-逆矩阵性质"><a href="#2-逆矩阵性质" class="headerlink" title="2.逆矩阵性质"></a>2.逆矩阵性质</h2><ul>
<li>若A可逆，那么$A^{-1}$也可逆，即$(A^{-1})^{-1}=A$</li>
<li>若A、B均可逆，那么AB均可逆，且$(AB)^{-1}=B^{-1}A^{-1}$</li>
<li>若A可逆，则$A^T$也可逆，且$(A^T)^{-1}=(A^{-1})^T$；若$k\ne 0$，则$(kA)^{-1}=\frac1kA^{-1}$</li>
<li>若A可逆，则$|A^{-1}|=|A|^{-1}$</li>
<li>若A可逆，则$A^<em>$也可逆，且$(A^</em>)^{-1}=\frac1{|A|}A$</li>
</ul>
<hr>
<h1 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h1><ul>
<li><p><strong>标准形矩阵：从左上角开始的一串1，串中1不能间断，不一定是方阵</strong></p>
<script type="math/tex; mode=display">
A =\begin{bmatrix}
1 & 0 & \dots & 0\\
0 & 1 & \dots & 0\\
\dots & \dots & \dots & \dots \\
0 & 0 & \dots & 0\\
\end{bmatrix}_{m\times n}=\begin{bmatrix}
A_1 & A_2\\
A_3 & A_4
\end{bmatrix}</script></li>
<li><p>分块矩阵的乘法与基本矩阵乘法一致，前提是可乘</p>
</li>
</ul>
<hr>
<h1 id="初等变换"><a href="#初等变换" class="headerlink" title="初等变换"></a>初等变换</h1><ul>
<li><p>初等变换包括：</p>
<ul>
<li>交换两行（列）</li>
<li>用$k(k\ne 0)$乘以某行（列）</li>
<li>用某行（列）乘以一个数加到另一行（列）上去</li>
</ul>
</li>
<li><p>任给一个矩阵都可以通过初等变换化成标准形</p>
<script type="math/tex; mode=display">
A =\begin{bmatrix}
1 & 2 & 1\\
-1 & -1 & 0\\
0 & 1 & 1\\
1 & 3 & 2\\
\end{bmatrix}\rightarrow\begin{bmatrix}
1 & 2 & 1\\
0 & 1 & 1\\
0 & 1 & 1\\
0 & 1 & 1\\
\end{bmatrix}\rightarrow\begin{bmatrix}
1 & 0 & -1\\
0 & 1 & 1\\
0 & 0 & 0\\
0 & 0 & 0\\
\end{bmatrix}\rightarrow \begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 0\\
0 & 0 & 0\\
\end{bmatrix}</script></li>
<li><p><strong>等价：由矩阵A经初等变换得到B，即称A等价于B</strong></p>
<ul>
<li>对称性：若A等价于B，则B也等价于A</li>
<li>传递性：若A等价于B，B等价于C，则A也等价于C</li>
</ul>
</li>
</ul>
<h2 id="1-初等方阵"><a href="#1-初等方阵" class="headerlink" title="1.初等方阵"></a>1.初等方阵</h2><ul>
<li><p>初等方阵：对单位阵E做一次初等变换得到的矩阵</p>
<ul>
<li>交换两行的初等方阵：$|E(i,j)|=-1$</li>
<li>行乘以某数的初等方阵：$|E(i(k)|=k(k\ne 0)$</li>
<li>行乘以某数加到某行的初等方阵：$|E(i,j(k))|=1$</li>
</ul>
</li>
<li><p>初等方阵的相关性质：</p>
<ul>
<li><p>初等方阵均可逆：</p>
<script type="math/tex; mode=display">
E^{-1}(i,j)=E(i,j)\quad E^{-1}(i(k))=E(i(\frac1k))\quad E^{-1}(i,j(l))=E(i,j(-l))</script></li>
<li><p>其逆矩阵和转置矩阵均为初等方阵</p>
</li>
<li><p>若A可逆，那么其充分必要条件是A的标准形为E</p>
</li>
<li><p>若A可逆，那么其充分必要条件是A=一些初等方阵的乘积</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-初行变换法求逆"><a href="#2-初行变换法求逆" class="headerlink" title="2.初行变换法求逆"></a>2.初行变换法求逆</h2><ul>
<li><strong>只做初等行变换</strong>，使得：<script type="math/tex; mode=display">
(A,E)\rightarrow(E,A^{-1})</script></li>
</ul>
<p><img src="/2023/08/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E7%9F%A9%E9%98%B5/image-20230808151254781.png" alt="image-20230808151254781" style="zoom: 33%;"></p>
<hr>
<h1 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h1><ul>
<li>定义：<strong>非零子式的最高阶数</strong>，记$r(A)=r$</li>
<li><strong>有矩阵$A_{m\times n}$，则有$0\le r(A)\le min\{m,n\}$</strong><ul>
<li>满秩：$r(A)= min\{m,n\}$</li>
<li>降秩：$r(A)&lt;min\{m,n\}$</li>
</ul>
</li>
<li><strong>若A为方阵，有A满秩$\Leftrightarrow$A可逆</strong></li>
<li><strong>$r(A)=r\Leftrightarrow$有一个r阶子式不为0，所有r+1阶子式为0</strong></li>
</ul>
<h2 id="1-阶梯形"><a href="#1-阶梯形" class="headerlink" title="1.阶梯形"></a>1.阶梯形</h2><ul>
<li><p>定义：</p>
<ul>
<li>若有零行，零行在非零的下边</li>
<li>左起首非零元左边零个数随行数增加而严格增加</li>
</ul>
<script type="math/tex; mode=display">
A =\begin{bmatrix}
1 & 1 & 1 & 1\\
0 & 1 & 0 & 4\\
0 & 0 & 0 & 5\\
\end{bmatrix}</script></li>
</ul>
<h2 id="2-简化阶梯形"><a href="#2-简化阶梯形" class="headerlink" title="2.简化阶梯形"></a>2.简化阶梯形</h2><ul>
<li>非零行的首非零元是1</li>
<li>首非零元所在列的其余元素是0</li>
</ul>
<script type="math/tex; mode=display">
A =\begin{bmatrix}
1 & 0 & 0 & 4\\
0 & 1 & 0 & 5\\
0 & 0 & 1 & 4\\
0 & 0 & 0 & 0\\
\end{bmatrix}</script><h2 id="3-秩相关的定理与性质"><a href="#3-秩相关的定理与性质" class="headerlink" title="3.秩相关的定理与性质"></a>3.秩相关的定理与性质</h2><ul>
<li><p>初等变换不改变秩</p>
</li>
<li><p><strong>r(A)=阶梯形非零行的行数</strong></p>
<p><img src="/2023/08/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E7%9F%A9%E9%98%B5/image-20230808173850984.png" alt="image-20230808173850984"></p>
</li>
<li><p>$r(A)=r(A^T)$</p>
</li>
<li><p><strong>任意矩阵乘以可逆矩阵，其秩不变</strong></p>
</li>
<li><p>有矩阵$A_{m\times n}$，P为m阶可逆方阵，Q为n阶可逆方阵</p>
<script type="math/tex; mode=display">
r(A)=r(PA)=r(AQ)=r(PAQ)</script></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数之行列式</title>
    <url>/2023/08/05/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B9%8B%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<p>本节主要介绍了行列式的基本性质与相关定理</p>
<span id="more"></span>
<h1 id="排列与对换"><a href="#排列与对换" class="headerlink" title="排列与对换"></a>排列与对换</h1><h2 id="1-排列"><a href="#1-排列" class="headerlink" title="1.排列"></a>1.排列</h2><ul>
<li><p>排列：由1，2，……，n组成的一个有序数组（中间不能缺数），叫n级排列</p>
</li>
<li><p>n级排列的个数有：$n\times (n-1)\dots 3\times 2\times 1=n!$</p>
</li>
<li><p>逆序：大数排在小数的前面</p>
</li>
<li><p>逆序数：逆序的总数（从第一个数开始，数后面有几个比它小的）</p>
<ul>
<li><p>如4213的逆序数$N(4213)=3+1=4$</p>
</li>
<li><p>逆序数为奇数为奇排列</p>
</li>
<li>逆序数为偶数为偶排列</li>
</ul>
</li>
<li><p>标准（自然）排列：$N(1,2,3,\dots n)=0$</p>
</li>
</ul>
<h2 id="2-对换"><a href="#2-对换" class="headerlink" title="2.对换"></a>2.对换</h2><ul>
<li>交换一个排列中的两个数</li>
<li>对换一次，奇偶性改变一次</li>
<li>n级排列中，奇排列和偶排列各占一半，即$\frac{n!}{2}$</li>
</ul>
<hr>
<h1 id="n阶行列式"><a href="#n阶行列式" class="headerlink" title="n阶行列式"></a>n阶行列式</h1><ul>
<li><p><strong>行列式的本质就是一个数</strong></p>
</li>
<li><p><strong>按行展开的定义</strong>：<strong>行</strong>标取标准排列，<strong>列</strong>标取排列的所有可能，从<strong>不同行不同列</strong>取出n各元素相乘，<strong>符号由列标排列的奇偶性决定</strong>，奇数为负，偶数取正</p>
<script type="math/tex; mode=display">
下三角 = \begin{vmatrix}
a_{11} & 0 & 0 &\dots & 0\\
a_{21} & a_{22} & 0 &\dots & 0\\
\dots & \dots &  \dots & \dots & \dots\\
a_{n1} & a_{n2} & a_{a3} &\dots & a_{nn}
\end{vmatrix}=a_{11}a_{22}\dots a_{nn}(主对角元素相乘)</script><script type="math/tex; mode=display">
上三角 = \begin{vmatrix}
a_{11} & a_{12} & a_{13} &\dots & a_{1n}\\
0 & a_{22} &a_{23} & \dots & a_{2n} &\\
\dots & \dots &  \dots & \dots & \dots\\
0 & 0 & 0 &\dots & a_{nn}\\
\end{vmatrix}=a_{11}a_{22}\dots a_{nn}(主对角元素相乘)</script></li>
<li><p><strong>按列展开的定义</strong>：<strong>列</strong>标取标准排列，<strong>行</strong>标取排列的所有可能，从<strong>不同行不同列</strong>取出n各元素相乘，<strong>符号由行标排列的奇偶性决定</strong>，奇数为负，偶数取正</p>
</li>
<li><p>当矩阵即不按行也不按列展开时，其符号由行排列与列排列的奇偶性的和决定</p>
</li>
</ul>
<hr>
<h1 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h1><h2 id="1-转置"><a href="#1-转置" class="headerlink" title="1.转置"></a>1.转置</h2><ul>
<li>$D\rightarrow D^T$：行列交换</li>
<li>$(D^T)^T=D$</li>
<li>$D^T=D$：行列式转置后其值不变，<strong>对行成立的性质，对列也成立</strong></li>
</ul>
<h2 id="2-互换"><a href="#2-互换" class="headerlink" title="2.互换"></a>2.互换</h2><ul>
<li>行列式中两行互换，值变号</li>
<li><strong>两行（列）相等，$D=0$</strong></li>
</ul>
<h2 id="3-公因数提取"><a href="#3-公因数提取" class="headerlink" title="3.公因数提取"></a>3.公因数提取</h2><ul>
<li><p>某一行（列）都乘以k，等于用k乘以D</p>
</li>
<li><p>行列式所有元素，均有公因子k，则k外提n次</p>
</li>
<li><strong>两行对应成比例，$D=0$</strong></li>
</ul>
<h2 id="4-全零行"><a href="#4-全零行" class="headerlink" title="4.全零行"></a>4.全零行</h2><ul>
<li><strong>某一行（列）全为0，$D=0$</strong></li>
</ul>
<h2 id="5-分解"><a href="#5-分解" class="headerlink" title="5.分解"></a>5.分解</h2><ul>
<li><p>行列式中某一行（列）是两个数相加，则是和的那一行分开，其余行保持不变</p>
</li>
<li><p><strong>某一行（列）乘以一个数，加到另外一行（列）上去，D不变</strong>，即行列式的值不变</p>
</li>
</ul>
<h2 id="6-反对称行列式"><a href="#6-反对称行列式" class="headerlink" title="6.反对称行列式"></a>6.反对称行列式</h2><ul>
<li>奇数阶的反对称行列式$D=0$<script type="math/tex; mode=display">
\begin{vmatrix}
0 & a & b\\
-a & 0 & c\\
-b & -c & 0 
\end{vmatrix}=0</script></li>
</ul>
<hr>
<h1 id="行列式按行展开"><a href="#行列式按行展开" class="headerlink" title="行列式按行展开"></a>行列式按行展开</h1><h2 id="1-余子式与代数余子式"><a href="#1-余子式与代数余子式" class="headerlink" title="1.余子式与代数余子式"></a>1.余子式与代数余子式</h2><ul>
<li><p>假设有行列式：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
1 & 1 & 0 & 3\\
1 & 1 & 1 & 1\\
2 & 2 & 3 & 4\\
5 & 5 & 6 & 6
\end{vmatrix}</script></li>
<li><p>则余子式：</p>
<script type="math/tex; mode=display">
M_{32}=\begin{vmatrix}
1 & 0 & 3\\
1 & 1 & 1\\
5 & 6 & 6
\end{vmatrix}</script><script type="math/tex; mode=display">
M_{14}=\begin{vmatrix}
1 & 1 & 1\\
2 & 2 & 3\\
5 & 5 & 6
\end{vmatrix}</script></li>
<li><p>则代数余子式：</p>
<script type="math/tex; mode=display">
A_{32}=(-1)^{3+2}\begin{vmatrix}
1 & 0 & 3\\
1 & 1 & 1\\
5 & 6 & 6
\end{vmatrix}=(-1)^{3+2}M_{32}</script><script type="math/tex; mode=display">
A_{14}=(-1)^{1+4}\begin{vmatrix}
1 & 1 & 1\\
2 & 2 & 3\\
5 & 5 & 6
\end{vmatrix}=(-1)^{1+4}M_{14}</script></li>
<li><p><strong>相关定理</strong>：</p>
<ul>
<li>$D=a_{i1}A_{i1}+a_{i2}A_{i2}+\dots+a_{in}A_{in}$（按某一行展开）</li>
<li>$D = a_{1j}A_{1j}+a_{2j}A_{2j}+\dots+a_{nj}A_{nj}$（按某一列展开）</li>
</ul>
</li>
<li><strong>异乘变零定理：某一行元素与另一行元素的代数余子式乘积之和=0</strong></li>
</ul>
<h2 id="2-拉普拉斯展开定理"><a href="#2-拉普拉斯展开定理" class="headerlink" title="2.拉普拉斯展开定理"></a>2.拉普拉斯展开定理</h2><ul>
<li><p>k阶子式：取k行k列，重叠部分即为k阶子式</p>
<ul>
<li><p>若有行列式：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
1 & 2 & 3 & 4\\
1 & 1 & 2 & 5\\
1 & 1 & 0 & 8\\
9 & 9 & 9 & 10
\end{vmatrix}</script></li>
<li><p>取第1、2行与1、2列，则其2阶子式为：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
1 & 2 \\
1 & 1 
\end{vmatrix}</script></li>
</ul>
</li>
<li><p>余子式：取完k行k列后剩下的行列式</p>
<ul>
<li>则余子式为：<script type="math/tex; mode=display">
\begin{vmatrix}
0 & 8 \\
9 & 10 
\end{vmatrix}</script></li>
</ul>
</li>
<li><p>代数余子式：在余子式的基础上乘以代数$(-1)^{取的行数和+列数和}$</p>
<ul>
<li>则代数余子式为：<script type="math/tex; mode=display">
(-1)^{1+2+1+2}\begin{vmatrix}
0 & 8 \\
9 & 10 
\end{vmatrix}</script></li>
</ul>
</li>
<li><p>定理：取定k行，由k行元素组成的所有k阶子式与代数余子式乘积之和=D（行列式的值）</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
1 & 2 & 0 & 0 & 0\\
3 & 4 & 0 & 0 & 0\\
1 & 2 & 3 & 4 & 5\\
1 & 1 & 1 & 1 & 1\\
6 & 6 & 8 & 3 & 1
\end{vmatrix}=\begin{vmatrix}
1 & 2 \\
3 & 4 
\end{vmatrix}\times(-1)^{1+2+1+2}\times \begin{vmatrix}
3 & 4 & 5\\
1 & 1 & 1\\
8 & 3 & 1
\end{vmatrix}</script></li>
</ul>
<hr>
<h1 id="范德蒙德行列式"><a href="#范德蒙德行列式" class="headerlink" title="范德蒙德行列式"></a>范德蒙德行列式</h1><script type="math/tex; mode=display">
\begin{vmatrix}
1 & 1 & 1 & \dots & 1\\
x_1 & x_2 & x_3 & \dots& x_n\\
\dots & \dots & \dots & \dots & \dots\\
x_1^{n-2} & x_2^{n-2} & x_3^{n-2} & \dots & x_n^{n-2}\\
x_1^{n-1} & x_2^{n-1} & x_3^{n-1} & \dots & x_n^{n-1}
\end{vmatrix}=\prod_{1\le j<i\le n}(x_i-x_j)</script><hr>
<h1 id="Cramer法则"><a href="#Cramer法则" class="headerlink" title="Cramer法则"></a>Cramer法则</h1><script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
x_1 + x_2 + x_3 & = 1\\
x_1 - x_2 + 5x_3 & = 6\\
-x_1 + x_2 + 6x_3 & = 9
\end{aligned}
\end{cases}</script><ul>
<li><p>则：</p>
<script type="math/tex; mode=display">
D=\begin{vmatrix}
1 & 1 & 1\\
1 & -1 & 5\\
-1 & 1 & 6\\
\end{vmatrix}\quad D_1=\begin{vmatrix}
1 & 1 & 1\\
6 & -1 & 5\\
9 & 1 & 6\\
\end{vmatrix}\quad D_2=\begin{vmatrix}
1 & 1 & 1\\
1 & 6 & 5\\
-1 & 9 & 6\\
\end{vmatrix}\quad D_3=\begin{vmatrix}
1 & 1 & 1\\
1 & -1 & 6\\
-1 & 1 & 9\\
\end{vmatrix}</script></li>
<li><p>则：</p>
<script type="math/tex; mode=display">
x_1=\frac{D_1}{D}\quad x_2=\frac{D_2}{D}\quad x_3=\frac{D_3}{D}</script></li>
<li><p><strong>只适用于方程个数=未知量个数，且$D\neq 0$的情况</strong></p>
</li>
<li><p>当方程组右侧的值均为0时，则称为齐次方程组</p>
<ul>
<li>其至少有零解</li>
<li>若$D\neq 0$，则只有零解</li>
<li>齐次方程有非零解的充分必要条件是$D=0$</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构之指令系统</title>
    <url>/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>本节主要介绍了流水线的相关基础知识</p>
<span id="more"></span>
<h1 id="流水线基本概念"><a href="#流水线基本概念" class="headerlink" title="流水线基本概念"></a>流水线基本概念</h1><h2 id="1-流水线的特点"><a href="#1-流水线的特点" class="headerlink" title="1.流水线的特点"></a>1.流水线的特点</h2><ul>
<li>流水过程由多个相关的子过程组成，这些子过程称为流水线的“级”或“段”，“段”的数目称为流水线的“深度”</li>
<li>每个子过程由专用的功能段实现</li>
<li>各功能段的时间应基本相等，通常为1个时钟周期（1拍）</li>
<li>流水线需要经过<strong>一定的通过时间</strong>才能稳定</li>
<li>流水技术适合于<strong>大量重复</strong>的时序过程</li>
</ul>
<h2 id="2-流水线的分类"><a href="#2-流水线的分类" class="headerlink" title="2.流水线的分类"></a>2.流水线的分类</h2><ul>
<li><p>按流水线所<strong>完成的功能</strong>分类：</p>
<ul>
<li><p>单功能流水线，是指只能完成一种固定功能的流水线</p>
</li>
<li><p>多功能流水线，是指各段可以进行不同的连接，从而完成不同的功能</p>
<p><img src="/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230804102006973.png" alt="image-20230804102006973" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>按<strong>同一时间内流水线的连接方式</strong>划分</p>
<ul>
<li>静态流水线，是指在同一时间内，流水线的各段只能按同一种功能的连接方式工作</li>
<li>动态流水线，是指在同一时间内，当某些段正在实现某种运算时，另一些段却在实现另一种运算</li>
</ul>
</li>
<li><p>按<strong>流水的级别</strong>划分</p>
<ul>
<li>部件级流水线，又叫运算操作流水线，是把处理机的算术逻辑部件分段，使得各种数据类型的操作能够进行流水</li>
<li>处理机级流水线，又叫指令流水线，是把解释指令的过程按照流水方式处理</li>
<li>处理时间流水线，又叫宏流水线，是由两个以上的处理机串行地对同一数据流进行处理，每个处理机完成一项任务</li>
</ul>
</li>
<li><p>按照<strong>数据</strong>表示来进行分类</p>
<ul>
<li>标量流水处理机，是指处理机不具有向量数据表示，仅对标量数据进行流水处理</li>
<li>向量流水处理机，是指处理机具有向量数据表示，并通过向量指令对向量的各元素进行处理</li>
</ul>
</li>
<li><p>按照是否有<strong>反馈回路</strong>来进行分类</p>
<ul>
<li><p>线性流水线，是指流水线的各段串行连接，没有反馈回路</p>
</li>
<li><p>非线性流水线，是指流水线种除有串行连接的通路外，还有反馈回路</p>
<ul>
<li>但其存在流水线调度问题</li>
<li>确定什么时候向流水线引进新的输入，从而使新输入的数据和先前操作的反馈数据流水线中不产生冲突，此即所谓流水线调度问题</li>
</ul>
<p><img src="/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230804103817743.png" alt="image-20230804103817743"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="MIPS基本流水线"><a href="#MIPS基本流水线" class="headerlink" title="MIPS基本流水线"></a>MIPS基本流水线</h1><h2 id="1-实现MIPS指令的一种简单数据通路"><a href="#1-实现MIPS指令的一种简单数据通路" class="headerlink" title="1.实现MIPS指令的一种简单数据通路"></a>1.实现MIPS指令的一种简单数据通路</h2><p><img src="/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230804110313673.png" alt="image-20230804110313673" style="zoom:50%;"></p>
<ul>
<li><p>这是一种非流水方式</p>
</li>
<li><p>将指令执行划分为5个阶段：</p>
<ul>
<li><p>取指令周期（IF）</p>
<ul>
<li><p>根据PC值从存储器中取出指令，并将指令送入指令寄存器IR，PC值增加4，指向顺序的下一条指令，</p>
</li>
<li><p>并将下一条指令的地址放入临时寄存器NPC中</p>
<script type="math/tex; mode=display">
IR\leftarrow Mem[PC]\\NPC\leftarrow PC+4</script></li>
</ul>
</li>
<li><p>指令译码/读寄存器周期（ID）</p>
<ul>
<li><p>进行指令译码，读取IR寄存器（指令寄存器），按照相应寄存器号读寄存器文件，并将读出结果放入两个临时寄存器A和B中</p>
</li>
<li><p>同时对IR寄存器中内容的低16位进行符号扩展，然后将符号扩展后的32位立即值保存在临时寄存器Imm中</p>
<script type="math/tex; mode=display">
A\leftarrow Regs[IR_{6..10}]\\B\leftarrow Regs[IR_{11..15}]\\Imm\leftarrow ((IR_{16})^{16}\#\#IR_{16..31})</script></li>
</ul>
</li>
<li><p>执行/有效地址计算周期（EX）</p>
<ul>
<li>存储器访问：$ALUoutput\leftarrow A+Imm$</li>
<li>寄存器-寄存器ALU：$ALUoutput\leftarrow A\,op\,B$</li>
<li>寄存器-立即数ALU：$ALUoutput\leftarrow A\, op\, Imm$</li>
<li>分支操作：$ALUoutput\leftarrow NPC+Imm\quad Cond\leftarrow (A\,op\, 0)$</li>
</ul>
</li>
<li><p>存储器访问/分支完成周期（MEM）</p>
<ul>
<li><p>访问操作：</p>
<ul>
<li>$Load:\quad LMD\leftarrow LMDMEN[ALUoutput]$</li>
<li>$Store:\quad Mem[ALUoutput]\leftarrow B$</li>
</ul>
</li>
<li><p>分支操作：</p>
<script type="math/tex; mode=display">
if\,(Cond)\,PC\leftarrow ALUouput\\
else\, PC\leftarrow NPC</script></li>
</ul>
</li>
<li><p>写回周期（WB）</p>
<ul>
<li>寄存器-寄存器型ALU指令：$Reg[IR_{16..20}]\leftarrow ALUoutput$</li>
<li>寄存器-立即值型ALU指令：$Reg[IR_{11..15}]\leftarrow ALUoutput$</li>
<li>Load指令：$Reg[IR_{11..15}]\leftarrow LMD$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-一种简单的MIPS流水线"><a href="#2-一种简单的MIPS流水线" class="headerlink" title="2.一种简单的MIPS流水线"></a>2.一种简单的MIPS流水线</h2><ul>
<li><p>数据通路中的每一个周期成为流水线的一段</p>
</li>
<li><p>每个时钟周期启动一条指令</p>
<p><img src="/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230804114637409.png" alt="image-20230804114637409"></p>
</li>
<li><p>实现流水技术应解决的一些问题</p>
<ul>
<li>应保证流水线各段不会在同一时钟周期内使用相同的寄存器通路资源</li>
<li>PC计算问题：为了能够在每个时钟周期启动一条新的指令，流水线必须在IF段获取下一条指令的地址，并将其保存在PC中</li>
<li>合理划分流水段，每段内的操作必须在一个时钟周期内完成</li>
<li>流水线寄存器设计：为防止寄存器中的值在为流水线中某条指令所用时被流水线中其他的指令所重写，可在流水线各段时间设置流水线寄存器文件，也称锁存器</li>
</ul>
</li>
</ul>
<hr>
<h1 id="流水线性能分析"><a href="#流水线性能分析" class="headerlink" title="流水线性能分析"></a>流水线性能分析</h1><h2 id="1-吞吐率"><a href="#1-吞吐率" class="headerlink" title="1.吞吐率"></a>1.吞吐率</h2><ul>
<li><p>是衡量流水线速度的重要指标</p>
</li>
<li><p><strong>吞吐率</strong>：是指单位时间内流水线所完成的任务数或输出结果的数量</p>
</li>
<li><p><strong>最大吞吐率</strong>$TP_{max}$：是指流水线在达到稳定状态后所得到的吞吐率</p>
<ul>
<li><p>假设流水线各段的时间相等，均为$\Delta t_0$，则：</p>
<script type="math/tex; mode=display">
TP_{max}=\frac 1{\Delta t_0}</script></li>
<li><p>假设流水线各段的时间不相等，第i段的时间为$\Delta t_i$，则：</p>
<script type="math/tex; mode=display">
TP_{max}=\frac 1{max(\Delta t_i)}</script></li>
<li><p>最大吞吐率取决于流水线中最慢一段所需要的时间，该段为流水线的瓶颈</p>
</li>
</ul>
</li>
<li><p><strong>实际吞吐率</strong>$TP$：设流水线由m段组成，完成n个任务的吞吐率称为实际吞吐率</p>
<ul>
<li><p>若各段时间相等（假设均为$\Delta t_0$），则完成时间：</p>
<script type="math/tex; mode=display">
T_{流水}=m\Delta t_0+(n-1)\Delta t_0</script><p><img src="/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230804183304160.png" alt="image-20230804183304160"></p>
</li>
<li><p>则实际吞吐率为：</p>
<script type="math/tex; mode=display">
TP=\frac{n}{T_{流水}}=\frac{n}{m\Delta t_0+(n-1)\Delta t_0}=\frac{TP_{max}}{1+\frac{m-1}{n}}</script></li>
<li><p>若各段时间不等（假设第i段为$\Delta t_i$），且假设$\Delta t_j=max{\Delta t_i}$，则完成时间：</p>
<script type="math/tex; mode=display">
T=\sum_{i=1}^m\Delta t_i+(n-1)\Delta t_j</script></li>
<li><p>则实际吞吐率为：</p>
<script type="math/tex; mode=display">
TP=\frac{n}{\sum_{i=1}^m\Delta t_i+(n-1)\Delta t_j}</script></li>
</ul>
</li>
</ul>
<h2 id="2-加速比"><a href="#2-加速比" class="headerlink" title="2.加速比"></a>2.加速比</h2><ul>
<li><p>加速比S是指流水线速度与等功能的非流水线速度之比</p>
<script type="math/tex; mode=display">
S=\frac{T_{非流水}}{T_{流水}}</script></li>
<li><p>若流水线为m段，每段时间均为$\Delta t_0$，则：</p>
<script type="math/tex; mode=display">
T_{非流水}=nm\Delta t_0</script><script type="math/tex; mode=display">
T_{流水}=m\Delta t_0+(n-1)\Delta t_0</script><script type="math/tex; mode=display">
S=\frac{mn}{m+n-1}=\frac{m}{1+\frac{m-1}{n}}</script></li>
</ul>
<p><img src="/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230804183540421.png" alt="image-20230804183540421"></p>
<h2 id="3-效率"><a href="#3-效率" class="headerlink" title="3.效率"></a>3.效率</h2><ul>
<li><p>效率是指流水线的设备利用率</p>
</li>
<li><p>由于流水线有<strong>通过时间</strong>和<strong>排空时间</strong>，所以流水线的各段并非一直满负荷工作，E&lt;1</p>
<p><img src="/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230804183356816.png" alt="image-20230804183356816"></p>
</li>
<li><p>若各段时间相等，则各段效率也相等，即e1=e2=e3……=$n\Delta t_0/T_{流水}$</p>
</li>
<li><p>整个流水线效率：</p>
<script type="math/tex; mode=display">
E=\frac{n\Delta t_0}{T_{流水}}=\frac{n}{m+n-1}=\frac{1}{1+\frac{m-1}{n}}</script><p><img src="/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/image-20230804183419046.png" alt="image-20230804183419046"></p>
</li>
<li><p>当$n&gt;&gt;m$时，$E\approx1$</p>
</li>
</ul>
<h2 id="4-吞吐率、加速比和效率的关系"><a href="#4-吞吐率、加速比和效率的关系" class="headerlink" title="4.吞吐率、加速比和效率的关系"></a>4.吞吐率、加速比和效率的关系</h2><ul>
<li><p>效率是实际加速比S与最大加速比m之比</p>
<script type="math/tex; mode=display">
E=\frac{n\Delta t_0}{T_{流水}}=\frac{mn\Delta t_0}{T_{流水}m}=\frac Sm</script></li>
<li><p>当$\Delta t_0$不变时，流水线的效率与吞吐率呈正比，为了提高效率而采取的措施，也有助于提高吞吐率</p>
<script type="math/tex; mode=display">
E=\frac{n\Delta t_0}{T_{流水}}=\frac{n}{T_{流水}}.\Delta t_0=TP\Delta t_0</script></li>
</ul>
<hr>
<h1 id="向量处理机"><a href="#向量处理机" class="headerlink" title="向量处理机"></a>向量处理机</h1><ul>
<li>向量处理机：具有向量数据表示和相应向量指令的流水线处理机称为向量流水线处理机，也称向量处理机</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构之指令系统</title>
    <url>/2023/08/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本节主要介绍了指令集结构的基本概念及其寻址方式</p>
<span id="more"></span>
<h1 id="指令集结构概述"><a href="#指令集结构概述" class="headerlink" title="指令集结构概述"></a>指令集结构概述</h1><ul>
<li><p>指令集：一些指令的集合，每条指令都是直接由CPU硬件执行</p>
</li>
<li><p>指令的表示方式：</p>
<ul>
<li>二进制表示</li>
<li>物理存储空间组织方式是位、字节、字和多字等</li>
<li>当前的指令字长有：16、32、64位</li>
<li>可变长格式和固定长度格式</li>
</ul>
</li>
<li><p>指令的特点：</p>
<ul>
<li><strong>指令由操作码和地址码组成</strong></li>
<li>每个操作需要的操作数个数为0~3个不等<ul>
<li>操作数是一些存储单元的地址</li>
<li>典型的存储单元通常有：主存、寄存器、堆栈和累加器</li>
</ul>
</li>
<li>操作数地址隐含表示或显式表示</li>
</ul>
</li>
<li><p>指令集与计算机的性能：</p>
<script type="math/tex; mode=display">
T_{CPU}=CPI\times IC \times T_{CLK}</script></li>
</ul>
<hr>
<h1 id="通用寄存器型指令集结构（GPR）"><a href="#通用寄存器型指令集结构（GPR）" class="headerlink" title="通用寄存器型指令集结构（GPR）"></a>通用寄存器型指令集结构（GPR）</h1><ul>
<li>CPU中用来存储操作数的存储单元主要有：<ul>
<li>堆栈</li>
<li>累加器</li>
<li>一组寄存器</li>
</ul>
</li>
<li>指令中的操作数可以被明确地显示给出，也可以按照某种约定隐式给出</li>
<li>通用寄存器型指令集结构的主要优点：<ul>
<li>在表达式求值方面，比其他类型指令集结构都具有更大的灵活性</li>
<li>寄存器可以用来存放变量<ul>
<li>减少存储器的通信量，加快程序的执行速度（<strong>因为寄存器比存储器快</strong>）</li>
<li>可以用更少的地址位来寻址寄存器，从而可以有效改进程序的目标代码大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="指令集的寻址"><a href="#指令集的寻址" class="headerlink" title="指令集的寻址"></a>指令集的寻址</h1><h2 id="1-寻址技术"><a href="#1-寻址技术" class="headerlink" title="1.寻址技术"></a>1.寻址技术</h2><ul>
<li>在通用寄存器型指令集结构中，一般是利用寻址方式指明指令中的<strong>操作数是一个常数、一个寄存器操作数，又或是一个存储器操作数</strong></li>
<li>寻址实际上是从形式地址到实际地址的转换，形式地址由指令描述，实际地址也称为<strong>有效地址</strong></li>
<li>有效地址指明的是<strong>存储器单元的地址或寄存器地址</strong></li>
<li><strong>必须加速有效地址生成</strong></li>
</ul>
<h2 id="2-常用的一些操作数寻址方式"><a href="#2-常用的一些操作数寻址方式" class="headerlink" title="2.常用的一些操作数寻址方式"></a>2.常用的一些操作数寻址方式</h2><ul>
<li><strong>寄存器寻址</strong>：<ul>
<li>指令实例：Add R4,R3</li>
<li>含义：Regs[R4]&lt;-Regs[R4]+Regs[R3]</li>
</ul>
</li>
<li><strong>立即值寻址</strong>：<ul>
<li>指令实例：Add R4,#3</li>
<li>含义：Regs[R4]&lt;-Regs[R4]+3</li>
</ul>
</li>
<li><strong>偏移寻址</strong>：<ul>
<li>指令实例：Add R4,100(R1)</li>
<li>含义：Regs[R4]&lt;-Regs[R4]+Mem[100+Regs[R1]]</li>
</ul>
</li>
<li><strong>寄存器间接寻址</strong>：<ul>
<li>指令实例：Add R4,(R1)</li>
<li>含义：Regs[R4]&lt;-Regs[R4]+Mem[Regs[R1]]</li>
</ul>
</li>
<li><p><strong>索引寻址</strong>：</p>
<ul>
<li>指令实例：Add R3,(R1+R2)</li>
<li>含义：Regs[R3]&lt;-Regs[R3]+Mem[Regs[R1]+Regs[R2]]</li>
</ul>
</li>
<li><p><strong>直接寻址或绝对寻址</strong>：</p>
<ul>
<li>指令实例：Add R1,(1001)</li>
<li>含义：Regs[R1]&lt;-Regs[R1]+Mem[1001]</li>
</ul>
</li>
<li><p><strong>存储器间接寻址</strong>：</p>
<ul>
<li>指令实例：Add R1,@(R3)</li>
<li>含义：Regs[R1]&lt;-Regs[R1]+Mem[Mem[Regs[R3]]]</li>
</ul>
</li>
<li><p><strong>自增寻址</strong>：</p>
<ul>
<li>指令实例：Add R1,(R2)+</li>
<li>含义：<ul>
<li>Regs[R1]&lt;-Regs[R1]+Mem[Regs[R2]]</li>
<li>Regs[R2]&lt;-Regs[R2]+d</li>
<li><strong>d代表R2所占的字节个数</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>自减寻址</strong>：<ul>
<li>指令实例：Add R1,-(R2)</li>
<li>含义：<ul>
<li>Regs[R2]&lt;-Regs[R2]-d</li>
<li>Regs[R1]&lt;-Regs[R1]+Mem[Regs[R2]]</li>
</ul>
</li>
</ul>
</li>
<li><strong>缩放寻址</strong>：<ul>
<li>指令实例：Add R1,100(R2)[R3]</li>
<li>含义：Regs[R1]&lt;-Regs[R1]+Mem[100+Regs[R2]+Regs[R3]*d]</li>
</ul>
</li>
</ul>
<hr>
<h1 id="MIPS指令集结构"><a href="#MIPS指令集结构" class="headerlink" title="MIPS指令集结构"></a>MIPS指令集结构</h1><ul>
<li>寄存器：<ul>
<li>32个32位的通用寄存器（GPRs），寄存器R0的内容恒为全0</li>
<li>32个32位浮点寄存器（FPRS），单精度浮点数表示和双精度浮点数表示</li>
</ul>
</li>
<li>数据类型：<ul>
<li>整型数据：8位、16位、32位</li>
<li>浮点数据：<ul>
<li>32位单精度浮点</li>
<li>64位双精度浮点</li>
</ul>
</li>
</ul>
</li>
<li>操作类型：<ul>
<li>符号“&lt;-”表示数据传送操作，其后附带一个下标n，也即“&lt;-n”表示传送一个n位数据</li>
<li>符号”##”用来表示两个域的串联操作，它可以出现在数据传送操作的任何一边</li>
</ul>
</li>
<li><p>域的下表用来表明从该域中选择一位，域中位的标记是从最高位开始标记，并且起始标记为0</p>
</li>
<li><p>上标表示复制一个域，如$0^{24}$可以得到一个24位全为0的一个域</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构之基本概念</title>
    <url>/2023/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>本节主要介绍了存储程序计算机、Amdahl定律、CPU的性能计算</p>
<span id="more"></span>
<h1 id="存储程序计算机"><a href="#存储程序计算机" class="headerlink" title="存储程序计算机"></a>存储程序计算机</h1><ul>
<li><p>存储程序计算机：</p>
<ul>
<li>一种计算机系统设计模型</li>
<li>实现了一种通用图灵机</li>
</ul>
</li>
<li><p>冯诺依曼描述的计算机由四个部分组成：</p>
<ul>
<li>运算器：用于完成数值运算</li>
<li>存储器：用于存储数据和程序</li>
<li>输入/输出：用于完成计算机和外部的信息交流</li>
<li>控制器：根据程序形成控制（指令、命令）序列，完成对数据的运算</li>
</ul>
</li>
<li><p>存储程序机器的结构：</p>
<p><img src="/2023/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230626231440573.png" alt="image-20230626231440573" style="zoom: 25%;"></p>
</li>
<li><p><strong>运算器与控制器以及寄存器组一起构成CPU</strong></p>
</li>
</ul>
<hr>
<h1 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h1><ul>
<li><p>假设我们对机器（部件）进行某种改进，那么机器系统（部件）的加速比就是：</p>
<script type="math/tex; mode=display">
系统加速比=\frac{系统性能_{改进后}}{系统性能_{改进前}}=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}</script><ul>
<li>系统加速比告知改进后的机器比改进前快多少</li>
</ul>
</li>
<li><p>系统加速比依赖于两个因素：</p>
<ul>
<li>可改进比例：可改进部分在原系统计算时间中所占的比例，它总是小于等于1的：$\frac{T_1}{T_0}$</li>
<li>部件加速比：可改进部分改进以后的性能提高，一般情况下它是大于1的：$\frac{T_1}{T_2}$</li>
</ul>
<p><img src="/2023/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230626232435362.png" alt="image-20230626232435362" style="zoom: 33%;"></p>
</li>
<li><p>Amdahl的系统执行时间：部件改进后，系统的总执行时间等于不可改进部分的执行时间加上可改进部分改进后的执行时间，即：</p>
<script type="math/tex; mode=display">
总执行时间_{改进后}=(1-可改进比例)\times总执行时间_{执行前}+\frac{可改进比例\times总执行时间_{改进前}}{部件加速比}\\=总执行时间_{改进前}\times[(1-可改进比例)+\frac{可改进比例}{部件加速比}]</script></li>
<li><p>故Amdahl的系统加速比：</p>
<script type="math/tex; mode=display">
系统加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}=\frac{1}{(1-可改进比例)+\frac{可改进比例}{部件加速比}}</script></li>
<li><p>Amdahl定律的观点</p>
<ul>
<li>性能增加的递减规则：仅仅对计算机中的一部分做性能改进，则改进越多，系统获得的效果越小</li>
<li>Amdahl定律的一个重要推论：针对整个任务的一部分进行优化，则最大加速比不大于$\frac{1}{1-可改进比例}$</li>
<li>Amdahl定律衡量一个”好”的计算机系统：具有高性能价格比的计算机系统是一个带宽平衡的系统，而不是看它使用的某个部件的性能</li>
</ul>
</li>
</ul>
<hr>
<h1 id="CPU的性能计算"><a href="#CPU的性能计算" class="headerlink" title="CPU的性能计算"></a>CPU的性能计算</h1><ul>
<li><p>程序执行过程中所处理的指令数，记为<strong>IC</strong></p>
</li>
<li><p>每条指令执行所需要的时钟周期数<strong>CPI</strong></p>
</li>
<li><p>每条指令执行所需要的平均时钟周期数：</p>
<script type="math/tex; mode=display">
CPI=\frac{CLK}{IC}</script><ul>
<li>$CLK$表示总共的周期数</li>
</ul>
</li>
<li><p>假设计算机系统由$n$种指令，其中第$i$种指令的处理周期数为$CPI_i$，在程序中第$i$种指令出现的次数为$IC_i$</p>
<script type="math/tex; mode=display">
T_{CPU}=\frac{CLK}{f}\\
CLK=\sum(IC_i\times CPI_i)\\
T_{CPU}=\frac{\sum(IC_i\times CPI_i)}{f}=\sum(IC_i\times CPI_i)\times T_{CLK}\\
=\frac{\sum(IC_i\times CPI_i)}{IC}=\sum[(\frac{IC_i}{IC})\times CPI_i]</script></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch之多层感知机</title>
    <url>/2023/04/12/Pytorch%E4%B9%8B%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    <content><![CDATA[<p>本节主要介绍了多层感知机、K-折交叉验证、欠拟合与过拟合以及权重衰退</p>
<span id="more"></span>
<h1 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h1><ul>
<li><p>我们可以通过在网络中加入一个或多个隐藏层来克服线性模型的限制， 使其能处理更普遍的函数关系类型。</p>
</li>
<li><p>要做到这一点，最简单的方法是将许多全连接层堆叠在一起，每一层都输出到上面的层，直到生成最后的输出</p>
</li>
<li><p>我们可以把前$L−1$层看作表示，把最后一层看作线性预测器</p>
</li>
<li><p>这种架构通常称为<em>多层感知机</em>（multilayer perceptron），通常缩写为MLP</p>
<p><img src="/2023/04/12/Pytorch%E4%B9%8B%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/image-20230413192102040.png" alt="image-20230413192102040" style="zoom:50%;"></p>
</li>
<li><p>这个多层感知机有4个输入，3个输出，其隐藏层包含5个隐藏单元</p>
</li>
<li><p>输入层不涉及任何计算，因此使用此网络产生输出只需要实现隐藏层和输出层的计算，因此，这个多层感知机中的层数为2</p>
</li>
<li><p>注意，这两个层都是全连接的，每个输入都会影响隐藏层中的每个神经元， 而隐藏层中的每个神经元又会影响输出层中的每个神经元</p>
</li>
<li><p><strong>多层感知机在输出层和输入层之间增加一个或多个全连接隐藏层，并通过激活函数转换隐藏层的输出</strong></p>
</li>
<li><strong>常用的激活函数包括ReLU函数、sigmoid函数和tanh函数</strong></li>
</ul>
<hr>
<h1 id="多层感知机的简洁实现"><a href="#多层感知机的简洁实现" class="headerlink" title="多层感知机的简洁实现"></a>多层感知机的简洁实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取数据集</span></span><br><span class="line">trans = transforms.ToTensor() <span class="comment">#通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式</span></span><br><span class="line">mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;D:\App_Data_File\VScode_Project\Python\Pytorch\dataset\Fashion-MNIST&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">False</span>)</span><br><span class="line">mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;D:\App_Data_File\VScode_Project\Python\Pytorch\dataset\Fashion-MNIST&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter = data.DataLoader(mnist_train, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_iter = data.DataLoader(mnist_test, batch_size, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型参数</span></span><br><span class="line">net = nn.Sequential(nn.Flatten(),</span><br><span class="line">                    nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">                    nn.ReLU(),</span><br><span class="line">                    nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights)</span><br><span class="line"></span><br><span class="line"><span class="comment">#损失函数</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#优化算法：使用学习率为0.1的小批量随机梯度下降作为优化算法</span></span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练模型</span></span><br><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">train_loss = []</span><br><span class="line">train_acc = []</span><br><span class="line">test_loss = []</span><br><span class="line">test_acc = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    net.train()</span><br><span class="line">    total_loss, total_correct = <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">        y_hat = net(X)</span><br><span class="line">        l = loss(y_hat, y)</span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.mean().backward()</span><br><span class="line">        trainer.step()</span><br><span class="line"></span><br><span class="line">        total_loss += l.<span class="built_in">sum</span>()</span><br><span class="line">        total_correct += (y_hat.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    train_loss.append(total_loss.detach().numpy() / <span class="built_in">len</span>(mnist_train))</span><br><span class="line">    train_acc.append(total_correct / <span class="built_in">len</span>(mnist_train))</span><br><span class="line"></span><br><span class="line">    net.<span class="built_in">eval</span>()</span><br><span class="line">    total_loss, total_correct = <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> test_iter:</span><br><span class="line">        y_hat = net(X)</span><br><span class="line">        l = loss(y_hat, y)</span><br><span class="line"></span><br><span class="line">        total_loss += l.<span class="built_in">sum</span>()</span><br><span class="line">        total_correct += (y_hat.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    test_loss.append(total_loss.detach().numpy() / <span class="built_in">len</span>(mnist_test))</span><br><span class="line">    test_acc.append(total_correct / <span class="built_in">len</span>(mnist_test))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Epoch [<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;num_epochs&#125;</span>], Train Loss: <span class="subst">&#123;train_loss[-<span class="number">1</span>]:<span class="number">.4</span>f&#125;</span>, Train Acc: <span class="subst">&#123;train_acc[-<span class="number">1</span>]*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%, Test Loss: <span class="subst">&#123;test_loss[-<span class="number">1</span>]:<span class="number">.4</span>f&#125;</span>, Test Acc: <span class="subst">&#123;test_acc[-<span class="number">1</span>]*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(train_loss, label=<span class="string">&#x27;Train Loss&#x27;</span>)</span><br><span class="line">plt.plot(test_loss, label=<span class="string">&#x27;Test Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(train_acc, label=<span class="string">&#x27;Train Acc&#x27;</span>)</span><br><span class="line">plt.plot(test_acc, label=<span class="string">&#x27;Test Acc&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">##从测试集中选中10个样本去测试训练好的模型，并可视化测试结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_fashion_mnist_labels</span>(<span class="params">labels</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回Fashion-MNIST数据集的文本标签&quot;&quot;&quot;</span></span><br><span class="line">    text_labels = [<span class="string">&#x27;t-shirt&#x27;</span>, <span class="string">&#x27;trouser&#x27;</span>, <span class="string">&#x27;pullover&#x27;</span>, <span class="string">&#x27;dress&#x27;</span>, <span class="string">&#x27;coat&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;sandal&#x27;</span>, <span class="string">&#x27;shirt&#x27;</span>, <span class="string">&#x27;sneaker&#x27;</span>, <span class="string">&#x27;bag&#x27;</span>, <span class="string">&#x27;ankle boot&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> text_labels[labels]</span><br><span class="line"></span><br><span class="line">test_samples = data.DataLoader(mnist_test, batch_size=<span class="number">10</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_batch = <span class="built_in">next</span>(<span class="built_in">iter</span>(test_samples))</span><br><span class="line">X_test, y_test = test_batch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测并可视化结果</span></span><br><span class="line">net.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    y_pred = net(X_test).argmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fig2=plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">5</span>, i+<span class="number">1</span>)</span><br><span class="line">    plt.imshow(X_test[i, <span class="number">0</span>], cmap=<span class="string">&#x27;CMRmap&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">f&quot;Pred: <span class="subst">&#123;get_fashion_mnist_labels(y_pred[i])&#125;</span>, Actual: <span class="subst">&#123;get_fashion_mnist_labels(y_test[i])&#125;</span>&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">fig2.subplots_adjust(hspace=<span class="number">1.2</span>, wspace=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Epoch [1/10], Train Loss: 1.0367, Train Acc: 64.71%, Test Loss: 0.6816, Test Acc: 76.38%</span><br><span class="line">Epoch [2/10], Train Loss: 0.5972, Train Acc: 78.91%, Test Loss: 0.5632, Test Acc: 80.51%</span><br><span class="line">Epoch [3/10], Train Loss: 0.5189, Train Acc: 81.77%, Test Loss: 0.5277, Test Acc: 81.49%</span><br><span class="line">Epoch [4/10], Train Loss: 0.4791, Train Acc: 83.14%, Test Loss: 0.5051, Test Acc: 82.13%</span><br><span class="line">Epoch [5/10], Train Loss: 0.4549, Train Acc: 83.95%, Test Loss: 0.4625, Test Acc: 83.73%</span><br><span class="line">Epoch [6/10], Train Loss: 0.4315, Train Acc: 84.88%, Test Loss: 0.4773, Test Acc: 83.28%</span><br><span class="line">Epoch [7/10], Train Loss: 0.4155, Train Acc: 85.26%, Test Loss: 0.4530, Test Acc: 83.56%</span><br><span class="line">Epoch [8/10], Train Loss: 0.4036, Train Acc: 85.76%, Test Loss: 0.4420, Test Acc: 84.14%</span><br><span class="line">Epoch [9/10], Train Loss: 0.3904, Train Acc: 86.21%, Test Loss: 0.4351, Test Acc: 84.05%</span><br><span class="line">Epoch [10/10], Train Loss: 0.3824, Train Acc: 86.46%, Test Loss: 0.4199, Test Acc: 84.63%</span><br></pre></td></tr></table></figure>
<p><img src="/2023/04/12/Pytorch%E4%B9%8B%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/image-20230419235927270.png" alt="image-20230419235927270" style="zoom:50%;"></p>
<p><img src="/2023/04/12/Pytorch%E4%B9%8B%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/image-20230419235953900.png" alt="image-20230419235953900"></p>
<p><img src="/2023/04/12/Pytorch%E4%B9%8B%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/image-20230420000011181.png" alt="image-20230420000011181"></p>
<ul>
<li><code>with torch.no_grad()</code>的理解：<a href="https://blog.csdn.net/sazass/article/details/116668755">【pytorch系列】 with torch.no_grad():用法详解_大黑山修道的博客-CSDN博客</a></li>
</ul>
<hr>
<h1 id="K-折交叉验证"><a href="#K-折交叉验证" class="headerlink" title="K-折交叉验证"></a>K-折交叉验证</h1><ul>
<li><p>非大数据集上通常使用k-折交叉验证</p>
</li>
<li><p>训练数据集：训练模型参数</p>
</li>
<li><p>验证数据集：选择模型超参数</p>
</li>
<li><p>K-折交叉验证的算法：</p>
<ul>
<li>将训练数据分割成K块</li>
<li><p>For i = 1,…,K</p>
<ul>
<li>使用第i块作为验证数据集，其余的k-1块作为训练数据集</li>
</ul>
</li>
<li><p>报告K个验证集误差的平均</p>
</li>
<li><p>常用K=5或10</p>
</li>
<li><p>例如：若K=3</p>
<p>|      | 块1   | 块2   | 块3   |<br>| —— | ——- | ——- | ——- |<br>| i=1  | val   | train | train |<br>| i=2  | train | val   | train |<br>| i=3  | train | train | val   |</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="欠拟合与过拟合"><a href="#欠拟合与过拟合" class="headerlink" title="欠拟合与过拟合"></a>欠拟合与过拟合</h1><ul>
<li><p>模型容量：</p>
<ul>
<li>拟合各种函数的能力</li>
<li>低容量的模型难以拟合训练数据</li>
<li>高容量的模型可以记住所有的训练数据</li>
</ul>
</li>
<li><p><strong>过拟合与欠拟合</strong></p>
<p>|                  | <strong>数据：简单</strong> | <strong>数据：复杂</strong> |<br>| ———————— | ——————— | ——————— |<br>| <strong>模型容量：低</strong> | 正常           | 欠拟合         |<br>| <strong>模型容量：高</strong> | 过拟合         | 正常           |</p>
<ul>
<li>过拟合：在训练集上表现好，但是在测试集上效果差</li>
<li>欠拟合（高偏差）：模型拟合不够，在训练集上表现效果差，没有充分的利用数据，预测的准确度低</li>
<li>偏差：反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精确度</li>
<li>方差：反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性</li>
</ul>
</li>
<li><p>模型复杂度对欠拟合和过拟合的影响</p>
<p><img src="/2023/04/12/Pytorch%E4%B9%8B%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/image-20230624232454855.png" alt="image-20230624232454855" style="zoom: 67%;"></p>
</li>
<li><p>如何防止过拟合与欠拟合：</p>
<ul>
<li>防止过拟合方法：<ul>
<li>补充数据集</li>
<li>减少模型参数</li>
<li>Dropout</li>
<li>Earlystopping</li>
<li>正则化或稀疏化</li>
</ul>
</li>
<li>防止欠拟合方法<ul>
<li>加大模型参数</li>
<li>减少正则化参数</li>
<li>更充分的训练</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="权重衰退（-L-2-正则化）"><a href="#权重衰退（-L-2-正则化）" class="headerlink" title="权重衰退（$L_2$正则化）"></a>权重衰退（$L_2$正则化）</h1><ul>
<li><p>在训练参数化机器学习模型时， <em>权重衰减</em>（weight decay）是最广泛使用的正则化的技术之一， 它通常也被称为$L_2$正则化</p>
</li>
<li><p>使用均方范数作为硬性限制：</p>
<ul>
<li><p>通过限制参数值的选择范围来控制模型容量</p>
<script type="math/tex; mode=display">
min[l(w,b)]\,\,\,subject\, to\, ||W||^2\leq\theta</script></li>
<li><p>通常不限制偏移b</p>
</li>
<li><p>小的$\theta$意味着更强的正则项</p>
</li>
</ul>
</li>
<li><p>使用均方范数作为柔性限制</p>
<ul>
<li><p>对于每一个$\theta$，都可以找到$\lambda$使得之前的目标函数等价于：</p>
<script type="math/tex; mode=display">
min[l(w,b)+\frac\lambda2||w||^2]</script></li>
<li><p>超参数$\lambda$控制了正则项的重要程度</p>
<ul>
<li>$\lambda=0$：正则项无作用</li>
<li>$\lambda\rightarrow \infty$：意味着$\theta\rightarrow0$,$w\rightarrow0$</li>
</ul>
</li>
</ul>
</li>
<li><p>参数更新法则：</p>
<ul>
<li><p>计算梯度：</p>
<script type="math/tex; mode=display">
\frac{\partial (l(w,b)+\frac\lambda2||w||^2)}{\partial w}=\frac{\partial l(w,b)}{\partial w}+\lambda w</script></li>
<li><p>时间t更新参数：</p>
<script type="math/tex; mode=display">
w_{t+1}=w_t-\eta\frac{\partial loss}{\partial w_t}</script><script type="math/tex; mode=display">
w_{t+1}=(1-\eta\lambda)w_t-\eta\frac{\partial l(w_t,b_t)}{\partial w_t}</script></li>
<li><p>通常$\eta\lambda&lt;1$，在深度学习中通常叫做权重衰退</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zh.d2l.ai/chapter_multilayer-perceptrons/index.html">4. 多层感知机 — 动手学深度学习 2.0.0 documentation (d2l.ai)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch之线性神经网络</title>
    <url>/2023/03/28/Pytorch%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本节主要介绍了回归问题与分类问题</p>
<span id="more"></span>
<h1 id="线性回归从零开始实现"><a href="#线性回归从零开始实现" class="headerlink" title="线性回归从零开始实现"></a>线性回归从零开始实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成y=Xw+b+噪声&quot;&quot;&quot;</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))</span><br><span class="line">    w = w.reshape(<span class="built_in">len</span>(w),<span class="number">1</span>)</span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line">    <span class="keyword">return</span> X, y</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;features:&#x27;</span>, features[<span class="number">0</span>],<span class="string">&#x27;\nlabel:&#x27;</span>, labels[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The features shape is:&#x27;</span>,features.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The features shape is:&#x27;</span>,labels.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span><br><span class="line">    num_examples = features.shape[<span class="number">0</span>]</span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples))</span><br><span class="line">    <span class="comment"># 这些样本是随机读取的，没有特定的顺序</span></span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size):<span class="comment">#每次取batch_size个features与labels</span></span><br><span class="line">        batch_indices = torch.tensor(indices[i: <span class="built_in">min</span>(i + batch_size, num_examples)])</span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices]</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">    <span class="built_in">print</span>(X, <span class="string">&#x27;\n&#x27;</span>, y)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化模型的参数</span></span><br><span class="line">w = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(<span class="number">2</span>,<span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义线性回归模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linreg</span>(<span class="params">X, w, b</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性回归模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> torch.matmul(X, w) + b</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义损失函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">squared_loss</span>(<span class="params">y_hat, y</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;均方损失&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="number">2</span> / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义优化算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;小批量随机梯度下降&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            param.grad.zero_()</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练回归模型</span></span><br><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y)  <span class="comment"># X和y的小批量损失</span></span><br><span class="line">        <span class="comment"># 因为l形状是(batch_size,1)，而不是一个标量。l中的所有元素被加到一起，</span></span><br><span class="line">        <span class="comment"># 并以此计算关于[w,b]的梯度</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        sgd([w, b], lr, batch_size)  <span class="comment"># 使用参数的梯度更新参数</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():<span class="comment">#这里是先通过batch_size迭代一个epoch后，得到此时的权重大小</span></span><br><span class="line">        train_l = loss(net(features, w, b), labels) <span class="comment">#最后用一个epoch全部所有样本去计算训练误差</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean()):f&#125;</span>&#x27;</span>)</span><br><span class="line">		<span class="comment">#:f 是指输出格式，表示输出浮点数的值，并保留小数点后面的数字（默认保留6位小数）</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w的估计误差: <span class="subst">&#123;true_w - w.reshape(true_w.shape)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;b的估计误差: <span class="subst">&#123;true_b - b&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">features: tensor([-1.7930, -0.8309]) </span><br><span class="line">label: tensor([3.4262])</span><br><span class="line">The features shape is: torch.Size([1000, 2])</span><br><span class="line">The features shape is: torch.Size([1000, 1])</span><br><span class="line">---------------------------------------------</span><br><span class="line">tensor([[ 1.8215, -0.5405],</span><br><span class="line">        [-1.2937,  0.0948],</span><br><span class="line">        [-0.5884,  1.1061],</span><br><span class="line">        [ 0.8890, -0.3747],</span><br><span class="line">        [ 0.8483,  0.6304],</span><br><span class="line">        [ 0.0467, -0.5271],</span><br><span class="line">        [ 1.2621,  0.3016],</span><br><span class="line">        [ 1.4067, -0.1602],</span><br><span class="line">        [ 0.6865, -1.0503],</span><br><span class="line">        [ 0.9774, -1.1767]]) </span><br><span class="line"> tensor([[ 9.6800],</span><br><span class="line">        [ 1.2851],</span><br><span class="line">        [-0.7400],</span><br><span class="line">        [ 7.2501],</span><br><span class="line">        [ 3.7616],</span><br><span class="line">        [ 6.1004],</span><br><span class="line">        [ 5.6812],</span><br><span class="line">        [ 7.5717],</span><br><span class="line">        [ 9.1570],</span><br><span class="line">        [10.1526]])</span><br><span class="line">epoch 1, loss 0.038120</span><br><span class="line">epoch 2, loss 0.000143</span><br><span class="line">epoch 3, loss 0.000051</span><br><span class="line">w的估计误差: tensor([0.0003, 0.0005], grad_fn=&lt;SubBackward0&gt;)</span><br><span class="line">b的估计误差: tensor([-2.5749e-05], grad_fn=&lt;RsubBackward1&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>yield</code>理解参考：<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">python中yield的用法详解——最简单，最清晰的解释_python yield_冯爽朗的博客-CSDN博客</a></li>
</ul>
<hr>
<h1 id="线性回归的简洁实现"><a href="#线性回归的简洁实现" class="headerlink" title="线性回归的简洁实现"></a>线性回归的简洁实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成合成数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成y=Xw+b+噪声&quot;&quot;&quot;</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))</span><br><span class="line">    w = w.reshape(<span class="built_in">len</span>(w),<span class="number">1</span>)</span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line">    <span class="keyword">return</span> X, y</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#我们可以调用框架中现有的API来读取数据</span></span><br><span class="line"><span class="comment">#我们将features和labels作为API的参数传递，并通过数据迭代器指定batch_size</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_array</span>(<span class="params">data_arrays, batch_size, is_train=<span class="literal">True</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;构造一个PyTorch数据迭代器&quot;&quot;&quot;</span></span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br><span class="line">x1=<span class="built_in">next</span>(<span class="built_in">iter</span>(data_iter)) <span class="comment">#next() 函数返回迭代器中的下一项。若添加返回值，以在迭代结束时返回。</span></span><br><span class="line"><span class="built_in">print</span>(x1)</span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#定义模型</span></span><br><span class="line"><span class="comment"># nn是神经网络的缩写</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="comment">#第一个指定输入特征形状，即2，第二个指定输出特征形状，输出特征形状为单个标量，因此为1</span></span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化模型参数</span></span><br><span class="line"><span class="comment">#在PyTorch中，有默认的参数初始化方式。</span></span><br><span class="line"><span class="comment">#因此，当我们定义好网络模型之后，可以不对模型进行显式的参数初始化操作</span></span><br><span class="line"><span class="comment">#可以使用替换方法normal_和fill_来重写参数值</span></span><br><span class="line">net[<span class="number">0</span>].weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">net[<span class="number">0</span>].bias.data.fill_(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义损失函数</span></span><br><span class="line"><span class="comment">#计算均方误差使用的是MSELoss类，也称为平方L2范数。默认情况下，它返回所有样本损失的平均值。</span></span><br><span class="line">loss = nn.MSELoss()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义优化函数</span></span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>) <span class="comment">#其实现的就是w-lr*(dw)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#训练</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        l = loss(net(X) ,y) <span class="comment">#通过调用net(X)生成预测并计算损失l（前向传播）</span></span><br><span class="line">        trainer.zero_grad() <span class="comment">#进行新一轮backward之前，一定要清空之前那个batch输入在计算图中留下的梯度</span></span><br><span class="line">        <span class="comment">#否则下面的backward产生的新梯度将会和旧梯度形成梯度累加。</span></span><br><span class="line">        l.backward() <span class="comment">#通过进行反向传播来计算梯度</span></span><br><span class="line">        trainer.step() <span class="comment">#通过调用优化器来更新模型参数</span></span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l:f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">w = net[<span class="number">0</span>].weight.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w的估计误差:&#x27;</span>, true_w - w.reshape(true_w.shape))</span><br><span class="line">b = net[<span class="number">0</span>].bias.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的估计误差:&#x27;</span>, true_b - b)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[tensor([[-0.8065,  0.9427],</span><br><span class="line">        [-0.4614,  0.0982],</span><br><span class="line">        [ 2.1349,  1.9414],</span><br><span class="line">        [ 1.4705,  0.5361],</span><br><span class="line">        [-0.3739, -1.3624],</span><br><span class="line">        [-0.6564,  0.4396],</span><br><span class="line">        [-0.8825, -0.4132],</span><br><span class="line">        [ 0.4002, -1.3953],</span><br><span class="line">        [ 1.0390,  1.4680],</span><br><span class="line">        [-1.7860, -0.5864]]), tensor([[-0.6337],</span><br><span class="line">        [ 2.9607],</span><br><span class="line">        [ 1.8597],</span><br><span class="line">        [ 5.3196],</span><br><span class="line">        [ 8.0967],</span><br><span class="line">        [ 1.3851],</span><br><span class="line">        [ 3.8302],</span><br><span class="line">        [ 9.7453],</span><br><span class="line">        [ 1.2802],</span><br><span class="line">        [ 2.6194]])]</span><br><span class="line">epoch 1, loss 0.000171</span><br><span class="line">epoch 2, loss 0.000107</span><br><span class="line">epoch 3, loss 0.000106</span><br><span class="line">w的估计误差: tensor([-0.0002,  0.0007])</span><br><span class="line">b的估计误差: tensor([5.1498e-05])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>next</code>理解参考：<a href="https://www.w3school.com.cn/python/ref_func_next.asp">Python next() 函数 (w3school.com.cn)</a></li>
</ul>
<hr>
<h1 id="波斯顿房价预测实现"><a href="#波斯顿房价预测实现" class="headerlink" title="波斯顿房价预测实现"></a>波斯顿房价预测实现</h1><h2 id="1-网络搭建与训练"><a href="#1-网络搭建与训练" class="headerlink" title="1.网络搭建与训练"></a>1.网络搭建与训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.数据集处理</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ff = <span class="built_in">open</span>(<span class="string">&quot;housing.data&quot;</span>).readlines()</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ff:</span><br><span class="line">    out = re.sub(<span class="string">r&quot;\s&#123;2,&#125;&quot;</span>, <span class="string">&quot; &quot;</span>, item).strip() <span class="comment">#使得每一行的每个数之间只有一个空格</span></span><br><span class="line">    data.append(out.split(<span class="string">&quot; &quot;</span>)) <span class="comment">#利用空格对数据进行分割</span></span><br><span class="line">data = np.array(data).astype(np.<span class="built_in">float</span>) <span class="comment">#将数据转化为float型</span></span><br><span class="line"><span class="comment">#print(data.shape) #将有506*14的数据矩阵，其中506表示有506条数据，14中前13个是input特征，第14个是label标签</span></span><br><span class="line"></span><br><span class="line">X = data[:, <span class="number">0</span>: -<span class="number">1</span>] <span class="comment">#input</span></span><br><span class="line">Y = data[:, -<span class="number">1</span>] <span class="comment">#label</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据集的划分</span></span><br><span class="line">X_train = X[<span class="number">0</span>: <span class="number">496</span>, :]</span><br><span class="line">Y_train = Y[<span class="number">0</span>: <span class="number">496</span>]</span><br><span class="line">X_test = X[<span class="number">496</span>: , :]</span><br><span class="line">Y_test = Y[<span class="number">496</span>: <span class="number">506</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搭建网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_feature, n_output</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.hidden = torch.nn.Linear(n_feature, <span class="number">100</span>)</span><br><span class="line">        self.predict = torch.nn.Linear(<span class="number">100</span>, n_output)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out_hidden = self.hidden(x)</span><br><span class="line">        out_relu = torch.relu(out_hidden)</span><br><span class="line">        out = self.predict(out_relu)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">net = Net(<span class="number">13</span>, <span class="number">1</span>) <span class="comment">#初始化网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.定义损失函数</span></span><br><span class="line">loss_func = torch.nn.MSELoss() <span class="comment">#采用均方loss</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.定义优化器</span></span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr = <span class="number">1e-5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.训练模型</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):<span class="comment">#训练一万次</span></span><br><span class="line">    <span class="comment">#训练集</span></span><br><span class="line">    x_data = torch.tensor(X_train, dtype = torch.float32)</span><br><span class="line">    y_data = torch.tensor(Y_train, dtype = torch.float32)</span><br><span class="line">    pred = net.forward(x_data)</span><br><span class="line">    pred = pred.reshape(-<span class="number">1</span>)</span><br><span class="line">    loss_train = loss_func(pred, y_data)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad() <span class="comment">#将数据网络中参数的梯度清零</span></span><br><span class="line">    loss_train.backward() <span class="comment">#利用backward进行反向传播</span></span><br><span class="line">    optimizer.step() <span class="comment">#对网络中的参数进行梯度更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(&quot;ite: &#123;&#125;, loss:&#123;&#125;&quot;.format(i, loss)) #打印训练次数与loss的结果</span></span><br><span class="line">    <span class="comment"># print(pred[0: 10]) #预测数据的前10个值</span></span><br><span class="line">    <span class="comment"># print(y_data[0: 10]) #与真实数据的前10个值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#测试集</span></span><br><span class="line">    x_data = torch.tensor(X_test, dtype = torch.float32)</span><br><span class="line">    y_data = torch.tensor(Y_test, dtype = torch.float32)</span><br><span class="line">    pred = net.forward(x_data)</span><br><span class="line">    pred = pred.reshape(-<span class="number">1</span>)</span><br><span class="line">    loss_test = loss_func(pred, y_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ite: &#123;&#125;, loss:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, loss_train, loss_test))</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.保存模型</span></span><br><span class="line">torch.save(net, <span class="string">&quot;Boston_model.pkl&quot;</span>) <span class="comment">#并使用torch.load(&quot;&quot;)加载</span></span><br><span class="line"><span class="comment">#若使用torch.save(net.state_dict(), &quot;params.pkl&quot;)只保存模型参数</span></span><br><span class="line"><span class="comment">#那么使用时先加载网络net，再使用net.load_state_dict(&quot;&quot;)加载模型参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7.测试模型（在另一个文件夹中展示）</span></span><br></pre></td></tr></table></figure>
<h2 id="2-模型测试与评估"><a href="#2-模型测试与评估" class="headerlink" title="2.模型测试与评估"></a>2.模型测试与评估</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.数据集处理</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ff = <span class="built_in">open</span>(<span class="string">&quot;housing.data&quot;</span>).readlines()</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ff:</span><br><span class="line">    out = re.sub(<span class="string">r&quot;\s&#123;2,&#125;&quot;</span>, <span class="string">&quot; &quot;</span>, item).strip() <span class="comment">#使得每一行的每个数之间只有一个空格</span></span><br><span class="line">    data.append(out.split(<span class="string">&quot; &quot;</span>)) <span class="comment">#利用空格对数据进行分割</span></span><br><span class="line">data = np.array(data).astype(np.<span class="built_in">float</span>) <span class="comment">#将数据转化为float型</span></span><br><span class="line"><span class="comment">#print(data.shape) #将有506*14的数据矩阵，其中506表示有506条数据，14中前13个是input特征，第14个是label标签</span></span><br><span class="line"></span><br><span class="line">X = data[:, <span class="number">0</span>: -<span class="number">1</span>] <span class="comment">#input</span></span><br><span class="line">Y = data[:, -<span class="number">1</span>] <span class="comment">#label</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据集的划分</span></span><br><span class="line">X_var = X[<span class="number">135</span>: <span class="number">178</span>, :]</span><br><span class="line">Y_var = Y[<span class="number">135</span>: <span class="number">178</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.加载模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_feature, n_output</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.hidden = torch.nn.Linear(n_feature, <span class="number">100</span>)</span><br><span class="line">        self.predict = torch.nn.Linear(<span class="number">100</span>, n_output)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out_hidden = self.hidden(x)</span><br><span class="line">        out_relu = torch.relu(out_hidden)</span><br><span class="line">        out = self.predict(out_relu)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">net = torch.load(<span class="string">&quot;Boston_model.pkl&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.测试与验证模型</span></span><br><span class="line">x_data = torch.tensor(X_var, dtype = torch.float32)</span><br><span class="line">y_data = torch.tensor(Y_var, dtype = torch.float32)</span><br><span class="line">pred = net.forward(x_data)</span><br><span class="line">pred = pred.reshape(-<span class="number">1</span>)</span><br><span class="line">loss_func = torch.nn.MSELoss()</span><br><span class="line">loss_test = loss_func(pred, y_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;loss test: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(loss_test)) <span class="comment">#打印验证损失</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="softmax回归"><a href="#softmax回归" class="headerlink" title="softmax回归"></a>softmax回归</h1><h2 id="1-softmax函数"><a href="#1-softmax函数" class="headerlink" title="1.softmax函数"></a>1.softmax函数</h2><ul>
<li><p>softmax函数能够将未规范化的预测变换为非负数并且总和为1，同时让模型保持 可导的性质</p>
<script type="math/tex; mode=display">
Softmax(z_i)=\frac{e^{z_i}}{\sum_{c=1}^Ce^{z_c}}</script></li>
<li><p>其中$z_i$为第$i$个节点的输出值，C为输出节点的个数，即分类的类别个数</p>
</li>
</ul>
<h2 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2.损失函数"></a>2.损失函数</h2><ul>
<li><p>对于任何标签$y$和模型预测$\hat{y}$（回归模型经过softmax函数后的预测概率值），损失函数为：</p>
<script type="math/tex; mode=display">
l(y,\hat y)=-\sum_{j=1}^qy_jlog\hat y_j</script></li>
<li><p>该损失函数通常被称为交叉熵损失</p>
</li>
<li><p><strong>由于$y$是一个长度为$q$的独热编码向量，所以除一个项以外的所有项$j$都消失了</strong></p>
</li>
<li><p>由于所有$\hat{y}$都是预测的概率，所以它们的对数永远不会大于0</p>
</li>
</ul>
<h2 id="3-图像分类数据集Fashion-mnist"><a href="#3-图像分类数据集Fashion-mnist" class="headerlink" title="3.图像分类数据集Fashion-mnist"></a>3.图像分类数据集Fashion-mnist</h2><ul>
<li><p>Fashion-MNIST由10个类别的图像组成， 每个类别由<em>训练数据集</em>（train dataset）中的6000张图像和<em>测试数据集</em>（test dataset）中的1000张图像组成</p>
</li>
<li><p>因此，训练集和测试集分别包含60000和10000张图像</p>
</li>
<li><p>测试数据集不会用于训练，只用于评估模型性能</p>
</li>
<li><p>每个输入图像的高度和宽度均为28像素。 数据集由灰度图像组成，其通道数为1</p>
</li>
<li><p>将高度$h$像素、宽度$w$像素图像的形状记为$h\times w$或$(h,w)$</p>
</li>
<li><p><strong>transforms.ToTensor() 的作用是将 PIL 图像或 NumPy 数组转换为一个张量（Tensor）格式，并将其归一化为值在 [0,1] 之间的浮点数</strong></p>
</li>
<li><p><strong><code>torchvision.datasets.FashionMNIST</code> 函数返回的是一个 <code>Dataset</code> 对象，而不是一个 <code>Tensor</code> 对象。因此，不能通过调用 <code>shape</code> 属性来获取数据集的大小和形状</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个计时器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;记录多次运行时间&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.times = []</span><br><span class="line">        self.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;启动计时器&quot;&quot;&quot;</span></span><br><span class="line">        self.tik = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;停止计时器并将时间记录在列表中&quot;&quot;&quot;</span></span><br><span class="line">        self.times.append(time.time() - self.tik)</span><br><span class="line">        <span class="keyword">return</span> self.times[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">avg</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回平均时间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.times) / <span class="built_in">len</span>(self.times)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回时间总和&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.times)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cumsum</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回累计时间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> np.array(self.times).cumsum().tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取数据集</span></span><br><span class="line">trans = transforms.ToTensor() <span class="comment">#通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式</span></span><br><span class="line">mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;D:\App_Data_File\VScode_Project\Python\Pytorch\dataset\Fashion-MNIST&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;D:\App_Data_File\VScode_Project\Python\Pytorch\dataset\Fashion-MNIST&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取mnist_train中的第一个样本，即 mnist_train[0]。</span></span><br><span class="line"><span class="comment">#这个样本包含一个图像数据和一个标签</span></span><br><span class="line"><span class="comment">#使用一个元组来将它们分别赋值给image和label变量</span></span><br><span class="line"><span class="comment">#最后，输出image的形状，以查看它的维度信息</span></span><br><span class="line">sample = mnist_train[<span class="number">0</span>] <span class="comment"># 获取第一个样本</span></span><br><span class="line">image, label = sample</span><br><span class="line"><span class="built_in">print</span>(image.shape) <span class="comment"># 输出训练集第一个图像数据的形状</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Fashion-MNIST中包含的10个类别</span></span><br><span class="line"><span class="comment">#分别为t-shirt（T恤）、trouser（裤子）、pullover（套衫）、dress（连衣裙）、coat（外套）</span></span><br><span class="line"><span class="comment">#sandal（凉鞋）、shirt（衬衫）、sneaker（运动鞋）、bag（包）和ankle boot（短靴）</span></span><br><span class="line"><span class="comment">#以下函数用于在数字标签索引及其文本名称之间进行转换。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_fashion_mnist_labels</span>(<span class="params">labels</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回Fashion-MNIST数据集的文本标签&quot;&quot;&quot;</span></span><br><span class="line">    text_labels = [<span class="string">&#x27;t-shirt&#x27;</span>, <span class="string">&#x27;trouser&#x27;</span>, <span class="string">&#x27;pullover&#x27;</span>, <span class="string">&#x27;dress&#x27;</span>, <span class="string">&#x27;coat&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;sandal&#x27;</span>, <span class="string">&#x27;shirt&#x27;</span>, <span class="string">&#x27;sneaker&#x27;</span>, <span class="string">&#x27;bag&#x27;</span>, <span class="string">&#x27;ankle boot&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> text_labels[labels]</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出数据集中前20个训练集的图像</span></span><br><span class="line"><span class="comment"># fig, axs = plt.subplots(4, 5, figsize=(10, 8))</span></span><br><span class="line"><span class="comment"># for i in range(20):</span></span><br><span class="line"><span class="comment">#     image, label = mnist_train[i]</span></span><br><span class="line"><span class="comment">#     row, col = divmod(i, 5)</span></span><br><span class="line"><span class="comment">#     axs[row, col].imshow(image.squeeze(), cmap=&#x27;CMRmap&#x27;)</span></span><br><span class="line"><span class="comment">#     axs[row, col].set_title(f&#x27;Label: &#123;get_fashion_mnist_labels(label)&#125;&#x27;)</span></span><br><span class="line"><span class="comment">#     axs[row, col].axis(&#x27;off&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##读取小批量数据集</span></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter = data.DataLoader(mnist_train, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看读取数据集所需要的时间</span></span><br><span class="line">timer = Timer()</span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;timer.stop():<span class="number">.2</span>f&#125;</span> sec&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.Size([1, 28, 28])</span><br><span class="line">2.00 sec</span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/28/Pytorch%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230412194037759.png" alt="image-20230412194037759" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="softmax回归的简洁实现"><a href="#softmax回归的简洁实现" class="headerlink" title="softmax回归的简洁实现"></a>softmax回归的简洁实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取数据集</span></span><br><span class="line">trans = transforms.ToTensor() <span class="comment">#通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式</span></span><br><span class="line">mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;D:\App_Data_File\VScode_Project\Python\Pytorch\dataset\Fashion-MNIST&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">False</span>)</span><br><span class="line">mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;D:\App_Data_File\VScode_Project\Python\Pytorch\dataset\Fashion-MNIST&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter = data.DataLoader(mnist_train, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_iter = data.DataLoader(mnist_test, batch_size, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PyTorch不会隐式地调整输入的形状。因此，</span></span><br><span class="line"><span class="comment"># 我们在线性层前定义了展平层（flatten），来调整网络输入的形状</span></span><br><span class="line">net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="number">784</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights)</span><br><span class="line"></span><br><span class="line"><span class="comment">#交叉熵损失函数</span></span><br><span class="line"><span class="comment">#reduction=&#x27;none&#x27;意味着每个元素的损失将作为与输入张量相同形状的张量返回</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#优化算法：使用学习率为0.1的小批量随机梯度下降作为优化算法</span></span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练模型</span></span><br><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">train_loss = []</span><br><span class="line">train_acc = []</span><br><span class="line">test_loss = []</span><br><span class="line">test_acc = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    net.train()</span><br><span class="line">    total_loss, total_correct = <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">        y_hat = net(X)</span><br><span class="line">        l = loss(y_hat, y)</span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.mean().backward()</span><br><span class="line">        trainer.step()</span><br><span class="line"></span><br><span class="line">        total_loss += l.<span class="built_in">sum</span>()</span><br><span class="line">        total_correct += (y_hat.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    train_loss.append(total_loss.detach().numpy() / <span class="built_in">len</span>(mnist_train))</span><br><span class="line">    train_acc.append(total_correct / <span class="built_in">len</span>(mnist_train))</span><br><span class="line"></span><br><span class="line">    net.<span class="built_in">eval</span>()</span><br><span class="line">    total_loss, total_correct = <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> test_iter:</span><br><span class="line">        y_hat = net(X)</span><br><span class="line">        l = loss(y_hat, y)</span><br><span class="line"></span><br><span class="line">        total_loss += l.<span class="built_in">sum</span>()</span><br><span class="line">        total_correct += (y_hat.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    test_loss.append(total_loss.detach().numpy() / <span class="built_in">len</span>(mnist_test))</span><br><span class="line">    test_acc.append(total_correct / <span class="built_in">len</span>(mnist_test))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Epoch [<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;num_epochs&#125;</span>], Train Loss: <span class="subst">&#123;train_loss[-<span class="number">1</span>]:<span class="number">.4</span>f&#125;</span>, Train Acc: <span class="subst">&#123;train_acc[-<span class="number">1</span>]*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%, Test Loss: <span class="subst">&#123;test_loss[-<span class="number">1</span>]:<span class="number">.4</span>f&#125;</span>, Test Acc: <span class="subst">&#123;test_acc[-<span class="number">1</span>]*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(train_loss, label=<span class="string">&#x27;Train Loss&#x27;</span>)</span><br><span class="line">plt.plot(test_loss, label=<span class="string">&#x27;Test Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(train_acc, label=<span class="string">&#x27;Train Acc&#x27;</span>)</span><br><span class="line">plt.plot(test_acc, label=<span class="string">&#x27;Test Acc&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">##从测试集中选中10个样本去测试训练好的模型，并可视化测试结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_fashion_mnist_labels</span>(<span class="params">labels</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回Fashion-MNIST数据集的文本标签&quot;&quot;&quot;</span></span><br><span class="line">    text_labels = [<span class="string">&#x27;t-shirt&#x27;</span>, <span class="string">&#x27;trouser&#x27;</span>, <span class="string">&#x27;pullover&#x27;</span>, <span class="string">&#x27;dress&#x27;</span>, <span class="string">&#x27;coat&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;sandal&#x27;</span>, <span class="string">&#x27;shirt&#x27;</span>, <span class="string">&#x27;sneaker&#x27;</span>, <span class="string">&#x27;bag&#x27;</span>, <span class="string">&#x27;ankle boot&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> text_labels[labels]</span><br><span class="line"></span><br><span class="line">test_samples = data.DataLoader(mnist_test, batch_size=<span class="number">10</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_batch = <span class="built_in">next</span>(<span class="built_in">iter</span>(test_samples))</span><br><span class="line">X_test, y_test = test_batch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测并可视化结果</span></span><br><span class="line">net.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    y_pred = net(X_test).argmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fig2=plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">5</span>, i+<span class="number">1</span>)</span><br><span class="line">    plt.imshow(X_test[i, <span class="number">0</span>], cmap=<span class="string">&#x27;CMRmap&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">f&quot;Pred: <span class="subst">&#123;get_fashion_mnist_labels(y_pred[i])&#125;</span>, Actual: <span class="subst">&#123;get_fashion_mnist_labels(y_test[i])&#125;</span>&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">fig2.subplots_adjust(hspace=<span class="number">1</span>, wspace=<span class="number">1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Epoch [1/10], Train Loss: 0.7841, Train Acc: 74.86%, Test Loss: 0.6342, Test Acc: 78.64%</span><br><span class="line">Epoch [2/10], Train Loss: 0.5703, Train Acc: 81.25%, Test Loss: 0.5693, Test Acc: 80.85%</span><br><span class="line">Epoch [3/10], Train Loss: 0.5253, Train Acc: 82.55%, Test Loss: 0.5408, Test Acc: 81.74%</span><br><span class="line">Epoch [4/10], Train Loss: 0.5012, Train Acc: 83.16%, Test Loss: 0.5229, Test Acc: 82.00%</span><br><span class="line">Epoch [5/10], Train Loss: 0.4850, Train Acc: 83.78%, Test Loss: 0.5157, Test Acc: 82.19%</span><br><span class="line">Epoch [6/10], Train Loss: 0.4744, Train Acc: 83.98%, Test Loss: 0.5145, Test Acc: 81.75%</span><br><span class="line">Epoch [7/10], Train Loss: 0.4650, Train Acc: 84.26%, Test Loss: 0.5182, Test Acc: 81.54%</span><br><span class="line">Epoch [8/10], Train Loss: 0.4581, Train Acc: 84.55%, Test Loss: 0.4883, Test Acc: 82.92%</span><br><span class="line">Epoch [9/10], Train Loss: 0.4532, Train Acc: 84.60%, Test Loss: 0.4955, Test Acc: 82.36%</span><br><span class="line">Epoch [10/10], Train Loss: 0.4479, Train Acc: 84.74%, Test Loss: 0.4801, Test Acc: 83.55%</span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/28/Pytorch%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230412220145971.png" alt="image-20230412220145971" style="zoom:50%;"></p>
<p><img src="/2023/03/28/Pytorch%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230412220215897.png" alt="image-20230412220215897" style="zoom: 50%;"></p>
<p><img src="/2023/03/28/Pytorch%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20230412220235794.png" alt="image-20230412220235794"></p>
<hr>
<h1 id="手写数字集的识别"><a href="#手写数字集的识别" class="headerlink" title="手写数字集的识别"></a>手写数字集的识别</h1><h2 id="1-数据集处理与模型训练"><a href="#1-数据集处理与模型训练" class="headerlink" title="1.数据集处理与模型训练"></a>1.数据集处理与模型训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> dataset</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> data_utils</span><br><span class="line"><span class="keyword">from</span> mnist_net <span class="keyword">import</span> CNN</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.数据集处理</span></span><br><span class="line">train_data = dataset.MNIST(root = <span class="string">&quot;mnist&quot;</span>,</span><br><span class="line">                           train = <span class="literal">True</span>, <span class="comment">#加载训练集</span></span><br><span class="line">                           transform = transforms.ToTensor(), <span class="comment">#将数据转化为tensor</span></span><br><span class="line">                           download = <span class="literal">True</span>) </span><br><span class="line">test_data = dataset.MNIST(root = <span class="string">&quot;mnist&quot;</span>,</span><br><span class="line">                          train = <span class="literal">False</span>, <span class="comment">#加载测试集</span></span><br><span class="line">                          transform = transforms.ToTensor(), <span class="comment">#将数据转化为tensor</span></span><br><span class="line">                          download = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#batchsize：利用DataLoader完成数据小批量采样</span></span><br><span class="line">train_loader = data_utils.DataLoader(dataset = train_data,</span><br><span class="line">                                     batch_size = <span class="number">64</span>,</span><br><span class="line">                                     shuffle = <span class="literal">True</span>)</span><br><span class="line">test_loader = data_utils.DataLoader(dataset = test_data,</span><br><span class="line">                                     batch_size = <span class="number">64</span>,</span><br><span class="line">                                     shuffle = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.搭建网络    </span></span><br><span class="line">cnn = CNN()</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.定义损失函数</span></span><br><span class="line">loss_func = torch.nn.CrossEntropyLoss() <span class="comment">#分类问题采用交叉熵损失函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.定义优化率</span></span><br><span class="line">optimizer = torch.optim.Adam(cnn.parameters(), lr = <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.训练模型</span></span><br><span class="line">loss_test = <span class="number">0</span></span><br><span class="line">accuracy_test = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="comment">#训练集</span></span><br><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        outputs = cnn(images)</span><br><span class="line">        loss_train = loss_func(outputs, labels)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss_train.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment"># print(&quot;echo is &#123;&#125;, &#123;&#125;/&#123;&#125;, loss is &#123;&#125;&quot;.format(epoch + 1, i, len(train_data)//64, loss_train.item()))</span></span><br><span class="line">    <span class="comment">#测试集</span></span><br><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_loader):</span><br><span class="line">        outputs = cnn(images)</span><br><span class="line">        <span class="comment">#计算每个batch的损失和</span></span><br><span class="line">        loss_test += loss_func(outputs, labels)</span><br><span class="line">        <span class="comment">#计算每个batch的正确率</span></span><br><span class="line">        _, pred = outputs.<span class="built_in">max</span>(<span class="number">1</span>) <span class="comment">#1表示在第一个维度上，即每张图对应输出10个值的那一行，pred是最大值的索引</span></span><br><span class="line">        accuracy_test += (pred == labels).<span class="built_in">sum</span>().item()</span><br><span class="line">    accuracy_test = accuracy_test / <span class="built_in">len</span>(test_data)</span><br><span class="line">    loss_test = loss_test / (<span class="built_in">len</span>(test_data) // <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch is &#123;&#125;, accuracy_test is &#123;&#125;, loss_train is &#123;&#125;, loss_test is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>,</span><br><span class="line">                                                                                      accuracy_test,</span><br><span class="line">                                                                                      loss_train.item(),</span><br><span class="line">                                                                                      loss_test.item()))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#6.保存模型</span></span><br><span class="line">torch.save(cnn, <span class="string">&quot;mnist_model.pkl&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-网络搭建"><a href="#2-网络搭建" class="headerlink" title="2.网络搭建"></a>2.网络搭建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CNN</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(CNN, self).__init__()</span><br><span class="line">        self.conv = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">1</span>, <span class="number">32</span>, kernel_size = <span class="number">5</span>, padding = <span class="number">2</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">32</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        self.fc = torch.nn.Linear(<span class="number">14</span> * <span class="number">14</span> * <span class="number">32</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = self.conv(x)</span><br><span class="line">        out = out.reshape(out.size()[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">        out = self.fc(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<h2 id="3-模型测试与评估"><a href="#3-模型测试与评估" class="headerlink" title="3.模型测试与评估"></a>3.模型测试与评估</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> dataset</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> data_utils</span><br><span class="line"><span class="keyword">from</span> mnist_net <span class="keyword">import</span> CNN</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.数据集处理</span></span><br><span class="line">test_data = dataset.MNIST(root = <span class="string">&quot;mnist&quot;</span>,</span><br><span class="line">                          train = <span class="literal">False</span>, <span class="comment">#加载测试集</span></span><br><span class="line">                          transform = transforms.ToTensor(), <span class="comment">#将数据转化为tensor</span></span><br><span class="line">                          download = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">test_loader = data_utils.DataLoader(dataset = test_data,</span><br><span class="line">                                     batch_size = <span class="number">64</span>,</span><br><span class="line">                                     shuffle = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.加载模型</span></span><br><span class="line">cnn = torch.load(<span class="string">&quot;mnist_model.pkl&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.测试与验证模型</span></span><br><span class="line">loss_test = <span class="number">0</span></span><br><span class="line">loss_func = torch.nn.CrossEntropyLoss() </span><br><span class="line">accuracy_test = <span class="number">0</span></span><br><span class="line"><span class="comment">#测试集</span></span><br><span class="line"><span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_loader):</span><br><span class="line">    outputs = cnn(images)</span><br><span class="line">    <span class="comment">#计算每个batch的损失和</span></span><br><span class="line">    loss_test += loss_func(outputs, labels)</span><br><span class="line">    <span class="comment">#计算每个batch的正确率</span></span><br><span class="line">    _, pred = outputs.<span class="built_in">max</span>(<span class="number">1</span>) <span class="comment">#1表示在第一个维度上，即每张图对应输出10个值的那一行，pred是最大值的索引</span></span><br><span class="line">    accuracy_test += (pred == labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#可视化分析并显示结果</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(images.shape[<span class="number">0</span>]):</span><br><span class="line">        im_data = images[idx].numpy()</span><br><span class="line">        im_data = im_data.transpose(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">        im_label = labels[idx].numpy()</span><br><span class="line">        im_pred = pred[idx].numpy()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;label&quot;</span>, im_label)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;pred&quot;</span>, im_pred)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;imdata&quot;</span>, im_data)</span><br><span class="line">        cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">accuracy_test = accuracy_test / <span class="built_in">len</span>(test_data)</span><br><span class="line">loss_test = loss_test / (<span class="built_in">len</span>(test_data) // <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loss test: &#123;&#125;, Accuracy test: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(loss_test, accuracy_test))</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h1><ul>
<li>torch.nn.CrossEntropyLoss()实际上是LogSoftmax与NLLLoss函数的叠加</li>
<li><strong>则在使用torch.nn.CrossEntropyLoss()时，不需要在网络输出中经过softmax层</strong></li>
<li>torch.nn.CrossEntropyLoss()的输入可以是独热编码，也可以是直接是标签分类值</li>
<li><a href="https://www.cnblogs.com/douzi2/p/17002610.html">pytorch 多分类中的损失函数 - 宋桓公 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/580367698">torch.nn.CrossEntropyLoss() 参数、计算过程以及及输入Tensor形状 - 知乎 (zhihu.com)</a></li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zh.d2l.ai/chapter_linear-networks/index.html">3. 线性神经网络 — 动手学深度学习 2.0.0 documentation (d2l.ai)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>信号处理中的小知识点</title>
    <url>/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>本文将分享一些信号处理中常见却难懂的小知识点，并推荐一些好的小文章</p>
<span id="more"></span>
<h1 id="FS、FT、DTFT、DFS、DFT"><a href="#FS、FT、DTFT、DFS、DFT" class="headerlink" title="FS、FT、DTFT、DFS、DFT"></a>FS、FT、DTFT、DFS、DFT</h1><ul>
<li>$连续\Longleftrightarrow非周期$</li>
<li>$离散\Longleftrightarrow周期$</li>
<li><strong>时域的离散造成频域的延拓（周期性），因而频域的离散也会造成时域的延拓（周期性）</strong></li>
</ul>
<h2 id="1-FS"><a href="#1-FS" class="headerlink" title="1.FS"></a>1.FS</h2><ul>
<li><p><strong>时域连续周期、频域离散非周期</strong></p>
</li>
<li><p>傅里叶级数的指数形式：</p>
<script type="math/tex; mode=display">
f(t)=\sum_{n=\infty}^\infty C_ne^{jnw_1t}</script><script type="math/tex; mode=display">
C_n=\frac{1}{T}\int_0^Tf(t)e^{-jnw_1t}dt</script></li>
</ul>
<h2 id="2-FT"><a href="#2-FT" class="headerlink" title="2.FT"></a>2.FT</h2><ul>
<li><p><strong>傅里叶变换的本质，即将一个信号拆分成不同频率的cos和sin分量的叠加。得到的是这些不同频率分量的幅值</strong></p>
</li>
<li><p><strong>时域连续非周期，频域连续非周期</strong></p>
</li>
<li><p>傅里叶变换的公式：</p>
<script type="math/tex; mode=display">
x(w)=\int_{-\infty}^{+\infty}x(t)e^{-jwt}dt</script><script type="math/tex; mode=display">
逆变换:x(t)=\frac1{2\pi}\int_{-\infty}^{+\infty}x(w)e^{jwt}dw</script></li>
</ul>
<h2 id="3-DTFT"><a href="#3-DTFT" class="headerlink" title="3.DTFT"></a>3.DTFT</h2><ul>
<li><p>一个<strong>N点离散时间序列的傅里叶变换（DTFT）的频谱是以（$2\pi$）为周期进行延拓的连续函数</strong></p>
</li>
<li><p><strong>时域离散非周期，频域连续周期</strong></p>
</li>
<li><p>离散时间傅里叶变换的公式：</p>
<script type="math/tex; mode=display">
x(e^{jw})=\sum_{n=-\infty}^{+\infty}x(n)e^{-jwn}</script><script type="math/tex; mode=display">
逆变换:x(n)=\frac1{2\pi}\int_{2\pi}x(e^{jw})e^{jwn}dw</script></li>
</ul>
<h2 id="4-DFS"><a href="#4-DFS" class="headerlink" title="4.DFS"></a>4.DFS</h2><ul>
<li><p><strong>当离散的信号为周期序列时，严格的讲，离散时间傅里叶变换是不存在的，因为它不满足信号序列绝对级数和收敛（绝对可和）这一傅里叶变换的充要条件</strong>，但是采用DFS这一分析工具仍然可以对其进行傅里叶分析</p>
</li>
<li><p><strong>时域离散周期，频域离散周期</strong></p>
</li>
<li><p>离散傅里叶级数的公式：</p>
<script type="math/tex; mode=display">
x(n)=\sum_{k=0}^{N-1}x(k)e^{j\frac{2\pi}{N}kn}</script><script type="math/tex; mode=display">
x(k)=\frac1N\sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}Nkn}\quad k=0\sim N-1</script></li>
</ul>
<h2 id="5-DFT"><a href="#5-DFT" class="headerlink" title="5.DFT"></a>5.DFT</h2><ul>
<li><strong>DFT只是对一周期内的有限个离散频率的表示，所以它在频率上是离散的，就相当于DTFT变换成连续频谱后再对其采样</strong></li>
<li><strong>DFT只是为了计算机处理方便，在频率域对DTFT进行的采样并截取主值而已</strong></li>
<li><p><strong>一个N点离散时间信号可以用频域内一个N点序列来唯一确定，这就是DFT表达式所揭示的内容</strong></p>
</li>
<li><p><strong>DFT的本质是将离散的时域序列用有限个余弦波和正弦波合成。比如一个32点的时域序列，可以用17个余弦波和17个正弦波合成。17个余弦波的幅值就是频谱的实部，17个正弦波的幅值就是频谱的虚部</strong></p>
</li>
<li><p>离散傅里叶变换的公式：</p>
<script type="math/tex; mode=display">
x(k)=\sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi k}Nn} \quad k=0\sim N-1</script><script type="math/tex; mode=display">
逆变换:x(n)=\frac1N\sum_{k=0}^{N-1}x(k)e^{j\frac{2\pi k}Nn}</script></li>
</ul>
<h2 id="6-不同变换之间的示意图"><a href="#6-不同变换之间的示意图" class="headerlink" title="6.不同变换之间的示意图"></a>6.不同变换之间的示意图</h2><p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230304010731421.png" alt="image-20230304010731421" style="zoom: 50%;"></p>
<h2 id="7-Reference"><a href="#7-Reference" class="headerlink" title="7.Reference"></a>7.Reference</h2><ul>
<li><a href="https://www.cnblogs.com/guojun-junguo/p/10099489.html">FS，FT，DFS，DTFT，DFT，FFT的联系和区别 - 骏骏 - 博客园 (cnblogs.com)</a></li>
<li><p><a href="https://www.cnblogs.com/BitArt/archive/2012/11/24/2786390.html">一幅图弄清DFT与DTFT,DFS的关系 - BitArt - 博客园 (cnblogs.com)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_44618906/article/details/116379127">(深入理解DSP中的重要概念（FT、DTFT、DFT、DFS、ZT、FFT）_ft与dft的区别_IT说的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/137509394">如何理解DFT？ - 知乎 (zhihu.com)</a></p>
</li>
</ul>
<hr>
<h1 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h1><h2 id="1-频率分辨率"><a href="#1-频率分辨率" class="headerlink" title="1.频率分辨率"></a>1.频率分辨率</h2><ul>
<li><p><strong>波形分辨率</strong>：由原始数据的时间长度决定</p>
<script type="math/tex; mode=display">
\Delta R_w=\frac1T</script></li>
<li><p><strong>FFT分辨率</strong>：由采样频率和参与FFT的数据点数决定</p>
<script type="math/tex; mode=display">
\Delta R_{fft}=\frac{F_s}{N_{fft}}</script></li>
</ul>
<h2 id="2-FFT中的补零操作"><a href="#2-FFT中的补零操作" class="headerlink" title="2.FFT中的补零操作"></a>2.FFT中的补零操作</h2><ul>
<li><p>补零相当于提高了FFT分辨率，但并不能提高波形分辨率，若不补零，那么波形分辨率与FFT分辨率是相等的</p>
</li>
<li><p><strong>进行zero padding只是增加了数据的长度，而不是原信号的长度。并不能增加频谱分辨率，只相当于频域插值</strong>，具体解释如下：</p>
<p>本来信号是一个周期的余弦信号，如果补了9个周期长度的0，那么信号并不是10个周期的余弦信号，而是一个周期的余弦加一串0，补的0并没有带来新的信息。zero padding等价于频域的sinc函数内插，<strong>而这个sinc函数的形状（主瓣宽度）是由补0前的信号长度决定的</strong>，<strong>补0的作用只是细化了这个sinc函数，并没有改变其主瓣宽度</strong>。而频率分辨率的含义是两个频率不同的信号在频率上可分，也就要求它们不能落到一个sinc函数的主瓣上。所以，如果待分析的两个信号频率接近，而时域长度又较短，那么在频域上它们就落在一个sinc主瓣内了，补再多的0也是无济于事的。</p>
</li>
<li><p>补零前：</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230304205220920.png" alt="image-20230304205220920" style="zoom:50%;"></p>
</li>
<li><p>补零后：</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230304205201292.png" alt="image-20230304205201292" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="3-加窗与窗函数"><a href="#3-加窗与窗函数" class="headerlink" title="3.加窗与窗函数"></a>3.加窗与窗函数</h2><ul>
<li><p>信号截断分为周期截断和非周期截断。<strong>周期截断</strong>是指截断后的信号为周期信号，而<strong>非周期截断</strong>是指截断后的信号不再是周期信号，哪怕原始信号本身是周期信号，周期信号最明显的特征是信号的起始和结束时刻的幅值相等，哪怕是一个周期</p>
<ul>
<li><p>周期截断：</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230304211946376.png" alt="image-20230304211946376" style="zoom:50%;"></p>
</li>
<li><p>非周期截断：</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230304212112985.png" alt="image-20230304212112985" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>由于信号的非周期截断，导致频谱在整个频带内发生了拖尾现象。这是非常严重的误差，称为<strong>泄漏</strong></p>
</li>
<li><p><strong>窗函数只能减少泄漏，不能消除泄漏</strong></p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230304212232648.png" alt="image-20230304212232648" style="zoom: 50%;"></p>
</li>
<li><p><strong>窗函数的时域特征</strong>：加窗实质是用一个所谓的窗函数与原始的时域信号作乘积的过程（当然加窗也可以在频域进行，但时域更为普遍），使得相乘后的信号似乎更好地满足傅立叶变换的周期性要求。为了减少泄漏，用一个窗函数与原始周期信号相乘，得到加窗后的信号为周期信号，从而满足FFT变换的周期性要求</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230305000537489.png" alt="image-20230305000537489" style="zoom:50%;"></p>
</li>
<li><p><strong>窗函数的典型频谱特征</strong>：</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230305000725975.png" alt="image-20230305000725975" style="zoom:50%;"></p>
<ul>
<li><strong>主瓣宽度主要影响信号能量分布和频率分辨能力</strong>。频率的实际分辨能力为有效噪声带宽乘以频率分辨率，因此，主瓣越宽，有效噪声带宽越宽，在频率分辨率相同的情况下，频率的分辨能力越差</li>
<li><strong>旁瓣高低及其衰减率影响能量泄漏程度（频谱拖尾效应）</strong>。旁瓣越高，说明能量泄漏越严重，衰减越慢，频谱拖尾越严重</li>
</ul>
</li>
<li><p><strong>加窗函数的原则</strong>：</p>
<ul>
<li>加窗函数时，应使窗函数频谱的<strong>主瓣宽度应尽量窄</strong>，以获得高的频率分辨能力；<strong>旁瓣衰减应尽量大，以减少频谱拖尾</strong>，但通常都不能同时满足这两个要求</li>
<li><strong>如果截断的信号仍为周期信号，则不存在泄漏，无须加窗，相当于加矩形窗</strong>。</li>
<li>如果信号是随机信号或者未知信号，或者有多个频率分量，测试关注的是频率点而非能量大小，建议选择汉宁窗</li>
<li>对于校准目的，则要求幅值精确，平顶窗是个不错的选择。</li>
<li>如果同时要求幅值精度和频率精度，可选择凯塞窗。</li>
<li>如果检测两个频率相近、幅值不同的信号，建议用布莱克曼窗。</li>
<li>锤击法试验力信号加力窗，响应可加指数窗。</li>
</ul>
</li>
</ul>
<h2 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4.Reference"></a>4.Reference</h2><ul>
<li><p><a href="https://blog.csdn.net/s09094031/article/details/105744720"> 一文读懂FFT，补零对FFT的影响_fft补零的作用_Li Kang的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/85863024">快速傅里叶变换(FFT)中为什么要“补零”？ - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/24318554">什么是窗函数? - 知乎 (zhihu.com)</a></p>
</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI5NTM0MTQwNA==&amp;mid=2247484164&amp;idx=1&amp;sn=fdaf2164306a9ca4166c2aa8713cacc5&amp;scene=21#wechat_redirect">什么是泄漏？ (qq.com)</a></li>
</ul>
<hr>
<h1 id="2D-FFT"><a href="#2D-FFT" class="headerlink" title="2D-FFT"></a>2D-FFT</h1><ul>
<li><p><strong>二维傅里叶变换的意义在于：一个满足一定条件的二维信号可以表示为无数个x向正余弦函数与y向正余弦函数乘积（即二维正交基）的线性组合</strong></p>
</li>
<li><p>二维正交基：</p>
<script type="math/tex; mode=display">
cos(2\pi ux)cos(2\pi vy)\\
cos(2\pi ux)sin(2\pi vy)\\
sin(2\pi ux)cos(2\pi vy)\\
sin(2\pi ux)sin(2\pi vy)</script></li>
<li><p><strong>二维傅里叶变换具可分离性，即它可分离成两次一维傅里叶变换</strong></p>
</li>
</ul>
<h2 id="1-计算流程"><a href="#1-计算流程" class="headerlink" title="1.计算流程"></a>1.计算流程</h2><ul>
<li><p><strong>range-FFT</strong>：雷达处理接收天线接收回来的数据，对每一个接收回来的chirp做range-fft，然后range-fft处理后的数据按行存储到L3或DDR中，由于range-fft对应的频率与距离成正比，因此可以将x轴绘制为距离轴</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230306003411595.png" alt="image-20230306003411595"></p>
</li>
<li><p><strong>doppler-FFT</strong>：在执行完range-fft之后，要在chirp index方向上做doppler-fft，做doppler-fft的时候，要将数据从L3或DDR内存中取出，然后再执行doppler-fft，由于dopper-fft对应离散角频率与速度成正比，因此可以将y轴绘制为速度轴。</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230306003525318.png" alt="image-20230306003525318"></p>
</li>
<li><p>通俗理解：range-FFT就是很正常的FFT求频率，而doppler-FFT可以理解为在频率确定的情况下，将相位（range-FFT结果中复数的角度）当成是变量，对其求FFT则可得到所求频率，这里的频率实际上就是想得到的相位角</p>
</li>
<li><p><strong>对于雷达信号处理而言：速度维上所求的频率即为多普勒频率$f_d$</strong>，多普勒频率是由于速度$v$而导致的固定频率</p>
<script type="math/tex; mode=display">
\because \Delta\Phi=\frac{4\pi vT_c}{\lambda}</script><p>而$\Delta\Phi$其实又可以理解为：$\Delta\Phi$是由$f_d$造成的，因为多了$f_d$，导致在一个chirp周期$T_c$内，波形会多走$2\pi f_d T_c$弧度，即：</p>
<script type="math/tex; mode=display">
\Delta\Phi=2\pi f_dT_c</script><p>综合上述两式可以得到：</p>
<script type="math/tex; mode=display">
v=\frac{\lambda f_d}{2}</script><p><strong>而由速度维FFT计算得到的频率正是$f_d$，故知道$f_d$后则乘以系数$\frac{\lambda}{2}$即可得到对应速度，速度维FFT结果的频率间隔为：$\frac{1}{T_cN_{chirp}}$</strong></p>
</li>
<li><p><strong>只有一个frame中的全部chirp做了range-fft之后才可以执行doppler-fft，因此系统中必须有足够的存储器来存储执行range-fft之后的数据</strong></p>
</li>
</ul>
<h2 id="2-快时间与慢时间"><a href="#2-快时间与慢时间" class="headerlink" title="2.快时间与慢时间"></a>2.快时间与慢时间</h2><p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%BF%AB%E6%97%B6%E9%97%B4%E4%B8%8E%E6%85%A2%E6%97%B6%E9%97%B4.png" alt="快时间与慢时间" style="zoom:50%;"></p>
<h2 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3.Reference"></a>3.Reference</h2><ul>
<li><a href="https://blog.csdn.net/Xiao_Jie123/article/details/113071519"> Xiaojie雷达之路—-毫米波雷达基础知识—-一些系统设计的话题_doppler fft_XXXXiaojie的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/580489895">雷达信号处理之3D-FFT原理（附带MATLAB仿真程序） - 知乎 (zhihu.com)</a></li>
</ul>
<hr>
<h1 id="数字域频率"><a href="#数字域频率" class="headerlink" title="数字域频率"></a>数字域频率</h1><ul>
<li><p>数字域频率为：</p>
<script type="math/tex; mode=display">
w_0=\Omega_0T_s=\frac{\Omega_0}{f_s}=2\pi\frac{f_0}{f_s}=\frac{2\pi}{N}</script><script type="math/tex; mode=display">
其中:\Omega_0为模拟角频率(rad/s),\quad w_0为数字角频率(rad)\\
T_s为采样间隔(s),\quad f_s为采样频率(Hz),\quad f_0为模拟频率(Hz)\\
N=T_0\times f_s,其中T_0为原始模拟信号的周期</script></li>
<li><p>推导过程：</p>
<ul>
<li>连续时间正弦信号：$x_a(t)=cos(\Omega_0t+\phi)$</li>
<li>令$t=nT$，$T$为采样间隔</li>
<li>则$x_a(t)|_{t=nT}=cos(\Omega nT+\phi)=x_a(nT)$</li>
<li>将$x_a(nT)$简记为$x(n)$</li>
<li>$\Omega_0 T$记为$w_0$</li>
<li>则离散时间正弦序列为：$x(n)=cos(w_0n+\phi)$</li>
</ul>
</li>
<li><p>个人理解：数字域频率为在复频域上每个点转动的平均角度</p>
</li>
</ul>
<hr>
<h1 id="深入理解复数"><a href="#深入理解复数" class="headerlink" title="深入理解复数"></a>深入理解复数</h1><h2 id="1-复数的基本概念"><a href="#1-复数的基本概念" class="headerlink" title="1.复数的基本概念"></a>1.复数的基本概念</h2><p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230307155947019.png" alt="image-20230307155947019" style="zoom:50%;"></p>
<script type="math/tex; mode=display">
c=a+jb=Me^{j\phi}=M(cos\phi+jsin\phi)</script><ul>
<li><p>将j看做是一个旋转因子：<strong>在复平面上任意数字乘以j，结果都是90度的逆时针旋转。乘以-j，就引起复平面上的90度顺时针旋转。</strong></p>
</li>
<li><p>将这个复平面扩展成一个三维图像：<strong>$e^{j2πf_0t}$的实部和虚部就是正弦和余弦投影</strong></p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230307160204467.png" alt="image-20230307160204467" style="zoom:50%;"></p>
</li>
<li><p>欧拉等式：</p>
<script type="math/tex; mode=display">
cos(2\pi f_0 t)=\frac{e^{j2\pi f_0t}+e^{-j2\pi f_0 t}}{2}=\frac{e^{j2\pi f_0t}}{2}+\frac{e^{-j2\pi f_0t}}{2}</script><script type="math/tex; mode=display">
sin(2\pi f_0 t)=\frac{e^{j2\pi f_0t}-e^{-j2\pi f_0 t}}{2j}=\frac{je^{-j2\pi f_0t}}{2}-\frac{je^{j2\pi f_0t}}{2}</script></li>
</ul>
<h2 id="2-复数的频域特性"><a href="#2-复数的频域特性" class="headerlink" title="2.复数的频域特性"></a>2.复数的频域特性</h2><ul>
<li><p>在复平面与频率轴构成的三维图像中：$cos(2\pi f_0t)$与$sin(2\pi f_0t)$的频域特性</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230307161446375.png" alt="image-20230307161446375" style="zoom: 50%;"></p>
</li>
<li><p>$e^{j2\pi f_0t}=cos{(2\pi f_0t)+jsin(2\pi f_0t)}$的频域特性：</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230307163016808.png" alt="image-20230307163016808" style="zoom:50%;"></p>
</li>
<li><p>可以将正余弦波理解为从两个正交的通道中输入，即水平通道（实数方向）为输入的cos波，垂直通道（虚数方向）为输入的sin波，分别对这两个通道进行傅里叶变换，当对一个水平通道上的数乘以j时，则表示将数值逆时针旋转90°到垂直通道上</p>
</li>
<li><p><strong>一个时域信号乘以复指数$e^{j2πf_0t}$，该信号的频谱将被向上搬移$f_0$Hz，这个过程我们叫做正交混频（quadrature mixing）（也叫做复调制complex mixing）。同样，一个时域信号乘以$e^{-j2πf_0t}$，将把信号频谱向下搬移$f_0$Hz</strong>。</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230307165135281.png" alt="image-20230307165135281" style="zoom:50%;"></p>
</li>
<li><p><strong>实数的信号总是有正的和负的频谱分量，任何一个实数的信号，其同相（cos）频谱的正和负的频率分量总是以零频点为中心对称，同相（sin）分量的正和负的频率分量互为镜像</strong></p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230307164052191.png" alt="image-20230307164052191" style="zoom:50%;"></p>
</li>
<li><p><strong>复数带宽是实数带宽的一半，其只保留正频部分</strong></p>
</li>
</ul>
<h2 id="3-Reference-1"><a href="#3-Reference-1" class="headerlink" title="3.Reference"></a>3.Reference</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/503472041">信号处理专业必读：是复数但并不复杂的正交信号（万字长文） - 知乎 (zhihu.com)</a></li>
</ul>
<hr>
<h1 id="数字信号中的上采样和下采样"><a href="#数字信号中的上采样和下采样" class="headerlink" title="数字信号中的上采样和下采样"></a>数字信号中的上采样和下采样</h1><h2 id="1-插值"><a href="#1-插值" class="headerlink" title="1.插值"></a>1.插值</h2><ul>
<li><p>长度为N的序列，在每两个点之间插入L个0后，其频域（带宽）相当于压缩为原来的$\frac1L$，并产生$\frac{f_s}{L}$（或者说是$\frac{2\pi}{L}$，因为对于DTFT，其$2\pi$位置对应$f_s$的位置）的周期延拓</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230310152736465.png" alt="image-20230310152736465" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-上采样"><a href="#2-上采样" class="headerlink" title="2.上采样"></a>2.上采样</h2><ul>
<li><p>上采样我们又通常称之为过采样或信号插值，<strong>在频域上是对频谱进行了压缩</strong></p>
</li>
<li><p>上采样流程是先通过采样模块（<strong>在原序列x(n)的两个点之间插入L-1个0</strong>），再通过低通滤波器，其中低通滤波器主要功能是抗周期延拓。</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题" style="zoom: 50%;"></p>
</li>
<li><p>上采样的具体过程：</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230310154416666.png" alt="image-20230310154416666" style="zoom:50%;"></p>
</li>
<li><p><strong>上采样后，可以得到长度为LN的信号序列</strong></p>
</li>
<li><p>这里的低通滤波器主要是为了对$x_L(n)$中的0点进行插值</p>
</li>
</ul>
<h2 id="3-下采样"><a href="#3-下采样" class="headerlink" title="3.下采样"></a>3.下采样</h2><ul>
<li><p>下采样我们又通常称之为欠采样或信号抽取，<strong>在频域上是对频谱进行了拓展</strong>，会产生频谱混叠现象</p>
</li>
<li><p>下采样流程是先通过低通滤波器，再通过采样模块（<strong>即在原序列x(n)中每隔M-1个点抽取一个点</strong>），其中低通滤波器主要功能是抗频谱混叠</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%97%A0%E6%A0%87%E9%A2%98-1678435254317-2.png" alt="无标题" style="zoom:50%;"></p>
</li>
<li><p>下采样的具体流程：</p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230310161741157.png" alt="image-20230310161741157" style="zoom: 50%;"></p>
</li>
<li><p><strong>下采样后，可以得到长度为$\frac NM$的信号序列</strong></p>
</li>
<li><p>这里的低通滤波器主要是为了防止$\frac{f_s}{M}&lt;B$时，采样引起信号在频域上的混叠</p>
</li>
</ul>
<h2 id="4-上采样与下采样混合"><a href="#4-上采样与下采样混合" class="headerlink" title="4.上采样与下采样混合"></a>4.上采样与下采样混合</h2><ul>
<li><p><strong>上采样、下采样配合滤波器可将原采样点数$N$变换为原来的$\frac LM$倍</strong></p>
<p><img src="/2023/03/03/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%97%A0%E6%A0%87%E9%A2%98-1678437333685-4.png" alt="无标题"></p>
</li>
</ul>
<h2 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5.Reference"></a>5.Reference</h2><ul>
<li><a href="https://blog.csdn.net/ReCclay/article/details/122364182">数字信号中的上采样和下采样_信号上采样和下采样_ReCclay的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/544436706">通信系统各个基本步骤（编码-插值-上采样-上变频-下变频-低通滤波-下采样-匹配率波-译码） - 知乎 (zhihu.com)</a></li>
</ul>
<hr>
<h1 id="脉冲压缩与去斜处理"><a href="#脉冲压缩与去斜处理" class="headerlink" title="脉冲压缩与去斜处理"></a>脉冲压缩与去斜处理</h1><h2 id="1-脉冲压缩"><a href="#1-脉冲压缩" class="headerlink" title="1.脉冲压缩"></a>1.脉冲压缩</h2><h2 id="2-去斜处理"><a href="#2-去斜处理" class="headerlink" title="2.去斜处理"></a>2.去斜处理</h2><h2 id="3-脉冲压缩与去斜处理的区别"><a href="#3-脉冲压缩与去斜处理的区别" class="headerlink" title="3.脉冲压缩与去斜处理的区别"></a>3.脉冲压缩与去斜处理的区别</h2><h2 id="4-Reference-1"><a href="#4-Reference-1" class="headerlink" title="4.Reference"></a>4.Reference</h2><ul>
<li><a href="https://blog.csdn.net/Shen_KL/article/details/121064315">脉冲压缩与去斜处理的区别__Karen_的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/449869538">雷达信号处理技术——脉冲压缩 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/567656893">雷达入门课系列文章（1）| 基于MATLAB的雷达信号处理实验教程 - 知乎 (zhihu.com)</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之类和动态内存分配</title>
    <url>/2023/02/18/C++%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>C++之类和动态内存分配……</p>
<span id="more"></span>
<h1 id="动态内存与类"><a href="#动态内存与类" class="headerlink" title="动态内存与类"></a>动态内存与类</h1><ul>
<li><p>stringbad.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STRINGBAD_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STRINGBAD_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringBad</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">char</span> *str;</span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> num_strings;<span class="comment">//不能对static变量在类定义中直接赋值，否则会报错，const除外</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> *s);</span><br><span class="line">		<span class="built_in">StringBad</span>();</span><br><span class="line">		~<span class="built_in">StringBad</span>();</span><br><span class="line">		<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> StringBad &amp;st);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stringbad.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stringbad.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> StringBad::num_strings = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> *s)  <span class="comment">// StringBad str(&quot;Hello world&quot;)</span></span><br><span class="line">&#123;</span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">	num_strings++;</span><br><span class="line">	cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;. \&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBad::<span class="built_in">StringBad</span>()</span><br><span class="line">&#123;</span><br><span class="line">	len = <span class="number">4</span>;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">	num_strings++;</span><br><span class="line">	cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;. \&quot;&quot;</span> &lt;&lt; endl;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBad::~<span class="built_in">StringBad</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot; object deleted.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	--num_strings;</span><br><span class="line">	cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot; left.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> []str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> StringBad &amp;st)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; st.str;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>vegnews.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stringbad.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme1</span><span class="params">(StringBad &amp;rsb)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme2</span><span class="params">(StringBad sb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">StringBad <span class="title">headline1</span><span class="params">(<span class="string">&quot;Hello world&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">StringBad <span class="title">headline2</span><span class="params">(<span class="string">&quot;Good morning&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">StringBad <span class="title">sports</span><span class="params">(<span class="string">&quot;I love you, Rick&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sports: &quot;</span> &lt;&lt; sports &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">callme1</span>(headline1);</span><br><span class="line">	<span class="built_in">callme2</span>(headline2);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme1</span><span class="params">(StringBad &amp;rsb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;String passed by reference:&quot;</span>  &lt;&lt; rsb &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme2</span><span class="params">(StringBad sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;String passed by value: &quot;</span> &lt;&lt; sb &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/18/C++%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230225_222952.png" alt="屏幕截图_20230225_222952"></p>
</li>
<li><p>不能对static变量在类定义中直接赋值，否则会报错，static const类型除外。其通常在类的声明cpp文件中赋初始值一次</p>
</li>
<li><code>callme2(headline2)</code>中使用直接赋值的方式相当于将<code>StringBad sb=headline2</code>，而这条语句会触发类的自动类型转换，即会调用符合条件的构造函数，但不存在符合条件的构造函数（符合条件的构造函数为<code>StringBad(const StringBad &amp;)</code>）</li>
<li>而当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数，故实际只存在三个指针，但删除时却需要删除四个指针，故会发生报错</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch之数据操作及其预处理</title>
    <url>/2023/02/11/Pytorch%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%85%B6%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>本节主要介绍了张量的简单操作、CSV数据集的读取以及自动求导机制</p>
<span id="more"></span>
<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="1-张量的创建"><a href="#1-张量的创建" class="headerlink" title="1.张量的创建"></a>1.张量的创建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建张量</span></span><br><span class="line"><span class="comment">#使用arrange创建张量</span></span><br><span class="line">x=torch.arange(<span class="number">24</span>) <span class="comment">#创建0~23的整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x is:&quot;</span>,x)</span><br><span class="line"><span class="comment">#我们还可以通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值</span></span><br><span class="line"><span class="built_in">print</span>(torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]]))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.改变张量形状</span></span><br><span class="line"><span class="comment">#改变一个张量的形状而不改变元素数量和元素值</span></span><br><span class="line">x=x.reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x is:&quot;</span>,x)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.查看张量的形状，数量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The shape of x is:&quot;</span>,x.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The size of x[0] is:&quot;</span>,x.size(axis=<span class="number">0</span>)) <span class="comment">#可以根据axis指定计算哪个维度的元素个数</span></span><br><span class="line"><span class="built_in">print</span>(x.numel()) <span class="comment">#返回张量中总共包含多少个元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.创建特殊张量</span></span><br><span class="line"><span class="comment">#创建全0张量与全1张量</span></span><br><span class="line"><span class="built_in">print</span>(torch.zeros((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(torch.ones((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line"><span class="comment">#创建均值为0、标准差为1的标准高斯分布的张量</span></span><br><span class="line"><span class="built_in">print</span>(torch.randn(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment">#利用randperm返回一个0~n-1的随机打乱数组</span></span><br><span class="line"><span class="built_in">print</span>(torch.randperm(<span class="number">10</span>))</span><br><span class="line"><span class="comment">#创建随机均匀分布的张量,其中torch.Tensor(2,2)用来指定tensor的shape</span></span><br><span class="line"><span class="built_in">print</span>(torch.Tensor(<span class="number">2</span>,<span class="number">2</span>).uniform_(-<span class="number">1</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x is: tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,</span><br><span class="line">        18, 19, 20, 21, 22, 23])</span><br><span class="line">tensor([[2, 1, 4, 3],</span><br><span class="line">        [1, 2, 3, 4],</span><br><span class="line">        [4, 3, 2, 1]])</span><br><span class="line">----------------------------------------</span><br><span class="line">x is: tensor([[[ 0,  1,  2,  3],</span><br><span class="line">         [ 4,  5,  6,  7],</span><br><span class="line">         [ 8,  9, 10, 11]],</span><br><span class="line"></span><br><span class="line">        [[12, 13, 14, 15],</span><br><span class="line">         [16, 17, 18, 19],</span><br><span class="line">         [20, 21, 22, 23]]])</span><br><span class="line">----------------------------------------</span><br><span class="line">The shape of x is: torch.Size([2, 3, 4])</span><br><span class="line">The size of x[0] is: 2</span><br><span class="line">24</span><br><span class="line">----------------------------------------</span><br><span class="line">tensor([[[0., 0., 0., 0.],</span><br><span class="line">         [0., 0., 0., 0.],</span><br><span class="line">         [0., 0., 0., 0.]],</span><br><span class="line"></span><br><span class="line">        [[0., 0., 0., 0.],</span><br><span class="line">         [0., 0., 0., 0.],</span><br><span class="line">         [0., 0., 0., 0.]]])</span><br><span class="line">tensor([[[1., 1., 1., 1.],</span><br><span class="line">         [1., 1., 1., 1.],</span><br><span class="line">         [1., 1., 1., 1.]],</span><br><span class="line"></span><br><span class="line">        [[1., 1., 1., 1.],</span><br><span class="line">         [1., 1., 1., 1.],</span><br><span class="line">         [1., 1., 1., 1.]]])</span><br><span class="line">tensor([[ 1.4646, -0.6201,  0.6223,  1.7981],</span><br><span class="line">        [-2.5379, -1.5198,  0.2865,  1.6249],</span><br><span class="line">        [-0.3724,  0.7659,  2.1007, -1.8540]])</span><br><span class="line">tensor([2, 9, 6, 4, 0, 1, 7, 5, 8, 3])</span><br><span class="line">tensor([[ 0.8090, -0.2894],</span><br><span class="line">        [-0.3646, -0.4624]])</span><br></pre></td></tr></table></figure>
<h2 id="2-张量的属性"><a href="#2-张量的属性" class="headerlink" title="2.张量的属性"></a>2.张量的属性</h2><ul>
<li>Tensor的属性：<ul>
<li>每个Tensor有torch.dtype、torch.device、torch.layout三种属性</li>
<li>torch.device标识了torch.Tensor对象在创建之后所存储在的设备名称</li>
<li>torch.layout表示torch.Tensor内存布局的对象</li>
</ul>
</li>
<li><strong>稀疏张量的定义</strong>：<ul>
<li>torch.sparse_coo_tensor，coo类型表示非零元素的坐标形式</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.tensor的相关属性</span></span><br><span class="line">dev = torch.device(<span class="string">&quot;cpu&quot;</span>) <span class="comment">#这里的cpu区分大小写</span></span><br><span class="line"><span class="comment">#dev = torch.device(&quot;cuda&quot;)</span></span><br><span class="line"></span><br><span class="line">a = torch.tensor([<span class="number">2</span>, <span class="number">2</span>], dtype = torch.float32, device = dev)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.稀疏矩阵的表示与使用</span></span><br><span class="line">i = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]) <span class="comment">#张量的位置</span></span><br><span class="line">v = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">#每个位置对应的值</span></span><br><span class="line">a = torch.sparse_coo_tensor(i, v, (<span class="number">4</span>, <span class="number">4</span>)).to_dense()<span class="comment">#使用to_dense()将其转化为正常的矩阵形式</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([2., 2.])</span><br><span class="line">tensor([[1, 0, 0, 0],</span><br><span class="line">        [0, 2, 0, 0],</span><br><span class="line">        [0, 0, 3, 0],</span><br><span class="line">        [0, 0, 0, 0]])</span><br></pre></td></tr></table></figure>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3.运算符"></a>3.运算符</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x is:&quot;</span>,x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y is:&quot;</span>,y)</span><br><span class="line"><span class="comment">#1.普通运算符操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x+y is:&quot;</span>,x + y) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x-y is:&quot;</span>,x - y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x*y is:&quot;</span>,x * y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x/y is:&quot;</span>,x/y) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x^y is:&quot;</span>,x**y) <span class="comment">#**运算符是求幂运算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e^x is:&quot;</span>,torch.exp(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"></span><br><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">Y = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X is:&quot;</span>,X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Y is:&quot;</span>,Y)</span><br><span class="line"><span class="comment">#2.拼接运算符</span></span><br><span class="line"><span class="built_in">print</span>(torch.cat((X, Y), dim=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.cat((X, Y), dim=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#3.逻辑运算符：在每个对应元素位置上比较</span></span><br><span class="line"><span class="built_in">print</span>(X == Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#4.求和运算符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>,X.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>,X.<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x is: tensor([1., 2., 4., 8.])</span><br><span class="line">y is: tensor([2, 2, 2, 2])</span><br><span class="line">x+y is: tensor([ 3.,  4.,  6., 10.])</span><br><span class="line">x-y is: tensor([-1.,  0.,  2.,  6.])</span><br><span class="line">x*y is: tensor([ 2.,  4.,  8., 16.])</span><br><span class="line">x/y is: tensor([0.5000, 1.0000, 2.0000, 4.0000])</span><br><span class="line">x^y is: tensor([ 1.,  4., 16., 64.])</span><br><span class="line">e^x is: tensor([2.7183e+00, 7.3891e+00, 5.4598e+01, 2.9810e+03])</span><br><span class="line">----------------------------------------</span><br><span class="line">X is: tensor([[ 0.,  1.,  2.,  3.],</span><br><span class="line">        [ 4.,  5.,  6.,  7.],</span><br><span class="line">        [ 8.,  9., 10., 11.]])</span><br><span class="line">Y is: tensor([[2, 1, 4, 3],</span><br><span class="line">        [1, 2, 3, 4],</span><br><span class="line">        [4, 3, 2, 1]])</span><br><span class="line">tensor([[ 0.,  1.,  2.,  3.],</span><br><span class="line">        [ 4.,  5.,  6.,  7.],</span><br><span class="line">        [ 8.,  9., 10., 11.],</span><br><span class="line">        [ 2.,  1.,  4.,  3.],</span><br><span class="line">        [ 1.,  2.,  3.,  4.],</span><br><span class="line">        [ 4.,  3.,  2.,  1.]])</span><br><span class="line">tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],</span><br><span class="line">        [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],</span><br><span class="line">        [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]])</span><br><span class="line">----------------------------------------</span><br><span class="line">tensor([[False,  True, False,  True],</span><br><span class="line">        [False, False, False, False],</span><br><span class="line">        [False, False, False, False]])</span><br><span class="line">----------------------------------------</span><br><span class="line">The sum is: tensor(66.)</span><br><span class="line">The sum is: tensor([ 6., 22., 38.])</span><br></pre></td></tr></table></figure>
<h2 id="4-张量索引"><a href="#4-张量索引" class="headerlink" title="4.张量索引"></a>4.张量索引</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">X=torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],[<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X is:&quot;</span>,X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X[-1] is:&quot;</span>,X[-<span class="number">1</span>]) <span class="comment">#-1代表取最后</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X[1:3] is:&quot;</span>,X[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">X[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X is:&quot;</span>,X)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">X[<span class="number">0</span>:<span class="number">2</span>, :] = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X is:&quot;</span>,X)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X is: tensor([[2, 1, 4, 3],</span><br><span class="line">        [1, 2, 3, 4],</span><br><span class="line">        [4, 3, 2, 1],</span><br><span class="line">        [5, 9, 8, 7]])</span><br><span class="line">X[-1] is: tensor([5, 9, 8, 7])</span><br><span class="line">----------------------------------------</span><br><span class="line">X[1:3] is: tensor([[1, 2, 3, 4],</span><br><span class="line">        [4, 3, 2, 1]])</span><br><span class="line">----------------------------------------</span><br><span class="line">X is: tensor([[2, 1, 4, 3],</span><br><span class="line">        [1, 2, 9, 4],</span><br><span class="line">        [4, 3, 2, 1],</span><br><span class="line">        [5, 9, 8, 7]])</span><br><span class="line">----------------------------------------</span><br><span class="line">X is: tensor([[12, 12, 12, 12],</span><br><span class="line">        [12, 12, 12, 12],</span><br><span class="line">        [ 4,  3,  2,  1],</span><br><span class="line">        [ 5,  9,  8,  7]])</span><br></pre></td></tr></table></figure>
<h2 id="5-张量切片"><a href="#5-张量切片" class="headerlink" title="5.张量切片"></a>5.张量切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.torch.chunk</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;torch.chunk&#x27;</span>)</span><br><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">out = torch.chunk(a, <span class="number">2</span>, dim = <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(out[<span class="number">0</span>], out[<span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(out[<span class="number">1</span>], out[<span class="number">1</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.torch.split</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;torch.split&#x27;</span>)</span><br><span class="line">a = torch.rand(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">out = torch.split(a, <span class="number">2</span>, dim = <span class="number">0</span>) <span class="comment">#split的拆分方式一</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> out:</span><br><span class="line">    <span class="built_in">print</span>(i, i.shape)</span><br><span class="line"></span><br><span class="line">out = torch.split(a, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>], dim = <span class="number">0</span>) <span class="comment">#split的拆分方式二</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> out:</span><br><span class="line">    <span class="built_in">print</span>(i, i.shape)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.chunk</span><br><span class="line">tensor([[0.2251, 0.0545, 0.7452, 0.7359],</span><br><span class="line">        [0.1663, 0.7839, 0.9890, 0.5553],</span><br><span class="line">        [0.4612, 0.9375, 0.9323, 0.0996]])</span><br><span class="line">tensor([[0.2251, 0.0545, 0.7452, 0.7359],</span><br><span class="line">        [0.1663, 0.7839, 0.9890, 0.5553]]) torch.Size([2, 4])</span><br><span class="line">tensor([[0.4612, 0.9375, 0.9323, 0.0996]]) torch.Size([1, 4])</span><br><span class="line">--------------------------------------------------</span><br><span class="line">torch.split</span><br><span class="line">tensor([[0.3003, 0.9461, 0.4454, 0.1446],</span><br><span class="line">        [0.8573, 0.5407, 0.9421, 0.2710],</span><br><span class="line">        [0.4454, 0.8425, 0.0993, 0.9189],</span><br><span class="line">        [0.3519, 0.9107, 0.2126, 0.4638],</span><br><span class="line">        [0.0914, 0.5672, 0.5462, 0.7540],</span><br><span class="line">        [0.8343, 0.8356, 0.4863, 0.5255]])</span><br><span class="line">tensor([[0.3003, 0.9461, 0.4454, 0.1446],</span><br><span class="line">        [0.8573, 0.5407, 0.9421, 0.2710]]) torch.Size([2, 4])</span><br><span class="line">tensor([[0.4454, 0.8425, 0.0993, 0.9189],</span><br><span class="line">        [0.3519, 0.9107, 0.2126, 0.4638]]) torch.Size([2, 4])</span><br><span class="line">tensor([[0.0914, 0.5672, 0.5462, 0.7540],</span><br><span class="line">        [0.8343, 0.8356, 0.4863, 0.5255]]) torch.Size([2, 4])</span><br><span class="line">tensor([[0.3003, 0.9461, 0.4454, 0.1446]]) torch.Size([1, 4])</span><br><span class="line">tensor([[0.8573, 0.5407, 0.9421, 0.2710],</span><br><span class="line">        [0.4454, 0.8425, 0.0993, 0.9189],</span><br><span class="line">        [0.3519, 0.9107, 0.2126, 0.4638]]) torch.Size([3, 4])</span><br><span class="line">tensor([[0.0914, 0.5672, 0.5462, 0.7540],</span><br><span class="line">        [0.8343, 0.8356, 0.4863, 0.5255]]) torch.Size([2, 4])</span><br></pre></td></tr></table></figure>
<h2 id="6-排序运算与最大值求取"><a href="#6-排序运算与最大值求取" class="headerlink" title="6.排序运算与最大值求取"></a>6.排序运算与最大值求取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.张量的排序torch.sort</span></span><br><span class="line">a = torch.tensor([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>],[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(torch.sort(a, dim = <span class="number">1</span>, descending = <span class="literal">True</span>)) <span class="comment">#descending = True代表降序排列，为False代表升序排列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.张量中：沿着指定维度返回最大k个数值及其索引值torch.topk</span></span><br><span class="line">a = torch.tensor([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>],[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(torch.topk(a, k = <span class="number">2</span>, dim = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.张量中：沿着指定维度返回第k个最小值及其索引值torch.kthvalue</span></span><br><span class="line">a = torch.tensor([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>],[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(torch.kthvalue(a, k = <span class="number">2</span>, dim = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.Size([2, 5])</span><br><span class="line">torch.return_types.sort(</span><br><span class="line">values=tensor([[5, 4, 4, 3, 1],</span><br><span class="line">        [5, 3, 3, 2, 1]]),</span><br><span class="line">indices=tensor([[4, 1, 2, 3, 0],</span><br><span class="line">        [4, 1, 3, 0, 2]]))</span><br><span class="line">---------------------------------</span><br><span class="line">torch.Size([2, 5])</span><br><span class="line">torch.return_types.topk(</span><br><span class="line">values=tensor([[2, 4, 4, 3, 5],</span><br><span class="line">        [1, 3, 1, 3, 5]]),</span><br><span class="line">indices=tensor([[1, 0, 0, 0, 0],</span><br><span class="line">        [0, 1, 1, 1, 1]]))</span><br><span class="line">---------------------------------</span><br><span class="line">torch.Size([2, 5])</span><br><span class="line">torch.return_types.kthvalue(</span><br><span class="line">values=tensor([2, 4, 4, 3, 5]),</span><br><span class="line">indices=tensor([1, 0, 0, 1, 1]))</span><br><span class="line">---------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="7-类型转换"><a href="#7-类型转换" class="headerlink" title="7.类型转换"></a>7.类型转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">X=torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],[<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>]])</span><br><span class="line">A = X.numpy() <span class="comment">#将tensor类型转化为numpy类型</span></span><br><span class="line">B = torch.tensor(A) <span class="comment">#将numpy类型转化为tensor类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of A is:&quot;</span>,<span class="built_in">type</span>(A)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of B is:&quot;</span>,<span class="built_in">type</span>(B))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#要将大小为1的张量转换为Python标量，我们可以调用item函数或Python的内置函数</span></span><br><span class="line">a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line"><span class="built_in">print</span>(a, a.item(), <span class="built_in">float</span>(a), <span class="built_in">int</span>(a))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type of A is: &lt;class &#x27;numpy.ndarray&#x27;&gt;</span><br><span class="line">type of B is: &lt;class &#x27;torch.Tensor&#x27;&gt;</span><br><span class="line">----------------------------------------</span><br><span class="line">tensor([3.5000]) 3.5 3.5 3</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="1-设置随机种子"><a href="#1-设置随机种子" class="headerlink" title="1.设置随机种子"></a>1.设置随机种子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置随机种子</span></span><br><span class="line">torch.manual_seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">mean = torch.rand(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">#rand是从区间[0, 1)的均匀分布中抽取的一组随机数</span></span><br><span class="line">std = torch.rand(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.normal(mean, std))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2023/02/11/Pytorch%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%85%B6%E9%A2%84%E5%A4%84%E7%90%86/image-20230803211605227.png" alt="image-20230803211605227"></p>
<h2 id="2-读取数据集"><a href="#2-读取数据集" class="headerlink" title="2.读取数据集"></a>2.读取数据集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#将数据写入一个CSV文件中</span></span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="comment"># 列名</span></span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="comment"># 每行表示一个数据样本</span></span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过pandas库读取数据</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   NumRooms Alley   Price</span><br><span class="line">0       NaN  Pave  127500</span><br><span class="line">1       2.0   NaN  106000</span><br><span class="line">2       4.0   NaN  178100</span><br><span class="line">3       NaN   NaN  140000</span><br></pre></td></tr></table></figure>
<h2 id="3-张量裁剪"><a href="#3-张量裁剪" class="headerlink" title="3.张量裁剪"></a>3.张量裁剪</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.rand(<span class="number">2</span>, <span class="number">2</span>)*<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = a.clamp(<span class="number">2</span>, <span class="number">5</span>) <span class="comment">#将数据限制在2到5之间，小于2的数为2，大于5的数为5</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[5.5637, 0.2108],</span><br><span class="line">        [2.4912, 3.2161]])</span><br><span class="line">tensor([[5.0000, 2.0000],</span><br><span class="line">        [2.4912, 3.2161]])</span><br></pre></td></tr></table></figure>
<h2 id="4-数据筛选"><a href="#4-数据筛选" class="headerlink" title="4.数据筛选"></a>4.数据筛选</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.torch.where(condition, x, y)：按照条件从x和y中选出满足条件的元素组成新的tensor</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;torch.where&#x27;</span>)</span><br><span class="line">a = torch.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">b = torch.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">out = torch.where(a &gt; <span class="number">0.5</span>, a, b) <span class="comment">#若a大于0.5输出a，否则输出b</span></span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.torch.index_select(input, dim, index, out = None)：按照指定索引输出tensor</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;torch.index_select&#x27;</span>)</span><br><span class="line">a = torch.rand(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">out = torch.index_select(a, dim = <span class="number">0</span>, index = torch.tensor([<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.torch.gather(input, dim, index, out = None)：在指定维度上按照索引赋值输出tensor</span></span><br><span class="line"><span class="comment">#dim = 0, out[i, j, k] = input[index[i, j, k], j, k]</span></span><br><span class="line"><span class="comment">#dim = 1, out[i, j, k] = input[i, index[i, j, k], k]</span></span><br><span class="line"><span class="comment">#dim = 2, out[i, j, k] = input[i, j, index[i, j, k]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;torch.gather&#x27;</span>)</span><br><span class="line">a = torch.linspace(<span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>).view(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">out = torch.gather(a, dim = <span class="number">0</span>, index = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                                                     [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], </span><br><span class="line">                                                     [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]]))</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.torch.masked_select(input, mask, out = None)：按照mask输出tensor，输出为向量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;torch.masked_select&#x27;</span>)</span><br><span class="line">a = torch.linspace(<span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>).view(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">mask = torch.gt(a, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(mask)</span><br><span class="line">out = torch.masked_select(a, mask)</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.torch.take(input, indices)：将输入看成1D-tensor，按照索引得到输出tensor</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;torch.take&#x27;</span>)</span><br><span class="line">a = torch.linspace(<span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>).view(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">b = torch.take(a, index = torch.tensor([<span class="number">0</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">10</span>]))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.torch.nonzero(input, out = None)：输出非0元素的坐标</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;torch.nonzero&#x27;</span>)</span><br><span class="line">a = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">out = torch.nonzero(a)</span><br><span class="line"><span class="built_in">print</span>(out)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.where</span><br><span class="line">tensor([[0.8185, 0.1795, 0.9199],</span><br><span class="line">        [0.0798, 0.4916, 0.7768]])</span><br><span class="line">tensor([[0.7131, 0.4783, 0.1815],</span><br><span class="line">        [0.6423, 0.9752, 0.2171]])</span><br><span class="line">tensor([[0.8185, 0.4783, 0.9199],</span><br><span class="line">        [0.6423, 0.9752, 0.7768]])</span><br><span class="line">--------------------------------------------------</span><br><span class="line">torch.index_select</span><br><span class="line">tensor([[0.8434, 0.7979, 0.2893, 0.9534],</span><br><span class="line">        [0.0751, 0.2321, 0.8226, 0.6785],</span><br><span class="line">        [0.9144, 0.2765, 0.5214, 0.9405],</span><br><span class="line">        [0.0807, 0.1131, 0.1234, 0.2099]])</span><br><span class="line">tensor([[0.8434, 0.7979, 0.2893, 0.9534],</span><br><span class="line">        [0.0807, 0.1131, 0.1234, 0.2099],</span><br><span class="line">        [0.9144, 0.2765, 0.5214, 0.9405]])</span><br><span class="line">--------------------------------------------------</span><br><span class="line">torch.gather</span><br><span class="line">tensor([[ 1.,  2.,  3.,  4.],</span><br><span class="line">        [ 5.,  6.,  7.,  8.],</span><br><span class="line">        [ 9., 10., 11., 12.],</span><br><span class="line">        [13., 14., 15., 16.]])</span><br><span class="line">tensor([[ 1.,  6.,  7.,  8.],</span><br><span class="line">        [ 1.,  6., 11., 12.],</span><br><span class="line">        [ 1.,  6., 15., 16.]])</span><br><span class="line">--------------------------------------------------</span><br><span class="line">torch.masked_select</span><br><span class="line">tensor([[ 1.,  2.,  3.,  4.],</span><br><span class="line">        [ 5.,  6.,  7.,  8.],</span><br><span class="line">        [ 9., 10., 11., 12.],</span><br><span class="line">        [13., 14., 15., 16.]])</span><br><span class="line">tensor([[False, False, False, False],</span><br><span class="line">        [False, False, False, False],</span><br><span class="line">        [ True,  True,  True,  True],</span><br><span class="line">        [ True,  True,  True,  True]])</span><br><span class="line">tensor([ 9., 10., 11., 12., 13., 14., 15., 16.])</span><br><span class="line">--------------------------------------------------</span><br><span class="line">torch.take</span><br><span class="line">tensor([ 1., 16., 14., 11.])</span><br><span class="line">--------------------------------------------------</span><br><span class="line">torch.nonzero</span><br><span class="line">tensor([[0, 1],</span><br><span class="line">        [0, 2],</span><br><span class="line">        [1, 0],</span><br><span class="line">        [1, 1],</span><br><span class="line">        [1, 3]])</span><br></pre></td></tr></table></figure>
<h2 id="5-处理缺失值"><a href="#5-处理缺失值" class="headerlink" title="5.处理缺失值"></a>5.处理缺失值</h2><ul>
<li>通过位置索引<code>iloc</code>，将<code>data</code>分成<code>inputs</code>和<code>outputs</code>， 其中前者为<code>data</code>的前两列，而后者为<code>data</code>的最后一列。 对于<code>inputs</code>中缺少的数值，我们用同一列的均值替换“NaN”项。</li>
<li>或通过独热码的形式填充NaN</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#3.处理缺失值</span></span><br><span class="line">inputs, outputs = data.iloc[:,<span class="number">0</span>:<span class="number">2</span>], data.iloc[:,<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The inputs data is:\n&quot;</span>,inputs)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The outputs data is:\n&quot;</span>,outputs)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">inputs = inputs.fillna(inputs.mean(numeric_only=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.利用get_dummies实现独热码</span></span><br><span class="line">inputs = pd.get_dummies(inputs, dummy_na=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------</span><br><span class="line">The inputs data is:</span><br><span class="line">    NumRooms Alley</span><br><span class="line">0       NaN  Pave</span><br><span class="line">1       2.0   NaN</span><br><span class="line">2       4.0   NaN</span><br><span class="line">3       NaN   NaN</span><br><span class="line">--------------------------------------------------</span><br><span class="line">The outputs data is:</span><br><span class="line">     Price</span><br><span class="line">0  127500</span><br><span class="line">1  106000</span><br><span class="line">2  178100</span><br><span class="line">3  140000</span><br><span class="line">--------------------------------------------------</span><br><span class="line">   NumRooms Alley</span><br><span class="line">0       3.0  Pave</span><br><span class="line">1       2.0   NaN</span><br><span class="line">2       4.0   NaN</span><br><span class="line">3       3.0   NaN</span><br><span class="line">--------------------------------------------------</span><br><span class="line">   NumRooms  Alley_Pave  Alley_nan</span><br><span class="line">0       3.0           1          0</span><br><span class="line">1       2.0           0          1</span><br><span class="line">2       4.0           0          1</span><br><span class="line">3       3.0           0          1</span><br></pre></td></tr></table></figure>
<h2 id="6-转化为张量格式"><a href="#6-转化为张量格式" class="headerlink" title="6.转化为张量格式"></a>6.转化为张量格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将输入CSV数据转化为张量形式</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">X, y = torch.tensor(inputs.values), torch.tensor(outputs.values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X is:\n&quot;</span>,X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y is:\n&quot;</span>,y)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X is:</span><br><span class="line"> tensor([[3., 1., 0.],</span><br><span class="line">        [2., 0., 1.],</span><br><span class="line">        [4., 0., 1.],</span><br><span class="line">        [3., 0., 1.]], dtype=torch.float64)</span><br><span class="line">y is:</span><br><span class="line"> tensor([[127500],</span><br><span class="line">        [106000],</span><br><span class="line">        [178100],</span><br><span class="line">        [140000]])</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment">##1.标量</span></span><br><span class="line">x = torch.tensor(<span class="number">12.98</span>)</span><br><span class="line">y = torch.tensor(<span class="number">13.78</span>)</span><br><span class="line"><span class="built_in">print</span>(x,<span class="string">&#x27;,&#x27;</span>,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##2.向量</span></span><br><span class="line">z = torch.arange(<span class="number">24</span>)</span><br><span class="line"><span class="comment">#与普通的Python数组一样，我们可以通过调用Python的内置len()函数来访问张量的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(z))</span><br><span class="line">z = z.reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(z.shape) <span class="comment">#形状（shape）是一个元素组，列出了张量沿每个轴的长度（维数）</span></span><br><span class="line"><span class="built_in">print</span>(z.size()) <span class="comment">#size()与shape的功能一样，只是用法不同</span></span><br><span class="line"><span class="built_in">print</span>(z.shape[<span class="number">0</span>]) </span><br><span class="line"><span class="built_in">print</span>(z.size()[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##3.矩阵</span></span><br><span class="line">A = torch.arange(<span class="number">20</span>).reshape(<span class="number">5</span>, <span class="number">4</span>) </span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment">#求转置</span></span><br><span class="line"><span class="built_in">print</span>(A.T)</span><br><span class="line"><span class="comment">#点积:是相同位置的按元素乘积的和</span></span><br><span class="line">x1 = torch.arange(<span class="number">4</span>, dtype=torch.float32)</span><br><span class="line">x2 = torch.ones(<span class="number">4</span>, dtype=torch.float32)</span><br><span class="line"><span class="built_in">print</span>(torch.dot(x1,x2))</span><br><span class="line"><span class="comment">#矩阵-向量积:当我们为矩阵A和向量x调用torch.mv(A, x)时，会执行矩阵-向量积</span></span><br><span class="line">y1 = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">y2 = torch.arange(<span class="number">4</span>, dtype=torch.float32)</span><br><span class="line"><span class="built_in">print</span>(torch.mv(y1,y2))</span><br><span class="line"><span class="comment">#矩阵乘法</span></span><br><span class="line">z1 = torch.ones((<span class="number">4</span>, <span class="number">3</span>), dtype=torch.float32)</span><br><span class="line"><span class="built_in">print</span>(torch.mm(y1, z1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##4.张量算法的基本性质</span></span><br><span class="line">A = torch.arange(<span class="number">8</span>, dtype=torch.float32).reshape(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">B = A.clone()  <span class="comment">#通过分配新内存，将A的一个副本分配给B</span></span><br><span class="line">B = B + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="built_in">print</span>(A) <span class="comment">#A结果没变，说明B是新开辟了一个空间，并不是A的引用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.求和.sum(),求均值.mean()其用法与求和一致</span></span><br><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>()) <span class="comment">#默认对所有值求和</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis = <span class="number">1</span>)) <span class="comment">#对每一行求和</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=[<span class="number">0</span>, <span class="number">1</span>])) <span class="comment">#效果等同sum()</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line">sum_A = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>) <span class="comment">#有时在调用函数来计算总和或均值时保持轴数不变会很有用</span></span><br><span class="line"><span class="built_in">print</span>(sum_A)</span><br><span class="line"><span class="built_in">print</span>(A.cumsum(axis=<span class="number">0</span>)) <span class="comment">#沿某个轴计算A元素的累积总和,此函数不会沿任何轴降低输入张量的维度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.范数</span></span><br><span class="line"><span class="comment">#L2范数</span></span><br><span class="line">u = torch.tensor([<span class="number">3.0</span>, -<span class="number">4.0</span>])</span><br><span class="line"><span class="built_in">print</span>(torch.norm(u)) <span class="comment">#元素平方求和再开根号</span></span><br><span class="line"><span class="comment">#L1范数</span></span><br><span class="line">u1 = torch.<span class="built_in">abs</span>(u).<span class="built_in">sum</span>() <span class="comment">#元素绝对值求和</span></span><br><span class="line"><span class="built_in">print</span>(u1)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor(12.9800) , tensor(13.7800)</span><br><span class="line">----------------------------------------</span><br><span class="line">24</span><br><span class="line">torch.Size([2, 3, 4])</span><br><span class="line">torch.Size([2, 3, 4])</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">----------------------------------------</span><br><span class="line">tensor([[ 0,  1,  2,  3],</span><br><span class="line">        [ 4,  5,  6,  7],</span><br><span class="line">        [ 8,  9, 10, 11],</span><br><span class="line">        [12, 13, 14, 15],</span><br><span class="line">        [16, 17, 18, 19]])</span><br><span class="line">tensor([[ 0,  4,  8, 12, 16],</span><br><span class="line">        [ 1,  5,  9, 13, 17],</span><br><span class="line">        [ 2,  6, 10, 14, 18],</span><br><span class="line">        [ 3,  7, 11, 15, 19]])</span><br><span class="line">tensor(6.)</span><br><span class="line">tensor([ 14.,  38.,  62.,  86., 110.])</span><br><span class="line">tensor([[ 6.,  6.,  6.],</span><br><span class="line">        [22., 22., 22.],</span><br><span class="line">        [38., 38., 38.],</span><br><span class="line">        [54., 54., 54.],</span><br><span class="line">        [70., 70., 70.]])</span><br><span class="line">----------------------------------------</span><br><span class="line">tensor([[1., 2., 3., 4.],</span><br><span class="line">        [5., 6., 7., 8.]])</span><br><span class="line">tensor([[0., 1., 2., 3.],</span><br><span class="line">        [4., 5., 6., 7.]])</span><br><span class="line">----------------------------------------</span><br><span class="line">tensor(190.)</span><br><span class="line">tensor([ 6., 22., 38., 54., 70.])</span><br><span class="line">tensor(190.)</span><br><span class="line">tensor([[ 0.,  1.,  2.,  3.],</span><br><span class="line">        [ 4.,  5.,  6.,  7.],</span><br><span class="line">        [ 8.,  9., 10., 11.],</span><br><span class="line">        [12., 13., 14., 15.],</span><br><span class="line">        [16., 17., 18., 19.]])</span><br><span class="line">tensor([[ 6.],</span><br><span class="line">        [22.],</span><br><span class="line">        [38.],</span><br><span class="line">        [54.],</span><br><span class="line">        [70.]])</span><br><span class="line">tensor([[ 0.,  1.,  2.,  3.],</span><br><span class="line">        [ 4.,  6.,  8., 10.],</span><br><span class="line">        [12., 15., 18., 21.],</span><br><span class="line">        [24., 28., 32., 36.],</span><br><span class="line">        [40., 45., 50., 55.]])</span><br><span class="line">----------------------------------------</span><br><span class="line">tensor(5.)</span><br><span class="line">tensor(7.)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.arange(<span class="number">4.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x is:&#x27;</span>,x)</span><br><span class="line"><span class="comment">#requires_grad_用来指明是否需要求导</span></span><br><span class="line"><span class="comment">#在张量间的计算过程中，如果在所有输入中，有一个输入需要求导，那么输出一定会需要求导；</span></span><br><span class="line"><span class="comment">#相反，只有当所有输入都不需要求导的时候，输出才会不需要</span></span><br><span class="line"><span class="comment">#虽然输入的训练数据是默认不求导的，但是，我们的 model 中的所有参数，它默认是求导的</span></span><br><span class="line">x.requires_grad_(<span class="literal">True</span>)  <span class="comment">#等价于x=torch.arange(4.0,requires_grad=True)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;the gradient of x is:&#x27;</span>,x.grad)  <span class="comment">#默认值是None</span></span><br><span class="line">y = <span class="number">2</span> * torch.dot(x, x) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y is:&#x27;</span>,y)</span><br><span class="line">y.backward()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;the gradient of y to x is:&#x27;</span>,x.grad)</span><br><span class="line"></span><br><span class="line">x.grad.zero_() <span class="comment">#在默认情况下，PyTorch会累积梯度，我们需要清除之前的值</span></span><br><span class="line">y = x.<span class="built_in">sum</span>()</span><br><span class="line">y.backward()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;the new gardient of y to x is:&#x27;</span>,x.grad)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x is: tensor([0., 1., 2., 3.])</span><br><span class="line">the gradient of x is: None</span><br><span class="line">y is: tensor(28., grad_fn=&lt;MulBackward0&gt;)</span><br><span class="line">the gradient of y to x is: tensor([ 0.,  4.,  8., 12.])</span><br><span class="line">the new gardient of y to x is: tensor([1., 1., 1., 1.])</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://www.cnblogs.com/yanghh/p/16786016.html">PyTorch的Autograd机制 - _yanghh - 博客园 (cnblogs.com)</a></li>
</ul>
<hr>
<h1 id="Anconda下Pytorch的安装方法-并在pycharm中使用"><a href="#Anconda下Pytorch的安装方法-并在pycharm中使用" class="headerlink" title="Anconda下Pytorch的安装方法,并在pycharm中使用"></a>Anconda下Pytorch的安装方法,并在pycharm中使用</h1><ul>
<li><p><a href="https://blog.csdn.net/qq_45281807/article/details/112442423">在Anaconda下安装Pytorch的超详细步骤_伏城无嗔的博客-CSDN博客_anaconda pytorch</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_41858644/article/details/118974512"> 安装pytorch步骤即遇到错误的解决方法_ZFuJin的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_42658887/article/details/112094547">从零开始安装pytorch，并在pycharm中使用_俩猫的博客-CSDN博客_pytorch和pycharm</a></p>
</li>
</ul>
<hr>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/438509608">复数神经网络及其 PyTorch 实现 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://huaweicloud.csdn.net/63808343dacf622b8df8941f.html">傻瓜式讲解Conv1D家族-系列2-ConvTranspose1d_pytorch_11721206-DevPress官方社区 (csdn.net)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_38156052/article/details/81265220">Pytorch学习笔记（一） 使用PyTorch搭建神经网络的套路_cg101202的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/83131026">PyTorch中的损失函数—L1Loss /L2Loss/SmoothL1Loss - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zfhsfdhdfajhsr/article/details/115637954">【Pytorch基础】torch.nn.MSELoss损失函数_一穷二白到年薪百万的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/darkknightzh/p/6836568.html">PyTorch中使用指定的GPU - darkknightzh - 博客园 (cnblogs.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/583866931">Python-Matlab交互 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zdz8207/p/linux-cp-dir.html">linux复制指定目录下的全部文件到另一个目录中，linux cp 文件夹 - 大自然的流风 - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之使用类</title>
    <url>/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>C++之使用类……</p>
<span id="more"></span>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="1-运算符重载的基本使用"><a href="#1-运算符重载的基本使用" class="headerlink" title="1.运算符重载的基本使用"></a>1.运算符重载的基本使用</h2><ul>
<li><p>mytime1.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYTIME1_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYTIME1_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> hours;</span><br><span class="line">		<span class="type">int</span> minutes;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Time</span>();</span><br><span class="line">		<span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m = <span class="number">0</span>);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">AddMin</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">AddHr</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="comment">//运算符重载的声明</span></span><br><span class="line">		Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp;t) <span class="type">const</span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mytime1.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>()</span><br><span class="line">&#123;</span><br><span class="line">	hours = minutes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">	hours = h;</span><br><span class="line">	minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddMin</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	minutes += m;</span><br><span class="line">	hours += minutes / <span class="number">60</span>;</span><br><span class="line">	minutes %= <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddHr</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hours += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Reset</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hours = h;</span><br><span class="line">	minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>+(<span class="type">const</span> Time &amp;t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time sum;</span><br><span class="line"></span><br><span class="line">	sum.minutes = minutes + t.minutes;</span><br><span class="line">	sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">	sum.minutes %= <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; hours &lt;&lt; <span class="string">&quot; hours,  &quot;</span> &lt;&lt; minutes &lt;&lt; <span class="string">&quot; minutes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;---------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>usetime1.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Time <span class="title">coding</span><span class="params">(<span class="number">2</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Time <span class="title">fixing</span><span class="params">(<span class="number">5</span>, <span class="number">55</span>)</span></span>;</span><br><span class="line">	Time total;</span><br><span class="line">	Time Planning;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;coding time = &quot;</span>;</span><br><span class="line">	coding.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;fixing time = &quot;</span>;</span><br><span class="line">	fixing.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不用运算符重载的方式</span></span><br><span class="line">	<span class="comment">//total = coding.Sum(fixing);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//运算符重载的常见使用方式</span></span><br><span class="line">	total = coding + fixing;</span><br><span class="line">	total.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载的另一种使用形式</span></span><br><span class="line">	Planning = coding.<span class="keyword">operator</span>+(fixing);</span><br><span class="line">	Planning.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/image-20230210132912766.png" alt="image-20230210132912766"></p>
</li>
<li><p>对于<code>Time operator+(const Time &amp;t) const;</code>函数，其<strong>返回值不能是引用类型Time &amp;</strong>，因为返回类型如果是Time &amp;，则引用的将是sum对象，但由于sum对象是局部变量，在函数结束时将被删除，因此引用将指向一个不存在的对象</p>
</li>
</ul>
<h2 id="2-运算符重载中遇到的问题"><a href="#2-运算符重载中遇到的问题" class="headerlink" title="2.运算符重载中遇到的问题"></a>2.运算符重载中遇到的问题</h2><ul>
<li><p>mytime2.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYTIME2_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYTIME2_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> hours;</span><br><span class="line">		<span class="type">int</span> minutes;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Time</span>();</span><br><span class="line">		<span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m = <span class="number">0</span>);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">AddMin</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">AddHr</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">		Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp;t) <span class="type">const</span>;</span><br><span class="line">		Time <span class="keyword">operator</span>-(<span class="type">const</span> Time &amp;t) <span class="type">const</span>;</span><br><span class="line">		Time <span class="keyword">operator</span>*(<span class="type">double</span> mult) <span class="type">const</span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mytime2.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>()</span><br><span class="line">&#123;</span><br><span class="line">	hours = minutes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">	hours = h;</span><br><span class="line">	minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddMin</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	minutes += m;</span><br><span class="line">	hours += minutes / <span class="number">60</span>;</span><br><span class="line">	minutes %= <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddHr</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hours += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Reset</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hours = h;</span><br><span class="line">	minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>+(<span class="type">const</span> Time &amp;t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time sum;</span><br><span class="line"></span><br><span class="line">	sum.minutes = minutes + t.minutes;</span><br><span class="line">	sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">	sum.minutes %= <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>-(<span class="type">const</span> Time &amp;t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time diff;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> tot1, tot2;</span><br><span class="line">	tot1 = hours * <span class="number">60</span> + minutes;</span><br><span class="line">	tot2 = t.hours * <span class="number">60</span> + t.minutes;</span><br><span class="line">	diff.hours = (tot1 - tot2) / <span class="number">60</span>;</span><br><span class="line">	diff.minutes = (tot1 - tot2) % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>*(<span class="type">double</span> mult) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time result;</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> totalminutes = hours*mult*<span class="number">60</span> + minutes*mult;</span><br><span class="line">	result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">	result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; hours &lt;&lt; <span class="string">&quot; hours,  &quot;</span> &lt;&lt; minutes &lt;&lt; <span class="string">&quot; minutes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>usetime2.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Time <span class="title">coding</span><span class="params">(<span class="number">4</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Time <span class="title">fixing</span><span class="params">(<span class="number">2</span>, <span class="number">47</span>)</span></span>;</span><br><span class="line">	Time total;</span><br><span class="line">	Time diff;</span><br><span class="line">	Time adjusted;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;coding time = &quot;</span>;</span><br><span class="line">	coding.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;fixing time = &quot;</span>;</span><br><span class="line">	fixing.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	total = coding + fixing;</span><br><span class="line">	total.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	diff = coding - fixing;</span><br><span class="line">	diff.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	adjusted = coding * <span class="number">1.5</span>;</span><br><span class="line">	adjusted.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/image-20230213124123583.png" alt="image-20230213124123583"></p>
</li>
<li><p>对于重载运算符<code>*</code>，其将一个Time值与一个double值结合在一起，这限制了该运算符的使用方式，因为<strong>左侧的操作数是调用对象</strong>，故使用重载运算符<em>时，只能写成`coding</em>1.5<code>，不能写成</code>1.5*coding`，否则会报错</p>
</li>
<li><p>其解决方式有使用如下的友元函数</p>
</li>
</ul>
<hr>
<h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><ul>
<li>友元函数不是成员函数，但它与成员函数有相同的访问权限</li>
</ul>
<h2 id="1-友元函数实现重载-运算符"><a href="#1-友元函数实现重载-运算符" class="headerlink" title="1.友元函数实现重载*运算符"></a>1.友元函数实现重载*运算符</h2><ul>
<li><p>mytime3.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYTIME3_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYTIME3_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> hours;</span><br><span class="line">		<span class="type">int</span> minutes;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Time</span>();</span><br><span class="line">		<span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m = <span class="number">0</span>);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">AddMin</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">AddHr</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">		Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp;t) <span class="type">const</span>;</span><br><span class="line">		Time <span class="keyword">operator</span>-(<span class="type">const</span> Time &amp;t) <span class="type">const</span>;</span><br><span class="line">		Time <span class="keyword">operator</span>*(<span class="type">double</span> mult) <span class="type">const</span>;</span><br><span class="line">		<span class="comment">//友元函数的声明</span></span><br><span class="line">		<span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="type">double</span> mult, <span class="type">const</span> Time &amp;t);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mytime3.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>()</span><br><span class="line">&#123;</span><br><span class="line">	hours = minutes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">	hours = h;</span><br><span class="line">	minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddMin</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	minutes += m;</span><br><span class="line">	hours += minutes / <span class="number">60</span>;</span><br><span class="line">	minutes %= <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddHr</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hours += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Reset</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hours = h;</span><br><span class="line">	minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>+(<span class="type">const</span> Time &amp;t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time sum;</span><br><span class="line"></span><br><span class="line">	sum.minutes = minutes + t.minutes;</span><br><span class="line">	sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">	sum.minutes %= <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>-(<span class="type">const</span> Time &amp;t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time diff;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> tot1, tot2;</span><br><span class="line">	tot1 = hours * <span class="number">60</span> + minutes;</span><br><span class="line">	tot2 = t.hours * <span class="number">60</span> + t.minutes;</span><br><span class="line">	diff.hours = (tot1 - tot2) / <span class="number">60</span>;</span><br><span class="line">	diff.minutes = (tot1 - tot2) % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>*(<span class="type">double</span> mult) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time result;</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> totalminutes = hours*mult*<span class="number">60</span> + minutes*mult;</span><br><span class="line">	result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">	result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; hours &lt;&lt; <span class="string">&quot; hours,  &quot;</span> &lt;&lt; minutes &lt;&lt; <span class="string">&quot; minutes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数的定义</span></span><br><span class="line">Time <span class="keyword">operator</span>*(<span class="type">double</span> mult, <span class="type">const</span> Time &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	Time result;</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> totalminutes = t.hours*mult*<span class="number">60</span> + t.minutes*mult;</span><br><span class="line">	result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">	result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>usetime3.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Time <span class="title">coding</span><span class="params">(<span class="number">4</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Time <span class="title">fixing</span><span class="params">(<span class="number">2</span>, <span class="number">47</span>)</span></span>;</span><br><span class="line">	Time total;</span><br><span class="line">	Time Planning;</span><br><span class="line">	Time diff;</span><br><span class="line">	Time adjusted;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;coding time = &quot;</span>;</span><br><span class="line">	coding.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;fixing time = &quot;</span>;</span><br><span class="line">	fixing.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	total = coding + fixing;</span><br><span class="line">	total.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	diff = coding - fixing;</span><br><span class="line">	diff.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	adjusted = coding * <span class="number">1.5</span>;</span><br><span class="line">	adjusted.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	adjusted = <span class="number">1.5</span> * coding;</span><br><span class="line">	adjusted.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/image-20230213130105898.png" alt="image-20230213130105898"></p>
</li>
</ul>
<h2 id="2-友元函数实现重载-lt-lt-运算符"><a href="#2-友元函数实现重载-lt-lt-运算符" class="headerlink" title="2.友元函数实现重载&lt;&lt;运算符"></a>2.友元函数实现重载&lt;&lt;运算符</h2><ul>
<li><p>mytime4.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYTIME4_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYTIME4_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> hours;</span><br><span class="line">		<span class="type">int</span> minutes;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Time</span>();</span><br><span class="line">		<span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m = <span class="number">0</span>);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">AddMin</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">AddHr</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">		Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp;t) <span class="type">const</span>;</span><br><span class="line">		Time <span class="keyword">operator</span>-(<span class="type">const</span> Time &amp;t) <span class="type">const</span>;</span><br><span class="line">		Time <span class="keyword">operator</span>*(<span class="type">double</span> mult) <span class="type">const</span>;</span><br><span class="line">		<span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="type">double</span> mult, <span class="type">const</span> Time &amp;t);</span><br><span class="line">		<span class="comment">//利用友元函数重载运算符&lt;&lt;,实现输出显示</span></span><br><span class="line">		<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Time &amp;t);</span><br><span class="line"><span class="comment">//		void Show() const;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mytime4.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime4.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>()</span><br><span class="line">&#123;</span><br><span class="line">	hours = minutes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">	hours = h;</span><br><span class="line">	minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddMin</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	minutes += m;</span><br><span class="line">	hours += minutes / <span class="number">60</span>;</span><br><span class="line">	minutes %= <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddHr</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hours += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Reset</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hours = h;</span><br><span class="line">	minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>+(<span class="type">const</span> Time &amp;t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time sum;</span><br><span class="line"></span><br><span class="line">	sum.minutes = minutes + t.minutes;</span><br><span class="line">	sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">	sum.minutes %= <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>-(<span class="type">const</span> Time &amp;t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time diff;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> tot1, tot2;</span><br><span class="line">	tot1 = hours * <span class="number">60</span> + minutes;</span><br><span class="line">	tot2 = t.hours * <span class="number">60</span> + t.minutes;</span><br><span class="line">	diff.hours = (tot1 - tot2) / <span class="number">60</span>;</span><br><span class="line">	diff.minutes = (tot1 - tot2) % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>*(<span class="type">double</span> mult) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Time result;</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> totalminutes = hours*mult*<span class="number">60</span> + minutes*mult;</span><br><span class="line">	result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">	result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void Time::Show() const</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; hours &lt;&lt; &quot; hours,  &quot; &lt;&lt; minutes &lt;&lt; &quot; minutes.&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Time <span class="keyword">operator</span>*(<span class="type">double</span> mult, <span class="type">const</span> Time &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	Time result;</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> totalminutes = t.hours*mult*<span class="number">60</span> + t.minutes*mult;</span><br><span class="line">	result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">	result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Time &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; t.hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">&quot; minutes.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>usetime4.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime4.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Time <span class="title">coding</span><span class="params">(<span class="number">4</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Time <span class="title">fixing</span><span class="params">(<span class="number">2</span>, <span class="number">47</span>)</span></span>;</span><br><span class="line">	Time total;</span><br><span class="line">	Time Planning;</span><br><span class="line">	Time diff;</span><br><span class="line">	Time adjusted;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;coding time = &quot;</span>;</span><br><span class="line"><span class="comment">//	coding.Show();</span></span><br><span class="line">	cout &lt;&lt; coding;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;fixing time = &quot;</span>;</span><br><span class="line"><span class="comment">//	fixing.Show();</span></span><br><span class="line">	cout &lt;&lt; fixing;</span><br><span class="line"></span><br><span class="line">	total = coding + fixing;</span><br><span class="line"><span class="comment">//	total.Show();</span></span><br><span class="line">	cout &lt;&lt; total;</span><br><span class="line"></span><br><span class="line">	diff = coding - fixing;</span><br><span class="line"><span class="comment">//	diff.Show();</span></span><br><span class="line">	cout &lt;&lt; diff;</span><br><span class="line">	adjusted = coding * <span class="number">1.5</span>;</span><br><span class="line"><span class="comment">//	adjusted.Show();</span></span><br><span class="line">	cout &lt;&lt; adjusted;</span><br><span class="line"></span><br><span class="line">	adjusted = <span class="number">1.5</span> * coding;</span><br><span class="line"><span class="comment">//	adjusted.Show();</span></span><br><span class="line">	cout &lt;&lt; adjusted;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; coding &lt;&lt; fixing;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/image-20230213132741698.png" alt="image-20230213132741698"></p>
</li>
</ul>
<hr>
<h1 id="矢量类"><a href="#矢量类" class="headerlink" title="矢量类"></a>矢量类</h1><ul>
<li><p>vector.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __VECTOR_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __VECTOR_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> VECTOR</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">			<span class="keyword">enum</span> <span class="title class_">Mode</span>&#123;RECT, POL&#125;;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">			<span class="comment">//直角坐标x，y</span></span><br><span class="line">			<span class="type">double</span> x;</span><br><span class="line">			<span class="type">double</span> y;</span><br><span class="line">			<span class="comment">//极坐标的模长mag以及角度ang</span></span><br><span class="line">			<span class="type">double</span> mag;</span><br><span class="line">			<span class="type">double</span> ang;</span><br><span class="line">			<span class="comment">//模式：是直角坐标还是极坐标</span></span><br><span class="line">			Mode mode;</span><br><span class="line">			<span class="comment">//计算极坐标的模值和角度</span></span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">set_mag</span><span class="params">()</span></span>;</span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">set_ang</span><span class="params">()</span></span>;</span><br><span class="line">			<span class="comment">//计算直角坐标的x与y值</span></span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">()</span></span>;</span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">set_y</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">			<span class="comment">//默认构造函数</span></span><br><span class="line">			<span class="built_in">Vector</span>();</span><br><span class="line">			<span class="comment">//用户自定义构造函数：初始化直角坐标与极坐标</span></span><br><span class="line">			<span class="built_in">Vector</span>(<span class="type">double</span> n1, <span class="type">double</span> n2, Mode form = RECT);</span><br><span class="line">			<span class="comment">//重置直角坐标与极坐标</span></span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2, Mode form = RECT)</span></span>;</span><br><span class="line">			<span class="comment">//返回各个成员变量</span></span><br><span class="line">			<span class="function"><span class="type">double</span> <span class="title">xval</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">			<span class="function"><span class="type">double</span> <span class="title">yval</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">			<span class="function"><span class="type">double</span> <span class="title">magval</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> mag;&#125;</span><br><span class="line">			<span class="function"><span class="type">double</span> <span class="title">angval</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> ang;&#125;</span><br><span class="line">			<span class="comment">//设置坐标系模式</span></span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">polar_mode</span><span class="params">()</span></span>;</span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">rect_mode</span><span class="params">()</span></span>;</span><br><span class="line">			<span class="comment">//成员函数实现坐标计算</span></span><br><span class="line">			Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector &amp;b) <span class="type">const</span>;</span><br><span class="line">			Vector <span class="keyword">operator</span>-(<span class="type">const</span> Vector &amp;b) <span class="type">const</span>;</span><br><span class="line">			Vector <span class="keyword">operator</span>-() <span class="type">const</span>;<span class="comment">//这里的-代表取反</span></span><br><span class="line">			Vector <span class="keyword">operator</span>*(<span class="type">double</span> n) <span class="type">const</span>;</span><br><span class="line">			<span class="comment">//友元函数实现重载*与输出&lt;&lt;</span></span><br><span class="line">			<span class="keyword">friend</span> Vector <span class="keyword">operator</span>*(<span class="type">double</span> n, <span class="type">const</span> Vector &amp;a);</span><br><span class="line">			<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Vector &amp;v);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>vector.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> VECTOR</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> Rad_to_deg = <span class="number">45.0</span> / <span class="built_in">atan</span>(<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::set_mag</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mag = <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::set_ang</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>)</span><br><span class="line">			ang = <span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ang = <span class="built_in">atan2</span>(y, x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::set_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x = mag * <span class="built_in">cos</span>(ang);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::set_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		y = mag * <span class="built_in">sin</span>(ang);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector::<span class="built_in">Vector</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		x = y = mag = ang = <span class="number">0.0</span>;</span><br><span class="line">		mode = RECT;</span><br><span class="line">	&#125;</span><br><span class="line">	Vector::<span class="built_in">Vector</span>(<span class="type">double</span> n1, <span class="type">double</span> n2, Mode form)</span><br><span class="line">	&#123;</span><br><span class="line">		mode = form;</span><br><span class="line">		<span class="keyword">if</span>(form == RECT)</span><br><span class="line">		&#123;</span><br><span class="line">			x = n1;</span><br><span class="line">			y = n2;</span><br><span class="line">			<span class="built_in">set_mag</span>();</span><br><span class="line">			<span class="built_in">set_ang</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(form == POL)</span><br><span class="line">		&#123;</span><br><span class="line">			mag = n1;</span><br><span class="line">			ang = n2 / Rad_to_deg;</span><br><span class="line">			<span class="built_in">set_x</span>();</span><br><span class="line">			<span class="built_in">set_y</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Error&quot;</span> &lt;&lt; endl;</span><br><span class="line">			x = y = mag = ang = <span class="number">0.0</span>;</span><br><span class="line">			mode = RECT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::reset</span><span class="params">(<span class="type">double</span> n1, <span class="type">double</span> n2, Mode form)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mode = form;</span><br><span class="line">		<span class="keyword">if</span>(form == RECT)</span><br><span class="line">		&#123;</span><br><span class="line">			x = n1;</span><br><span class="line">			y = n2;</span><br><span class="line">			<span class="built_in">set_mag</span>();</span><br><span class="line">			<span class="built_in">set_ang</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(form == POL)</span><br><span class="line">		&#123;</span><br><span class="line">			mag = n1;</span><br><span class="line">			ang = n2 / Rad_to_deg;</span><br><span class="line">			<span class="built_in">set_x</span>();</span><br><span class="line">			<span class="built_in">set_y</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Error&quot;</span> &lt;&lt; endl;</span><br><span class="line">			x = y = mag = ang = <span class="number">0.0</span>;</span><br><span class="line">			mode = RECT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::polar_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mode = POL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Vector::rect_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mode = RECT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector Vector::<span class="keyword">operator</span>+(<span class="type">const</span> Vector &amp;b) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector</span>(x + b.x, y + b.y);<span class="comment">//巧妙利用自定义构造函数返回计算后的Vector类</span></span><br><span class="line">	&#125;</span><br><span class="line">	Vector Vector::<span class="keyword">operator</span>-(<span class="type">const</span> Vector &amp;b) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector</span>(x - b.x, y - b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Vector Vector::<span class="keyword">operator</span>-() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector</span>(-x, -y);</span><br><span class="line">	&#125;</span><br><span class="line">	Vector Vector::<span class="keyword">operator</span>*(<span class="type">double</span> n) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Vector</span>(n*x, n*y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector <span class="keyword">operator</span>*(<span class="type">double</span> n, <span class="type">const</span> Vector &amp;a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a * n;<span class="comment">//巧妙利用重载运算符*实现a*n</span></span><br><span class="line">	&#125;</span><br><span class="line">	ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Vector &amp;v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v.mode == Vector::RECT)<span class="comment">//在类声明外使用public内容都需要加Vector</span></span><br><span class="line">			os &lt;&lt; <span class="string">&quot;x, y = &quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(v.mode == Vector::POL)</span><br><span class="line">			os &lt;&lt; <span class="string">&quot;mag, ang = &quot;</span> &lt;&lt; v.mag &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.ang &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			os &lt;&lt; <span class="string">&quot;Invalid mode&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> VECTOR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> target;</span><br><span class="line">	<span class="type">double</span> dstep;</span><br><span class="line">	<span class="function">Vector <span class="title">result</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">	<span class="type">double</span> direction;</span><br><span class="line">	Vector step;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> steps = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//随机数种子</span></span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter target distance(q to quit): &quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; target)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter the step lenght: &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(cin &gt;&gt; dstep))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(result.<span class="built_in">magval</span>() &lt; target)</span><br><span class="line">		&#123;</span><br><span class="line">			direction = <span class="built_in">rand</span>() % <span class="number">360</span>;</span><br><span class="line">			step.<span class="built_in">reset</span>(dstep, direction, Vector::POL);</span><br><span class="line">			result = result + step;</span><br><span class="line">			steps++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;After &quot;</span> &lt;&lt; steps &lt;&lt; <span class="string">&quot; steps, the subject has the following location:\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; result;</span><br><span class="line">		result.<span class="built_in">polar_mode</span>();</span><br><span class="line">		cout &lt;&lt; result;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		steps = <span class="number">0</span>;</span><br><span class="line">		result.<span class="built_in">reset</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter target distance(q to quit): &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Bye&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230214_131742.png" alt="屏幕截图_20230214_131742"></p>
</li>
</ul>
<hr>
<h1 id="类的自动转换与强制类型转换"><a href="#类的自动转换与强制类型转换" class="headerlink" title="类的自动转换与强制类型转换"></a>类的自动转换与强制类型转换</h1><h2 id="1-类的自动类型转换"><a href="#1-类的自动类型转换" class="headerlink" title="1.类的自动类型转换"></a>1.类的自动类型转换</h2><ul>
<li><p>定义类对象时使用<code>=</code>，会自动调用相匹配的构造函数实现自动类型转换，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stonewt incognito = 275;//就相当于是Stonewt incognito(275); Stonewt incognito = Stonewt(275);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可使用<code>explicit</code>禁止自动类型转换，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explicit Stonewt(double lbs);</span><br></pre></td></tr></table></figure>
</li>
<li><p>stonewt.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STONEWT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STONEWT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stonewt</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">enum</span>&#123;Lbs_per_stn = <span class="number">14</span>&#125;;</span><br><span class="line">		<span class="type">int</span> stone;</span><br><span class="line">		<span class="type">double</span> pds_left;</span><br><span class="line">		<span class="type">double</span> pounds;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//使用explicit禁止自动类型转换</span></span><br><span class="line">		<span class="comment">//explicit Stonewt(double lbs);</span></span><br><span class="line">		<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs);</span><br><span class="line">		<span class="built_in">Stonewt</span>(<span class="type">int</span> stn, <span class="type">double</span> lbs);</span><br><span class="line">		<span class="built_in">Stonewt</span>();</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">show_lbs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">show_stn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stonewt.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stonewt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs)</span><br><span class="line">&#123;</span><br><span class="line">	stone = (<span class="type">int</span>)lbs / Lbs_per_stn;</span><br><span class="line">	pds_left = (<span class="type">int</span>)lbs % Lbs_per_stn + lbs - (<span class="type">int</span>)lbs;</span><br><span class="line">	pounds = lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">int</span> stn, <span class="type">double</span> lbs)</span><br><span class="line">&#123;</span><br><span class="line">	stone = stn;</span><br><span class="line">	pds_left = lbs;</span><br><span class="line">	pounds = stn * Lbs_per_stn + lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>()</span><br><span class="line">&#123;</span><br><span class="line">	stone = pds_left = pounds = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stonewt::show_stn</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; stone &lt;&lt; <span class="string">&quot; stone, &quot;</span> &lt;&lt; pds_left &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stonewt::show_lbs</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; pounds &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>stone.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stonewt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stonewt incognito = <span class="number">275</span>;<span class="comment">//Stonewt incognito(275); Stonewt incognito = Stonewt(275);</span></span><br><span class="line">	<span class="function">Stonewt <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>; <span class="comment">//Stonewt(double );</span></span><br><span class="line">	<span class="function">Stonewt <span class="title">taft</span><span class="params">(<span class="number">21</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	incognito.<span class="built_in">show_stn</span>();</span><br><span class="line">	wolfe.<span class="built_in">show_stn</span>();</span><br><span class="line">	taft.<span class="built_in">show_lbs</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	incognito = <span class="number">276.8</span>;</span><br><span class="line">	taft = <span class="number">325</span>;</span><br><span class="line">	incognito.<span class="built_in">show_stn</span>();</span><br><span class="line">	taft.<span class="built_in">show_lbs</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/image-20230215142637177.png" alt="image-20230215142637177"></p>
</li>
</ul>
<h2 id="2-类的强制类型转换"><a href="#2-类的强制类型转换" class="headerlink" title="2.类的强制类型转换"></a>2.类的强制类型转换</h2><ul>
<li>转换函数：<strong>转换函数是类成员函数，没有返回类型和参数</strong>，名为operator typeName()，其中typeName是对象将被转换成的类型</li>
<li><p>在转换函数的声明前加<code>explicit</code>可防止隐式转换，而只允许显示转换</p>
</li>
<li><p>stonewt1.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STONEWT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STONEWT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stonewt</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">enum</span>&#123;Lbs_per_stn = <span class="number">14</span>&#125;;</span><br><span class="line">		<span class="type">int</span> stone;</span><br><span class="line">		<span class="type">double</span> pds_left;</span><br><span class="line">		<span class="type">double</span> pounds;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//explicit Stonewt(double lbs);</span></span><br><span class="line">		<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs);</span><br><span class="line">		<span class="built_in">Stonewt</span>(<span class="type">int</span> stn, <span class="type">double</span> lbs);</span><br><span class="line">		<span class="built_in">Stonewt</span>();</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">show_lbs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">show_stn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="comment">//转换函数</span></span><br><span class="line">		<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stonewt1.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stonewt1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs)</span><br><span class="line">&#123;</span><br><span class="line">	stone = (<span class="type">int</span>)lbs / Lbs_per_stn;</span><br><span class="line">	pds_left = (<span class="type">int</span>)lbs % Lbs_per_stn + lbs - (<span class="type">int</span>)lbs;</span><br><span class="line">	pounds = lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">int</span> stn, <span class="type">double</span> lbs)</span><br><span class="line">&#123;</span><br><span class="line">	stone = stn;</span><br><span class="line">	pds_left = lbs;</span><br><span class="line">	pounds = stn * Lbs_per_stn + lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>()</span><br><span class="line">&#123;</span><br><span class="line">	stone = pds_left = pounds = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stonewt::show_stn</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; stone &lt;&lt; <span class="string">&quot; stone, &quot;</span> &lt;&lt; pds_left &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stonewt::show_lbs</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; pounds &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stonewt::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)(pounds + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stonewt::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>stone1.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stonewt1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Stonewt <span class="title">poppins</span><span class="params">(<span class="number">9</span>, <span class="number">2.8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//隐式调用转换函数：operator double() const</span></span><br><span class="line">	<span class="type">double</span> p_wt = poppins;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;poppins = &quot;</span> &lt;&lt; p_wt &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//隐式调用转换函数：operator int() const;</span></span><br><span class="line">	<span class="type">int</span> weight = poppins;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;poppins = &quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示调用转换函数：此处若不使用显示调用则会报错，因为两个转换函数都满足条件</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;poppins = &quot;</span> &lt;&lt; <span class="built_in">int</span>(poppins) &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;poppins = &quot;</span> &lt;&lt; <span class="built_in">double</span>(poppins) &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_211341.png" alt="屏幕截图_20230216_211341"></p>
</li>
</ul>
<hr>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="1-将矢量类中的结果输出至文本文件"><a href="#1-将矢量类中的结果输出至文本文件" class="headerlink" title="1.将矢量类中的结果输出至文本文件"></a>1.将矢量类中的结果输出至文本文件</h2><ul>
<li><p>vectorFile.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> VECTOR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> target;</span><br><span class="line">	<span class="type">double</span> dstep;</span><br><span class="line">	<span class="function">Vector <span class="title">result</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">	<span class="type">double</span> direction;</span><br><span class="line">	Vector step;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> steps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入文件对象</span></span><br><span class="line">	ofstream fout;</span><br><span class="line">	fout.<span class="built_in">open</span>(<span class="string">&quot;randwalk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter target distance(q to quit): &quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; target)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter the step lenght: &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(cin &gt;&gt; dstep))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在文件中输出目标距离和每步的长度</span></span><br><span class="line">		fout &lt;&lt; <span class="string">&quot;Target distance: &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot;, step size: &quot;</span> &lt;&lt; dstep &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(result.<span class="built_in">magval</span>() &lt; target)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//在文件中输出每一步的位置</span></span><br><span class="line">			fout &lt;&lt; steps &lt;&lt; <span class="string">&quot;: (x, y) = &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">			direction = <span class="built_in">rand</span>() % <span class="number">360</span>;</span><br><span class="line">			step.<span class="built_in">reset</span>(dstep, direction, Vector::POL);</span><br><span class="line">			result = result + step;</span><br><span class="line">			steps++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;After &quot;</span> &lt;&lt; steps &lt;&lt; <span class="string">&quot; steps, the subject has the following location:\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在文件中输出最终需要多少步以及最终的位置</span></span><br><span class="line">		fout &lt;&lt; <span class="string">&quot;After &quot;</span> &lt;&lt; steps &lt;&lt; <span class="string">&quot; steps, the subject has the following location:\n&quot;</span>;</span><br><span class="line">		fout &lt;&lt; result;</span><br><span class="line"></span><br><span class="line">		result.<span class="built_in">polar_mode</span>();</span><br><span class="line">		cout &lt;&lt; result;</span><br><span class="line">		fout &lt;&lt; result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在文件中显示平均每一步走多远</span></span><br><span class="line">		fout &lt;&lt; <span class="string">&quot;Average outward distance per step = &quot;</span> &lt;&lt; result.<span class="built_in">magval</span>() / steps &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">        fout &lt;&lt; <span class="string">&quot;------------------------------------------------------\n&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">		steps = <span class="number">0</span>;</span><br><span class="line">		result.<span class="built_in">reset</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter target distance(q to quit): &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Bye&quot;</span> &lt;&lt; endl;</span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230218_163055.png" alt="屏幕截图_20230218_163055"></p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/image-20230218163421983.png" alt="image-20230218163421983"></p>
</li>
</ul>
<h2 id="2-类实现有关复数运算"><a href="#2-类实现有关复数运算" class="headerlink" title="2.类实现有关复数运算"></a>2.类实现有关复数运算</h2><ul>
<li><p>输入输出流一定要使用友元函数重载，若直接重载那运算符左侧一定要是类的对象，所以只能使用友元函数重载运算符</p>
</li>
<li><p>complex0.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX_0_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX_0_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">double</span> real;</span><br><span class="line">		<span class="type">double</span> imaginary;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">complex</span>();</span><br><span class="line">		<span class="built_in">complex</span>(<span class="type">double</span> r, <span class="type">double</span> i);</span><br><span class="line">		complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;c) <span class="type">const</span>;</span><br><span class="line">		complex <span class="keyword">operator</span>-(<span class="type">const</span> complex &amp;c) <span class="type">const</span>;</span><br><span class="line">		complex <span class="keyword">operator</span>*(<span class="type">const</span> complex &amp;c) <span class="type">const</span>;</span><br><span class="line">		complex <span class="keyword">operator</span>~() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">friend</span> complex <span class="keyword">operator</span>*(<span class="type">double</span> x, <span class="type">const</span> complex &amp;c);</span><br><span class="line">		<span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, complex &amp;c);</span><br><span class="line">		<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> complex &amp;c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>complex0.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;complex0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>()</span><br><span class="line">&#123;</span><br><span class="line">	real = imaginary = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="type">double</span> r, <span class="type">double</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	real = r;</span><br><span class="line">	imaginary = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex complex::<span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;c) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span>(real+c.real, imaginary+c.imaginary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex complex::<span class="keyword">operator</span>-(<span class="type">const</span> complex &amp;c) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span>(real-c.real, imaginary-c.imaginary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex complex::<span class="keyword">operator</span>*(<span class="type">const</span> complex &amp;c) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span>(real*c.real - imaginary*c.imaginary, real*c.imaginary + imaginary*c.real);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex complex::<span class="keyword">operator</span>~() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span>(real, -imaginary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span>*(<span class="type">double</span> x, <span class="type">const</span> complex &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span>(x*c.real, x*c.imaginary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入符重载</span></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, complex &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">	is &gt;&gt; c.real &gt;&gt; c.imaginary;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> complex &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;real = &quot;</span> &lt;&lt; c.real &lt;&lt; <span class="string">&quot;, imaginary = &quot;</span> &lt;&lt; c.imaginary &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;complex0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">complex <span class="title">a</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">	complex c;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter a complex number (q to quit): \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; c)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c is &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;complex conjugate is &quot;</span> &lt;&lt; ~c &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a is &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a + c is &quot;</span> &lt;&lt; a + c &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a - c is &quot;</span> &lt;&lt; a - c &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a * c is &quot;</span> &lt;&lt; a * c &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2 * c is &quot;</span> &lt;&lt; <span class="number">2</span> * c &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter a complex number (q to quit): \n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_232832.png" alt="屏幕截图_20230219_232832"></p>
</li>
</ul>
<h2 id="3-类对象数组的初始化与比较"><a href="#3-类对象数组的初始化与比较" class="headerlink" title="3.类对象数组的初始化与比较"></a>3.类对象数组的初始化与比较</h2><ul>
<li>类对象数组的初始化：通过类的自动类型转换或构造函数初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Stonewt stone_arr[SIZE] = &#123;<span class="number">275</span>, <span class="built_in">Stonewt</span>(<span class="number">285.7</span>), <span class="built_in">Stonewt</span>(<span class="number">21</span>, <span class="number">8</span>)&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>stonewt.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STONEWT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STONEWT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stonewt</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">enum</span>&#123;Lbs_per_stn = <span class="number">14</span>&#125;;</span><br><span class="line">		<span class="type">int</span> stone;</span><br><span class="line">		<span class="type">double</span> pds_left;</span><br><span class="line">		<span class="type">double</span> pounds;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs);</span><br><span class="line">		<span class="built_in">Stonewt</span>(<span class="type">int</span> stn, <span class="type">double</span> lbs);</span><br><span class="line">		<span class="built_in">Stonewt</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span>;</span><br><span class="line">		<span class="type">bool</span> <span class="built_in">operator</span>&lt;=(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span>;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span>;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span>;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span>;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">show_lbs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">show_stn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stonewt.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stonewt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs)</span><br><span class="line">&#123;</span><br><span class="line">	stone = (<span class="type">int</span>)lbs / Lbs_per_stn;</span><br><span class="line">	pds_left = (<span class="type">int</span>)lbs % Lbs_per_stn + lbs - (<span class="type">int</span>)lbs;</span><br><span class="line">	pounds = lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">int</span> stn, <span class="type">double</span> lbs)</span><br><span class="line">&#123;</span><br><span class="line">	stone = stn;</span><br><span class="line">	pds_left = lbs;</span><br><span class="line">	pounds = stn * Lbs_per_stn + lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>()</span><br><span class="line">&#123;</span><br><span class="line">	stone = pds_left = pounds = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Stonewt::<span class="keyword">operator</span>&lt;(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds &lt; s.pounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Stonewt::<span class="keyword">operator</span>&lt;=(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds &lt;= s.pounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Stonewt::<span class="keyword">operator</span>&gt;(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds &gt; s.pounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Stonewt::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds &gt;= s.pounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Stonewt::<span class="keyword">operator</span>==(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds == s.pounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Stonewt::<span class="keyword">operator</span>!=(<span class="type">const</span> Stonewt &amp;s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds != s.pounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stonewt::show_stn</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; stone &lt;&lt; <span class="string">&quot; stone, &quot;</span> &lt;&lt; pds_left &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stonewt::show_lbs</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; pounds &lt;&lt; <span class="string">&quot; pounds.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>stone.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stonewt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//类对象数组的赋值</span></span><br><span class="line">	Stonewt stone_arr[SIZE] = &#123;<span class="number">275</span>, <span class="built_in">Stonewt</span>(<span class="number">285.7</span>), <span class="built_in">Stonewt</span>(<span class="number">21</span>, <span class="number">8</span>)&#125;;</span><br><span class="line">	<span class="type">double</span> input;</span><br><span class="line">	Stonewt max = stone_arr[<span class="number">0</span>];</span><br><span class="line">	Stonewt min = stone_arr[<span class="number">0</span>];</span><br><span class="line">	Stonewt eleven = <span class="built_in">Stonewt</span>(<span class="number">11</span>, <span class="number">0.0</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; SIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter number &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; element.(in pounds)&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; input;</span><br><span class="line">		stone_arr[i] = <span class="built_in">Stonewt</span>(input);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		max = max &gt; stone_arr[i] ? max : stone_arr[i];</span><br><span class="line">		min = min &lt; stone_arr[i] ? min : stone_arr[i];</span><br><span class="line">		<span class="keyword">if</span>(stone_arr[i] &gt; eleven)</span><br><span class="line">			count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The max weigth: &quot;</span>;</span><br><span class="line">	max.<span class="built_in">show_lbs</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The min weight: &quot;</span>;</span><br><span class="line">	min.<span class="built_in">show_lbs</span>();</span><br><span class="line">	cout &lt;&lt; count &lt;&lt; <span class="string">&quot; objects are heavier than eleven&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/08/C++%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%B1%BB/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_234404.png" alt="屏幕截图_20230219_234404"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之类与对象</title>
    <url>/2023/02/02/C++%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>C++之类与对象……</p>
<span id="more"></span>
<h1 id="C-中的类"><a href="#C-中的类" class="headerlink" title="C++中的类"></a>C++中的类</h1><h2 id="1-组成"><a href="#1-组成" class="headerlink" title="1.组成"></a>1.组成</h2><ul>
<li>类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口</li>
<li>类方法定义：描述如何实现类成员函数</li>
</ul>
<h2 id="2-公有与私有"><a href="#2-公有与私有" class="headerlink" title="2.公有与私有"></a>2.公有与私有</h2><ul>
<li>数据成员通常放在私有部分，组成类接口的成员函数放在共有部分</li>
<li>使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数来访问对象的私有成员</li>
<li>类声明中不加关键字默认为private</li>
</ul>
<h2 id="3-类的声明定义与类对象"><a href="#3-类的声明定义与类对象" class="headerlink" title="3.类的声明定义与类对象"></a>3.类的声明定义与类对象</h2><ul>
<li><p>stock00.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STOCK00__H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STOCK00__H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string company;</span><br><span class="line">        <span class="type">long</span> shares;</span><br><span class="line">        <span class="type">double</span> share_val;</span><br><span class="line">        <span class="type">double</span> total_val;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_tot</span><span class="params">(<span class="type">void</span>)</span></span>&#123;total_val=shares*share_val;&#125;<span class="comment">//其为内联函数，函数定义在类的声明中出现</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">(<span class="type">const</span> string &amp;co,<span class="type">long</span> n,<span class="type">double</span> pr)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(<span class="type">long</span> num,<span class="type">double</span> price)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(<span class="type">long</span> num,<span class="type">double</span> price)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">double</span> price)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stock00.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stock00.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::acquire</span><span class="params">(<span class="type">const</span> string &amp;co,<span class="type">long</span> n,<span class="type">double</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    company=co;<span class="comment">//类的成员函数可以直接访问私有数据成员</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of shares can not be negative!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;So set &quot;</span>&lt;&lt;company&lt;&lt;<span class="string">&quot; shares =0&quot;</span>&lt;&lt;endl;</span><br><span class="line">        shares=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shares=n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    share_val=pr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="type">long</span> num,<span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of shares you buy can not be negative!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shares+=num;</span><br><span class="line">        share_val=price;</span><br><span class="line">        <span class="built_in">set_tot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="type">long</span> num,<span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of shares you sell can not be negative!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num&gt;shares)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;You can not sell more than you have!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        shares-=num;</span><br><span class="line">        share_val=price;</span><br><span class="line">        <span class="built_in">set_tot</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::update</span><span class="params">(<span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    share_val=price;</span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Company:&quot;</span>&lt;&lt;company&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Shares:&quot;</span>&lt;&lt;shares&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Share Price:&quot;</span>&lt;&lt;share_val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Total Worth:&quot;</span>&lt;&lt;total_val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stock00.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个类的对象</span></span><br><span class="line">    Stock sto;</span><br><span class="line">    sto.<span class="built_in">acquire</span>(<span class="string">&quot;NanoSmart&quot;</span>,<span class="number">20</span>,<span class="number">12.5</span>);</span><br><span class="line">    sto.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    sto.<span class="built_in">buy</span>(<span class="number">15</span>,<span class="number">17.125</span>);</span><br><span class="line">    sto.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    sto.<span class="built_in">sell</span>(<span class="number">400</span>,<span class="number">20</span>);</span><br><span class="line">    sto.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    sto.<span class="built_in">buy</span>(<span class="number">3000</span>,<span class="number">40.125</span>);</span><br><span class="line">    sto.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    sto.<span class="built_in">sell</span>(<span class="number">1000</span>,<span class="number">100</span>);</span><br><span class="line">    sto.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/02/C++%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20230207215318666.png" alt="image-20230207215318666"></p>
</li>
</ul>
<h2 id="4-类的构造函数与析构函数"><a href="#4-类的构造函数与析构函数" class="headerlink" title="4.类的构造函数与析构函数"></a>4.类的构造函数与析构函数</h2><h3 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h3><ul>
<li><p>类构造函数就是用来初始化的</p>
</li>
<li><p>构造函数的名称与类名一样，构造函数没有返回值</p>
</li>
<li><p>用户自定义构造函数的调用： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stock</span>(<span class="type">const</span> string &amp;co,<span class="type">long</span> n,<span class="type">double</span> pr);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>(<span class="type">const</span> string &amp;co,<span class="type">long</span> n,<span class="type">double</span> pr)</span><br><span class="line">&#123;</span><br><span class="line">    company=co;<span class="comment">//类的成员函数可以直接访问私有数据成员</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of shares can not be negative!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;So set &quot;</span>&lt;&lt;company&lt;&lt;<span class="string">&quot; shares =0&quot;</span>&lt;&lt;endl;</span><br><span class="line">        shares=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shares=n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    share_val=pr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>显示调用：<code>Stock garment = Stock(&quot;Furry&quot;, 50 ,2.5);</code></li>
<li>隐式调用：<code>Stock garment (&quot;Furry&quot;, 50 ,2.5);</code></li>
</ul>
</li>
<li><p><strong>默认构造函数的两种定义方式</strong>：</p>
<ul>
<li><p><strong>给构造函数的所有参数提供默认值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//默认构造函数定义方法1</span></span><br><span class="line">    <span class="built_in">Stock</span>(<span class="type">const</span> string &amp;co=<span class="string">&quot;Error&quot;</span>,<span class="type">long</span> n=<span class="number">0</span>,<span class="type">double</span> pr=<span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>(<span class="type">const</span> string &amp;co,<span class="type">long</span> n,<span class="type">double</span> pr)</span><br><span class="line">&#123;</span><br><span class="line">    company=co;<span class="comment">//类的成员函数可以直接访问私有数据成员</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of shares can not be negative!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;So set &quot;</span>&lt;&lt;company&lt;&lt;<span class="string">&quot; shares =0&quot;</span>&lt;&lt;endl;</span><br><span class="line">        shares=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shares=n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    share_val=pr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>没有参数的构造函数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//默认构造函数定义方法2</span></span><br><span class="line">    <span class="built_in">Stock</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">    company=<span class="string">&quot;Error&quot;</span>;</span><br><span class="line">    shares=<span class="number">0</span>;</span><br><span class="line">    share_val=<span class="number">0</span>;</span><br><span class="line">    total_val=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>默认构造函数的两种调用方式</strong>：</p>
<ul>
<li>隐式调用：<code>Stock garment;</code></li>
<li>显示调用：<code>stock garment=stock();</code></li>
</ul>
</li>
</ul>
<h3 id="4-2-析构函数"><a href="#4-2-析构函数" class="headerlink" title="4.2 析构函数"></a>4.2 析构函数</h3><ul>
<li><p>析构函数完成清理工作，例：如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存</p>
</li>
<li><p>析构函数的名称是在类名前加上<code>~</code>，析构函数没有返回值和声明类型，例：<code>~Stock()</code></p>
</li>
<li><p>当对象被删除时，程序将调用析构函数，每个类只能由一个析构函数</p>
</li>
<li><p>stock00.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STOCK00__H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STOCK00__H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string company;</span><br><span class="line">        <span class="type">long</span> shares;</span><br><span class="line">        <span class="type">double</span> share_val;</span><br><span class="line">        <span class="type">double</span> total_val;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_tot</span><span class="params">(<span class="type">void</span>)</span></span>&#123;total_val=shares*share_val;&#125;<span class="comment">//其为内联函数，函数定义在类的声明中出现</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//默认构造函数定义方法1</span></span><br><span class="line">        <span class="comment">//Stock(const string &amp;co=&quot;Error&quot;,long n=0,double pr=0.0);</span></span><br><span class="line">        <span class="comment">//默认构造函数定义方法2</span></span><br><span class="line">        <span class="built_in">Stock</span>();</span><br><span class="line">        <span class="built_in">Stock</span>(<span class="type">const</span> string &amp;co,<span class="type">long</span> n,<span class="type">double</span> pr);</span><br><span class="line">        <span class="comment">//析构函数</span></span><br><span class="line">        ~<span class="built_in">Stock</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(<span class="type">long</span> num,<span class="type">double</span> price)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(<span class="type">long</span> num,<span class="type">double</span> price)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">double</span> price)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stock00.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stock00.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的定义</span></span><br><span class="line">Stock::<span class="built_in">Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">    company=<span class="string">&quot;Error&quot;</span>;</span><br><span class="line">    shares=<span class="number">0</span>;</span><br><span class="line">    share_val=<span class="number">0</span>;</span><br><span class="line">    total_val=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stock::<span class="built_in">Stock</span>(<span class="type">const</span> string &amp;co,<span class="type">long</span> n,<span class="type">double</span> pr)</span><br><span class="line">&#123;</span><br><span class="line">    company=co;<span class="comment">//类的成员函数可以直接访问私有数据成员</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of shares can not be negative!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;So set &quot;</span>&lt;&lt;company&lt;&lt;<span class="string">&quot; shares =0&quot;</span>&lt;&lt;endl;</span><br><span class="line">        shares=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shares=n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    share_val=pr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::~<span class="built_in">Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Bye &quot;</span>&lt;&lt;company&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="type">long</span> num,<span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of shares you buy can not be negative!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shares+=num;</span><br><span class="line">        share_val=price;</span><br><span class="line">        <span class="built_in">set_tot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="type">long</span> num,<span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of shares you sell can not be negative!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num&gt;shares)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;You can not sell more than you have!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shares-=num;</span><br><span class="line">        share_val=price;</span><br><span class="line">        <span class="built_in">set_tot</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::update</span><span class="params">(<span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    share_val=price;</span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Company:&quot;</span>&lt;&lt;company&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Shares:&quot;</span>&lt;&lt;shares&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Share Price:&quot;</span>&lt;&lt;share_val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Total Worth:&quot;</span>&lt;&lt;total_val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stock00.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stock garment;</span><br><span class="line">    garment.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Stock <span class="title">sto</span><span class="params">(<span class="string">&quot;NanoSmart&quot;</span>,<span class="number">20</span>,<span class="number">12.5</span>)</span></span>;</span><br><span class="line">    sto.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Stock <span class="title">sto2</span><span class="params">(<span class="string">&quot;Fultty&quot;</span>,<span class="number">50</span>,<span class="number">20.7</span>)</span></span>;</span><br><span class="line">    sto2.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//类对象之间可以直接赋值</span></span><br><span class="line">    sto=sto2;</span><br><span class="line">    sto.<span class="built_in">show</span>();</span><br><span class="line">    sto2.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/02/C++%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20230208120000805.png" alt="image-20230208120000805"></p>
</li>
</ul>
<h2 id="5-const成员函数"><a href="#5-const成员函数" class="headerlink" title="5.const成员函数"></a>5.const成员函数</h2><ul>
<li><strong>在类方法后加上const，能保证类方法不修改调用对象</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Company:&quot;</span>&lt;&lt;company&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Shares:&quot;</span>&lt;&lt;shares&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Share Price:&quot;</span>&lt;&lt;share_val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Total Worth:&quot;</span>&lt;&lt;total_val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> Stock <span class="title">csto</span><span class="params">(<span class="string">&quot;Huawei&quot;</span>,<span class="number">89</span>,<span class="number">12.3</span>)</span></span>;</span><br><span class="line">    csto.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><ul>
<li><p><strong>this指针指向调用成员函数的那个对象</strong></p>
</li>
<li><p><strong>this是对象的地址，*this才是对象本身</strong></p>
</li>
<li><p>stock10.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STOCK10__H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STOCK10__H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string company;</span><br><span class="line">        <span class="type">long</span> shares;</span><br><span class="line">        <span class="type">double</span> share_val;</span><br><span class="line">        <span class="type">double</span> total_val;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_tot</span><span class="params">(<span class="type">void</span>)</span></span>&#123;total_val=shares*share_val;&#125;<span class="comment">//其为内联函数，函数定义在类的声明中出现</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//默认构造函数定义方法1</span></span><br><span class="line">        <span class="comment">//Stock(const string &amp;co=&quot;Error&quot;,long n=0,double pr=0.0);</span></span><br><span class="line">        <span class="comment">//默认构造函数定义方法2</span></span><br><span class="line">        <span class="built_in">Stock</span>();</span><br><span class="line">        <span class="built_in">Stock</span>(<span class="type">const</span> string &amp;co,<span class="type">long</span> n,<span class="type">double</span> pr);</span><br><span class="line">        <span class="comment">//析构函数</span></span><br><span class="line">        ~<span class="built_in">Stock</span>();</span><br><span class="line">        <span class="function"><span class="type">const</span> Stock &amp; <span class="title">topval</span><span class="params">(<span class="type">const</span> Stock &amp;s)</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stock10.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stock10.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的定义</span></span><br><span class="line">Stock::<span class="built_in">Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">    company=<span class="string">&quot;Error&quot;</span>;</span><br><span class="line">    shares=<span class="number">0</span>;</span><br><span class="line">    share_val=<span class="number">0</span>;</span><br><span class="line">    total_val=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stock::<span class="built_in">Stock</span>(<span class="type">const</span> string &amp;co,<span class="type">long</span> n,<span class="type">double</span> pr)</span><br><span class="line">&#123;</span><br><span class="line">    company=co;<span class="comment">//类的成员函数可以直接访问私有数据成员</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of shares can not be negative!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;So set &quot;</span>&lt;&lt;company&lt;&lt;<span class="string">&quot; shares =0&quot;</span>&lt;&lt;endl;</span><br><span class="line">        shares=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        shares=n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    share_val=pr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::~<span class="built_in">Stock</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Bye &quot;</span>&lt;&lt;company&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Stock &amp; <span class="title">Stock::topval</span><span class="params">(<span class="type">const</span> Stock &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.total_val&gt;total_val) <span class="comment">//这里的total_val代表this-&gt;total_val</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Company:&quot;</span>&lt;&lt;company&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Shares:&quot;</span>&lt;&lt;shares&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Share Price:&quot;</span>&lt;&lt;share_val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Total Worth:&quot;</span>&lt;&lt;total_val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stock10.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Stock <span class="title">sto</span><span class="params">(<span class="string">&quot;NanoSmart&quot;</span>,<span class="number">20</span>,<span class="number">12.5</span>)</span></span>;</span><br><span class="line">    sto.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Stock <span class="title">csto</span><span class="params">(<span class="string">&quot;Huawei&quot;</span>,<span class="number">89</span>,<span class="number">12.3</span>)</span></span>;</span><br><span class="line">    csto.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The max is:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Stock top=sto.<span class="built_in">topval</span>(csto);</span><br><span class="line">    top.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/02/C++%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20230208164703776.png" alt="image-20230208164703776"></p>
</li>
</ul>
<hr>
<h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stock10.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> STKS=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建类对象：与创建数组一样</span></span><br><span class="line">    <span class="comment">//并给对象赋初始值</span></span><br><span class="line">    Stock stocks[STKS]=&#123;</span><br><span class="line">        <span class="built_in">Stock</span>(<span class="string">&quot;NanoSmart&quot;</span>,<span class="number">12</span>,<span class="number">20</span>),</span><br><span class="line">        <span class="built_in">Stock</span>(<span class="string">&quot;Boffo Object&quot;</span>,<span class="number">200</span>,<span class="number">2.0</span>),</span><br><span class="line">        <span class="built_in">Stock</span>(<span class="string">&quot;Mono&quot;</span>,<span class="number">130</span>,<span class="number">3.25</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//显示创建的类对象数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> st=<span class="number">0</span>;st&lt;STKS;st++)</span><br><span class="line">    &#123;</span><br><span class="line">        stocks[st].<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出对象数组中价值最大的股票</span></span><br><span class="line">    <span class="type">const</span> Stock *top=&amp;stocks[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> st=<span class="number">1</span>;st&lt;STKS;st++)</span><br><span class="line">    &#123;</span><br><span class="line">        top=&amp;top-&gt;<span class="built_in">topval</span>(stocks[st]);</span><br><span class="line">    &#125;</span><br><span class="line">    top-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2023/02/02/C++%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20230208171159900.png" alt="image-20230208171159900"></p>
<hr>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><ul>
<li><p>利用类实现栈操作</p>
</li>
<li><p>stack.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STAKC_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STACK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="comment">//作用域为类的常量表示方法1：enum</span></span><br><span class="line">		<span class="keyword">enum</span> &#123;MAX = <span class="number">10</span>&#125;;</span><br><span class="line">    	<span class="comment">//作用域为类的常量表示方法2：利用static关键字</span></span><br><span class="line">    	<span class="comment">//static const int MAX=10;</span></span><br><span class="line">		Item items[MAX];</span><br><span class="line">		<span class="type">int</span> top;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>();</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Item &amp;item)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Item &amp;item)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stack.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Stack::<span class="built_in">Stack</span>()</span><br><span class="line">&#123;</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::isempty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::isfull</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(Item &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top &lt; MAX)</span><br><span class="line">	&#123;</span><br><span class="line">		items[top++] = item;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::pop</span><span class="params">(Item &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		item = items[--top];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>stacker.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> po;</span><br><span class="line">	Stack st;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please etner A to push to stack, \n&quot;</span></span><br><span class="line">	     &lt;&lt; <span class="string">&quot;P to pop from stack, Q to quit.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; ch &amp;&amp; <span class="built_in">toupper</span>(ch) != <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Enter a number you want to push to stack:\n&quot;</span>;</span><br><span class="line">				cin &gt;&gt; po;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;----------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">				<span class="keyword">if</span>(st.<span class="built_in">isfull</span>())</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;Stack already full&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					st.<span class="built_in">push</span>(po);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">				<span class="keyword">if</span>(st.<span class="built_in">isempty</span>())</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;Stack is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					st.<span class="built_in">pop</span>(po);</span><br><span class="line">					cout &lt;&lt; po &lt;&lt; <span class="string">&quot; is poped&quot;</span> &lt;&lt; endl;</span><br><span class="line">					cout&lt;&lt;<span class="string">&quot;----------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please enter A to push to stack, \n&quot;</span></span><br><span class="line">	     	     &lt;&lt; <span class="string">&quot;P to pop from stack, Q to quit.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/02/C++%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20230208182407710.png" alt="image-20230208182407710"></p>
</li>
</ul>
<hr>
<h1 id="实例：类实现简单列表"><a href="#实例：类实现简单列表" class="headerlink" title="实例：类实现简单列表"></a>实例：类实现简单列表</h1><ul>
<li><p>list.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit_item</span><span class="params">(Item &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">enum</span> &#123;MAX = <span class="number">10</span>&#125;;</span><br><span class="line">		Item items[MAX];</span><br><span class="line">		<span class="type">int</span> top;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">List</span>();</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(Item &amp;item)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(<span class="type">void</span> (*pf)(Item &amp;))</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>list.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">List::<span class="built_in">List</span>()</span><br><span class="line">&#123;</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List::isempty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List::isfull</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List::add</span><span class="params">(Item &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top &lt; MAX)</span><br><span class="line">	&#123;</span><br><span class="line">		items[top++] = item;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List::visit</span><span class="params">(<span class="type">void</span> (*pf)(Item &amp;))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">		<span class="built_in">pf</span>(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit_item</span><span class="params">(Item &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Item = &quot;</span> &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List list;</span><br><span class="line">	Item num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please enter a number: &quot;</span>;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		list.<span class="built_in">add</span>(num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list.<span class="built_in">visit</span>(visit_item);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2023/02/02/C++%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20230208203815674.png" alt="image-20230208203815674"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog之由浅入深学习</title>
    <url>/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文主要利用Vivado工具，结合实际应用进行巩固学习，重点对设计思路进行理解</p>
<span id="more"></span>
<h1 id="PLL的IP核配置"><a href="#PLL的IP核配置" class="headerlink" title="PLL的IP核配置"></a>PLL的IP核配置</h1><h2 id="1-配置过程"><a href="#1-配置过程" class="headerlink" title="1.配置过程"></a>1.配置过程</h2><ul>
<li><p>PLL实际相当于FPGA内部的一个时钟管理模块，能提供不同频率、相位、占空比的时钟</p>
</li>
<li><p>配置过程：</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105112155627.png" alt="image-20230105112155627"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105105058413.png" alt="image-20230105105058413" style="zoom: 50%;"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105105258480.png" alt="image-20230105105258480" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="2-实例应用"><a href="#2-实例应用" class="headerlink" title="2.实例应用"></a>2.实例应用</h2><ul>
<li>利用PLL进行时钟分频，并通过PLL产生的4个不同频率的时钟，分别驱动4个LED指示灯闪烁一样的频率</li>
</ul>
<h3 id="2-1源文件"><a href="#2-1源文件" class="headerlink" title="2.1源文件"></a>2.1源文件</h3><ul>
<li><p>PLL_design.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> PLL_design(</span><br><span class="line">	<span class="keyword">input</span> i_sys_clk,	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">	<span class="keyword">input</span> i_rst_n,	<span class="comment">//外部输入复位信号，低电平有效			</span></span><br><span class="line">	<span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] o_led		<span class="comment">//8个LED指示灯亮灭控制</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> clk_12m5;	<span class="comment">//PLL输出12.5MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_25m;	<span class="comment">//PLL输出25MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_50m;	<span class="comment">//PLL输出50MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_100m;	<span class="comment">//PLL输出100MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> sys_rst_n;	<span class="comment">//PLL输出的locked信号，作为FPGA内部的复位信号，低电平复位，高电平正常工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//`define SIMULATION_AT7 //仿真取消注释，实际应用则加上注释</span></span><br><span class="line">    <span class="meta">`<span class="keyword">ifdef</span> SIMULATION_AT7</span></span><br><span class="line">    	<span class="meta">`<span class="keyword">define</span>	PARAMETER_COUNTER	9</span></span><br><span class="line">    <span class="meta">`<span class="keyword">else</span></span></span><br><span class="line">    	<span class="meta">`<span class="keyword">define</span>	PARAMETER_COUNTER	23</span></span><br><span class="line">    <span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    clk_wiz_0 clk_wiz_0_U1(</span><br><span class="line">    <span class="comment">// Clock out ports</span></span><br><span class="line">    <span class="variable">.clk_out1</span>(clk_12m5),     <span class="comment">// output clk_out1</span></span><br><span class="line">    <span class="variable">.clk_out2</span>(clk_25m),     <span class="comment">// output clk_out2</span></span><br><span class="line">    <span class="variable">.clk_out3</span>(clk_50m),     <span class="comment">// output clk_out3</span></span><br><span class="line">    <span class="variable">.clk_out4</span>(clk_100m),     <span class="comment">// output clk_out4</span></span><br><span class="line">    <span class="comment">// Status and control signals</span></span><br><span class="line">    <span class="variable">.reset</span>(!i_rst_n), <span class="comment">// input reset</span></span><br><span class="line">    <span class="variable">.locked</span>(sys_rst_n),       <span class="comment">// output locked</span></span><br><span class="line">    <span class="comment">// Clock in ports</span></span><br><span class="line">    <span class="variable">.clk_in1</span>(i_sys_clk)      <span class="comment">// input clk_in1</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//12.5MHz时钟进行分频闪烁，计数器为23位															</span></span><br><span class="line">    led_controller	<span class="variable">#(`PARAMETER_COUNTER)</span>		</span><br><span class="line">    u2_led_controller_clk12m5(</span><br><span class="line">    	<span class="variable">.clk</span>(clk_12m5),		<span class="comment">//时钟信号</span></span><br><span class="line">    	<span class="variable">.rst_n</span>(sys_rst_n),	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.sled</span>(o_led[<span class="number">0</span>])		<span class="comment">//LED指示灯接口	</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//25MHz时钟进行分频闪烁，计数器为24位																</span></span><br><span class="line">    led_controller	<span class="variable">#(`PARAMETER_COUNTER+1)</span>		</span><br><span class="line">    u3_led_controller_clk25m(</span><br><span class="line">    	<span class="variable">.clk</span>(clk_25m),		<span class="comment">//时钟信号</span></span><br><span class="line">    	<span class="variable">.rst_n</span>(sys_rst_n),	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.sled</span>(o_led[<span class="number">1</span>])		<span class="comment">//LED指示灯接口	</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//50MHz时钟进行分频闪烁，计数器为25位																</span></span><br><span class="line">    led_controller	<span class="variable">#(`PARAMETER_COUNTER+2)</span>		</span><br><span class="line">    u4_led_controller_clk50m(</span><br><span class="line">    	<span class="variable">.clk</span>(clk_50m),		<span class="comment">//时钟信号</span></span><br><span class="line">    	<span class="variable">.rst_n</span>(sys_rst_n),	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.sled</span>(o_led[<span class="number">2</span>])		<span class="comment">//LED指示灯接口	</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//100MHz时钟进行分频闪烁，计数器为26位																</span></span><br><span class="line">    led_controller	<span class="variable">#(`PARAMETER_COUNTER+3)</span>		</span><br><span class="line">    u5_led_controller_clk100m(</span><br><span class="line">    	<span class="variable">.clk</span>(clk_100m),		<span class="comment">//时钟信号</span></span><br><span class="line">    	<span class="variable">.rst_n</span>(sys_rst_n),	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.sled</span>(o_led[<span class="number">3</span>])		<span class="comment">//LED指示灯接口	</span></span><br><span class="line">    );		</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------							</span></span><br><span class="line">    <span class="comment">//高4位LED指示灯关闭							</span></span><br><span class="line">    <span class="keyword">assign</span> o_led[<span class="number">7</span>:<span class="number">4</span>] = <span class="number">4&#x27;b1111</span>;			</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>led_controller.v</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> led_controller(</span><br><span class="line">	<span class="keyword">input</span> clk,		<span class="comment">//时钟信号</span></span><br><span class="line">	<span class="keyword">input</span> rst_n,	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">	<span class="keyword">output</span> sled		<span class="comment">//LED指示灯接口	</span></span><br><span class="line">	);													</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">parameter</span> CNT_HIGH = <span class="number">24</span>;	<span class="comment">//计数器最高位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="keyword">reg</span>[(CNT_HIGH-<span class="number">1</span>):<span class="number">0</span>] cnt;		<span class="comment">//24位计数器															</span></span><br><span class="line">    <span class="comment">//cnt计数器进行循环计数</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span>								</span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            cnt &lt;= <span class="number">0</span>;											</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= cnt+<span class="number">1&#x27;b1</span>;																		</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> sled = cnt[CNT_HIGH-<span class="number">1</span>];		</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2Testbench"><a href="#2-2Testbench" class="headerlink" title="2.2Testbench"></a>2.2Testbench</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> PLL_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> sys_clk_i;	<span class="comment">//50MHz时钟信号</span></span><br><span class="line">    <span class="keyword">reg</span> ext_rst_n;	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] led;	<span class="comment">//8个LED指示灯接口	</span></span><br><span class="line">    </span><br><span class="line">    PLL_design PLL_design_U1(</span><br><span class="line">    	<span class="variable">.i_sys_clk</span>(sys_clk_i),	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">    	<span class="variable">.i_rst_n</span>(ext_rst_n),	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.o_led</span>(led)		<span class="comment">//8个LED指示灯接口	</span></span><br><span class="line">    );			</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	sys_clk_i &lt;= <span class="number">0</span>;</span><br><span class="line">    	ext_rst_n &lt;= <span class="number">0</span>;	<span class="comment">//复位中</span></span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	@(<span class="keyword">posedge</span> sys_clk_i); #<span class="number">2</span>;</span><br><span class="line">    	ext_rst_n &lt;= <span class="number">1</span>;	<span class="comment">//复位结束，正常工作</span></span><br><span class="line">    	#<span class="number">200_000</span>;</span><br><span class="line">    	<span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> sys_clk_i &lt;= ~sys_clk_i;	<span class="comment">//50MHz时钟产生</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3仿真结果"><a href="#2-3仿真结果" class="headerlink" title="2.3仿真结果"></a>2.3仿真结果</h3><p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105110145328.png" alt="image-20230105110145328"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105110200795.png" alt="image-20230105110200795"></p>
<hr>
<h1 id="自定义IP核的创建与配置"><a href="#自定义IP核的创建与配置" class="headerlink" title="自定义IP核的创建与配置"></a>自定义IP核的创建与配置</h1><h2 id="1-IP核的创建"><a href="#1-IP核的创建" class="headerlink" title="1.IP核的创建"></a>1.IP核的创建</h2><p>工程源码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> led_controller(</span><br><span class="line">    <span class="keyword">input</span> i_clk, <span class="comment">//时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> i_rst_n, <span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">output</span> o_sled <span class="comment">//LED 指示灯接口</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> CLK_FREQUENCY = <span class="number">25000</span>; <span class="comment">//clk 的时钟频率，KHz</span></span><br><span class="line">    <span class="keyword">parameter</span> LED_FLASH_FREQUENCY = <span class="number">1</span>; <span class="comment">//LED 输出的闪烁频率，Hz</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cnt 分频计数最大值</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> MAX_CNT ((CLK_FREQUENCY*1000/LED_FLASH_FREQUENCY)-1)</span></span><br><span class="line">    <span class="comment">//cnt 分频计数最大值的一半</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> MAX_CNT_DIV2 (`MAX_CNT/2-1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] cnt; <span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cnt 计数器进行循环计数</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> i_clk <span class="keyword">or</span> <span class="keyword">negedge</span> i_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            cnt &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt; `MAX_CNT) </span><br><span class="line">            cnt &lt;= cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_sled = (cnt &lt; `MAX_CNT_DIV2) ? <span class="number">1&#x27;b1</span>:<span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105114939129.png" alt="image-20230105114939129"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105114641913.png" alt="image-20230105114641913"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105114807577.png" alt="image-20230105114807577"></p>
<h2 id="2-IP核的配置"><a href="#2-IP核的配置" class="headerlink" title="2.IP核的配置"></a>2.IP核的配置</h2><ul>
<li><p>配置页面：</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105115328827.png" alt="image-20230105115328827"></p>
</li>
<li><p><strong>第一个配置页面名为 Identification</strong>，即用户定制 IP 核相关的配置信息，如 IP 核供应商（Vendor）、库名称 （Library）、IP 核名称（Name）、版本号（Version）、IP 核显示名称（Display name）、描 述（Description）、供应商显示名称（Vendor display name）、公司网址（Company url） 等。特别提醒大家别忽略了最下面的 Categories 项，默认是空白的，若点击右侧的小加号， 可以增加一个名称，例如本实例增加了一个名为 UserIP 的名称选项，将来生成的用户定制 IP 核在我们的 IP 核配置面板中将会归类到名为 UserIP 类别的文件夹下</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105115813666.png" alt="image-20230105115813666"></p>
</li>
<li><p><strong>第二个配置页面名为Compatibility</strong>，即设定该 IP 核所支持的器件家族（Family）</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105115838942.png" alt="image-20230105115838942"></p>
</li>
<li><p><strong>第三个配置页面名为File Groups</strong>，可以预览 IP 核包含的相关源码文件，在源码工程中包含的所有Verilog源码或者仿真测试脚本，也都会出现在这里，被集成到IP核中</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105115905275.png" alt="image-20230105115905275"></p>
</li>
<li><p><strong>第四个配置页面名为Customization Parameters</strong>，配置页面罗列源码中所有可配置的参数 （即parameter 所定义的）</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105120008185.png" alt="image-20230105120008185"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105120047146.png" alt="image-20230105120047146" style="zoom: 50%;"></p>
</li>
<li><p><strong>第五个配置页面名为Ports and Interfaces</strong>，配置页面显示IP核的对外接口</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105120323311.png" alt="image-20230105120323311"></p>
</li>
<li><p><strong>第六个配置页面名为Addressing and Memory</strong>，配置页面则是针对含有总线接口，并且具有 多个寄存器需要寻址的 IP 核，我们的 IP 核则不需要，所以是空白的</p>
</li>
<li><p><strong>第七个配置页面名为Customization GUI</strong>，配置页面则显示当前接口在 GUI 上的 layout 和 preview 信息</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105120559933.png" alt="image-20230105120559933"></p>
</li>
<li><p><strong>第八个配置页面名为Review and Package</strong>，在这里点击Package IP完成IP核的配置</p>
</li>
<li><p>打开 IP Catalog 后，我们可以看到刚刚定义的用户 IP 核 led_controller_v1_0 已经出现在了 UserIP 文件夹下面</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105121227412.png" alt="image-20230105121227412"></p>
</li>
</ul>
<h2 id="3-移植IP核"><a href="#3-移植IP核" class="headerlink" title="3.移植IP核"></a>3.移植IP核</h2><ul>
<li><p><strong>找到创建IP核时所保存的位置，复制以下三个文件</strong></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105124655320.png" alt="image-20230105124655320"></p>
</li>
<li><p><strong>在另一工程的ip文件夹下创建led_controller的文件夹</strong></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105124900805.png" alt="image-20230105124900805"></p>
</li>
<li><p><strong>将刚刚复制的三个文件粘贴于此</strong></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105125001515.png" alt="image-20230105125001515"></p>
</li>
<li><p><strong>在新工程中按如下图所示操作</strong></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105125355216.png" alt="image-20230105125355216"></p>
</li>
<li><p><strong>添加led_controller所在路径</strong></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105125543056.png" alt="image-20230105125543056"></p>
</li>
<li><p>最终可以在IP Catalog中看到此自定义IP</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230105125650162.png" alt="image-20230105125650162"></p>
</li>
</ul>
<hr>
<h1 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖"></a>按键消抖</h1><h2 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h2><ul>
<li><p>思路：每过20ms（在20ms内检测到有按键按下，则认为是抖动，计数器清零）才将输入的按键值锁存，当两次锁存的按键值发生变化时，则有相应按键按下</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230106121303404.png" alt="image-20230106121303404" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-源代码"><a href="#2-源代码" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Key_filter_design(</span><br><span class="line">	<span class="keyword">input</span> i_clk,	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">	<span class="keyword">input</span> i_rst_n,	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>] i_key_h,	<span class="comment">//4个独立按键输入，未按下为高电平，按下后为低电平</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] o_led		<span class="comment">//8个LED指示灯接口	</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//按键抖动判断逻辑</span></span><br><span class="line">    <span class="keyword">wire</span> key;	<span class="comment">//所有按键值相与的结果，用于按键触发判断</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] keyr;  <span class="comment">//按键值key的缓存寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> key = i_key_h[<span class="number">0</span>] &amp; i_key_h[<span class="number">1</span>] &amp; i_key_h[<span class="number">2</span>] &amp; i_key_h[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk <span class="keyword">or</span> <span class="keyword">negedge</span> i_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!i_rst_n) </span><br><span class="line">            keyr &lt;= <span class="number">2&#x27;b11</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            keyr &lt;= &#123;keyr[<span class="number">0</span>],key&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> key_neg = ~keyr[<span class="number">0</span>] &amp; keyr[<span class="number">1</span>];	<span class="comment">//有按键被按下	</span></span><br><span class="line">    <span class="keyword">wire</span> key_pos = keyr[<span class="number">0</span>] &amp; ~keyr[<span class="number">1</span>];	<span class="comment">//有按键被释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//定时计数20ms时间，用于对按键的消抖判断</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">19</span>:<span class="number">0</span>]  cnt;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按键消抖定时计数器</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> i_clk <span class="keyword">or</span> <span class="keyword">negedge</span> i_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!i_rst_n) </span><br><span class="line">            cnt &lt;= <span class="number">20&#x27;d0</span>;	</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(key_pos || key_neg) </span><br><span class="line">            cnt &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt; <span class="number">20&#x27;d999_999</span>) </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] key_halue[<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//定时采集按键值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk <span class="keyword">or</span> <span class="keyword">negedge</span> i_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!i_rst_n) <span class="keyword">begin</span></span><br><span class="line">    		key_halue[<span class="number">0</span>] &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    		key_halue[<span class="number">1</span>] &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line">    		key_halue[<span class="number">1</span>] &lt;= key_halue[<span class="number">0</span>];		</span><br><span class="line">    		<span class="keyword">if</span>(cnt == <span class="number">20&#x27;d999_999</span>) </span><br><span class="line">                key_halue[<span class="number">0</span>] &lt;= i_key_h;	<span class="comment">//定时键值采集</span></span><br><span class="line">    		<span class="keyword">else</span> ;	</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是哪个按键按下</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] key_press = key_halue[<span class="number">1</span>] &amp; ~key_halue[<span class="number">0</span>];		<span class="comment">//消抖后按键值变化标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//LED切换控制</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> i_clk <span class="keyword">or</span> <span class="keyword">negedge</span> i_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!i_rst_n) </span><br><span class="line">            o_led &lt;= <span class="number">8&#x27;hff</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key_press[<span class="number">0</span>]) </span><br><span class="line">            o_led[<span class="number">0</span>] &lt;= ~o_led[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(key_press[<span class="number">1</span>]) </span><br><span class="line">            o_led[<span class="number">1</span>] &lt;= ~o_led[<span class="number">1</span>];</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(key_press[<span class="number">2</span>]) </span><br><span class="line">            o_led[<span class="number">2</span>] &lt;= ~o_led[<span class="number">2</span>];</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(key_press[<span class="number">3</span>]) </span><br><span class="line">            o_led[<span class="number">3</span>] &lt;= ~o_led[<span class="number">3</span>];</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench"><a href="#3-Testbench" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Key_filter_tb;</span><br><span class="line">    <span class="keyword">reg</span> sys_clk_i;	<span class="comment">//50MHz时钟信号</span></span><br><span class="line">    <span class="keyword">reg</span> ext_rst_n;	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] key_h;	<span class="comment">//4个独立按键输入，未按下为高电平，按下后为低电平</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] led;	<span class="comment">//8个LED指示灯接口		</span></span><br><span class="line">    </span><br><span class="line">    Key_filter_design Key_filter_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(sys_clk_i),	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">        <span class="variable">.i_rst_n</span>(ext_rst_n),	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">        <span class="variable">.i_key_h</span>(key_h),</span><br><span class="line">        <span class="variable">.o_led</span>(led)		<span class="comment">//8个LED指示灯接口	</span></span><br><span class="line">    );			</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	sys_clk_i = <span class="number">0</span>;</span><br><span class="line">    	ext_rst_n = <span class="number">0</span>;	<span class="comment">//复位中</span></span><br><span class="line">    	key_h = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	@(<span class="keyword">posedge</span> sys_clk_i); #<span class="number">2</span>;</span><br><span class="line">    	ext_rst_n = <span class="number">1</span>;	<span class="comment">//复位结束，正常工作</span></span><br><span class="line">    	@(<span class="keyword">posedge</span> sys_clk_i); #<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//模拟按键抖动（实际未被按下）</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	#<span class="number">1_000_000</span>;	<span class="comment">//1ms</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	#<span class="number">5_000_000</span>;	<span class="comment">//5ms	</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	#<span class="number">3_000_000</span>;	<span class="comment">//3ms	</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b1</span>;	</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//模拟按键动作</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	#<span class="number">1_000_000</span>;	<span class="comment">//1ms</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	#<span class="number">5_000_000</span>;	<span class="comment">//5ms	</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	#<span class="number">3_000_000</span>;	<span class="comment">//3ms	</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    	#<span class="number">3_000_000</span>;	<span class="comment">//3ms	</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	#<span class="number">500_000_000</span>;	<span class="comment">//500ms，按下</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b1</span>;	</span><br><span class="line">    	#<span class="number">3_000_000</span>;	<span class="comment">//3ms	</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	#<span class="number">3_000_000</span>;	<span class="comment">//3ms	</span></span><br><span class="line">    	key_h[<span class="number">0</span>] = <span class="number">1&#x27;b1</span>;	</span><br><span class="line">    </span><br><span class="line">    	#<span class="number">50_000_000</span>;</span><br><span class="line">    	<span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> sys_clk_i = ~sys_clk_i;	<span class="comment">//50MHz时钟产生</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果"><a href="#4-仿真结果" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230106124156404.png" alt="image-20230106124156404"></p>
<hr>
<h1 id="数码管显示"><a href="#数码管显示" class="headerlink" title="数码管显示"></a>数码管显示</h1><h2 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1.思路"></a>1.思路</h2><ul>
<li><p>通过8bit的分时计数器div_cnt，每隔64个时钟周期显示一个数码管</p>
</li>
<li><p>片选数码管与显示数据的同步，此处时序很妙</p>
</li>
</ul>
<h2 id="2-源代码-1"><a href="#2-源代码-1" class="headerlink" title="2.源代码"></a>2.源代码</h2><ul>
<li>Seg8_display_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Seg8_display_design(</span><br><span class="line">    <span class="keyword">input</span> sys_clk_i,	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> ext_rst_n,	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>] dtube_cs_n,	<span class="comment">//7段数码管位选信号</span></span><br><span class="line">    <span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] dtube_data	<span class="comment">//7段数码管段选信号（包括小数点为8段）						</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> clk_12m5;	<span class="comment">//PLL输出12.5MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_25m;	<span class="comment">//PLL输出25MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_50m;	<span class="comment">//PLL输出50MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_100m;	<span class="comment">//PLL输出100MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> sys_rst_n;	<span class="comment">//PLL输出的locked信号，作为FPGA内部的复位信号，低电平复位，高电平正常工作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//PLL例化</span></span><br><span class="line">    clk_wiz_0 u1_clk_wiz_0(</span><br><span class="line">        <span class="comment">// Clock in ports</span></span><br><span class="line">        <span class="variable">.clk_in1</span>(sys_clk_i), <span class="comment">// input clk_in1</span></span><br><span class="line">        <span class="comment">// Clock out ports</span></span><br><span class="line">        <span class="variable">.clk_out1</span>(clk_12m5), <span class="comment">// output clk_out1</span></span><br><span class="line">        <span class="variable">.clk_out2</span>(clk_25m),  <span class="comment">// output clk_out2</span></span><br><span class="line">        <span class="variable">.clk_out3</span>(clk_50m),  <span class="comment">// output clk_out3</span></span><br><span class="line">        <span class="variable">.clk_out4</span>(clk_100m), <span class="comment">// output clk_out4</span></span><br><span class="line">        <span class="comment">// Status and control signals</span></span><br><span class="line">        <span class="variable">.reset</span>(!ext_rst_n),  <span class="comment">// input reset</span></span><br><span class="line">        <span class="variable">.locked</span>(sys_rst_n)   <span class="comment">// output locked</span></span><br><span class="line">    );      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//25MHz时钟进行分频，产生每秒递增的16位数据</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">15</span>:<span class="number">0</span>] display_num;	<span class="comment">//数码管显示数据，[15:12]--数码管千位，[11:8]--数码管百位，[7:4]--数码管十位，[3:0]--数码管个位</span></span><br><span class="line"></span><br><span class="line">    Counter_design	uut_Counter_design(</span><br><span class="line">    	<span class="variable">.clk</span>(clk_25m),		        <span class="comment">//时钟信号</span></span><br><span class="line">    	<span class="variable">.rst_n</span>(sys_rst_n),	        <span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.display_num</span>(display_num)	<span class="comment">//LED指示灯接口	</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//4位数码管显示驱动															</span></span><br><span class="line">    Seg_drive_design uut_Seg_drive_design(</span><br><span class="line">    	<span class="variable">.clk</span>(clk_25m),		        <span class="comment">//时钟信号</span></span><br><span class="line">    	<span class="variable">.rst_n</span>(sys_rst_n),	        <span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.display_num</span>(display_num),  <span class="comment">//LED指示灯接口	</span></span><br><span class="line">    	<span class="variable">.dtube_cs_n</span>(dtube_cs_n),	<span class="comment">//7段数码管位选信号</span></span><br><span class="line">    	<span class="variable">.dtube_data</span>(dtube_data)		<span class="comment">//7段数码管段选信号（包括小数点为8段）</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Counter_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Counter_design(</span><br><span class="line">	<span class="keyword">input</span> clk,		<span class="comment">//时钟信号，25MHz</span></span><br><span class="line">	<span class="keyword">input</span> rst_n,	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] display_num	<span class="comment">//数码管显示数据，[15:12]--数码管千位，[11:8]--数码管百位，[7:4]--数码管十位，[3:0]--数码管个位</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> SIMULATION_AT7</span></span><br><span class="line">    <span class="meta">`<span class="keyword">ifdef</span> SIMULATION_AT7</span></span><br><span class="line">    	<span class="meta">`<span class="keyword">define</span>	MAX_CNT	25&#x27;d9_999</span></span><br><span class="line">    <span class="meta">`<span class="keyword">else</span></span></span><br><span class="line">    	<span class="meta">`<span class="keyword">define</span>	MAX_CNT	25&#x27;d24_999_999</span></span><br><span class="line">    <span class="meta">`<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//1s定时产生逻辑</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">24</span>:<span class="number">0</span>] timer_cnt;	<span class="comment">//1s计数器，0-24999999</span></span><br><span class="line">    <span class="comment">//1s定时计数</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            timer_cnt &lt;= <span class="number">25&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(timer_cnt &lt; `MAX_CNT) </span><br><span class="line">            timer_cnt &lt;= timer_cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            timer_cnt &lt;= <span class="number">25&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">wire</span> timer_1s_flag = (timer_cnt == `MAX_CNT);		<span class="comment">//1s定时的标志位，高有效一个时钟周期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//递增数据产生逻辑</span></span><br><span class="line">    <span class="comment">//显示数据每秒递增</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            display_num &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(timer_1s_flag) </span><br><span class="line">            display_num &lt;= display_num+<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Seg_drive_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Seg_drive_design(</span><br><span class="line">	<span class="keyword">input</span> clk,		<span class="comment">//时钟信号，25MHz</span></span><br><span class="line">	<span class="keyword">input</span> rst_n,	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] display_num,	<span class="comment">//数码管显示数据，[15:12]--数码管千位，[11:8]--数码管百位，[7:4]--数码管十位，[3:0]--数码管个位</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] dtube_cs_n,	<span class="comment">//7段数码管位选信号</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] dtube_data	<span class="comment">//7段数码管段选信号（包括小数点为8段）</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="comment">//数码管显示 0~F 对应段选输出</span></span><br><span class="line">    <span class="keyword">parameter</span> 	NUM0 	= <span class="number">8&#x27;h3f</span>,<span class="comment">//0</span></span><br><span class="line">    			NUM1 	= <span class="number">8&#x27;h06</span>,<span class="comment">//1</span></span><br><span class="line">    			NUM2 	= <span class="number">8&#x27;h5b</span>,<span class="comment">//2</span></span><br><span class="line">    			NUM3 	= <span class="number">8&#x27;h4f</span>,<span class="comment">//3</span></span><br><span class="line">    			NUM4 	= <span class="number">8&#x27;h66</span>,<span class="comment">//4</span></span><br><span class="line">    			NUM5 	= <span class="number">8&#x27;h6d</span>,<span class="comment">//5</span></span><br><span class="line">    			NUM6 	= <span class="number">8&#x27;h7d</span>,<span class="comment">//6</span></span><br><span class="line">    			NUM7 	= <span class="number">8&#x27;h07</span>,<span class="comment">//7</span></span><br><span class="line">    			NUM8 	= <span class="number">8&#x27;h7f</span>,<span class="comment">//8</span></span><br><span class="line">    			NUM9 	= <span class="number">8&#x27;h6f</span>,<span class="comment">//9</span></span><br><span class="line">    			NUMA 	= <span class="number">8&#x27;h77</span>,<span class="comment">//a</span></span><br><span class="line">    			NUMB 	= <span class="number">8&#x27;h7c</span>,<span class="comment">//b</span></span><br><span class="line">    			NUMC 	= <span class="number">8&#x27;h39</span>,<span class="comment">//c</span></span><br><span class="line">    			NUMD 	= <span class="number">8&#x27;h5e</span>,<span class="comment">//d</span></span><br><span class="line">    			NUME 	= <span class="number">8&#x27;h79</span>,<span class="comment">//e</span></span><br><span class="line">    			NUMF 	= <span class="number">8&#x27;h71</span>,<span class="comment">//f</span></span><br><span class="line">    			NDOT	= <span class="number">8&#x27;h80</span>;<span class="comment">//小数点显示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数码管位选 0~3 对应输出</span></span><br><span class="line">    <span class="keyword">parameter</span>	CSN		= <span class="number">4&#x27;b1111</span>,</span><br><span class="line">    			CS0		= <span class="number">4&#x27;b1110</span>,</span><br><span class="line">    			CS1		= <span class="number">4&#x27;b1101</span>,</span><br><span class="line">    			CS2		= <span class="number">4&#x27;b1011</span>,</span><br><span class="line">    			CS3		= <span class="number">4&#x27;b0111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//分时显示数据控制单元</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] current_display_num;	<span class="comment">//当前显示数据</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] div_cnt;	<span class="comment">//分时计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分时计数器</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            div_cnt &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            div_cnt &lt;= div_cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示数据</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            current_display_num &lt;= <span class="number">4&#x27;h0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(div_cnt)<span class="comment">//提前了一个时钟周期获得显示的数据</span></span><br><span class="line">    			<span class="number">8&#x27;hff</span>: current_display_num &lt;= display_num[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line">    			<span class="number">8&#x27;h3f</span>: current_display_num &lt;= display_num[<span class="number">7</span>:<span class="number">4</span>];</span><br><span class="line">    			<span class="number">8&#x27;h7f</span>: current_display_num &lt;= display_num[<span class="number">11</span>:<span class="number">8</span>];</span><br><span class="line">    			<span class="number">8&#x27;hbf</span>: current_display_num &lt;= display_num[<span class="number">15</span>:<span class="number">12</span>];</span><br><span class="line">    			<span class="keyword">default</span>: ;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//段选数据译码</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            dtube_data &lt;= NUM0;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(current_display_num) </span><br><span class="line">    			<span class="number">4&#x27;h0</span>: dtube_data &lt;= NUM0;</span><br><span class="line">    			<span class="number">4&#x27;h1</span>: dtube_data &lt;= NUM1;</span><br><span class="line">    			<span class="number">4&#x27;h2</span>: dtube_data &lt;= NUM2;</span><br><span class="line">    			<span class="number">4&#x27;h3</span>: dtube_data &lt;= NUM3;</span><br><span class="line">    			<span class="number">4&#x27;h4</span>: dtube_data &lt;= NUM4;</span><br><span class="line">    			<span class="number">4&#x27;h5</span>: dtube_data &lt;= NUM5;</span><br><span class="line">    			<span class="number">4&#x27;h6</span>: dtube_data &lt;= NUM6;</span><br><span class="line">    			<span class="number">4&#x27;h7</span>: dtube_data &lt;= NUM7;</span><br><span class="line">    			<span class="number">4&#x27;h8</span>: dtube_data &lt;= NUM8;</span><br><span class="line">    			<span class="number">4&#x27;h9</span>: dtube_data &lt;= NUM9;</span><br><span class="line">    			<span class="number">4&#x27;ha</span>: dtube_data &lt;= NUMA;</span><br><span class="line">    			<span class="number">4&#x27;hb</span>: dtube_data &lt;= NUMB;</span><br><span class="line">    			<span class="number">4&#x27;hc</span>: dtube_data &lt;= NUMC;</span><br><span class="line">    			<span class="number">4&#x27;hd</span>: dtube_data &lt;= NUMD;</span><br><span class="line">    			<span class="number">4&#x27;he</span>: dtube_data &lt;= NUME;</span><br><span class="line">    			<span class="number">4&#x27;hf</span>: dtube_data &lt;= NUMF;</span><br><span class="line">    			<span class="keyword">default</span>: ;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//位选译码：每64个时钟周期选择一个数码管</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            dtube_cs_n &lt;= CSN;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(div_cnt[<span class="number">7</span>:<span class="number">6</span>])</span><br><span class="line">    			<span class="number">2&#x27;b00</span>: dtube_cs_n &lt;= CS0;</span><br><span class="line">    			<span class="number">2&#x27;b01</span>: dtube_cs_n &lt;= CS1;</span><br><span class="line">    			<span class="number">2&#x27;b10</span>: dtube_cs_n &lt;= CS2;</span><br><span class="line">    			<span class="number">2&#x27;b11</span>: dtube_cs_n &lt;= CS3;</span><br><span class="line">    			<span class="keyword">default</span>:  dtube_cs_n &lt;= CSN;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-1"><a href="#3-Testbench-1" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Seg8_display_tb;</span><br><span class="line">    <span class="keyword">reg</span> sys_clk_i;	<span class="comment">//50MHz时钟信号</span></span><br><span class="line">    <span class="keyword">reg</span> ext_rst_n;	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] dtube_cs_n;	<span class="comment">//7段数码管位选信号</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] dtube_data;	<span class="comment">//7段数码管段选信号（包括小数点为8段）	</span></span><br><span class="line">    </span><br><span class="line">    Seg8_display_design	uut_Seg8_display_design(</span><br><span class="line">    	<span class="variable">.sys_clk_i</span>(sys_clk_i),	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">    	<span class="variable">.ext_rst_n</span>(ext_rst_n),	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.dtube_cs_n</span>(dtube_cs_n),</span><br><span class="line">    	<span class="variable">.dtube_data</span>(dtube_data)</span><br><span class="line">    );		</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数码管显示 0~F 对应段选输出</span></span><br><span class="line">    <span class="keyword">parameter</span> 	NUM0 	= <span class="number">8&#x27;h3f</span>,<span class="comment">//c0,</span></span><br><span class="line">    			NUM1 	= <span class="number">8&#x27;h06</span>,<span class="comment">//f9,</span></span><br><span class="line">    			NUM2 	= <span class="number">8&#x27;h5b</span>,<span class="comment">//a4,</span></span><br><span class="line">    			NUM3 	= <span class="number">8&#x27;h4f</span>,<span class="comment">//b0,</span></span><br><span class="line">    			NUM4 	= <span class="number">8&#x27;h66</span>,<span class="comment">//99,</span></span><br><span class="line">    			NUM5 	= <span class="number">8&#x27;h6d</span>,<span class="comment">//92,</span></span><br><span class="line">    			NUM6 	= <span class="number">8&#x27;h7d</span>,<span class="comment">//82,</span></span><br><span class="line">    			NUM7 	= <span class="number">8&#x27;h07</span>,<span class="comment">//F8,</span></span><br><span class="line">    			NUM8 	= <span class="number">8&#x27;h7f</span>,<span class="comment">//80,</span></span><br><span class="line">    			NUM9 	= <span class="number">8&#x27;h6f</span>,<span class="comment">//90,</span></span><br><span class="line">    			NUMA 	= <span class="number">8&#x27;h77</span>,<span class="comment">//88,</span></span><br><span class="line">    			NUMB 	= <span class="number">8&#x27;h7c</span>,<span class="comment">//83,</span></span><br><span class="line">    			NUMC 	= <span class="number">8&#x27;h39</span>,<span class="comment">//c6,</span></span><br><span class="line">    			NUMD 	= <span class="number">8&#x27;h5e</span>,<span class="comment">//a1,</span></span><br><span class="line">    			NUME 	= <span class="number">8&#x27;h79</span>,<span class="comment">//86,</span></span><br><span class="line">    			NUMF 	= <span class="number">8&#x27;h71</span>,<span class="comment">//8e;</span></span><br><span class="line">    			NDOT	= <span class="number">8&#x27;h80</span>;<span class="comment">//小数点显示		</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	sys_clk_i = <span class="number">0</span>;</span><br><span class="line">    	ext_rst_n = <span class="number">0</span>;	<span class="comment">//复位中</span></span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	@(<span class="keyword">posedge</span> sys_clk_i); #<span class="number">2</span>;</span><br><span class="line">    	ext_rst_n = <span class="number">1</span>;	<span class="comment">//复位结束，正常工作</span></span><br><span class="line">    	#<span class="number">100_000_000</span>;	<span class="comment">//0.1s</span></span><br><span class="line">    	<span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> sys_clk_i = ~sys_clk_i;	<span class="comment">//50MHz时钟产生</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] display_seg7;	<span class="comment">//模拟显示的数码管数据	</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] dtube_data_decoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(dtube_data) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">case</span>(dtube_data)</span><br><span class="line">    		NUM0: dtube_data_decoder &lt;= <span class="number">4&#x27;h0</span>;</span><br><span class="line">    		NUM1: dtube_data_decoder &lt;= <span class="number">4&#x27;h1</span>;</span><br><span class="line">    		NUM2: dtube_data_decoder &lt;= <span class="number">4&#x27;h2</span>;</span><br><span class="line">    		NUM3: dtube_data_decoder &lt;= <span class="number">4&#x27;h3</span>;</span><br><span class="line">    		NUM4: dtube_data_decoder &lt;= <span class="number">4&#x27;h4</span>;</span><br><span class="line">    		NUM5: dtube_data_decoder &lt;= <span class="number">4&#x27;h5</span>;</span><br><span class="line">    		NUM6: dtube_data_decoder &lt;= <span class="number">4&#x27;h6</span>;</span><br><span class="line">    		NUM7: dtube_data_decoder &lt;= <span class="number">4&#x27;h7</span>;</span><br><span class="line">    		NUM8: dtube_data_decoder &lt;= <span class="number">4&#x27;h8</span>;</span><br><span class="line">    		NUM9: dtube_data_decoder &lt;= <span class="number">4&#x27;h9</span>;</span><br><span class="line">    		NUMA: dtube_data_decoder &lt;= <span class="number">4&#x27;ha</span>;</span><br><span class="line">    		NUMB: dtube_data_decoder &lt;= <span class="number">4&#x27;hb</span>;</span><br><span class="line">    		NUMC: dtube_data_decoder &lt;= <span class="number">4&#x27;hc</span>;</span><br><span class="line">    		NUMD: dtube_data_decoder &lt;= <span class="number">4&#x27;hd</span>;</span><br><span class="line">    		NUME: dtube_data_decoder &lt;= <span class="number">4&#x27;he</span>;</span><br><span class="line">    		NUMF: dtube_data_decoder &lt;= <span class="number">4&#x27;hf</span>;</span><br><span class="line">    		<span class="keyword">default</span>: ;</span><br><span class="line">    	<span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(dtube_cs_n <span class="keyword">or</span> dtube_data_decoder) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!dtube_cs_n[<span class="number">0</span>]) </span><br><span class="line">            display_seg7[<span class="number">3</span>:<span class="number">0</span>] &lt;= dtube_data_decoder;</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    	<span class="keyword">if</span>(!dtube_cs_n[<span class="number">1</span>]) </span><br><span class="line">            display_seg7[<span class="number">7</span>:<span class="number">4</span>] &lt;= dtube_data_decoder;</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    	<span class="keyword">if</span>(!dtube_cs_n[<span class="number">2</span>]) </span><br><span class="line">            display_seg7[<span class="number">11</span>:<span class="number">8</span>] &lt;= dtube_data_decoder;</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    	<span class="keyword">if</span>(!dtube_cs_n[<span class="number">3</span>]) </span><br><span class="line">            display_seg7[<span class="number">15</span>:<span class="number">12</span>] &lt;= dtube_data_decoder;</span><br><span class="line">    	<span class="keyword">else</span> ;	</span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-1"><a href="#4-仿真结果-1" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230106155844156.png" alt="image-20230106155844156"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230106160011927.png" alt="image-20230106160011927"></p>
<hr>
<h1 id="4-times-4矩阵按键"><a href="#4-times-4矩阵按键" class="headerlink" title="4$\times$4矩阵按键"></a>4$\times$4矩阵按键</h1><ul>
<li>采集4X4矩阵按键的键值，输出到数码管的末位，数码管每新输入一位数据，都会将原有数据左移一位</li>
</ul>
<h2 id="1-思路-2"><a href="#1-思路-2" class="headerlink" title="1.思路"></a>1.思路</h2><ul>
<li>对列输入按键会触发行输出扫描信号，开始扫描，对于四行行信号，在同一时刻只会有一行信号被拉低，其余置高，只有被拉低的那一行信号是有效的，那么此时的列输入对应的就是这一组有效信号</li>
<li>通过状态机实现行信号的扫描，主要思路是：当检测到有按键按下时，进入状态K_H1OL，在这个状态内将行信号0拉低；接着进入状态K_H2OL，在这个状态中，先判断列输入信号是否有按键按下（即为1110，1101，1011，0111），若有效则说明是第0行的按键被按下了，否则将行信号1拉低；在进入K_H3OL状态之前，首先需判断按键是否弹起，若弹起则回到空闲状态，否则则继续进行行扫描，进入K_H3OL状态，在K_H3OL状态中的判断与K_H2OL一致，后面的状态跳变与状态内的操作依此类推。</li>
</ul>
<h2 id="2-源代码-2"><a href="#2-源代码-2" class="headerlink" title="2.源代码"></a>2.源代码</h2><ul>
<li>key4T4_sample_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> key4T4_sample_design(</span><br><span class="line">	<span class="keyword">input</span> clk,	<span class="comment">//外部输入25MHz时钟信号</span></span><br><span class="line">	<span class="keyword">input</span> rst_n,	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>] key_h,	<span class="comment">//4个行按键输入，未按下为高电平，按下后为低电平</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] key_v,	<span class="comment">//4个列按键输出</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] display_num	<span class="comment">//数码管显示数据，[15:12]--数码管千位，[11:8]--数码管百位，[7:4]--数码管十位，[3:0]--数码管个位</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//列按键键值采样</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] keyh_value;		<span class="comment">//列按键按下键值，高电平有效</span></span><br><span class="line"></span><br><span class="line">    key_filter_design uut_key_filter_design(</span><br><span class="line">    	<span class="variable">.clk</span>(clk),	<span class="comment">//外部输入25MHz时钟信号</span></span><br><span class="line">    	<span class="variable">.rst_n</span>(rst_n),	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.key_h</span>(key_h),	<span class="comment">//4个独立按键输入，未按下为高电平，按下后为低电平</span></span><br><span class="line">    	<span class="variable">.keyh_value</span>(keyh_value)		<span class="comment">//行按键键值，高电平有效	</span></span><br><span class="line">    	);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//状态机采样键值 </span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] nstate,cstate;</span><br><span class="line">    <span class="keyword">parameter</span> K_IDLE = <span class="number">4&#x27;d0</span>;	<span class="comment">//空闲状态，等待</span></span><br><span class="line">    <span class="keyword">parameter</span> K_H1OL = <span class="number">4&#x27;d1</span>;	<span class="comment">//key_v[0]拉低</span></span><br><span class="line">    <span class="keyword">parameter</span> K_H2OL = <span class="number">4&#x27;d2</span>;	<span class="comment">//key_v[1]拉低</span></span><br><span class="line">    <span class="keyword">parameter</span> K_H3OL = <span class="number">4&#x27;d3</span>;	<span class="comment">//key_v[2]拉低</span></span><br><span class="line">    <span class="keyword">parameter</span> K_H4OL = <span class="number">4&#x27;d4</span>;	<span class="comment">//key_v[3]拉低</span></span><br><span class="line">    <span class="keyword">parameter</span> K_CHCK = <span class="number">4&#x27;d5</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态切换</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            cstate &lt;= K_IDLE;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            cstate &lt;= nstate;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(cstate <span class="keyword">or</span> keyh_value <span class="keyword">or</span> key_h) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">case</span>(cstate)	</span><br><span class="line">    		K_IDLE:	<span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(keyh_value != <span class="number">4&#x27;b0000</span>) </span><br><span class="line">                    nstate &lt;= K_H1OL;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate &lt;= K_IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    		K_H1OL:	<span class="keyword">begin</span></span><br><span class="line">                nstate &lt;= K_H2OL;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    		K_H2OL:	<span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(key_h != <span class="number">4&#x27;b1111</span>) </span><br><span class="line">                    nstate &lt;= K_IDLE;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate &lt;= K_H3OL;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    		K_H3OL:	<span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(key_h != <span class="number">4&#x27;b1111</span>) </span><br><span class="line">                    nstate &lt;= K_IDLE;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate &lt;= K_H4OL;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    		K_H4OL:	<span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(key_h != <span class="number">4&#x27;b1111</span>) </span><br><span class="line">                    nstate &lt;= K_IDLE;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate &lt;= K_CHCK;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    		K_CHCK:	<span class="keyword">begin</span></span><br><span class="line">                nstate &lt;= K_IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    		<span class="keyword">default</span>: ;</span><br><span class="line">    	<span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//采样键值	</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] new_value;	<span class="comment">//新采样数据</span></span><br><span class="line">    <span class="keyword">reg</span> new_rdy;	<span class="comment">//新采样数据有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">    		key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    		new_value &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">    		new_rdy &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(cstate)	</span><br><span class="line">    			K_IDLE:	<span class="keyword">begin</span></span><br><span class="line">    				key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    				new_value &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">    				new_rdy &lt;= <span class="number">1&#x27;b0</span>;		</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			K_H1OL:	<span class="keyword">begin</span></span><br><span class="line">    				key_v &lt;= <span class="number">4&#x27;b1110</span>;</span><br><span class="line">    				new_value &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">    				new_rdy &lt;= <span class="number">1&#x27;b0</span>;		</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			K_H2OL:	<span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">case</span>(key_h) </span><br><span class="line">    					<span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>			</span><br><span class="line">    					<span class="number">4&#x27;b1101</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d1</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>			</span><br><span class="line">    					<span class="number">4&#x27;b1011</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d2</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>					</span><br><span class="line">    					<span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d3</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span></span><br><span class="line">    					<span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b1101</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b0</span>;		</span><br><span class="line">    						<span class="keyword">end</span></span><br><span class="line">    				<span class="keyword">endcase</span></span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			K_H3OL:	<span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">case</span>(key_h) </span><br><span class="line">    					<span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d4</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>			</span><br><span class="line">    					<span class="number">4&#x27;b1101</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d5</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>			</span><br><span class="line">    					<span class="number">4&#x27;b1011</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d6</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>					</span><br><span class="line">    					<span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d7</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span></span><br><span class="line">    					<span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b1011</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b0</span>;		</span><br><span class="line">    						<span class="keyword">end</span></span><br><span class="line">    				<span class="keyword">endcase</span></span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			K_H4OL:	<span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">case</span>(key_h) </span><br><span class="line">    					<span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d8</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>			</span><br><span class="line">    					<span class="number">4&#x27;b1101</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d9</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>			</span><br><span class="line">    					<span class="number">4&#x27;b1011</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d10</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>					</span><br><span class="line">    					<span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d11</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span></span><br><span class="line">    					<span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0111</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b0</span>;		</span><br><span class="line">    						<span class="keyword">end</span></span><br><span class="line">    				<span class="keyword">endcase</span></span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			K_CHCK:	<span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">case</span>(key_h) </span><br><span class="line">    					<span class="number">4&#x27;b1110</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d12</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>			</span><br><span class="line">    					<span class="number">4&#x27;b1101</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d13</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>			</span><br><span class="line">    					<span class="number">4&#x27;b1011</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d14</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span>					</span><br><span class="line">    					<span class="number">4&#x27;b0111</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d15</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b1</span>;		</span><br><span class="line">    						<span class="keyword">end</span></span><br><span class="line">    					<span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">    							key_v &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    							new_value &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">    							new_rdy &lt;= <span class="number">1&#x27;b0</span>;		</span><br><span class="line">    						<span class="keyword">end</span></span><br><span class="line">    				<span class="keyword">endcase</span></span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">default</span>: ;</span><br><span class="line">    		<span class="keyword">endcase</span>	</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//产生最新键值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            display_num &lt;= <span class="number">16&#x27;h0000</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(new_rdy) </span><br><span class="line">            display_num &lt;= &#123;display_num[<span class="number">11</span>:<span class="number">0</span>],new_value&#125;; <span class="comment">//左移显示</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>key_filter_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> key_filter_design(</span><br><span class="line">	<span class="keyword">input</span> clk,	<span class="comment">//外部输入25MHz时钟信号</span></span><br><span class="line">	<span class="keyword">input</span> rst_n,	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>] key_h,	<span class="comment">//4个行按键输入，未按下为高电平，按下后为低电平</span></span><br><span class="line">	<span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>] keyh_value		<span class="comment">//行按键按下键值，高电平有效	</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//按键抖动判断逻辑</span></span><br><span class="line">    <span class="keyword">wire</span> key;	<span class="comment">//所有按键值相与的结果，用于按键触发判断</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] keyr;  <span class="comment">//按键值key的缓存寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> key = key_h[<span class="number">0</span>] &amp; key_h[<span class="number">1</span>] &amp; key_h[<span class="number">2</span>] &amp; key_h[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span> (!rst_n) </span><br><span class="line">            keyr &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            keyr &lt;= &#123;keyr[<span class="number">2</span>:<span class="number">0</span>],key&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> key_neg = ~keyr[<span class="number">2</span>] &amp; keyr[<span class="number">3</span>];	<span class="comment">//有按键被按下	</span></span><br><span class="line">    <span class="keyword">wire</span> key_pos = keyr[<span class="number">2</span>] &amp; ~keyr[<span class="number">3</span>];	<span class="comment">//有按键被释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//定时计数逻辑，用于对按键的消抖判断</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">19</span>:<span class="number">0</span>]  cnt;	</span><br><span class="line">    <span class="comment">//按键消抖定时计数器</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst_n) </span><br><span class="line">            cnt &lt;= <span class="number">20&#x27;d0</span>;	</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(key_pos || key_neg) </span><br><span class="line">            cnt &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt; <span class="number">20&#x27;d999_999</span>) </span><br><span class="line">            cnt &lt;= cnt + <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] key_halue[<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//定时采集按键值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">        <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">    		key_halue[<span class="number">0</span>] &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    		key_halue[<span class="number">1</span>] &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line">    		key_halue[<span class="number">1</span>] &lt;= key_halue[<span class="number">0</span>];		</span><br><span class="line">    		<span class="keyword">if</span>(cnt == <span class="number">20&#x27;d999_999</span>) key_halue[<span class="number">0</span>] &lt;= key_h;	<span class="comment">//定时键值采集</span></span><br><span class="line">    		<span class="keyword">else</span> ;	</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> keyh_value = key_halue[<span class="number">1</span>] &amp; ~key_halue[<span class="number">0</span>];		<span class="comment">//消抖后按键值变化标志位</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>seg7_display_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> seg7_display_design(</span><br><span class="line">			<span class="keyword">input</span> clk,		<span class="comment">//时钟信号，25MHz</span></span><br><span class="line">			<span class="keyword">input</span> rst_n,	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">			<span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] display_num,	<span class="comment">//数码管显示数据，[15:12]--数码管千位，[11:8]--数码管百位，[7:4]--数码管十位，[3:0]--数码管个位</span></span><br><span class="line">			<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] dtube_cs_n,	<span class="comment">//7段数码管位选信号</span></span><br><span class="line">			<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] dtube_data	<span class="comment">//7段数码管段选信号（包括小数点为8段）</span></span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="comment">//数码管显示 0~F 对应段选输出</span></span><br><span class="line">    <span class="keyword">parameter</span> 	NUM0 	= <span class="number">8&#x27;h3f</span>,<span class="comment">//c0,</span></span><br><span class="line">    			NUM1 	= <span class="number">8&#x27;h06</span>,<span class="comment">//f9,</span></span><br><span class="line">    			NUM2 	= <span class="number">8&#x27;h5b</span>,<span class="comment">//a4,</span></span><br><span class="line">    			NUM3 	= <span class="number">8&#x27;h4f</span>,<span class="comment">//b0,</span></span><br><span class="line">    			NUM4 	= <span class="number">8&#x27;h66</span>,<span class="comment">//99,</span></span><br><span class="line">    			NUM5 	= <span class="number">8&#x27;h6d</span>,<span class="comment">//92,</span></span><br><span class="line">    			NUM6 	= <span class="number">8&#x27;h7d</span>,<span class="comment">//82,</span></span><br><span class="line">    			NUM7 	= <span class="number">8&#x27;h07</span>,<span class="comment">//F8,</span></span><br><span class="line">    			NUM8 	= <span class="number">8&#x27;h7f</span>,<span class="comment">//80,</span></span><br><span class="line">    			NUM9 	= <span class="number">8&#x27;h6f</span>,<span class="comment">//90,</span></span><br><span class="line">    			NUMA 	= <span class="number">8&#x27;h77</span>,<span class="comment">//88,</span></span><br><span class="line">    			NUMB 	= <span class="number">8&#x27;h7c</span>,<span class="comment">//83,</span></span><br><span class="line">    			NUMC 	= <span class="number">8&#x27;h39</span>,<span class="comment">//c6,</span></span><br><span class="line">    			NUMD 	= <span class="number">8&#x27;h5e</span>,<span class="comment">//a1,</span></span><br><span class="line">    			NUME 	= <span class="number">8&#x27;h79</span>,<span class="comment">//86,</span></span><br><span class="line">    			NUMF 	= <span class="number">8&#x27;h71</span>,<span class="comment">//8e;</span></span><br><span class="line">    			NDOT	= <span class="number">8&#x27;h80</span>;	<span class="comment">//小数点显示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数码管位选 0~3 对应输出</span></span><br><span class="line">    <span class="keyword">parameter</span>	CSN		= <span class="number">4&#x27;b1111</span>,</span><br><span class="line">    			CS0		= <span class="number">4&#x27;b1110</span>,</span><br><span class="line">    			CS1		= <span class="number">4&#x27;b1101</span>,</span><br><span class="line">    			CS2		= <span class="number">4&#x27;b1011</span>,</span><br><span class="line">    			CS3		= <span class="number">4&#x27;b0111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//分时显示数据控制单元</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] current_display_num;	<span class="comment">//当前显示数据</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] div_cnt;	<span class="comment">//分时计数器</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">//分时计数器</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) div_cnt &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> div_cnt &lt;= div_cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//显示数据</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) current_display_num &lt;= <span class="number">4&#x27;h0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(div_cnt)</span><br><span class="line">    			<span class="number">8&#x27;hff</span>: current_display_num &lt;= display_num[<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line">    			<span class="number">8&#x27;h3f</span>: current_display_num &lt;= display_num[<span class="number">7</span>:<span class="number">4</span>];</span><br><span class="line">    			<span class="number">8&#x27;h7f</span>: current_display_num &lt;= display_num[<span class="number">11</span>:<span class="number">8</span>];</span><br><span class="line">    			<span class="number">8&#x27;hbf</span>: current_display_num &lt;= display_num[<span class="number">15</span>:<span class="number">12</span>];</span><br><span class="line">    			<span class="keyword">default</span>: ;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//段选数据译码</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) dtube_data &lt;= NUM0;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(current_display_num) </span><br><span class="line">    			<span class="number">4&#x27;h0</span>: dtube_data &lt;= NUM0;</span><br><span class="line">    			<span class="number">4&#x27;h1</span>: dtube_data &lt;= NUM1;</span><br><span class="line">    			<span class="number">4&#x27;h2</span>: dtube_data &lt;= NUM2;</span><br><span class="line">    			<span class="number">4&#x27;h3</span>: dtube_data &lt;= NUM3;</span><br><span class="line">    			<span class="number">4&#x27;h4</span>: dtube_data &lt;= NUM4;</span><br><span class="line">    			<span class="number">4&#x27;h5</span>: dtube_data &lt;= NUM5;</span><br><span class="line">    			<span class="number">4&#x27;h6</span>: dtube_data &lt;= NUM6;</span><br><span class="line">    			<span class="number">4&#x27;h7</span>: dtube_data &lt;= NUM7;</span><br><span class="line">    			<span class="number">4&#x27;h8</span>: dtube_data &lt;= NUM8;</span><br><span class="line">    			<span class="number">4&#x27;h9</span>: dtube_data &lt;= NUM9;</span><br><span class="line">    			<span class="number">4&#x27;ha</span>: dtube_data &lt;= NUMA;</span><br><span class="line">    			<span class="number">4&#x27;hb</span>: dtube_data &lt;= NUMB;</span><br><span class="line">    			<span class="number">4&#x27;hc</span>: dtube_data &lt;= NUMC;</span><br><span class="line">    			<span class="number">4&#x27;hd</span>: dtube_data &lt;= NUMD;</span><br><span class="line">    			<span class="number">4&#x27;he</span>: dtube_data &lt;= NUME;</span><br><span class="line">    			<span class="number">4&#x27;hf</span>: dtube_data &lt;= NUMF;</span><br><span class="line">    			<span class="keyword">default</span>: ;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//位选译码</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) dtube_cs_n &lt;= CSN;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(div_cnt[<span class="number">7</span>:<span class="number">6</span>])</span><br><span class="line">    			<span class="number">2&#x27;b00</span>: dtube_cs_n &lt;= CS0;</span><br><span class="line">    			<span class="number">2&#x27;b01</span>: dtube_cs_n &lt;= CS1;</span><br><span class="line">    			<span class="number">2&#x27;b10</span>: dtube_cs_n &lt;= CS2;</span><br><span class="line">    			<span class="number">2&#x27;b11</span>: dtube_cs_n &lt;= CS3;</span><br><span class="line">    			<span class="keyword">default</span>:  dtube_cs_n &lt;= CSN;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Keyboard4T4_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Keyboard4T4_design(</span><br><span class="line">	<span class="keyword">input</span> sys_clk_i,	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">	<span class="keyword">input</span> ext_rst_n,	<span class="comment">//外部输入复位信号，低电平有效			</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>] key_h,	<span class="comment">//4个行按键输入，未按下为高电平，按下后为低电平</span></span><br><span class="line">	<span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>] key_v,	<span class="comment">//4个列按键输出</span></span><br><span class="line">	<span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>] dtube_cs_n,	<span class="comment">//7段数码管位选信号</span></span><br><span class="line">	<span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] dtube_data	<span class="comment">//7段数码管段选信号（包括小数点为8段）</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> clk_12m5;	<span class="comment">//PLL输出12.5MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_25m;	<span class="comment">//PLL输出25MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_50m;	<span class="comment">//PLL输出50MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_100m;	<span class="comment">//PLL输出100MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> sys_rst_n;	<span class="comment">//PLL输出的locked信号，作为FPGA内部的复位信号，低电平复位，高电平正常工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//PLL例化</span></span><br><span class="line">    clk_wiz_0 u1_clk_wiz_0(</span><br><span class="line">        <span class="comment">// Clock in ports</span></span><br><span class="line">        <span class="variable">.clk_in1</span>(sys_clk_i), <span class="comment">// input clk_in1</span></span><br><span class="line">        <span class="comment">// Clock out ports</span></span><br><span class="line">        <span class="variable">.clk_out1</span>(clk_12m5), <span class="comment">// output clk_out1</span></span><br><span class="line">        <span class="variable">.clk_out2</span>(clk_25m),  <span class="comment">// output clk_out2</span></span><br><span class="line">        <span class="variable">.clk_out3</span>(clk_50m),  <span class="comment">// output clk_out3</span></span><br><span class="line">        <span class="variable">.clk_out4</span>(clk_100m), <span class="comment">// output clk_out4</span></span><br><span class="line">        <span class="comment">// Status and control signals</span></span><br><span class="line">        <span class="variable">.reset</span>(!ext_rst_n),  <span class="comment">// input reset</span></span><br><span class="line">        <span class="variable">.locked</span>(sys_rst_n)   <span class="comment">// output locked</span></span><br><span class="line">    );      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//键值采集，产生数码管显示数据</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">15</span>:<span class="number">0</span>] display_num;	<span class="comment">//数码管显示数据，[15:12]--数码管千位，[11:8]--数码管百位，[7:4]--数码管十位，[3:0]--数码管个位</span></span><br><span class="line">    key4T4_sample_design uut_key4T4_sample_design(</span><br><span class="line">    	<span class="variable">.clk</span>(clk_25m),		<span class="comment">//时钟信号</span></span><br><span class="line">    	<span class="variable">.rst_n</span>(sys_rst_n),	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.key_h</span>(key_h),	<span class="comment">//4个按键输入，未按下为高电平，按下后为低电平</span></span><br><span class="line">    	<span class="variable">.key_v</span>(key_v),	<span class="comment">//4个行按键输出</span></span><br><span class="line">    	<span class="variable">.display_num</span>(display_num)	<span class="comment">//数码管显示数据，[15:12]--数码管千位，[11:8]--数码管百位，[7:4]--数码管十位，[3:0]--数码管个位</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//4位数码管显示驱动															</span></span><br><span class="line">    seg7_display_design uut_seg7_display_design(</span><br><span class="line">    	<span class="variable">.clk</span>(clk_25m),		<span class="comment">//时钟信号</span></span><br><span class="line">    	<span class="variable">.rst_n</span>(sys_rst_n),	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.display_num</span>(display_num),	</span><br><span class="line">    	<span class="variable">.dtube_cs_n</span>(dtube_cs_n),	<span class="comment">//7段数码管位选信号</span></span><br><span class="line">    	<span class="variable">.dtube_data</span>(dtube_data)		<span class="comment">//7段数码管段选信号（包括小数点为8段）</span></span><br><span class="line">    );	</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-2"><a href="#3-Testbench-2" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Keyboard4T4_tb;</span><br><span class="line">    <span class="keyword">reg</span> sys_clk_i;	<span class="comment">//50MHz时钟信号</span></span><br><span class="line">    <span class="keyword">reg</span> ext_rst_n;	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] key_h;	<span class="comment">//4个行按键输入，未按下为高电平，按下后为低电平</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] key_v;	<span class="comment">//4个列按键输出</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] dtube_cs_n;	<span class="comment">//7段数码管位选信号</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] dtube_data;	<span class="comment">//7段数码管段选信号（包括小数点为8段）</span></span><br><span class="line">    </span><br><span class="line">    Keyboard4T4_design	uut_Keyboard4T4_design(</span><br><span class="line">    	<span class="variable">.sys_clk_i</span>(sys_clk_i),	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">    	<span class="variable">.ext_rst_n</span>(ext_rst_n),	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.key_h</span>(key_h),</span><br><span class="line">    	<span class="variable">.key_v</span>(key_v),</span><br><span class="line">    	<span class="variable">.dtube_cs_n</span>(dtube_cs_n),</span><br><span class="line">    	<span class="variable">.dtube_data</span>(dtube_data)</span><br><span class="line">    );	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数码管显示 0~F 对应段选输出</span></span><br><span class="line">    <span class="keyword">parameter</span> 	NUM0 	= <span class="number">8&#x27;h3f</span>,<span class="comment">//c0,</span></span><br><span class="line">    			NUM1 	= <span class="number">8&#x27;h06</span>,<span class="comment">//f9,</span></span><br><span class="line">    			NUM2 	= <span class="number">8&#x27;h5b</span>,<span class="comment">//a4,</span></span><br><span class="line">    			NUM3 	= <span class="number">8&#x27;h4f</span>,<span class="comment">//b0,</span></span><br><span class="line">    			NUM4 	= <span class="number">8&#x27;h66</span>,<span class="comment">//99,</span></span><br><span class="line">    			NUM5 	= <span class="number">8&#x27;h6d</span>,<span class="comment">//92,</span></span><br><span class="line">    			NUM6 	= <span class="number">8&#x27;h7d</span>,<span class="comment">//82,</span></span><br><span class="line">    			NUM7 	= <span class="number">8&#x27;h07</span>,<span class="comment">//F8,</span></span><br><span class="line">    			NUM8 	= <span class="number">8&#x27;h7f</span>,<span class="comment">//80,</span></span><br><span class="line">    			NUM9 	= <span class="number">8&#x27;h6f</span>,<span class="comment">//90,</span></span><br><span class="line">    			NUMA 	= <span class="number">8&#x27;h77</span>,<span class="comment">//88,</span></span><br><span class="line">    			NUMB 	= <span class="number">8&#x27;h7c</span>,<span class="comment">//83,</span></span><br><span class="line">    			NUMC 	= <span class="number">8&#x27;h39</span>,<span class="comment">//c6,</span></span><br><span class="line">    			NUMD 	= <span class="number">8&#x27;h5e</span>,<span class="comment">//a1,</span></span><br><span class="line">    			NUME 	= <span class="number">8&#x27;h79</span>,<span class="comment">//86,</span></span><br><span class="line">    			NUMF 	= <span class="number">8&#x27;h71</span>,<span class="comment">//8e;</span></span><br><span class="line">    			NDOT	= <span class="number">8&#x27;h80</span>;	<span class="comment">//小数点显示				</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] key_press_value;	<span class="comment">//模拟按键值		</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	sys_clk_i = <span class="number">0</span>;</span><br><span class="line">    	ext_rst_n = <span class="number">0</span>;	<span class="comment">//复位中</span></span><br><span class="line">    	key_press_value = <span class="number">5&#x27;d16</span>;	<span class="comment">//没有按下</span></span><br><span class="line">    	key_h = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	@(<span class="keyword">posedge</span> sys_clk_i); #<span class="number">2</span>;</span><br><span class="line">    	ext_rst_n = <span class="number">1</span>;	<span class="comment">//复位结束，正常工作</span></span><br><span class="line">    </span><br><span class="line">    	press_key(<span class="number">4&#x27;hf</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;he</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;hd</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;hc</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;hb</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;ha</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h9</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h8</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h7</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h6</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h5</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h4</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h3</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h2</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h1</span>);</span><br><span class="line">    	press_key(<span class="number">4&#x27;h0</span>);</span><br><span class="line">    </span><br><span class="line">    	#<span class="number">200_000</span>;</span><br><span class="line">    	<span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> sys_clk_i = ~sys_clk_i;	<span class="comment">//50MHz时钟产生</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> press_key;</span><br><span class="line">    	<span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>] value;</span><br><span class="line">    	<span class="keyword">begin</span></span><br><span class="line">    	key_press_value = value;</span><br><span class="line">    	#<span class="number">100_000_000</span>;	<span class="comment">//100ms delay	</span></span><br><span class="line">    	key_press_value = <span class="number">5&#x27;d16</span>;	<span class="comment">//没有按下</span></span><br><span class="line">    	#<span class="number">100_000_000</span>;	<span class="comment">//400ms delay</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(key_press_value &lt; <span class="number">5&#x27;d16</span>) <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(key_press_value)</span><br><span class="line">    			<span class="number">5&#x27;d0</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">0</span>]) key_h &lt;= <span class="number">4&#x27;b1110</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d1</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">0</span>]) key_h &lt;= <span class="number">4&#x27;b1101</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d2</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">0</span>]) key_h &lt;= <span class="number">4&#x27;b1011</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d3</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">0</span>]) key_h &lt;= <span class="number">4&#x27;b0111</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    			<span class="number">5&#x27;d4</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">1</span>]) key_h &lt;= <span class="number">4&#x27;b1110</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d5</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">1</span>]) key_h &lt;= <span class="number">4&#x27;b1101</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d6</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">1</span>]) key_h &lt;= <span class="number">4&#x27;b1011</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d7</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">1</span>]) key_h &lt;= <span class="number">4&#x27;b0111</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    			<span class="number">5&#x27;d8</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">2</span>]) key_h &lt;= <span class="number">4&#x27;b1110</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d9</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">2</span>]) key_h &lt;= <span class="number">4&#x27;b1101</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d10</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">2</span>]) key_h &lt;= <span class="number">4&#x27;b1011</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d11</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">2</span>]) key_h &lt;= <span class="number">4&#x27;b0111</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    			<span class="number">5&#x27;d12</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">3</span>]) key_h &lt;= <span class="number">4&#x27;b1110</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d13</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">3</span>]) key_h &lt;= <span class="number">4&#x27;b1101</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d14</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">3</span>]) key_h &lt;= <span class="number">4&#x27;b1011</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="number">5&#x27;d15</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(!key_v[<span class="number">3</span>]) key_h &lt;= <span class="number">4&#x27;b0111</span>;</span><br><span class="line">    				<span class="keyword">else</span> key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    			<span class="keyword">end</span>	</span><br><span class="line">    			<span class="keyword">default</span>: key_h &lt;= <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] display_seg7;	<span class="comment">//模拟显示的数码管数据	</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] dtube_data_decoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(dtube_data) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">case</span>(dtube_data)</span><br><span class="line">    		NUM0: dtube_data_decoder &lt;= <span class="number">4&#x27;h0</span>;</span><br><span class="line">    		NUM1: dtube_data_decoder &lt;= <span class="number">4&#x27;h1</span>;</span><br><span class="line">    		NUM2: dtube_data_decoder &lt;= <span class="number">4&#x27;h2</span>;</span><br><span class="line">    		NUM3: dtube_data_decoder &lt;= <span class="number">4&#x27;h3</span>;</span><br><span class="line">    		NUM4: dtube_data_decoder &lt;= <span class="number">4&#x27;h4</span>;</span><br><span class="line">    		NUM5: dtube_data_decoder &lt;= <span class="number">4&#x27;h5</span>;</span><br><span class="line">    		NUM6: dtube_data_decoder &lt;= <span class="number">4&#x27;h6</span>;</span><br><span class="line">    		NUM7: dtube_data_decoder &lt;= <span class="number">4&#x27;h7</span>;</span><br><span class="line">    		NUM8: dtube_data_decoder &lt;= <span class="number">4&#x27;h8</span>;</span><br><span class="line">    		NUM9: dtube_data_decoder &lt;= <span class="number">4&#x27;h9</span>;</span><br><span class="line">    		NUMA: dtube_data_decoder &lt;= <span class="number">4&#x27;ha</span>;</span><br><span class="line">    		NUMB: dtube_data_decoder &lt;= <span class="number">4&#x27;hb</span>;</span><br><span class="line">    		NUMC: dtube_data_decoder &lt;= <span class="number">4&#x27;hc</span>;</span><br><span class="line">    		NUMD: dtube_data_decoder &lt;= <span class="number">4&#x27;hd</span>;</span><br><span class="line">    		NUME: dtube_data_decoder &lt;= <span class="number">4&#x27;he</span>;</span><br><span class="line">    		NUMF: dtube_data_decoder &lt;= <span class="number">4&#x27;hf</span>;</span><br><span class="line">    		<span class="keyword">default</span>: ;</span><br><span class="line">    	<span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(dtube_cs_n <span class="keyword">or</span> dtube_data_decoder) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!dtube_cs_n[<span class="number">0</span>]) display_seg7[<span class="number">3</span>:<span class="number">0</span>] &lt;= dtube_data_decoder;</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    	<span class="keyword">if</span>(!dtube_cs_n[<span class="number">1</span>]) display_seg7[<span class="number">7</span>:<span class="number">4</span>] &lt;= dtube_data_decoder;</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    	<span class="keyword">if</span>(!dtube_cs_n[<span class="number">2</span>]) display_seg7[<span class="number">11</span>:<span class="number">8</span>] &lt;= dtube_data_decoder;</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    	<span class="keyword">if</span>(!dtube_cs_n[<span class="number">3</span>]) display_seg7[<span class="number">15</span>:<span class="number">12</span>] &lt;= dtube_data_decoder;</span><br><span class="line">    	<span class="keyword">else</span> ;	</span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-2"><a href="#4-仿真结果-2" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230108232720454.png" alt="image-20230108232720454"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230108232946416.png" alt="image-20230108232946416"></p>
<hr>
<h1 id="序列码状态机"><a href="#序列码状态机" class="headerlink" title="序列码状态机"></a>序列码状态机</h1><h2 id="1-思路-3"><a href="#1-思路-3" class="headerlink" title="1.思路"></a>1.思路</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230109202839388.png" alt="image-20230109202839388"></p>
<h2 id="2-源代码-3"><a href="#2-源代码-3" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Sequential_detect_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">input</span> in_code,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> out_rdy</span><br><span class="line">	);													</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] cstate;  </span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] nstate;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> IDLE 	= <span class="number">4&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">parameter</span> S1 	= <span class="number">4&#x27;d1</span>;</span><br><span class="line">    <span class="keyword">parameter</span> S2 	= <span class="number">4&#x27;d2</span>;</span><br><span class="line">    <span class="keyword">parameter</span> S3 	= <span class="number">4&#x27;d3</span>;</span><br><span class="line">    <span class="keyword">parameter</span> S4 	= <span class="number">4&#x27;d4</span>;</span><br><span class="line">    <span class="keyword">parameter</span> S5 	= <span class="number">4&#x27;d5</span>;</span><br><span class="line">    <span class="keyword">parameter</span> S6 	= <span class="number">4&#x27;d6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两段式状态机</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)  </span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) cstate &lt;= IDLE;</span><br><span class="line">    	<span class="keyword">else</span> cstate &lt;= nstate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">case</span>(cstate)</span><br><span class="line">    		IDLE: <span class="keyword">begin</span></span><br><span class="line">    			out_rdy = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    			<span class="keyword">if</span>(in_code == <span class="number">1&#x27;b1</span>) </span><br><span class="line">                    nstate = S1;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IDLE;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		S1: <span class="keyword">begin</span></span><br><span class="line">    			out_rdy = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    			<span class="keyword">if</span>(in_code == <span class="number">1&#x27;b0</span>) </span><br><span class="line">                    nstate = S2;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = S1;			</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		S2: <span class="keyword">begin</span></span><br><span class="line">    			out_rdy = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    			<span class="keyword">if</span>(in_code == <span class="number">1&#x27;b1</span>) </span><br><span class="line">                    nstate = S3;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IDLE;		</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		S3: <span class="keyword">begin</span></span><br><span class="line">    			out_rdy = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    			<span class="keyword">if</span>(in_code == <span class="number">1&#x27;b1</span>) </span><br><span class="line">                    nstate = S4;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = S2;		</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		S4: <span class="keyword">begin</span></span><br><span class="line">    			out_rdy = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    			<span class="keyword">if</span>(in_code == <span class="number">1&#x27;b1</span>) </span><br><span class="line">                    nstate = S1;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = S5;		</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		S5: <span class="keyword">begin</span></span><br><span class="line">    			out_rdy = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    			<span class="keyword">if</span>(in_code == <span class="number">1&#x27;b1</span>) </span><br><span class="line">                    nstate = S3;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = S6;		</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		S6: <span class="keyword">begin</span></span><br><span class="line">    			out_rdy = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    			<span class="keyword">if</span>(in_code == <span class="number">1&#x27;b1</span>) </span><br><span class="line">                    nstate = S1;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IDLE;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		<span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">    			out_rdy = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    			nstate = IDLE;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-3"><a href="#3-Testbench-3" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Sequential_detect_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk;	<span class="comment">//50MHz时钟信号</span></span><br><span class="line">    <span class="keyword">reg</span> rst_n;	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">reg</span> in_code;</span><br><span class="line">    <span class="keyword">wire</span> out_rdy;	</span><br><span class="line">    </span><br><span class="line">    Sequential_detect_design uut_Sequential_detect_design(</span><br><span class="line">    	<span class="variable">.clk</span>(clk),	</span><br><span class="line">    	<span class="variable">.rst_n</span>(rst_n),	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">    	<span class="variable">.in_code</span>(in_code),</span><br><span class="line">    	<span class="variable">.out_rdy</span>(out_rdy)</span><br><span class="line">    );					</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	clk = <span class="number">0</span>;</span><br><span class="line">    	rst_n = <span class="number">0</span>;	<span class="comment">//复位中</span></span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	@(<span class="keyword">posedge</span> clk); </span><br><span class="line">    	rst_n = <span class="number">1</span>;	<span class="comment">//复位结束，正常工作</span></span><br><span class="line">    </span><br><span class="line">    	code_generation(<span class="number">6&#x27;b000000</span>);</span><br><span class="line">    	code_generation(<span class="number">6&#x27;b111111</span>);</span><br><span class="line">    	code_generation(<span class="number">6&#x27;b101100</span>);</span><br><span class="line">    	code_generation(<span class="number">6&#x27;b100010</span>);</span><br><span class="line">    	code_generation(<span class="number">6&#x27;b001110</span>);</span><br><span class="line">    	code_generation(<span class="number">6&#x27;b101100</span>);</span><br><span class="line">    	code_generation(<span class="number">6&#x27;b000000</span>);</span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	<span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> code_generation;</span><br><span class="line">    	<span class="keyword">input</span>[<span class="number">5</span>:<span class="number">0</span>] code_bus;</span><br><span class="line">    	<span class="keyword">begin</span></span><br><span class="line">    		@(<span class="keyword">posedge</span> clk); </span><br><span class="line">    		in_code &lt;= code_bus[<span class="number">5</span>];</span><br><span class="line">    		@(<span class="keyword">posedge</span> clk); </span><br><span class="line">    		in_code &lt;= code_bus[<span class="number">4</span>];</span><br><span class="line">    		@(<span class="keyword">posedge</span> clk); </span><br><span class="line">    		in_code &lt;= code_bus[<span class="number">3</span>];</span><br><span class="line">    		@(<span class="keyword">posedge</span> clk); </span><br><span class="line">    		in_code &lt;= code_bus[<span class="number">2</span>];</span><br><span class="line">    		@(<span class="keyword">posedge</span> clk); </span><br><span class="line">    		in_code &lt;= code_bus[<span class="number">1</span>];</span><br><span class="line">    		@(<span class="keyword">posedge</span> clk); </span><br><span class="line">    		in_code &lt;= code_bus[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-3"><a href="#4-仿真结果-3" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230109205926993.png" alt="image-20230109205926993"></p>
<hr>
<h1 id="UART的loopback实例"><a href="#UART的loopback实例" class="headerlink" title="UART的loopback实例"></a>UART的loopback实例</h1><ul>
<li>接收PC端发送的UART数据，原数据返回给PC端，即loopback功能</li>
</ul>
<h2 id="1-源代码"><a href="#1-源代码" class="headerlink" title="1.源代码"></a>1.源代码</h2><ul>
<li>uart_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收PC端发送的UART数据，原数据返回给PC端，即loopback功能</span></span><br><span class="line"><span class="keyword">module</span> uart_design(</span><br><span class="line">	<span class="keyword">input</span> sys_clk_i,	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">	<span class="keyword">input</span> ext_rst_n,	<span class="comment">//外部输入复位信号，低电平有效			</span></span><br><span class="line">	<span class="keyword">input</span> uart_rx,		<span class="comment">// UART接收数据信号</span></span><br><span class="line">	<span class="keyword">output</span> uart_tx		<span class="comment">// UART发送数据信号</span></span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//-------------------------------------</span></span><br><span class="line">	<span class="comment">//PLL例化</span></span><br><span class="line">	<span class="keyword">wire</span> clk_12m5;	<span class="comment">//PLL输出12.5MHz时钟</span></span><br><span class="line">	<span class="keyword">wire</span> clk_25m;	<span class="comment">//PLL输出25MHz时钟</span></span><br><span class="line">	<span class="keyword">wire</span> clk_50m;	<span class="comment">//PLL输出50MHz时钟</span></span><br><span class="line">	<span class="keyword">wire</span> clk_100m;	<span class="comment">//PLL输出100MHz时钟</span></span><br><span class="line">	<span class="keyword">wire</span> sys_rst_n;	<span class="comment">//PLL输出的locked信号，作为FPGA内部的复位信号，低电平复位，高电平正常工作</span></span><br><span class="line"></span><br><span class="line">	  clk_wiz_0 	u1_clk_wiz_0</span><br><span class="line">	   (</span><br><span class="line">	   <span class="comment">// Clock in ports</span></span><br><span class="line">	    <span class="variable">.clk_in1</span>(sys_clk_i),      <span class="comment">// input clk_in1</span></span><br><span class="line">	    <span class="comment">// Clock out ports</span></span><br><span class="line">	    <span class="variable">.clk_out1</span>(clk_12m5),     <span class="comment">// output clk_out1</span></span><br><span class="line">	    <span class="variable">.clk_out2</span>(clk_25m),     <span class="comment">// output clk_out2</span></span><br><span class="line">	    <span class="variable">.clk_out3</span>(clk_50m),     <span class="comment">// output clk_out3</span></span><br><span class="line">	    <span class="variable">.clk_out4</span>(clk_100m),     <span class="comment">// output clk_out4</span></span><br><span class="line">	    <span class="comment">// Status and control signals</span></span><br><span class="line">	    <span class="variable">.reset</span>(!ext_rst_n), <span class="comment">// input reset</span></span><br><span class="line">	    <span class="variable">.locked</span>(sys_rst_n));      <span class="comment">// output locked</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//-------------------------------------</span></span><br><span class="line">	<span class="comment">//下面的四个模块中，speed_rx和speed_tx是两个完全独立的硬件模块，可称之为逻辑复制</span></span><br><span class="line">	<span class="comment">//（不是资源共享，和软件中的同一个子程序调用不能混为一谈）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">wire</span> bps_start1,bps_start2;	<span class="comment">//接收到数据后，波特率时钟启动信号置位</span></span><br><span class="line">	<span class="keyword">wire</span> clk_bps1,clk_bps2;		<span class="comment">// clk_bps_r高电平为接收数据位的中间采样点,同时也作为发送数据的数据改变点 </span></span><br><span class="line">	<span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] rx_data;	<span class="comment">//接收数据寄存器，保存直至下一个数据来到</span></span><br><span class="line">	<span class="keyword">wire</span> rx_int;		<span class="comment">//接收数据中断信号,接收到数据期间始终为高电平</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//UART接收信号波特率设置</span></span><br><span class="line">	speed_setting	u2_speed_rx(	</span><br><span class="line">							<span class="variable">.clk</span>(clk_25m),	<span class="comment">//波特率选择模块</span></span><br><span class="line">							<span class="variable">.rst_n</span>(sys_rst_n),</span><br><span class="line">							<span class="variable">.bps_start</span>(bps_start1),</span><br><span class="line">							<span class="variable">.clk_bps</span>(clk_bps1)</span><br><span class="line">							);</span><br><span class="line">	<span class="comment">//UART接收数据处理</span></span><br><span class="line">	my_uart_rx		u3_my_uart_rx(		</span><br><span class="line">							<span class="variable">.clk</span>(clk_25m),	<span class="comment">//接收数据模块</span></span><br><span class="line">							<span class="variable">.rst_n</span>(sys_rst_n),</span><br><span class="line">							<span class="variable">.uart_rx</span>(uart_rx),</span><br><span class="line">							<span class="variable">.rx_data</span>(rx_data),</span><br><span class="line">							<span class="variable">.rx_int</span>(rx_int),</span><br><span class="line">							<span class="variable">.clk_bps</span>(clk_bps1),</span><br><span class="line">							<span class="variable">.bps_start</span>(bps_start1)</span><br><span class="line">							);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//-------------------------------------</span></span><br><span class="line">	<span class="comment">//UART发送信号波特率设置													</span></span><br><span class="line">	speed_setting	u4_speed_tx(	</span><br><span class="line">							<span class="variable">.clk</span>(clk_25m),	<span class="comment">//波特率选择模块</span></span><br><span class="line">							<span class="variable">.rst_n</span>(sys_rst_n),</span><br><span class="line">							<span class="variable">.bps_start</span>(bps_start2),</span><br><span class="line">							<span class="variable">.clk_bps</span>(clk_bps2)</span><br><span class="line">							);</span><br><span class="line">	<span class="comment">//UART发送数据处理</span></span><br><span class="line">	my_uart_tx		u5_my_uart_tx(		</span><br><span class="line">							<span class="variable">.clk</span>(clk_25m),	<span class="comment">//发送数据模块</span></span><br><span class="line">							<span class="variable">.rst_n</span>(sys_rst_n),</span><br><span class="line">							<span class="variable">.rx_data</span>(rx_data),</span><br><span class="line">							<span class="variable">.rx_int</span>(rx_int),</span><br><span class="line">							<span class="variable">.uart_tx</span>(uart_tx),</span><br><span class="line">							<span class="variable">.clk_bps</span>(clk_bps2),</span><br><span class="line">							<span class="variable">.bps_start</span>(bps_start2)</span><br><span class="line">							);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span>		</span><br></pre></td></tr></table></figure>
<ul>
<li>my_uart_tx.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my_uart_tx(</span><br><span class="line">	clk,</span><br><span class="line">	rst_n,</span><br><span class="line">	rx_data,</span><br><span class="line">	rx_int,</span><br><span class="line">	uart_tx,</span><br><span class="line">	clk_bps,</span><br><span class="line">	bps_start</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">input</span> clk;			<span class="comment">// 25MHz主时钟</span></span><br><span class="line">	<span class="keyword">input</span> rst_n;		<span class="comment">//低电平复位信号</span></span><br><span class="line">	<span class="keyword">input</span> clk_bps;		<span class="comment">// clk_bps_r高电平为接收数据位的中间采样点,同时也作为发送数据的数据改变点</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">7</span>:<span class="number">0</span>] rx_data;	<span class="comment">//接收数据寄存器</span></span><br><span class="line">	<span class="keyword">input</span> rx_int;		<span class="comment">//接收数据中断信号,接收到数据期间始终为高电平,在该模块中利用它的下降沿来启动串口发送数据</span></span><br><span class="line">	<span class="keyword">output</span> uart_tx;	<span class="comment">// RS232发送数据信号</span></span><br><span class="line">	<span class="keyword">output</span> bps_start;	<span class="comment">//接收或者要发送数据，波特率时钟启动信号置位</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//---------------------------------------------------------</span></span><br><span class="line">	<span class="keyword">reg</span> rx_int0,rx_int1,rx_int2;	<span class="comment">//rx_int信号寄存器，捕捉下降沿滤波用</span></span><br><span class="line">	<span class="keyword">wire</span> neg_rx_int;	<span class="comment">// rx_int下降沿标志位</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) </span><br><span class="line">		<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			rx_int0 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			rx_int1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			rx_int2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			rx_int0 &lt;= rx_int;</span><br><span class="line">			rx_int1 &lt;= rx_int0;</span><br><span class="line">			rx_int2 &lt;= rx_int1;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span> neg_rx_int =  ~rx_int1 &amp; rx_int2;	<span class="comment">//捕捉到下降沿后，neg_rx_int拉高保持一个主时钟周期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//---------------------------------------------------------</span></span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] tx_data;	<span class="comment">//待发送数据的寄存器</span></span><br><span class="line">	<span class="keyword">reg</span> bps_start_r;</span><br><span class="line">	<span class="keyword">reg</span> tx_en;	<span class="comment">//发送数据使能信号，高有效</span></span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) </span><br><span class="line">		<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			tx_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			tx_data &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(neg_rx_int) <span class="keyword">begin</span>	<span class="comment">//接收数据完毕，准备把接收到的数据发回去</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			tx_data &lt;= rx_data;	<span class="comment">//把接收到的数据存入发送数据寄存器</span></span><br><span class="line">			tx_en &lt;= <span class="number">1&#x27;b1</span>;		<span class="comment">//进入发送数据状态中</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">4&#x27;d10</span>) <span class="keyword">begin</span>	<span class="comment">//数据发送完成，复位</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			tx_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span> bps_start = bps_start_r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//---------------------------------------------------------</span></span><br><span class="line">	<span class="keyword">reg</span> uart_tx_r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">		<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			num &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">			uart_tx_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tx_en) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span>(clk_bps)	<span class="keyword">begin</span></span><br><span class="line">				num &lt;= num+<span class="number">1&#x27;b1</span>;</span><br><span class="line">				<span class="keyword">case</span> (num)</span><br><span class="line">					<span class="number">4&#x27;d0</span>: uart_tx_r &lt;= <span class="number">1&#x27;b0</span>; 	<span class="comment">//发送起始位</span></span><br><span class="line">					<span class="number">4&#x27;d1</span>: uart_tx_r &lt;= tx_data[<span class="number">0</span>];	<span class="comment">//发送bit0</span></span><br><span class="line">					<span class="number">4&#x27;d2</span>: uart_tx_r &lt;= tx_data[<span class="number">1</span>];	<span class="comment">//发送bit1</span></span><br><span class="line">					<span class="number">4&#x27;d3</span>: uart_tx_r &lt;= tx_data[<span class="number">2</span>];	<span class="comment">//发送bit2</span></span><br><span class="line">					<span class="number">4&#x27;d4</span>: uart_tx_r &lt;= tx_data[<span class="number">3</span>];	<span class="comment">//发送bit3</span></span><br><span class="line">					<span class="number">4&#x27;d5</span>: uart_tx_r &lt;= tx_data[<span class="number">4</span>];	<span class="comment">//发送bit4</span></span><br><span class="line">					<span class="number">4&#x27;d6</span>: uart_tx_r &lt;= tx_data[<span class="number">5</span>];	<span class="comment">//发送bit5</span></span><br><span class="line">					<span class="number">4&#x27;d7</span>: uart_tx_r &lt;= tx_data[<span class="number">6</span>];	<span class="comment">//发送bit6</span></span><br><span class="line">					<span class="number">4&#x27;d8</span>: uart_tx_r &lt;= tx_data[<span class="number">7</span>];	<span class="comment">//发送bit7</span></span><br><span class="line">					<span class="number">4&#x27;d9</span>: uart_tx_r &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//发送结束位</span></span><br><span class="line">				 	<span class="keyword">default</span>: uart_tx_r &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">				<span class="keyword">endcase</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">4&#x27;d10</span>) num &lt;= <span class="number">4&#x27;d0</span>;	<span class="comment">//复位</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span> uart_tx = uart_tx_r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>my_uart_rx.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> my_uart_rx(</span><br><span class="line">	clk,</span><br><span class="line">	rst_n,</span><br><span class="line">	uart_rx,</span><br><span class="line">	rx_data,</span><br><span class="line">	rx_int,</span><br><span class="line">	clk_bps,</span><br><span class="line">	bps_start</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">input</span> clk;		<span class="comment">// 25MHz主时钟</span></span><br><span class="line">	<span class="keyword">input</span> rst_n;	<span class="comment">//低电平复位信号</span></span><br><span class="line">	<span class="keyword">input</span> uart_rx;	<span class="comment">// RS232接收数据信号</span></span><br><span class="line">	<span class="keyword">input</span> clk_bps;	<span class="comment">// clk_bps的高电平为接收或者发送数据位的中间采样点</span></span><br><span class="line">	<span class="keyword">output</span> bps_start;		<span class="comment">//接收到数据后，波特率时钟启动信号置位</span></span><br><span class="line">	<span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] rx_data;	<span class="comment">//接收数据寄存器，保存直至下一个数据来到 </span></span><br><span class="line">	<span class="keyword">output</span> rx_int;	<span class="comment">//接收数据中断信号,接收到数据期间始终为高电平</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//----------------------------------------------------------------</span></span><br><span class="line">	<span class="keyword">reg</span> uart_rx0,uart_rx1,uart_rx2,uart_rx3;	<span class="comment">//接收数据寄存器，滤波用</span></span><br><span class="line">	<span class="keyword">wire</span> neg_uart_rx;	<span class="comment">//表示数据线接收到下降沿</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) </span><br><span class="line">		<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			uart_rx0 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			uart_rx1 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			uart_rx2 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			uart_rx3 &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">			uart_rx0 &lt;= uart_rx;</span><br><span class="line">			uart_rx1 &lt;= uart_rx0;</span><br><span class="line">			uart_rx2 &lt;= uart_rx1;</span><br><span class="line">			uart_rx3 &lt;= uart_rx2;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//下面的下降沿检测可以滤掉&lt;40ns-80ns的毛刺(包括高脉冲和低脉冲毛刺)，</span></span><br><span class="line">		<span class="comment">//这里就是用资源换稳定（前提是我们对时间要求不是那么苛刻，因为输入信号打了好几拍） </span></span><br><span class="line">		<span class="comment">//（当然我们的有效低脉冲信号肯定是远远大于80ns的）</span></span><br><span class="line">	<span class="keyword">assign</span> neg_uart_rx = uart_rx3 &amp; uart_rx2 &amp; ~uart_rx1 &amp; ~uart_rx0;	<span class="comment">//接收到下降沿后neg_uart_rx置高一个时钟周期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//----------------------------------------------------------------</span></span><br><span class="line">	<span class="keyword">reg</span> bps_start_r;</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] num;	<span class="comment">//移位次数</span></span><br><span class="line">	<span class="keyword">reg</span> rx_int;		<span class="comment">//接收数据中断信号,接收到数据期间始终为高电平</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">		<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">			rx_int &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(neg_uart_rx) <span class="keyword">begin</span>		<span class="comment">//接收到串口接收线uart_rx的下降沿标志信号</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//启动串口准备数据接收</span></span><br><span class="line">			rx_int &lt;= <span class="number">1&#x27;b1</span>;			<span class="comment">//接收数据中断信号使能</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">4&#x27;d9</span>) <span class="keyword">begin</span>		<span class="comment">//接收完有用数据信息</span></span><br><span class="line">			bps_start_r &lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">//数据接收完毕，释放波特率启动信号</span></span><br><span class="line">			rx_int &lt;= <span class="number">1&#x27;b0</span>;			<span class="comment">//接收数据中断信号关闭</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span> bps_start = bps_start_r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//----------------------------------------------------------------</span></span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] rx_data_r;		<span class="comment">//串口接收数据寄存器，保存直至下一个数据来到</span></span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] rx_temp_data;	<span class="comment">//当前接收数据寄存器</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">		<span class="keyword">if</span>(!rst_n) <span class="keyword">begin</span></span><br><span class="line">			rx_temp_data &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">			num &lt;= <span class="number">4&#x27;d0</span>;</span><br><span class="line">			rx_data_r &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(rx_int) <span class="keyword">begin</span>	<span class="comment">//接收数据处理</span></span><br><span class="line">			<span class="keyword">if</span>(clk_bps) <span class="keyword">begin</span>	<span class="comment">//读取并保存数据,接收数据为一个起始位，8bit数据，1或2个结束位		</span></span><br><span class="line">				num &lt;= num+<span class="number">1&#x27;b1</span>;</span><br><span class="line">				<span class="keyword">case</span> (num)</span><br><span class="line">					<span class="number">4&#x27;d1</span>: rx_temp_data[<span class="number">0</span>] &lt;= uart_rx;	<span class="comment">//锁存第0bit</span></span><br><span class="line">					<span class="number">4&#x27;d2</span>: rx_temp_data[<span class="number">1</span>] &lt;= uart_rx;	<span class="comment">//锁存第1bit</span></span><br><span class="line">					<span class="number">4&#x27;d3</span>: rx_temp_data[<span class="number">2</span>] &lt;= uart_rx;	<span class="comment">//锁存第2bit</span></span><br><span class="line">					<span class="number">4&#x27;d4</span>: rx_temp_data[<span class="number">3</span>] &lt;= uart_rx;	<span class="comment">//锁存第3bit</span></span><br><span class="line">					<span class="number">4&#x27;d5</span>: rx_temp_data[<span class="number">4</span>] &lt;= uart_rx;	<span class="comment">//锁存第4bit</span></span><br><span class="line">					<span class="number">4&#x27;d6</span>: rx_temp_data[<span class="number">5</span>] &lt;= uart_rx;	<span class="comment">//锁存第5bit</span></span><br><span class="line">					<span class="number">4&#x27;d7</span>: rx_temp_data[<span class="number">6</span>] &lt;= uart_rx;	<span class="comment">//锁存第6bit</span></span><br><span class="line">					<span class="number">4&#x27;d8</span>: rx_temp_data[<span class="number">7</span>] &lt;= uart_rx;	<span class="comment">//锁存第7bit</span></span><br><span class="line">					<span class="keyword">default</span>: ;</span><br><span class="line">				<span class="keyword">endcase</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">4&#x27;d9</span>) <span class="keyword">begin</span>		<span class="comment">//我们的标准接收模式下只有1+8+1(2)=11bit的有效数据</span></span><br><span class="line">				num &lt;= <span class="number">4&#x27;d0</span>;			<span class="comment">//接收到STOP位后结束,num清零</span></span><br><span class="line">				rx_data_r &lt;= rx_temp_data;	<span class="comment">//把数据锁存到数据寄存器rx_data中</span></span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span> rx_data = rx_data_r;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="2-Testbench"><a href="#2-Testbench" class="headerlink" title="2.Testbench"></a>2.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="keyword">module</span> uart_tb();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">reg</span> sys_clk_i;	<span class="comment">//50MHz时钟信号</span></span><br><span class="line"><span class="keyword">reg</span> ext_rst_n;	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line"><span class="keyword">reg</span> uart_rx;		<span class="comment">// UART接收数据信号</span></span><br><span class="line"><span class="keyword">wire</span> uart_tx;		<span class="comment">// UART发送数据信号</span></span><br><span class="line">	</span><br><span class="line">uart_design		u1_uart_design(</span><br><span class="line">			<span class="variable">.sys_clk_i</span>(sys_clk_i),	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">			<span class="variable">.ext_rst_n</span>(ext_rst_n),	<span class="comment">//外部输入复位信号，低电平有效</span></span><br><span class="line">			<span class="variable">.uart_rx</span>(uart_rx),</span><br><span class="line">			<span class="variable">.uart_tx</span>(uart_tx)</span><br><span class="line">		);	</span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> UART_BPS_DELAY_NS	1_000_000_000/9600		</span><span class="comment">//串口波特率延时			</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] uart_data_from_fpga;	<span class="comment">//接收FPGA发送的串口数据</span></span><br><span class="line"><span class="keyword">reg</span> uart_en_from_fpga;		<span class="comment">//接收FPGA发送的串口数据有效</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	sys_clk_i = <span class="number">0</span>;</span><br><span class="line">	ext_rst_n = <span class="number">0</span>;	<span class="comment">//复位中</span></span><br><span class="line">	uart_rx = <span class="number">1</span>;</span><br><span class="line">	uart_data_from_fpga = <span class="number">0</span>;</span><br><span class="line">	uart_en_from_fpga = <span class="number">0</span>;</span><br><span class="line">	#<span class="number">1000</span>;</span><br><span class="line">	@(<span class="keyword">posedge</span> sys_clk_i); #<span class="number">2</span>;</span><br><span class="line">	ext_rst_n = <span class="number">1</span>;	<span class="comment">//复位结束，正常工作</span></span><br><span class="line"></span><br><span class="line">	#<span class="number">100_000</span>;	<span class="comment">//延时100us</span></span><br><span class="line">	</span><br><span class="line">	pc_uart_tx_task(<span class="number">8&#x27;haa</span>);	<span class="comment">//发送数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS*10)</span>;	</span><br><span class="line">	<span class="built_in">$finish</span>;</span><br><span class="line"><span class="keyword">end</span>	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">always</span> #<span class="number">10</span> sys_clk_i = ~sys_clk_i;	<span class="comment">//50MHz时钟产生</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//模拟发送一帧串口数据</span></span><br><span class="line"><span class="keyword">task</span> pc_uart_tx_task;</span><br><span class="line">	<span class="keyword">input</span>[<span class="number">7</span>:<span class="number">0</span>] value;</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		uart_rx = <span class="number">0</span>;	<span class="comment">//起始位</span></span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;	</span><br><span class="line">		uart_rx = value[<span class="number">0</span>];</span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">		uart_rx = value[<span class="number">1</span>];</span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">		uart_rx = value[<span class="number">2</span>];</span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">		uart_rx = value[<span class="number">3</span>];</span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">		uart_rx = value[<span class="number">4</span>];</span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">		uart_rx = value[<span class="number">5</span>];</span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">		uart_rx = value[<span class="number">6</span>];</span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">		uart_rx = value[<span class="number">7</span>];</span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">		uart_rx = <span class="number">1</span>;	<span class="comment">//停止位</span></span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;		</span><br><span class="line">		uart_rx = <span class="number">1</span>;</span><br><span class="line">		<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//接收串口数据帧</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> uart_tx) <span class="keyword">begin</span></span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS/2)</span>;</span><br><span class="line">	uart_data_from_fpga[<span class="number">0</span>] = uart_tx;</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	uart_data_from_fpga[<span class="number">1</span>] = uart_tx;</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	uart_data_from_fpga[<span class="number">2</span>] = uart_tx;</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	uart_data_from_fpga[<span class="number">3</span>] = uart_tx;</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	uart_data_from_fpga[<span class="number">4</span>] = uart_tx;</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	uart_data_from_fpga[<span class="number">5</span>] = uart_tx;</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	uart_data_from_fpga[<span class="number">6</span>] = uart_tx;</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	uart_data_from_fpga[<span class="number">7</span>] = uart_tx;</span><br><span class="line">	uart_en_from_fpga = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">$display</span>(<span class="string">&quot;uart_data_from_fpga = %x\n&quot;</span>,uart_data_from_fpga);</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS)</span>;</span><br><span class="line">	uart_en_from_fpga = <span class="number">0</span>;</span><br><span class="line">	<span class="variable">#(`UART_BPS_DELAY_NS/2)</span>;</span><br><span class="line"><span class="keyword">end</span>	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-仿真结果"><a href="#3-仿真结果" class="headerlink" title="3.仿真结果"></a>3.仿真结果</h2><ul>
<li>RTL视图</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230210172236844.png" alt="image-20230210172236844"></p>
<ul>
<li>仿真波形：</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230210201852096.png" alt="image-20230210201852096"></p>
<ul>
<li>发送数据：</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230210200729375.png" alt="image-20230210200729375"></p>
<hr>
<h1 id="SPI接口DAC驱动控制"><a href="#SPI接口DAC驱动控制" class="headerlink" title="SPI接口DAC驱动控制"></a>SPI接口DAC驱动控制</h1><ul>
<li>DAC：数字-模拟转换器</li>
<li>功能描述：DAC 芯片DAC081S101的模拟电压输出直接连接到D5指示灯的正端，它的电压值决定 了D5指示灯的亮暗程度。FPGA工程实例产生一个0-255循环递增的数据，通过SPI接口不断的写入到DAC中，输出的模拟电压可以控制LED的亮暗变化</li>
</ul>
<h2 id="1-思路-4"><a href="#1-思路-4" class="headerlink" title="1.思路"></a>1.思路</h2><ul>
<li><p>发起一次DAC芯片的写入操作，需要先拉低同步信号SYNC，同时在紧接着的连续 16 个同步时钟SCLK上升沿送出数据DIN，DAC芯片内部则在时钟SCLK的下降沿采样数据DIN</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230213213410699.png" alt="image-20230213213410699" style="zoom:67%;"></p>
</li>
<li><p>DA芯片通信数据帧格式：FPGA 作为通讯的主机，若要控制DAC芯片DAC081S101完成一次转换，则一共需要传输16位的数据。最高 2 位（DB15-14）不用；DB13-12是当前传输数据的控制位，写 2’b00 时表示正常的DAC数据输出操作；DB11-DB4对应有效数据D7-0；最后4位数据DB3-0也不用</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230213213555843.png" alt="image-20230213213555843" style="zoom:50%;"></p>
</li>
<li><p>DAC使能转换信号dac_en时序</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230213231306851.png" alt="image-20230213231306851"></p>
</li>
<li><p>DAC帧同步信号dac_sync_n时序：</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230213232632326.png" alt="image-20230213232632326"></p>
</li>
</ul>
<h2 id="2-源代码-4"><a href="#2-源代码-4" class="headerlink" title="2.源代码"></a>2.源代码</h2><ul>
<li><p>SPI_DAC_design.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> SPI_DAC_design(</span><br><span class="line">		<span class="keyword">input</span> sys_clk_i,	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">		<span class="keyword">input</span> ext_rst_n,	<span class="comment">//外部输入复位信号，低电平有效			</span></span><br><span class="line">		<span class="keyword">output</span> dac_sync_n,	<span class="comment">//DAC帧同步信号，低电平有效</span></span><br><span class="line">		<span class="keyword">output</span> dac_sclk,	<span class="comment">//DAC串行时钟信号</span></span><br><span class="line">		<span class="keyword">output</span> dac_data		<span class="comment">//DAC串行数据信号</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> clk_12m5;	<span class="comment">//PLL输出12.5MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_25m;	<span class="comment">//PLL输出25MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_50m;	<span class="comment">//PLL输出50MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> clk_100m;	<span class="comment">//PLL输出100MHz时钟</span></span><br><span class="line">    <span class="keyword">wire</span> sys_rst_n;	<span class="comment">//PLL输出的locked信号，作为FPGA内部的复位信号，低电平复位，高电平正常工作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//PLL例化</span></span><br><span class="line">    clk_wiz_0 	u1_clk_wiz_0</span><br><span class="line">       (</span><br><span class="line">       <span class="comment">// Clock in ports</span></span><br><span class="line">        <span class="variable">.clk_in1</span>(sys_clk_i),      <span class="comment">// input clk_in1</span></span><br><span class="line">        <span class="comment">// Clock out ports</span></span><br><span class="line">        <span class="variable">.clk_out1</span>(clk_12m5),     <span class="comment">// output clk_out1</span></span><br><span class="line">        <span class="variable">.clk_out2</span>(clk_25m),     <span class="comment">// output clk_out2</span></span><br><span class="line">        <span class="variable">.clk_out3</span>(clk_50m),     <span class="comment">// output clk_out3</span></span><br><span class="line">        <span class="variable">.clk_out4</span>(clk_100m),     <span class="comment">// output clk_out4</span></span><br><span class="line">        <span class="comment">// Status and control signals</span></span><br><span class="line">        <span class="variable">.reset</span>(!ext_rst_n), <span class="comment">// input reset</span></span><br><span class="line">        <span class="variable">.locked</span>(sys_rst_n));      <span class="comment">// output locked</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------		</span></span><br><span class="line">    <span class="comment">//产生递增的DAC转换数据</span></span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] dac_out_bus;	<span class="comment">//DAC输出数据，模块内部自动判断该数据是否发生变化，若前后有变化，则通过IIC接口发起一次DAC转换数据写入操作，建议该数据变化速率不要超过1.5KHz</span></span><br><span class="line">    dac_dbgene		uut_dac_dbgene(</span><br><span class="line">    				<span class="variable">.clk</span>(clk_25m),		<span class="comment">//时钟信号</span></span><br><span class="line">    				<span class="variable">.rst_n</span>(sys_rst_n),	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    				<span class="variable">.dac_out_bus</span>(dac_out_bus)	<span class="comment">//DAC转换数据	</span></span><br><span class="line">    			);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------</span></span><br><span class="line">    <span class="comment">//DAC5571的IIC写DA转换数据模块</span></span><br><span class="line">    dac_controller		uut_dac_controller(</span><br><span class="line">    					<span class="variable">.clk</span>(clk_25m),		<span class="comment">//时钟信号</span></span><br><span class="line">    					<span class="variable">.rst_n</span>(sys_rst_n),	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">    					<span class="variable">.dac_out_bus</span>(dac_out_bus),	<span class="comment">//DAC输出数据，模块内部自动判断该数据是否发生变化，若前后有变化，则通过IIC接口发起一次DAC转换数据写入操作，建议该数据变化速率不要超过1.5KHz</span></span><br><span class="line">    					<span class="variable">.dac_sync_n</span>(dac_sync_n),</span><br><span class="line">    					<span class="variable">.dac_sclk</span>(dac_sclk),</span><br><span class="line">    					<span class="variable">.dac_data</span>(dac_data)</span><br><span class="line">    				);		</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dac_dbgene.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> dac_dbgene(</span><br><span class="line">	    <span class="keyword">input</span> clk,		<span class="comment">//时钟信号，25MHz</span></span><br><span class="line">	    <span class="keyword">input</span> rst_n,	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">	    <span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] dac_out_bus	<span class="comment">//DAC转换数据	</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> MAX_CNT_VALUE = <span class="number">18&#x27;d249_999</span>;		</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//10ms定时计数</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">17</span>:<span class="number">0</span>] cnt;	<span class="comment">//10ms计数器</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            cnt &lt;= <span class="number">18&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt; MAX_CNT_VALUE) </span><br><span class="line">            cnt &lt;= cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            cnt &lt;= <span class="number">18&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//DA转换数据递增</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            dac_out_bus &lt;= <span class="number">18&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(cnt == MAX_CNT_VALUE) </span><br><span class="line">            dac_out_bus &lt;= dac_out_bus+<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dac_controller.v</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> dac_controller(</span><br><span class="line">		<span class="keyword">input</span> clk,		<span class="comment">//时钟信号，25MHz</span></span><br><span class="line">		<span class="keyword">input</span> rst_n,	<span class="comment">//复位信号，低电平有效</span></span><br><span class="line">		<span class="keyword">input</span>[<span class="number">7</span>:<span class="number">0</span>] dac_out_bus,	<span class="comment">//DAC输出数据，模块内部自动判断该数据是否发生变化，若前后有变化，则通过SPI接口发起一次DAC转换数据写入操作，建议该数据变化速率不要超过1.5KHz</span></span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">reg</span> dac_sync_n,	<span class="comment">//DAC帧同步信号，低电平有效</span></span><br><span class="line">		<span class="keyword">output</span> dac_sclk,	<span class="comment">//DAC串行时钟信号</span></span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">reg</span> dac_data		<span class="comment">//DAC串行数据信号			</span></span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] cstate;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] nstate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//DAC输出时钟产生，clk的4分频，即6.25MHz</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] div;</span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            div &lt;= <span class="number">2&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            div &lt;= div+<span class="number">1&#x27;b1</span>;<span class="comment">//00 01 10 11</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> dac_sclk = ~div[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> div_en = (div == <span class="number">2&#x27;d2</span>);<span class="comment">//在时钟sclk由高变低的瞬间置1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------------------	</span></span><br><span class="line">    <span class="comment">//判断DAC输出数据是否变化，若变化则发起一次SPI数据写入操作					</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] dac_out_bus_r;		<span class="comment">//dac_data缓存寄存器</span></span><br><span class="line">    <span class="keyword">reg</span> dac_en;		<span class="comment">//DAC转换使能信号，高电平有效															</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁存前一拍的DAC值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span>									</span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            dac_out_bus_r &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(div_en) </span><br><span class="line">            dac_out_bus_r &lt;= dac_out_bus;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要写入新的DAC值，赋值DAC转换使能信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span>									</span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            dac_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(div_en) <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">if</span>(dac_out_bus_r != dac_out_bus) </span><br><span class="line">                dac_en &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//若DAC当前值与新的值不一致，则发起一次写DAC操作</span></span><br><span class="line">    		<span class="keyword">else</span> </span><br><span class="line">                dac_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="keyword">parameter</span> DAC_BIT15_14 = <span class="number">2&#x27;b00</span>;	<span class="comment">//don&#x27;t care</span></span><br><span class="line">    <span class="keyword">parameter</span> DAC_BIT13_12 = <span class="number">2&#x27;b00</span>;	<span class="comment">//2&#x27;b00--normal operation; 2&#x27;b01--1kohm to gnd; 2&#x27;b10--100kohm to gnd; 2&#x27;b11--high impedance</span></span><br><span class="line">    <span class="keyword">parameter</span> DAC_BIT3_0 = <span class="number">4&#x27;b0000</span>;	<span class="comment">//don&#x27;t care</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">15</span>:<span class="number">0</span>] dac_parallel_data = &#123;DAC_BIT15_14,DAC_BIT13_12,dac_out_bus_r,DAC_BIT3_0&#125;;	<span class="comment">//写入DAC的16位数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//DAC芯片SPI时序状态机</span></span><br><span class="line">    <span class="keyword">parameter</span> STATE_IDLE = <span class="number">5&#x27;d0</span>;	</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB15 = <span class="number">5&#x27;d1</span>;	</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB14 = <span class="number">5&#x27;d2</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB13 = <span class="number">5&#x27;d3</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB12 = <span class="number">5&#x27;d4</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB11 = <span class="number">5&#x27;d5</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB10 = <span class="number">5&#x27;d6</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB09 = <span class="number">5&#x27;d7</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB08 = <span class="number">5&#x27;d8</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB07 = <span class="number">5&#x27;d9</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB06 = <span class="number">5&#x27;d10</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB05 = <span class="number">5&#x27;d11</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB04 = <span class="number">5&#x27;d12</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB03 = <span class="number">5&#x27;d13</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB02 = <span class="number">5&#x27;d14</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB01 = <span class="number">5&#x27;d15</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DB00 = <span class="number">5&#x27;d16</span>;</span><br><span class="line">    <span class="keyword">parameter</span> STATE_DONE = <span class="number">5&#x27;d17</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时序逻辑，状态切换</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            cstate &lt;= STATE_IDLE;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            cstate &lt;= nstate;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换下一个状态</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            nstate &lt;= STATE_IDLE;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(div_en) <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(cstate)</span><br><span class="line">    			STATE_IDLE:	<span class="keyword">begin</span> </span><br><span class="line">                    <span class="keyword">if</span>(dac_en) </span><br><span class="line">                        nstate &lt;= STATE_DB15;	<span class="comment">//DAC芯片写操作</span></span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        nstate &lt;= STATE_IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    			STATE_DB15: nstate &lt;= STATE_DB14;</span><br><span class="line">    			STATE_DB14: nstate &lt;= STATE_DB13;</span><br><span class="line">    			STATE_DB13: nstate &lt;= STATE_DB12;</span><br><span class="line">    			STATE_DB12: nstate &lt;= STATE_DB11;</span><br><span class="line">    			STATE_DB11: nstate &lt;= STATE_DB10;</span><br><span class="line">    			STATE_DB10: nstate &lt;= STATE_DB09;</span><br><span class="line">    			STATE_DB09: nstate &lt;= STATE_DB08;</span><br><span class="line">    			STATE_DB08: nstate &lt;= STATE_DB07;			</span><br><span class="line">    			STATE_DB07: nstate &lt;= STATE_DB06;</span><br><span class="line">    			STATE_DB06: nstate &lt;= STATE_DB05;</span><br><span class="line">    			STATE_DB05: nstate &lt;= STATE_DB04;</span><br><span class="line">    			STATE_DB04: nstate &lt;= STATE_DB03;</span><br><span class="line">    			STATE_DB03: nstate &lt;= STATE_DB02;</span><br><span class="line">    			STATE_DB02: nstate &lt;= STATE_DB01;</span><br><span class="line">    			STATE_DB01: nstate &lt;= STATE_DB00;</span><br><span class="line">    			STATE_DB00: nstate &lt;= STATE_DONE;</span><br><span class="line">    			STATE_DONE: nstate &lt;= STATE_IDLE;</span><br><span class="line">    			<span class="keyword">default</span>: nstate &lt;= STATE_IDLE;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//DAC帧同步信号赋值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            dac_sync_n &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>((nstate == STATE_IDLE) &amp;&amp; div_en &amp;&amp; dac_en) </span><br><span class="line">            dac_sync_n &lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">//开始DAC操作时拉低帧同步信号</span></span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>((nstate == STATE_DB00) &amp;&amp; div_en) </span><br><span class="line">            dac_sync_n &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//结束DAC操作时拉高帧同步信号</span></span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>((nstate == STATE_IDLE) || (nstate == STATE_DONE)) </span><br><span class="line">            dac_sync_n &lt;= <span class="number">1&#x27;b1</span>;	<span class="comment">//其他状态下，帧同步信号拉高</span></span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            dac_sync_n &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//并串转换，送16位DAC数据</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!rst_n) </span><br><span class="line">            dac_data &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(nstate)</span><br><span class="line">    			STATE_IDLE:	dac_data &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    			STATE_DB15: dac_data &lt;= dac_parallel_data[<span class="number">15</span>];</span><br><span class="line">    			STATE_DB14: dac_data &lt;= dac_parallel_data[<span class="number">14</span>];</span><br><span class="line">    			STATE_DB13: dac_data &lt;= dac_parallel_data[<span class="number">13</span>];</span><br><span class="line">    			STATE_DB12: dac_data &lt;= dac_parallel_data[<span class="number">12</span>];</span><br><span class="line">    			STATE_DB11: dac_data &lt;= dac_parallel_data[<span class="number">11</span>];</span><br><span class="line">    			STATE_DB10: dac_data &lt;= dac_parallel_data[<span class="number">10</span>];</span><br><span class="line">    			STATE_DB09: dac_data &lt;= dac_parallel_data[<span class="number">9</span>];</span><br><span class="line">    			STATE_DB08: dac_data &lt;= dac_parallel_data[<span class="number">8</span>];			</span><br><span class="line">    			STATE_DB07: dac_data &lt;= dac_parallel_data[<span class="number">7</span>];</span><br><span class="line">    			STATE_DB06: dac_data &lt;= dac_parallel_data[<span class="number">6</span>];</span><br><span class="line">    			STATE_DB05: dac_data &lt;= dac_parallel_data[<span class="number">5</span>];</span><br><span class="line">    			STATE_DB04: dac_data &lt;= dac_parallel_data[<span class="number">4</span>];</span><br><span class="line">    			STATE_DB03: dac_data &lt;= dac_parallel_data[<span class="number">3</span>];</span><br><span class="line">    			STATE_DB02: dac_data &lt;= dac_parallel_data[<span class="number">2</span>];</span><br><span class="line">    			STATE_DB01: dac_data &lt;= dac_parallel_data[<span class="number">1</span>];</span><br><span class="line">    			STATE_DB00: dac_data &lt;= dac_parallel_data[<span class="number">0</span>];</span><br><span class="line">    			STATE_DONE: dac_data &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    			<span class="keyword">default</span>: dac_data &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Testbench-4"><a href="#3-Testbench-4" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> SPI_DAC_tb;</span><br><span class="line">    <span class="keyword">reg</span> clk;	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">    <span class="keyword">reg</span> rst_n;	<span class="comment">//外部输入复位信号，低电平有效			</span></span><br><span class="line">    <span class="keyword">wire</span> dac_sync_n;	<span class="comment">//DAC帧同步信号，低电平有效</span></span><br><span class="line">    <span class="keyword">wire</span> dac_sclk;	<span class="comment">//DAC串行时钟信号</span></span><br><span class="line">    <span class="keyword">wire</span> dac_data;		<span class="comment">//DAC串行数据信号</span></span><br><span class="line">    </span><br><span class="line">    SPI_DAC_design	uut_SPI_DAC_design(</span><br><span class="line">    			<span class="variable">.sys_clk_i</span>(clk),	<span class="comment">//外部输入50MHz时钟信号</span></span><br><span class="line">    			<span class="variable">.ext_rst_n</span>(rst_n),	<span class="comment">//外部输入复位信号，低电平有效			</span></span><br><span class="line">    			<span class="variable">.dac_sync_n</span>(dac_sync_n),	<span class="comment">//DAC帧同步信号，低电平有效</span></span><br><span class="line">    			<span class="variable">.dac_sclk</span>(dac_sclk),	<span class="comment">//DAC串行时钟信号</span></span><br><span class="line">    			<span class="variable">.dac_data</span>(dac_data)		<span class="comment">//DAC串行数据信号</span></span><br><span class="line">    		);	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	clk = <span class="number">0</span>;</span><br><span class="line">    	rst_n = <span class="number">0</span>;</span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	rst_n = <span class="number">1</span>;</span><br><span class="line">    	#<span class="number">50_000_000</span>;</span><br><span class="line">    	<span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;	</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-4"><a href="#4-仿真结果-4" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><ul>
<li><p>RTL视图</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230213232842741.png" alt="image-20230213232842741"></p>
</li>
<li><p>仿真波形</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230213224507939.png" alt="image-20230213224507939"></p>
</li>
</ul>
<hr>
<h1 id="IIC接口RTC时间显示控制"><a href="#IIC接口RTC时间显示控制" class="headerlink" title="IIC接口RTC时间显示控制"></a>IIC接口RTC时间显示控制</h1><ul>
<li>功能描述：本实例通过IIC接口定时读取RTC中的时、分、秒寄存器，同时将时、 分、秒数据通过UART发送到PC上的串口调试助手进行实时的显示；此外，PC上的串口调试助手也可以发送“0xaa+time+minute+second+0x55”这样的16进制字符串来重设RTC的时、 分、秒寄存器，重设后立即生效</li>
</ul>
<h2 id="1-思路-5"><a href="#1-思路-5" class="headerlink" title="1.思路"></a>1.思路</h2><ul>
<li><p>IIC协议：I2C通信中只涉及两条信号线，即时钟信号SCL和数据信号SDA。时钟信号为高电平时均可锁存数据（即时钟信号上升沿到下降沿之间）。当时钟信号SCL为高电平时，如果把数据信号SDA从高电平拉到低电平，则表示通信开始；如果把数据信号SDA从低电平拉到高电平，则表示通信结束。</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230214225300750.png" alt="image-20230214225300750"></p>
</li>
<li><p>器件地址（DEVICE ADDRESS）：最低位R/W表示读或者写状态，1表示读，0表示写；A0一般是由芯片的引脚决定的，PCF8563芯片的A0引脚和INT引脚公用，电路中做了上拉，因此为1。其它几位的取值由芯片定义好，查阅芯片手册可以得到。</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0/image-20230214225608426.png" alt="image-20230214225608426" style="zoom:50%;"></p>
</li>
<li></li>
</ul>
<h2 id="2-源代码-5"><a href="#2-源代码-5" class="headerlink" title="2.源代码"></a>2.源代码</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://space.bilibili.com/505270558">学习使我快乐100的个人空间_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog之边码边学</title>
    <url>/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/</url>
    <content><![CDATA[<p>本文主要利用Vivado工具，在码代码并仿真的过程中学习Verilog的知识点以及设计思路</p>
<span id="more"></span>
<h1 id="分频计数器设计"><a href="#分频计数器设计" class="headerlink" title="分频计数器设计"></a>分频计数器设计</h1><ul>
<li>将输入时钟100MHZ分频形成1MHZ</li>
</ul>
<h2 id="1-关键点"><a href="#1-关键点" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><p>最大计数值CNT_MAX为$\frac{输入时钟频率}{分频得到的频率}$，计数时从0计数到CNT_MAX-1</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产生0~100的时钟计数器</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        cnt_clk&lt;=<span class="number">8&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt_clk&lt;(`CNT_MAX-<span class="number">1</span>))<span class="comment">//从0计到99(cnt_clk为99时，其会消耗一个时钟周期回到0)，故总共消耗100个时钟周期</span></span><br><span class="line">        cnt_clk&lt;=cnt_clk+<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_clk&lt;=<span class="number">8&#x27;d0</span>;  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面代码看上去是不是像从0计数到98，但是当cnt_clk等于99时，也会进入这段代码，只是之后cnt_clk的值变为了0，故实际上这段代码是从0计数到99</li>
</ul>
</li>
<li><p>产生分频时钟，计数为0-49时为高电平，计数为50-99时为低电平</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产生1MHZ的时钟</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        clk_1mhz&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt_clk&lt;`CNT_MAX_div2)<span class="comment">//从0计到49，总共花费50个时钟周期</span></span><br><span class="line">        clk_1mhz&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        clk_1mhz&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上述分频时钟的产生实际上会比计数器的产生延时一个系统时钟周期，因为计数器cnt_clk在时钟上升沿变化时，不会被立马捕捉到，只有在再下一个时钟周期时，才能捕捉到变化后的值</li>
</ul>
</li>
</ul>
<h2 id="2-源代码"><a href="#2-源代码" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> CNT_MAX 100</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CNT_MAX_div2 `CNT_MAX/2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> vlg_design(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_1mhz</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//产生0~100的时钟计数器</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n)</span><br><span class="line">            cnt_clk&lt;=<span class="number">8&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt_clk&lt;(`CNT_MAX-<span class="number">1</span>))<span class="comment">//从0计到99(cnt_clk为99时，其会消耗一个时钟周期回到0)，故总共消耗100个时钟周期</span></span><br><span class="line">            cnt_clk&lt;=cnt_clk+<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt_clk&lt;=<span class="number">8&#x27;d0</span>;  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//产生1MHZ的时钟</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n)</span><br><span class="line">            clk_1mhz&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt_clk&lt;`CNT_MAX_div2)<span class="comment">//从0计到49，总共花费50个时钟周期</span></span><br><span class="line">            clk_1mhz&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clk_1mhz&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench"><a href="#3-Testbench" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> vlg_design_tb;</span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst_n;</span><br><span class="line">    <span class="keyword">wire</span> clk_1mhz;</span><br><span class="line">    </span><br><span class="line">    vlg_design vlg(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.clk_1mhz</span>(clk_1mhz)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> clk=~clk;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rst_n=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> rst_n=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">10_000</span> <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果"><a href="#4-仿真结果" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230105133849414.png" alt="image-20230105133849414"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230105133924479.png" alt="image-20230105133924479"></p>
<ul>
<li>由仿真结果可以很明显看到cnt_clk是从0-99计数，且输出的分频时钟延时了一个周期，看上去是从1-50为高电平</li>
</ul>
<hr>
<h1 id="使能时钟设计"><a href="#使能时钟设计" class="headerlink" title="使能时钟设计"></a>使能时钟设计</h1><ul>
<li>输入时钟100MHz，产生一个5MHz的时钟使能信号，并使能此时钟使能信号进行0~15的周期计数</li>
</ul>
<h2 id="1-关键点-1"><a href="#1-关键点-1" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><p>时钟使能信号只是持续了一个时钟周期，故用<code>divcnt==(DIVCNT_MAX-1)</code>来判断是否拉高</p>
</li>
<li><p>时序逻辑中，数据变化时，其他模块获取不到该数据变化的值，只有在下一个时钟周期时才能获取变化后的值，也就是相应数据的变化会在对应数据持续一个时钟周期之后再改变</p>
</li>
</ul>
<h2 id="2-源代码-1"><a href="#2-源代码-1" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> clk_en(</span><br><span class="line">    clk,</span><br><span class="line">    rst_n,</span><br><span class="line">    cnt</span><br><span class="line">);</span><br><span class="line">    <span class="comment">////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//输入输出端口的定义</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst_n;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt;<span class="comment">//输出计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//中间变量的定义</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] divcnt;<span class="comment">//分频计数器</span></span><br><span class="line">    <span class="keyword">localparam</span> DIVCNT_MAX = <span class="number">5&#x27;d20</span>;<span class="comment">//完成分频需要计数的最大值</span></span><br><span class="line">    <span class="keyword">reg</span> clk_en;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//计数器计数模块</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n)</span><br><span class="line">            divcnt&lt;=<span class="number">5&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(divcnt&lt;(DIVCNT_MAX-<span class="number">1</span>))</span><br><span class="line">            divcnt&lt;=divcnt+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            divcnt&lt;=<span class="number">5&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//时钟使能信号产生模块</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n)</span><br><span class="line">            clk_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(divcnt==(DIVCNT_MAX-<span class="number">1</span>))</span><br><span class="line">            clk_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            clk_en&lt;=<span class="number">1&#x27;b0</span>;            </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//时钟使能信号使能计数模块</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n)</span><br><span class="line">            cnt&lt;=<span class="number">4&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(clk_en==<span class="number">1&#x27;b1</span>)</span><br><span class="line">            cnt&lt;=cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt&lt;=cnt;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-1"><a href="#3-Testbench-1" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clk_en_tb;</span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst_n;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    </span><br><span class="line">    clk_en clk_en_U1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.cnt</span>(cnt)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> clk=~clk;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rst_n=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> rst_n=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">33_000</span> <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-1"><a href="#4-仿真结果-1" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230106162208489.png" alt="image-20230106162208489"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230106162114767.png" alt="image-20230106162114767"></p>
<hr>
<h1 id="基于Xlinx-BUFGCE原语的门控时钟设计"><a href="#基于Xlinx-BUFGCE原语的门控时钟设计" class="headerlink" title="基于Xlinx BUFGCE原语的门控时钟设计"></a>基于Xlinx BUFGCE原语的门控时钟设计</h1><ul>
<li>FPGA系统时钟100MHz，系统每秒进行一次数据采集与处理，每次维持10ms，其余时间空闲，在空闲时间内希望关闭100MHz的工作时钟</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230108234158354.png" alt="image-20230108234158354" style="zoom: 50%;"></p>
<h2 id="1-关键点-2"><a href="#1-关键点-2" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><p>BUFGCE原语的例化</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230108234846962.png" alt="image-20230108234846962" style="zoom: 67%;"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230108235053079.png" alt="image-20230108235053079" style="zoom: 50%;"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230108235240084.png" alt="image-20230108235240084" style="zoom:50%;"></p>
</li>
<li><p><strong>利用define、ifdef、endif语句方便仿真测试</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> SIMULATION</span><span class="comment">//在真实情况下运行时，将此行注释掉就行</span></span><br><span class="line"><span class="meta">`<span class="keyword">ifdef</span> SIMULATION</span></span><br><span class="line"><span class="comment">//仿真情况下用较小的计数值代替，不然仿真时间过长</span></span><br><span class="line"><span class="keyword">localparam</span> TIMER_CNT_1s = <span class="number">30&#x27;d1_000</span>-<span class="number">1&#x27;b1</span>;<span class="comment">//1s计数的最大值</span></span><br><span class="line"><span class="keyword">localparam</span> TIMER_CNT_10ms=<span class="number">30&#x27;d1_0</span>-<span class="number">1&#x27;b1</span>;<span class="comment">//10ms计数的最大值 </span></span><br><span class="line"><span class="meta">`<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">localparam</span> TIMER_CNT_1S = <span class="number">30&#x27;d100_000_000</span>-<span class="number">1&#x27;b1</span>;	<span class="comment">//1s计数的最大值	</span></span><br><span class="line"><span class="keyword">localparam</span> TIMER_CNT_10MS = <span class="number">30&#x27;d1_000_000</span>-<span class="number">1&#x27;b1</span>;	<span class="comment">//10ms计数的最大值</span></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-源代码-2"><a href="#2-源代码-2" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> BUFGCE_design(</span><br><span class="line">    clk,</span><br><span class="line">    rst_n,</span><br><span class="line">    outclk</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst_n;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> outclk;</span><br><span class="line"></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> SIMULATION</span><span class="comment">//在真实情况下运行时，将此行注释掉就行</span></span><br><span class="line">    <span class="meta">`<span class="keyword">ifdef</span> SIMULATION</span></span><br><span class="line">    <span class="comment">//仿真情况下用较小的计数值代替，不然仿真时间过长</span></span><br><span class="line">    <span class="keyword">localparam</span> TIMER_CNT_1s = <span class="number">30&#x27;d1_000</span>-<span class="number">1&#x27;b1</span>;<span class="comment">//1s计数的最大值</span></span><br><span class="line">    <span class="keyword">localparam</span> TIMER_CNT_10ms=<span class="number">30&#x27;d1_0</span>-<span class="number">1&#x27;b1</span>;<span class="comment">//10ms计数的最大值 </span></span><br><span class="line">    <span class="meta">`<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">localparam</span> TIMER_CNT_1S = <span class="number">30&#x27;d100_000_000</span>-<span class="number">1&#x27;b1</span>;	<span class="comment">//1s计数的最大值	</span></span><br><span class="line">    <span class="keyword">localparam</span> TIMER_CNT_10MS = <span class="number">30&#x27;d1_000_000</span>-<span class="number">1&#x27;b1</span>;	<span class="comment">//10ms计数的最大值</span></span><br><span class="line">    <span class="meta">`<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//中间变量</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">29</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">reg</span> en_10ms;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//1s周期计数模块</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n)</span><br><span class="line">            cnt&lt;=<span class="number">30&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt&lt;TIMER_CNT_1s)</span><br><span class="line">            cnt&lt;=cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cnt&lt;=<span class="number">30&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//10ms使能信号产生</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst_n)</span><br><span class="line">            en_10ms&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt&lt;=TIMER_CNT_10ms)</span><br><span class="line">            en_10ms&lt;=<span class="number">1&#x27;b1</span>;  </span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            en_10ms&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//例化BUFGCE原语</span></span><br><span class="line">    BUFGCE BUFGCE_inst (</span><br><span class="line">        <span class="variable">.O</span>(outclk),   <span class="comment">// 1-bit output: Clock output</span></span><br><span class="line">        <span class="variable">.CE</span>(en_10ms), <span class="comment">// 1-bit input: Clock enable input for I0</span></span><br><span class="line">        <span class="variable">.I</span>(clk)    <span class="comment">// 1-bit input: Primary clock</span></span><br><span class="line">   );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-2"><a href="#3-Testbench-2" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"><span class="keyword">module</span> BUFGCE_design_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst_n;</span><br><span class="line">    <span class="keyword">wire</span> outclk;</span><br><span class="line"></span><br><span class="line">    BUFGCE_design BUFGCE_design_1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.outclk</span>(outclk)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> clk=~clk;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rst_n=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> rst_n=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">3_000_000</span> <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-2"><a href="#4-仿真结果-2" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230108234639688.png" alt="image-20230108234639688"></p>
<hr>
<h1 id="同步复位与异步复位"><a href="#同步复位与异步复位" class="headerlink" title="同步复位与异步复位"></a>同步复位与异步复位</h1><h2 id="1-关键点-3"><a href="#1-关键点-3" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li>经过同步处理的异步复位信号与同步信号受到时钟控制会同时复位，异步信号会不受时钟控制立马复位</li>
<li>同步信号与异步信号同时退出复位，同步处理的异步信号会置后一个时钟周期后退出复位</li>
</ul>
<h2 id="2-源代码-3"><a href="#2-源代码-3" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> rst_signal_design(</span><br><span class="line">    i_clk,</span><br><span class="line">    i_rst_n,</span><br><span class="line">    i_data,</span><br><span class="line">    o_sync_data,</span><br><span class="line">    o_asyn_data,</span><br><span class="line">    o_asyn_data2<span class="comment">//经过同步处理的异步复位信号</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] o_sync_data;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] o_asyn_data;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] o_asyn_data2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步复位</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            o_sync_data&lt;=<span class="number">4&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            o_sync_data&lt;=i_data;       </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步复位</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk <span class="keyword">or</span> <span class="keyword">negedge</span> i_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            o_asyn_data=<span class="number">4&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            o_asyn_data&lt;=i_data;      </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对复位信号做同步处理，产生新的异步复位信号</span></span><br><span class="line">    <span class="keyword">reg</span> r_rst_n;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">        r_rst_n&lt;=i_rst_n;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk <span class="keyword">or</span> <span class="keyword">negedge</span> r_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!r_rst_n)</span><br><span class="line">            o_asyn_data2&lt;=<span class="number">4&#x27;d0</span>;<span class="comment">//此信号将和同步复位同时做复位操作</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            o_asyn_data2&lt;=i_data;<span class="comment">//相比同步复位退出复位会延时一个时钟周期</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-3"><a href="#3-Testbench-3" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"><span class="keyword">module</span> rst_signal_design_tb;</span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] o_sync_data;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] o_asyn_data;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] o_asyn_data2;</span><br><span class="line"></span><br><span class="line">    rst_signal_design rst_signal_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_data</span>(i_data),</span><br><span class="line">        <span class="variable">.o_sync_data</span>(o_sync_data),</span><br><span class="line">        <span class="variable">.o_asyn_data</span>(o_asyn_data),</span><br><span class="line">        <span class="variable">.o_asyn_data2</span>(o_asyn_data2)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">10</span>) <span class="keyword">begin</span> @(<span class="keyword">posedge</span> i_clk); <span class="keyword">end</span></span><br><span class="line">        #<span class="number">4</span> i_rst_n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">10</span>) <span class="keyword">begin</span> @(<span class="keyword">posedge</span> i_clk); <span class="keyword">end</span></span><br><span class="line">        i_rst_n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_data&lt;=<span class="number">4&#x27;b1111</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">30_000</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-3"><a href="#4-仿真结果-3" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230109104555400.png" alt="image-20230109104555400"></p>
<hr>
<h1 id="脉冲边沿检测"><a href="#脉冲边沿检测" class="headerlink" title="脉冲边沿检测"></a>脉冲边沿检测</h1><h2 id="1-关键点-4"><a href="#1-关键点-4" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li>使用两级寄存器对输入脉冲进行缓存，低位寄存器保存的是最新输入数据，而高位寄存器保存的是低位寄存器的数据，故高位寄存器比低位寄存器慢一个时钟周期</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230109110344324.png" alt="image-20230109110344324" style="zoom: 33%;"></p>
<ul>
<li><p>关键代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] r_pulse;<span class="comment">//两级寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">        r_pulse&lt;=<span class="number">2&#x27;b00</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r_pulse&lt;=&#123;r_pulse[<span class="number">0</span>],i_pulse&#125;;</span><br><span class="line">    <span class="comment">//上述代码等效为：</span></span><br><span class="line">    <span class="comment">//r_pulse[0]&lt;=i_pulse;</span></span><br><span class="line">    <span class="comment">//r_pulse[1]&lt;=r_pulse[0];</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-源代码-4"><a href="#2-源代码-4" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> edge_detection_design(</span><br><span class="line">    i_clk,</span><br><span class="line">    i_rst_n,</span><br><span class="line">    i_pulse,</span><br><span class="line">    o_rise_flag,</span><br><span class="line">    o_down_flag</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_pulse;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o_rise_flag;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o_down_flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] r_pulse;<span class="comment">//两级寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            r_pulse&lt;=<span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r_pulse&lt;=&#123;r_pulse[<span class="number">0</span>],i_pulse&#125;;</span><br><span class="line">        <span class="comment">//上述代码等效为：</span></span><br><span class="line">        <span class="comment">//r_pulse[0]&lt;=i_pulse;</span></span><br><span class="line">        <span class="comment">//r_pulse[1]&lt;=r_pulse[0];</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上升沿的判断</span></span><br><span class="line">    <span class="keyword">assign</span> o_rise_flag=r_pulse[<span class="number">0</span>]&amp;~r_pulse[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//下降沿的判断</span></span><br><span class="line">    <span class="keyword">assign</span> o_down_flag=~r_pulse[<span class="number">0</span>]&amp;r_pulse[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-4"><a href="#3-Testbench-4" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"><span class="keyword">module</span> edge_detection_design_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">reg</span> i_pulse;</span><br><span class="line">    <span class="keyword">wire</span> o_rise_flag;</span><br><span class="line">    <span class="keyword">wire</span> o_down_flag;</span><br><span class="line"></span><br><span class="line">    edge_detection_design edge_detection_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_pulse</span>(i_pulse),</span><br><span class="line">        <span class="variable">.o_rise_flag</span>(o_rise_flag), </span><br><span class="line">        <span class="variable">.o_down_flag</span>(o_down_flag) </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_pulse&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">4</span> i_pulse&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">4</span> i_pulse&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-4"><a href="#4-仿真结果-4" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230109112028556.png" alt="image-20230109112028556"></p>
<hr>
<h1 id="脉冲计数器"><a href="#脉冲计数器" class="headerlink" title="脉冲计数器"></a>脉冲计数器</h1><ul>
<li>在使能信号高电平进行计数，在低电平对计数清零</li>
</ul>
<h2 id="1-源代码"><a href="#1-源代码" class="headerlink" title="1.源代码"></a>1.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> pulse_counter_design(</span><br><span class="line">    i_clk,</span><br><span class="line">    i_rst_n,</span><br><span class="line">    i_pulse,</span><br><span class="line">    i_en,</span><br><span class="line">    o_pulse_cnt</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_pulse;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_en;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] r_pulse;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            r_pulse&lt;=<span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r_pulse=&#123;r_pulse[<span class="number">0</span>],i_pulse&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上升沿检测</span></span><br><span class="line">    <span class="keyword">wire</span> w_rise_edge;</span><br><span class="line">    <span class="keyword">assign</span> w_rise_edge=r_pulse[<span class="number">0</span>]&amp;~r_pulse[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(i_en) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(w_rise_edge)</span><br><span class="line">                o_pulse_cnt&lt;=o_pulse_cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                o_pulse_cnt&lt;=o_pulse_cnt;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            o_pulse_cnt&lt;=<span class="number">16&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span>     </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="2-Testbench"><a href="#2-Testbench" class="headerlink" title="2.Testbench"></a>2.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"><span class="keyword">module</span> pulse_counter_tb;</span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">reg</span> i_pulse;</span><br><span class="line">    <span class="keyword">reg</span> i_en;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt;</span><br><span class="line"></span><br><span class="line">    pulse_counter_design pulse_counter_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_pulse</span>(i_pulse),</span><br><span class="line">        <span class="variable">.i_en</span>(i_en), </span><br><span class="line">        <span class="variable">.o_pulse_cnt</span>(o_pulse_cnt) </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_pulse&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">4</span> i_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i_pulse激励的产生</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            #<span class="number">500</span> i_pulse&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">300</span> i_pulse&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">10_000</span>;</span><br><span class="line"></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">69</span>;i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            #<span class="number">500</span> i_pulse&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">300</span> i_pulse&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;  </span><br><span class="line">        #<span class="number">10_000</span>; </span><br><span class="line"></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            #<span class="number">500</span> i_pulse&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">300</span> i_pulse&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;  </span><br><span class="line">        #<span class="number">10_000</span>; </span><br><span class="line"></span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-仿真结果"><a href="#3-仿真结果" class="headerlink" title="3.仿真结果"></a>3.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230109113345645.png" alt="image-20230109113345645"></p>
<hr>
<h1 id="generate语法的使用"><a href="#generate语法的使用" class="headerlink" title="generate语法的使用"></a>generate语法的使用</h1><ul>
<li><p>设计一个脉冲计数器，功能如下：</p>
</li>
<li><p>输入脉冲：16路脉冲信号，分别对每路进行脉冲检测并计数</p>
</li>
<li><p>使能信号：高电平进行计数，低电平清零计数器</p>
</li>
</ul>
<h2 id="1-关键点-5"><a href="#1-关键点-5" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li>generate语法有generate for、generate if和generate case三种，可以在generate中使用的语法语句包括module、UDP（用户自定义原语）、门级原语、连续赋值语句assign、always语句和initial语句等</li>
<li>定义genvar作为generate我的循环变量</li>
<li>随机数的产生：<code>&#123;$random&#125;%65536;</code>//产生0~65535的随机数，若不加括号，即为<code>$random%65536</code>，则产生-65535-+65535之间的随机数</li>
</ul>
<h2 id="2-源代码-5"><a href="#2-源代码-5" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> generate_for_design(</span><br><span class="line">    i_clk,</span><br><span class="line">    i_rst_n,</span><br><span class="line">    i_pulse,</span><br><span class="line">    i_en,</span><br><span class="line">    o_pulse_cnt0,</span><br><span class="line">    o_pulse_cnt1,</span><br><span class="line">    o_pulse_cnt2,</span><br><span class="line">    o_pulse_cnt3,</span><br><span class="line">    o_pulse_cnt4,</span><br><span class="line">    o_pulse_cnt5,</span><br><span class="line">    o_pulse_cnt6,</span><br><span class="line">    o_pulse_cnt7,</span><br><span class="line">    o_pulse_cnt8,</span><br><span class="line">    o_pulse_cnt9,</span><br><span class="line">    o_pulse_cnta,</span><br><span class="line">    o_pulse_cntb,</span><br><span class="line">    o_pulse_cntc,</span><br><span class="line">    o_pulse_cntd,</span><br><span class="line">    o_pulse_cnte,</span><br><span class="line">    o_pulse_cntf</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] i_pulse;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_en;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt0;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt1;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt2;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt3;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt4;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt5;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt6;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt7;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt8;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt9;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnta;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cntb;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cntc;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cntd;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnte;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cntf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二维数组：16个16位宽的计数器</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] r_pulse_cnt[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//genvar for模块</span></span><br><span class="line">    <span class="keyword">genvar</span> i; </span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            pulse_counter_design pulse_counter_design_U(</span><br><span class="line">                <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">                <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">                <span class="variable">.i_pulse</span>(i_pulse[i]),</span><br><span class="line">                <span class="variable">.i_en</span>(i_en), </span><br><span class="line">                <span class="variable">.o_pulse_cnt</span>(r_pulse_cnt[i]) </span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt0=r_pulse_cnt[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt1=r_pulse_cnt[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt2=r_pulse_cnt[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt3=r_pulse_cnt[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt4=r_pulse_cnt[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt5=r_pulse_cnt[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt6=r_pulse_cnt[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt7=r_pulse_cnt[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt8=r_pulse_cnt[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt9=r_pulse_cnt[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnta=r_pulse_cnt[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cntb=r_pulse_cnt[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cntc=r_pulse_cnt[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cntd=r_pulse_cnt[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnte=r_pulse_cnt[<span class="number">14</span>];</span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cntf=r_pulse_cnt[<span class="number">15</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-5"><a href="#3-Testbench-5" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 10</span></span><br><span class="line"><span class="keyword">module</span> generate_for_tb;</span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] i_pulse;</span><br><span class="line">    <span class="keyword">reg</span> i_en;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt0;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt2;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt3;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt4;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt5;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt6;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt7;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt8;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt9;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnta;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cntb;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cntc;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cntd;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnte;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cntf;</span><br><span class="line"></span><br><span class="line">    generate_for_design generate_for_design(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_pulse</span>(i_pulse),</span><br><span class="line">        <span class="variable">.i_en</span>(i_en), </span><br><span class="line">        <span class="variable">.o_pulse_cnt0</span>(o_pulse_cnt0),</span><br><span class="line">        <span class="variable">.o_pulse_cnt1</span>(o_pulse_cnt1),</span><br><span class="line">        <span class="variable">.o_pulse_cnt2</span>(o_pulse_cnt2),</span><br><span class="line">        <span class="variable">.o_pulse_cnt3</span>(o_pulse_cnt3),</span><br><span class="line">        <span class="variable">.o_pulse_cnt4</span>(o_pulse_cnt4),</span><br><span class="line">        <span class="variable">.o_pulse_cnt5</span>(o_pulse_cnt5),</span><br><span class="line">        <span class="variable">.o_pulse_cnt6</span>(o_pulse_cnt6),</span><br><span class="line">        <span class="variable">.o_pulse_cnt7</span>(o_pulse_cnt7),</span><br><span class="line">        <span class="variable">.o_pulse_cnt8</span>(o_pulse_cnt8),</span><br><span class="line">        <span class="variable">.o_pulse_cnt9</span>(o_pulse_cnt9),</span><br><span class="line">        <span class="variable">.o_pulse_cnta</span>(o_pulse_cnta),</span><br><span class="line">        <span class="variable">.o_pulse_cntb</span>(o_pulse_cntb),</span><br><span class="line">        <span class="variable">.o_pulse_cntc</span>(o_pulse_cntc),</span><br><span class="line">        <span class="variable">.o_pulse_cntd</span>(o_pulse_cntd),</span><br><span class="line">        <span class="variable">.o_pulse_cnte</span>(o_pulse_cnte),</span><br><span class="line">        <span class="variable">.o_pulse_cntf</span>(o_pulse_cntf)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_pulse&lt;=<span class="number">16&#x27;b0</span>;</span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">4</span> i_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i_pulse激励的产生</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            #<span class="number">500</span> i_pulse&lt;=&#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;<span class="comment">//产生0~65535的随机数</span></span><br><span class="line">            #<span class="number">300</span> i_pulse&lt;=<span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">10_000</span>;</span><br><span class="line"></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">69</span>;i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            #<span class="number">500</span> i_pulse&lt;=&#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">            #<span class="number">300</span> i_pulse&lt;=<span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;  </span><br><span class="line">        #<span class="number">10_000</span>; </span><br><span class="line"></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            #<span class="number">500</span> i_pulse&lt;=&#123;<span class="built_in">$random</span>&#125;%<span class="number">65536</span>;</span><br><span class="line">            #<span class="number">300</span> i_pulse&lt;=<span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;  </span><br><span class="line">        #<span class="number">10_000</span>; </span><br><span class="line"></span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-5"><a href="#4-仿真结果-5" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230109122519817.png" alt="image-20230109122519817"></p>
<hr>
<h1 id="频率计数器"><a href="#频率计数器" class="headerlink" title="频率计数器"></a>频率计数器</h1><ul>
<li>在使能信号控制下，计算输入脉冲的每两个上升沿之间的时钟周期数并输出，即输出脉冲频率的计数值</li>
</ul>
<h2 id="1-关键点-6"><a href="#1-关键点-6" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><p>遇到上升沿检测标志就读取脉冲数</p>
</li>
<li><p>但是要滤除第一个上升沿检测标志，因为这时候刚刚使能，读取的第一个上升沿并不是两个上升沿之间的读数，滤除方式如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//输出信号产生：需要滤除第一个w_rise_edge脉冲信号</span></span><br><span class="line"><span class="keyword">reg</span> r_flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)	<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">		r_flag &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!i_en) </span><br><span class="line">		r_flag &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(w_rise_edge) </span><br><span class="line">		r_flag &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		r_flag&lt;=r_flag;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> o_vld = w_rise_edge &amp; r_flag;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为计数值是从0开始计数，故输出计数值时需要加1</p>
</li>
</ul>
<h2 id="2-源代码-6"><a href="#2-源代码-6" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> frequency_counter_design(</span><br><span class="line">	i_clk,</span><br><span class="line">	i_rst_n,</span><br><span class="line">	i_pulse,</span><br><span class="line">	i_en,</span><br><span class="line">	o_vld,</span><br><span class="line">	o_pulse_cnt</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> i_pulse;</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">wire</span> i_en;</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> o_vld;</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] r_pulse;</span><br><span class="line">    <span class="keyword">wire</span> w_rise_edge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//脉冲边沿检测逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)	</span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) r_pulse &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">    	<span class="keyword">else</span> r_pulse &lt;= &#123;r_pulse[<span class="number">0</span>],i_pulse&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> w_rise_edge = r_pulse[<span class="number">0</span>] &amp; ~r_pulse[<span class="number">1</span>];	</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//输出信号产生：需要滤除第一个w_rise_edge脉冲信号</span></span><br><span class="line">    <span class="keyword">reg</span> r_flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)	<span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">			r_flag &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(!i_en) </span><br><span class="line">			r_flag &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(w_rise_edge) </span><br><span class="line">			r_flag &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">			r_flag&lt;=r_flag;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_vld = w_rise_edge &amp; r_flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//脉冲计数逻辑</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] r_pulse_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)	<span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_en) </span><br><span class="line">			r_pulse_cnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(w_rise_edge) </span><br><span class="line">			r_pulse_cnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">			r_pulse_cnt &lt;= r_pulse_cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_pulse_cnt = r_pulse_cnt+<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-6"><a href="#3-Testbench-6" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIORD		10		</span><span class="comment">//时钟周期设置为10ns（100MHz）	</span></span><br><span class="line"><span class="keyword">module</span> frequency_counter_tb;</span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//接口申明</span></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst_n;</span><br><span class="line">    <span class="keyword">reg</span> i_pulse;</span><br><span class="line">    <span class="keyword">reg</span> i_en;</span><br><span class="line">    <span class="keyword">wire</span> o_vld;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">15</span>:<span class="number">0</span>] o_pulse_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////	</span></span><br><span class="line">    <span class="comment">//对被测试的设计进行例化</span></span><br><span class="line">    frequency_counter_design frequency_counter_design_U1(</span><br><span class="line">    	<span class="variable">.i_clk</span>(clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(rst_n),</span><br><span class="line">    	<span class="variable">.i_pulse</span>(i_pulse),</span><br><span class="line">    	<span class="variable">.i_en</span>(i_en),</span><br><span class="line">    	<span class="variable">.o_vld</span>(o_vld),</span><br><span class="line">    	<span class="variable">.o_pulse_cnt</span>(o_pulse_cnt)</span><br><span class="line">        );	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//复位和时钟产生</span></span><br><span class="line">    <span class="comment">//时钟和复位初始化、复位产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	clk &lt;= <span class="number">0</span>;</span><br><span class="line">    	rst_n &lt;= <span class="number">0</span>;</span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	rst_n &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//时钟产生</span></span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIORD/2)</span> clk = ~clk;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//测试激励产生</span></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	i_pulse &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	i_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	@(<span class="keyword">posedge</span> rst_n);	<span class="comment">//等待复位完成</span></span><br><span class="line">    </span><br><span class="line">    	@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    	<span class="keyword">repeat</span>(<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">    		@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	#<span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    	i_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">50</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">    		#<span class="number">1000</span>;</span><br><span class="line">    		i_pulse &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    		#<span class="number">1000</span>;</span><br><span class="line">    		i_pulse &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	i_en &lt;= <span class="number">1&#x27;b0</span>;	</span><br><span class="line">    	#<span class="number">10_000</span>;</span><br><span class="line">    </span><br><span class="line">    	i_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">69</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">    		#<span class="number">5000</span>;</span><br><span class="line">    		i_pulse &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    		#<span class="number">5000</span>;</span><br><span class="line">    		i_pulse &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	i_en &lt;= <span class="number">1&#x27;b0</span>;	</span><br><span class="line">    	#<span class="number">10_000</span>;	</span><br><span class="line">    </span><br><span class="line">    	i_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">    		#<span class="number">500</span>;</span><br><span class="line">    		i_pulse &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    		#<span class="number">300</span>;</span><br><span class="line">    		i_pulse &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	i_en &lt;= <span class="number">1&#x27;b0</span>;	</span><br><span class="line">    	#<span class="number">10_000</span>;</span><br><span class="line">    	<span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-6"><a href="#4-仿真结果-6" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230109194755161.png" alt="image-20230109194755161"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230109194540797.png" alt="image-20230109194540797"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230109194734655.png" alt="image-20230109194734655"></p>
<hr>
<h1 id="4位格雷码计数器"><a href="#4位格雷码计数器" class="headerlink" title="4位格雷码计数器"></a>4位格雷码计数器</h1><h2 id="1-关键点-7"><a href="#1-关键点-7" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li>系统显示任务<code>$display</code>和<code>$write</code><ul>
<li><code>$display</code>在一次输出后自动换行，而<code>$write</code>则不会</li>
<li>默认情况下，输出显示的数值所占字符个数由输出信号的数值类型和位宽决定。</li>
<li>用十进制显示时，高位的0会默认以空格填充，而用其他进制显示时，高位的0会显示出来。</li>
<li>在“%”和格式字符之间可以添加数字0，可以隐藏前置的0或空格，使得第一个非0数字顶格显示</li>
</ul>
</li>
<li>监视任务<code>$monitor</code><ul>
<li>当监视的信号发射变化时，会打印当前的值，通常与时间戳<code>$time</code>配合使用</li>
<li><code>$monitoroff</code>关闭监视</li>
<li><code>$monitoron</code>打开监视</li>
</ul>
</li>
<li>在always语句块中使用case语句描述组合逻辑，再使用assign将r_gray赋值给o_gray</li>
</ul>
<h2 id="2-源代码-7"><a href="#2-源代码-7" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gray_counter_design(</span><br><span class="line">    i_clk,<span class="comment">//50MHz的输入时钟</span></span><br><span class="line">    i_rst_n,</span><br><span class="line">    o_gray</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">localparam</span> TIMER_1S_MAX_CNT = <span class="number">32&#x27;d1_000_000_000</span>/<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//1s计数模块</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] cnt_1s;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            cnt_1s&lt;=<span class="number">32&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt_1s&lt;(TIMER_1S_MAX_CNT-<span class="number">1</span>))</span><br><span class="line">            cnt_1s&lt;=cnt_1s+<span class="number">32&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt_1s&lt;=<span class="number">32&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//计数器递增模块</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            counter&lt;=<span class="number">4&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt_1s==(TIMER_1S_MAX_CNT-<span class="number">1</span>))</span><br><span class="line">            counter&lt;=counter+<span class="number">4&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            counter&lt;=counter;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//将counter变成格雷码的形式</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] r_gray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_gray&lt;=<span class="number">4&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(counter)</span><br><span class="line">                <span class="number">4&#x27;b0000</span>:r_gray&lt;=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">                <span class="number">4&#x27;b0001</span>:r_gray&lt;=<span class="number">4&#x27;b0001</span>;</span><br><span class="line">                <span class="number">4&#x27;b0010</span>:r_gray&lt;=<span class="number">4&#x27;b0011</span>;</span><br><span class="line">                <span class="number">4&#x27;b0011</span>:r_gray&lt;=<span class="number">4&#x27;b0010</span>;</span><br><span class="line">                <span class="number">4&#x27;b0100</span>:r_gray&lt;=<span class="number">4&#x27;b0110</span>;</span><br><span class="line">                <span class="number">4&#x27;b0101</span>:r_gray&lt;=<span class="number">4&#x27;b0111</span>;</span><br><span class="line">                <span class="number">4&#x27;b0110</span>:r_gray&lt;=<span class="number">4&#x27;b0101</span>;</span><br><span class="line">                <span class="number">4&#x27;b0111</span>:r_gray&lt;=<span class="number">4&#x27;b0100</span>;</span><br><span class="line">                <span class="number">4&#x27;b1000</span>:r_gray&lt;=<span class="number">4&#x27;b1100</span>;</span><br><span class="line">                <span class="number">4&#x27;b1001</span>:r_gray&lt;=<span class="number">4&#x27;b1101</span>;</span><br><span class="line">                <span class="number">4&#x27;b1010</span>:r_gray&lt;=<span class="number">4&#x27;b1111</span>;</span><br><span class="line">                <span class="number">4&#x27;b1011</span>:r_gray&lt;=<span class="number">4&#x27;b1110</span>;</span><br><span class="line">                <span class="number">4&#x27;b1100</span>:r_gray&lt;=<span class="number">4&#x27;b1010</span>;</span><br><span class="line">                <span class="number">4&#x27;b1101</span>:r_gray&lt;=<span class="number">4&#x27;b1011</span>;</span><br><span class="line">                <span class="number">4&#x27;b1110</span>:r_gray&lt;=<span class="number">4&#x27;b1001</span>;</span><br><span class="line">                <span class="number">4&#x27;b1111</span>:r_gray&lt;=<span class="number">4&#x27;b1000</span>;</span><br><span class="line">                <span class="keyword">default</span>:;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_gray=r_gray;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-7"><a href="#3-Testbench-7" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 20</span></span><br><span class="line"><span class="keyword">module</span> gray_counter_tb;</span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    gray_counter_design gray_counter_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.o_gray</span>(o_gray)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">$monitor</span>(<span class="string">&quot;o_gray is %b at %0dns&quot;</span>,o_gray,<span class="built_in">$time</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-7"><a href="#4-仿真结果-7" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203164007128.png" alt="image-20230203164007128"></p>
<hr>
<h1 id="基于查找表的8位格雷码转换"><a href="#基于查找表的8位格雷码转换" class="headerlink" title="基于查找表的8位格雷码转换"></a>基于查找表的8位格雷码转换</h1><h2 id="1-关键点-8"><a href="#1-关键点-8" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><p>查找表</p>
<ul>
<li>查找表简单说就是一个预先存储好结果的数据表</li>
<li>通过访问这张预先存储好结果的数据表，可以快速的获取不同输入的输出结果</li>
</ul>
</li>
<li><p>ROM初始化COE文件制作</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203165642299.png" alt="image-20230203165642299"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203165922892.png" alt="image-20230203165922892" style="zoom: 50%;"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203170228814.png" alt="image-20230203170228814" style="zoom: 50%;"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203170655478.png" alt="image-20230203170655478" style="zoom: 50%;"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203170929138.png" alt="image-20230203170929138" style="zoom: 50%;"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203171454609.png" alt="image-20230203171454609" style="zoom:50%;"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203171705965.png" alt="image-20230203171705965" style="zoom: 67%;"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203172000521.png" alt="image-20230203172000521" style="zoom:50%;"></p>
</li>
<li><p><strong>打拍操作</strong>：其类似脉冲边沿检测</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203174713842.png" alt="image-20230203174713842"></p>
</li>
</ul>
<h2 id="2-源代码-8"><a href="#2-源代码-8" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gray8b_based_LUT_design(</span><br><span class="line">    i_clk,</span><br><span class="line">    i_rst_n,</span><br><span class="line">    i_en,</span><br><span class="line">    i_data,</span><br><span class="line">    o_vld,</span><br><span class="line">    o_gray</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_en;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o_vld;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打两拍操作</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] r_vld;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            r_vld&lt;=<span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r_vld&lt;=&#123;r_vld[<span class="number">0</span>],i_en&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_vld=r_vld[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    blk_mem_gen_0 blk_mem_gen_0_U (</span><br><span class="line">        <span class="variable">.clka</span>(i_clk),    <span class="comment">// input wire clka</span></span><br><span class="line">        <span class="variable">.addra</span>(i_data),  <span class="comment">// input wire [7 : 0] addra</span></span><br><span class="line">        <span class="variable">.douta</span>(o_gray)  <span class="comment">// output wire [7 : 0] douta</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-8"><a href="#3-Testbench-8" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 20</span></span><br><span class="line"><span class="keyword">module</span> grab8b_based_LUT_tb;</span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_en;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">wire</span> o_vld;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    gray8b_based_LUT_design gray8b_based_LUT_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_en</span>(i_en),</span><br><span class="line">        <span class="variable">.i_data</span>(i_data),</span><br><span class="line">        <span class="variable">.o_vld</span>(o_vld),</span><br><span class="line">        <span class="variable">.o_gray</span>(o_gray)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk&lt;=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n&lt;=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        i_data&lt;=<span class="number">8&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line">        @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line"></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        i_data&lt;=<span class="number">8&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">255</span>) <span class="keyword">begin</span></span><br><span class="line">            i_data&lt;=i_data+<span class="number">8&#x27;b1</span>;</span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        i_data&lt;=<span class="number">8&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用always对输出数据进行监控</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(o_vld) </span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;o_gray is:%b at time %d&quot;</span>,o_gray,<span class="built_in">$time</span>);</span><br><span class="line">        <span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-8"><a href="#4-仿真结果-8" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203175346897.png" alt="image-20230203175346897"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203180812501.png" alt="image-20230203180812501"></p>
<hr>
<h1 id="格雷码转换的快速算法"><a href="#格雷码转换的快速算法" class="headerlink" title="格雷码转换的快速算法"></a>格雷码转换的快速算法</h1><h2 id="1-关键点-9"><a href="#1-关键点-9" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><p>二进制码的最高位直接赋值给格雷码的最高位</p>
</li>
<li><p>对于次高位到最低位，使用二进制码相邻位异或的方式获取：</p>
<ul>
<li>若二进制码字的第i位和i+1位相同，则第i位的格雷码为0</li>
<li>若二进制码字的第i为和i+1位不同，则第i位的格雷码位1</li>
</ul>
</li>
<li><p>用generate语法实现异或处理</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">genvar</span> i;</span><br><span class="line"><span class="keyword">generate</span></span><br><span class="line">    <span class="keyword">for</span>(i=MSB-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i=i-<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">            o_gray[i]&lt;=i_data[i]^i_data[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-源代码-9"><a href="#2-源代码-9" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> grayCode_quickMethod_design #(</span><br><span class="line">    <span class="keyword">parameter</span> MSB = <span class="number">3</span></span><br><span class="line">    )</span><br><span class="line">    (</span><br><span class="line">        i_clk,</span><br><span class="line">        i_rst_n,</span><br><span class="line">        i_en,</span><br><span class="line">        i_data,</span><br><span class="line">        o_vld,</span><br><span class="line">        o_gray</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_en;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [MSB:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> o_vld;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [MSB:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            o_vld&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            o_vld&lt;=i_en;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        o_gray[MSB]&lt;=i_data[MSB];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">genvar</span> i;</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">for</span>(i=MSB-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i=i-<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">                o_gray[i]&lt;=i_data[i]^i_data[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-9"><a href="#3-Testbench-9" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 20</span></span><br><span class="line"><span class="keyword">module</span> grayCode_quickMethod_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> GRAY_MSB=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">reg</span> i_en;</span><br><span class="line">    <span class="keyword">reg</span> [GRAY_MSB:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">wire</span> o_vld;</span><br><span class="line">    <span class="keyword">wire</span> [GRAY_MSB:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    grayCode_quickMethod_design #(</span><br><span class="line">        <span class="variable">.MSB</span>(GRAY_MSB)</span><br><span class="line">        )</span><br><span class="line">        grayCode_quickMethod_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_en</span>(i_en),</span><br><span class="line">        <span class="variable">.i_data</span>(i_data),</span><br><span class="line">        <span class="variable">.o_vld</span>(o_vld),</span><br><span class="line">        <span class="variable">.o_gray</span>(o_gray)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk&lt;=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n&lt;=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        i_data&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;The value of GRAY_MSB is %0d&quot;</span>,GRAY_MSB);</span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line"></span><br><span class="line">        @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        i_data&lt;=<span class="number">0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">2</span>**(GRAY_MSB+<span class="number">1</span>)-<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            i_data&lt;=i_data+<span class="number">1</span>;</span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">            i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用always对输出数据进行监控</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(o_vld)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;o_gray is:%b&quot;</span>,o_gray);</span><br><span class="line">        <span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-9"><a href="#4-仿真结果-9" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230203194948495.png" alt="image-20230203194948495"></p>
<hr>
<h1 id="Testbench中文本文件写入操作"><a href="#Testbench中文本文件写入操作" class="headerlink" title="Testbench中文本文件写入操作"></a>Testbench中文本文件写入操作</h1><h2 id="1-关键点-10"><a href="#1-关键点-10" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><code>$fopen</code>的用法<ul>
<li><code>文件描述符=$fopen(&quot;文件名&quot;,&quot;文件操作类型&quot;)</code></li>
<li>文件操作类型：<ul>
<li><code>“r”</code>：读取文件</li>
<li><code>“w”</code>：写入文件</li>
<li><code>“a”</code>：在文件末尾追加文件</li>
</ul>
</li>
</ul>
</li>
<li><code>$fclose</code>的用法<ul>
<li><code>$fclose(&quot;文件描述符&quot;)</code></li>
</ul>
</li>
<li><code>$fwrite</code>的用法<ul>
<li><code>$fwrite(&quot;文件描述符&quot;,&quot;字符串与数据格式&quot;,变量)</code></li>
</ul>
</li>
</ul>
<h2 id="2-源代码-10"><a href="#2-源代码-10" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gray8b_based_LUT_design(</span><br><span class="line">    i_clk,</span><br><span class="line">    i_rst_n,</span><br><span class="line">    i_en,</span><br><span class="line">    i_data,</span><br><span class="line">    o_vld,</span><br><span class="line">    o_gray</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_en;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o_vld;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打两拍操作</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] r_vld;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            r_vld&lt;=<span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r_vld&lt;=&#123;r_vld[<span class="number">0</span>],i_en&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_vld=r_vld[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    blk_mem_gen_0 blk_mem_gen_0_U (</span><br><span class="line">        <span class="variable">.clka</span>(i_clk),    <span class="comment">// input wire clka</span></span><br><span class="line">        <span class="variable">.addra</span>(i_data),  <span class="comment">// input wire [7 : 0] addra</span></span><br><span class="line">        <span class="variable">.douta</span>(o_gray)  <span class="comment">// output wire [7 : 0] douta</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-10"><a href="#3-Testbench-10" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 20</span></span><br><span class="line"> <span class="keyword">module</span> grab8b_based_LUT_tb;</span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_en;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">wire</span> o_vld;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    gray8b_based_LUT_design gray8b_based_LUT_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_en</span>(i_en),</span><br><span class="line">        <span class="variable">.i_data</span>(i_data),</span><br><span class="line">        <span class="variable">.o_vld</span>(o_vld),</span><br><span class="line">        <span class="variable">.o_gray</span>(o_gray)</span><br><span class="line">    );                 </span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk&lt;=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n&lt;=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span>  wfile;</span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        i_data&lt;=<span class="number">8&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line">        @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line"></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        i_data&lt;=<span class="number">8&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">255</span>) <span class="keyword">begin</span></span><br><span class="line">            i_data&lt;=i_data+<span class="number">8&#x27;b1</span>;</span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">$fclose</span>(wfile);<span class="comment">//关闭文件</span></span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件的写入操作</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        wfile=<span class="built_in">$fopen</span>(<span class="string">&quot;D:/App_Data_File/Vivado_data/Vivado_project/gray8b_based_LUT_design_for_fileWrite/output_file/result_data.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//使用always对输出数据进行监控</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(o_vld) </span><br><span class="line">            <span class="built_in">$fwrite</span>(wfile,<span class="string">&quot;%b\n&quot;</span>,o_gray);<span class="comment">//$fdisplay与$fwrite用法一致，只是$fdisplay可以自动换行</span></span><br><span class="line">        <span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-10"><a href="#4-仿真结果-10" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230204220423725.png" alt="image-20230204220423725"></p>
<hr>
<h1 id="Testbench中文本文件读取操作"><a href="#Testbench中文本文件读取操作" class="headerlink" title="Testbench中文本文件读取操作"></a>Testbench中文本文件读取操作</h1><h2 id="1-关键点-11"><a href="#1-关键点-11" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li>十六进制文件读取$readmemh：<code>$readmenh(&quot;文件名&quot;,存储器名,起始地址,结束地址)</code></li>
<li>二进制文件读取$readmemb：<code>$readmenb(&quot;文件名&quot;,存储器名,起始地址,结束地址)</code></li>
</ul>
<h2 id="2-源代码-11"><a href="#2-源代码-11" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gray8b_based_LUT_design(</span><br><span class="line">    i_clk,</span><br><span class="line">    i_rst_n,</span><br><span class="line">    i_en,</span><br><span class="line">    i_data,</span><br><span class="line">    o_vld,</span><br><span class="line">    o_gray</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_clk;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_en;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> i_rst_n;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o_vld;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打两拍操作</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] r_vld;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            r_vld&lt;=<span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r_vld&lt;=&#123;r_vld[<span class="number">0</span>],i_en&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_vld=r_vld[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    blk_mem_gen_0 blk_mem_gen_0_U (</span><br><span class="line">        <span class="variable">.clka</span>(i_clk),    <span class="comment">// input wire clka</span></span><br><span class="line">        <span class="variable">.addra</span>(i_data),  <span class="comment">// input wire [7 : 0] addra</span></span><br><span class="line">        <span class="variable">.douta</span>(o_gray)  <span class="comment">// output wire [7 : 0] douta</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-11"><a href="#3-Testbench-11" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 20</span></span><br><span class="line"> <span class="keyword">module</span> grab8b_based_LUT_tb;</span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_en;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">wire</span> o_vld;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    gray8b_based_LUT_design gray8b_based_LUT_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_en</span>(i_en),</span><br><span class="line">        <span class="variable">.i_data</span>(i_data),</span><br><span class="line">        <span class="variable">.o_vld</span>(o_vld),</span><br><span class="line">        <span class="variable">.o_gray</span>(o_gray)</span><br><span class="line">    );                 </span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk&lt;=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n&lt;=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//文本文件的读取</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data_mem[<span class="number">255</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">initial</span> <span class="built_in">$readmemb</span>(<span class="string">&quot;D:/App_Data_File/Vivado_data/Vivado_project/gray8b_based_LUT_design_for_ReadFile/input_file/gray8_data.txt&quot;</span>,data_mem);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        i_data&lt;=<span class="number">8&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line">        @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line"></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        i_data&lt;=<span class="number">8&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">255</span>) <span class="keyword">begin</span></span><br><span class="line">            i_data&lt;=i_data+<span class="number">8&#x27;b1</span>;</span><br><span class="line">            @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        #<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较读取文件中的数据与实际生成的数据是否相等</span></span><br><span class="line">    <span class="keyword">integer</span> cnt;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            cnt&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(o_vld)</span><br><span class="line">            cnt&lt;=cnt+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(o_vld)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;%b\n%b\n&quot;</span>,o_gray,data_mem[cnt]);</span><br><span class="line">        <span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-11"><a href="#4-仿真结果-11" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230204224322669.png" alt="image-20230204224322669"></p>
<hr>
<h1 id="基于随机数的自动化仿真测试"><a href="#基于随机数的自动化仿真测试" class="headerlink" title="基于随机数的自动化仿真测试"></a>基于随机数的自动化仿真测试</h1><ul>
<li>通过自动生成随机数测试格雷码转换的快速算法模块是否正确</li>
</ul>
<h2 id="1-关键点-12"><a href="#1-关键点-12" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><p><code>$random(seed)</code></p>
</li>
<li><p>$random表示产生一个32位的随机数，如果不设置seed，每次取得的随机数是相同的</p>
</li>
<li><p><code>&#123;$random&#125;%65536;</code>//产生0~65535的随机数，若不加括号，即为<code>$random%65536</code>，则产生-65535-+65535之间的随机数</p>
</li>
<li><p><code>rand=min+&#123;$random&#125;&amp;(max-min+1)</code>产生一个在min-max之间的随机数</p>
</li>
<li><p><strong>因为格雷码快速算法要延后一个时钟周期才能计算出结果，故对文件中的数据寻址时寻址地址也要延迟一个时钟周期</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] r_data;<span class="comment">//用r_data作为寻址地址</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line"> 	r_data &lt;= i_data;</span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-源代码-12"><a href="#2-源代码-12" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gray8b_based_LUT_design #(</span><br><span class="line">    	<span class="keyword">parameter</span> MSB = <span class="number">3</span></span><br><span class="line">    )</span><br><span class="line">    (</span><br><span class="line">    	<span class="keyword">input</span> i_clk,</span><br><span class="line">    	<span class="keyword">input</span> i_rst_n,</span><br><span class="line">    	<span class="keyword">input</span> i_en,</span><br><span class="line">    	<span class="keyword">input</span>[MSB:<span class="number">0</span>] i_data,</span><br><span class="line">    	<span class="keyword">output</span> <span class="keyword">reg</span> o_vld,</span><br><span class="line">    	<span class="keyword">output</span> <span class="keyword">reg</span>[MSB:<span class="number">0</span>] o_gray</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            o_vld &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            o_vld &lt;= i_en;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	o_gray[MSB] &lt;= i_data[MSB];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">genvar</span> i;</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">    	<span class="keyword">for</span>(i=MSB-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i=i-<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    			o_gray[i] &lt;= i_data[i] ^ i_data[i+<span class="number">1</span>];	</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span>	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-12"><a href="#3-Testbench-12" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> CLK_PERIOD 20</span></span><br><span class="line"> <span class="keyword">module</span> grab8b_based_LUT_tb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> GRAY_MSB	= <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_en;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] i_data;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">wire</span> o_vld;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] o_gray;</span><br><span class="line"></span><br><span class="line">    gray8b_based_LUT_design #(</span><br><span class="line">	    <span class="variable">.MSB</span>(GRAY_MSB)</span><br><span class="line">        )   </span><br><span class="line">        gray8b_based_LUT_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_en</span>(i_en),</span><br><span class="line">        <span class="variable">.i_data</span>(i_data),</span><br><span class="line">        <span class="variable">.o_vld</span>(o_vld),</span><br><span class="line">        <span class="variable">.o_gray</span>(o_gray)</span><br><span class="line">        );                 </span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> i_clk&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIOD/2)</span> i_clk&lt;=~i_clk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复位信号的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_rst_n&lt;=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">1000</span> i_rst_n&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//文本文件的读取</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data_mem[<span class="number">255</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemb</span>(<span class="string">&quot;D:/App_Data_File/Vivado_data/Vivado_project/gray8b_based_LUT_design_for_RandomTest/input_file/gray8_data.txt&quot;</span>,data_mem);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输入激励的产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        i_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        i_data&lt;=<span class="number">8&#x27;b0</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> i_rst_n);<span class="comment">//等待复位完成</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">repeat</span>(<span class="number">2</span>**(GRAY_MSB+<span class="number">1</span>)) <span class="keyword">begin</span></span><br><span class="line">	    	@(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">	    	i_en &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">	    	i_data &lt;= &#123;<span class="built_in">$random</span>&#125; % <span class="number">256</span>;	<span class="comment">//产生0~255的随机数</span></span><br><span class="line">	    <span class="keyword">end</span></span><br><span class="line">	    @(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">	    i_en &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">	    #<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">	    <span class="built_in">$display</span>(<span class="string">&quot;Test Finish!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较读取文件中的数据与实际生成的数据是否相等</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] r_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	r_data &lt;= i_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(o_vld) <span class="keyword">begin</span></span><br><span class="line">    		<span class="built_in">$display</span>(<span class="string">&quot;i_data = %b\no_gray   = %b\ndata_mem = %b&quot;</span>,r_data,o_gray,data_mem[r_data]);</span><br><span class="line">    		<span class="keyword">if</span>(o_gray == data_mem[r_data]) <span class="keyword">begin</span></span><br><span class="line">    			<span class="built_in">$display</span>(<span class="string">&quot;Successful!\n&quot;</span>);</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line">    			<span class="built_in">$display</span>(<span class="string">&quot;Fail!&quot;</span>);</span><br><span class="line">    			<span class="built_in">$stop</span>;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-12"><a href="#4-仿真结果-12" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230204234624012.png" alt="image-20230204234624012"></p>
<hr>
<h1 id="可配置的PWM设计"><a href="#可配置的PWM设计" class="headerlink" title="可配置的PWM设计"></a>可配置的PWM设计</h1><ul>
<li>PWM波的产生，有通过i_times控制产生PWM波重复的次数</li>
</ul>
<h2 id="1-关键点-13"><a href="#1-关键点-13" class="headerlink" title="1.关键点"></a>1.关键点</h2><p>时序分析：</p>
<ul>
<li>首先需要需要i_en信号的上升沿与计数结束的标志信号w_end_en置1，从而生成控制计数器工作的使能信号r_cnt_en</li>
<li>在使能信号r_cnt_en的控制下进行PWM的周期计数，当周期计数达到其值时，次数计数加1，从而实现PWM波的次数计数</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230205235810859.png" alt="image-20230205235810859"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206000138514.png" alt="image-20230206000138514"></p>
<h2 id="2-源代码-13"><a href="#2-源代码-13" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> PWM_design(</span><br><span class="line">	<span class="keyword">input</span> i_clk,	<span class="comment">//50MHz（20ns）时钟</span></span><br><span class="line">	<span class="keyword">input</span> i_rst_n,	<span class="comment">//复位</span></span><br><span class="line">	<span class="keyword">input</span> i_en,	<span class="comment">//使能</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>] i_periord,	<span class="comment">//PWM的周期</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>] i_high,	<span class="comment">//高电平时间</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] i_times,	<span class="comment">//次数</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> o_pwm	<span class="comment">//PWM信号</span></span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] r_en;</span><br><span class="line">    <span class="keyword">wire</span> w_pos_en;</span><br><span class="line">    <span class="keyword">wire</span> w_end_en;</span><br><span class="line">    <span class="keyword">reg</span> r_cnt_en;	<span class="comment">//内部各个计数器工作的使能信号</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] r_pcnt;	<span class="comment">//周期计数器</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] r_tcnt;	<span class="comment">//周期次数的计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生i_en的上升沿标志信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            r_en &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    	    r_en &lt;= &#123;r_en[<span class="number">0</span>],i_en&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> w_pos_en = ~r_en[<span class="number">1</span>] &amp; r_en[<span class="number">0</span>];	</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生内部PWM结束信号</span></span><br><span class="line">    <span class="keyword">assign</span> w_end_en = (r_pcnt == (i_periord-<span class="number">1</span>)) &amp;&amp; (r_tcnt == (i_times-<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生内部各个计数器工作的是能信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_cnt_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(w_pos_en) </span><br><span class="line">            r_cnt_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(w_end_en) </span><br><span class="line">            r_cnt_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_cnt_en &lt;= r_cnt_en;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//周期计数</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!r_cnt_en) </span><br><span class="line">            r_pcnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(r_pcnt &lt; (i_periord-<span class="number">1</span>)) </span><br><span class="line">            r_pcnt &lt;= r_pcnt+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_pcnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//周期次数计数	</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!r_cnt_en) </span><br><span class="line">            r_tcnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(r_pcnt == (i_periord-<span class="number">1</span>)) </span><br><span class="line">            r_tcnt &lt;= r_tcnt+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_tcnt &lt;= r_tcnt;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//输出PWM波形</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            o_pwm &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>((r_pcnt &gt; <span class="number">32&#x27;d0</span>) &amp;&amp; (r_pcnt &lt;= i_high)) </span><br><span class="line">            o_pwm &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            o_pwm &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-13"><a href="#3-Testbench-13" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> PWM_tb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> CLK_PERIORD		20		</span><span class="comment">//时钟周期设置为20ns（50MHz）	</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//接口申明</span></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst_n;</span><br><span class="line">    <span class="keyword">reg</span> i_en;	<span class="comment">//使能</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] i_periord;	<span class="comment">//周期，单位：40ns</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] i_high;	<span class="comment">//高电平时间，单位：40ns</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] i_times;	<span class="comment">//次数</span></span><br><span class="line">    <span class="keyword">wire</span> o_pwm;		<span class="comment">//PWM信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////	</span></span><br><span class="line">    <span class="comment">//对被测试的设计进行例化</span></span><br><span class="line">    PWM_design PWM_design_U1(</span><br><span class="line">    	<span class="variable">.i_clk</span>(clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(rst_n),</span><br><span class="line">    	<span class="variable">.i_en</span>(i_en),</span><br><span class="line">    	<span class="variable">.i_periord</span>(i_periord),</span><br><span class="line">    	<span class="variable">.i_high</span>(i_high),</span><br><span class="line">    	<span class="variable">.i_times</span>(i_times),</span><br><span class="line">    	<span class="variable">.o_pwm</span>(o_pwm)</span><br><span class="line">        );	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//复位和时钟产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	clk &lt;= <span class="number">0</span>;</span><br><span class="line">    	rst_n &lt;= <span class="number">0</span>;</span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	rst_n &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIORD/2)</span> clk = ~clk;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//测试激励产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	i_en		&lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">//使能</span></span><br><span class="line">    	i_periord	&lt;= <span class="number">32&#x27;d0</span>;	<span class="comment">//周期，单位：40ns</span></span><br><span class="line">    	i_high		&lt;= <span class="number">32&#x27;d0</span>;	<span class="comment">//高电平时间，单位：40ns</span></span><br><span class="line">    	i_times		&lt;= <span class="number">32&#x27;d0</span>;	<span class="comment">//次数</span></span><br><span class="line"></span><br><span class="line">    	@(<span class="keyword">posedge</span> rst_n);	<span class="comment">//等待复位完成</span></span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    </span><br><span class="line">    	task_pwm_setting(<span class="number">2500</span>,<span class="number">250</span>,<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    	#<span class="number">100_000</span>;</span><br><span class="line">    </span><br><span class="line">    	task_pwm_setting(<span class="number">1000</span>,<span class="number">500</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    	#<span class="number">10_000</span>;</span><br><span class="line">    	<span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> task_pwm_setting;</span><br><span class="line">    	<span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>] pwm_periord;</span><br><span class="line">    	<span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>] pwm_high;</span><br><span class="line">    	<span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] pwm_times;</span><br><span class="line">    	<span class="keyword">begin</span></span><br><span class="line">    		@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    		i_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    </span><br><span class="line">    		i_periord &lt;= pwm_periord;</span><br><span class="line">    		i_high &lt;= pwm_high;</span><br><span class="line">    		i_times &lt;= pwm_times;</span><br><span class="line">    		<span class="variable">#(pwm_periord*pwm_times*`CLK_PERIORD)</span>;</span><br><span class="line">    		@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    		i_en &lt;= <span class="number">1&#x27;b0</span>;				</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-13"><a href="#4-仿真结果-13" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206000713569.png" alt="image-20230206000713569"></p>
<hr>
<h1 id="超声波测距设计"><a href="#超声波测距设计" class="headerlink" title="超声波测距设计"></a>超声波测距设计</h1><h2 id="1-关键点-14"><a href="#1-关键点-14" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><p>超声波测距模块原理：每隔100ms时间，定时产生10us时间的TRIG高脉冲给到超声波测距模块，用于触发超声波模块工作，通过测量ECHO端口高电平持续的时间即可得到距离信息</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E6%A8%A1%E5%9D%97-1675668397252-2.png" alt="超声波测距模块"></p>
</li>
<li><p><strong>模块划分与接口定义</strong>：</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/%E7%AB%AF%E5%8F%A3%E5%88%92%E5%88%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89-1675669738038-5.png" alt="端口划分与接口定义"></p>
</li>
<li><p><strong>IP核实现乘法器</strong>：</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206163556109.png" alt="image-20230206163556109"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206164233042.png" alt="image-20230206164233042"></p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206164149984.png" alt="image-20230206164149984"></p>
</li>
</ul>
<h2 id="2-源代码-14"><a href="#2-源代码-14" class="headerlink" title="2.源代码"></a>2.源代码</h2><ul>
<li>顶层模块supersonic_wave_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> supersonic_wave_design(</span><br><span class="line">    <span class="keyword">input</span> i_clk,</span><br><span class="line">    <span class="keyword">input</span> i_rst_n,</span><br><span class="line">    <span class="keyword">input</span> i_echo,</span><br><span class="line">    <span class="keyword">output</span> o_trig,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">13</span>:<span class="number">0</span>] o_s_mm</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">localparam</span> P_CLK_PERIORD=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">wire</span> w_clk_en;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] w_t_us;</span><br><span class="line"></span><br><span class="line">    en_design #(</span><br><span class="line">    	<span class="variable">.P_CLK_PERIORD</span>(P_CLK_PERIORD)	<span class="comment">//i_clk的时钟周期为20ns</span></span><br><span class="line">    )</span><br><span class="line">    uut_en_design(</span><br><span class="line">    	<span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">    	<span class="variable">.o_clk_en</span>(w_clk_en)</span><br><span class="line">    );	</span><br><span class="line">    </span><br><span class="line">    trig_design	uut_trig_design(</span><br><span class="line">    	<span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">    	<span class="variable">.i_clk_en</span>(w_clk_en),</span><br><span class="line">    	<span class="variable">.o_trig</span>(o_trig)</span><br><span class="line">    );	</span><br><span class="line"></span><br><span class="line">    echo_design	uut_echo_design(</span><br><span class="line">    	<span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">    	<span class="variable">.i_clk_en</span>(w_clk_en),</span><br><span class="line">    	<span class="variable">.i_echo</span>(i_echo),</span><br><span class="line">    	<span class="variable">.o_t_us</span>(w_t_us)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    cal_design uut_cal_design(</span><br><span class="line">        <span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">        <span class="variable">.i_t_us</span>(w_t_us),</span><br><span class="line">        <span class="variable">.o_s_mm</span>(o_s_mm)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子模块：en_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> en_design #(<span class="keyword">parameter</span> P_CLK_PERIORD = <span class="number">20</span>)</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">input</span> i_clk,</span><br><span class="line">        <span class="keyword">input</span> i_rst_n,</span><br><span class="line">        <span class="keyword">output</span> <span class="keyword">reg</span> o_clk_en</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">localparam</span> P_DIVCLK_MAX = <span class="number">1000</span>/P_CLK_PERIORD-<span class="number">1</span>;<span class="comment">//分频计数器的最大值</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] r_divcnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//对输出时钟i_clk做分频计数，产生1us的时钟使能信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            r_divcnt&lt;=<span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r_divcnt&lt;P_DIVCLK_MAX)</span><br><span class="line">            r_divcnt&lt;=r_divcnt+<span class="number">8&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r_divcnt&lt;=<span class="number">8&#x27;b0</span>;        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//输出1us的时钟使能信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            o_clk_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r_divcnt==P_DIVCLK_MAX)</span><br><span class="line">            o_clk_en&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            o_clk_en&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子模块：trig_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> trig_design(</span><br><span class="line">    <span class="keyword">input</span> i_clk,</span><br><span class="line">    <span class="keyword">input</span> i_rst_n,</span><br><span class="line">    <span class="keyword">input</span> i_clk_en,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> o_trig</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">localparam</span> P_TRIG_PERIORD_MAX=<span class="number">100_000</span>-<span class="number">1</span>;<span class="comment">//100ms的计数最大值</span></span><br><span class="line">    <span class="keyword">localparam</span> P_TRIG_HIGH_MAX=<span class="number">10</span>;<span class="comment">//10us高脉冲保持时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">16</span>:<span class="number">0</span>] r_tricnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//100ms的周期计数</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            r_tricnt&lt;=<span class="number">17&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i_clk_en) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(r_tricnt&lt;P_TRIG_PERIORD_MAX)</span><br><span class="line">                r_tricnt&lt;=r_tricnt+<span class="number">17&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r_tricnt&lt;=<span class="number">17&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r_tricnt&lt;=r_tricnt;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生保持10us的高脉冲o_trig信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            o_trig&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r_tricnt&gt;<span class="number">17&#x27;b0</span> &amp;&amp; r_tricnt&lt;=P_TRIG_HIGH_MAX)</span><br><span class="line">            o_trig&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            o_trig&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子模块：echo_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> echo_design(</span><br><span class="line">    	<span class="keyword">input</span> i_clk,</span><br><span class="line">    	<span class="keyword">input</span> i_rst_n,</span><br><span class="line">    	<span class="keyword">input</span> i_clk_en,</span><br><span class="line">    	<span class="keyword">input</span> i_echo,</span><br><span class="line">    	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] o_t_us</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] r_echo;</span><br><span class="line">    <span class="keyword">wire</span> pos_echo,neg_echo;</span><br><span class="line">    <span class="keyword">reg</span> r_cnt_en;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] r_echo_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    超声波测距模块的量程是2mm~4500mm</span></span><br><span class="line"><span class="comment">    根据公式 s = 0.173*t ， t = s/0.173</span></span><br><span class="line"><span class="comment">    11 &lt; t &lt; 26011</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//对i_echo信号锁存2拍，获取边沿检测信号，产生计数使能信号r_cnt_en</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_echo &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_echo &lt;= &#123;r_echo[<span class="number">0</span>],i_echo&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> pos_echo = ~r_echo[<span class="number">1</span>] &amp; r_echo[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> neg_echo = r_echo[<span class="number">1</span>] &amp; ~r_echo[<span class="number">0</span>];	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_cnt_en &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(pos_echo) </span><br><span class="line">            r_cnt_en &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(neg_echo) </span><br><span class="line">            r_cnt_en &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//对i_echo信号的高电平保持时间进行1us为单位的计数</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_echo_cnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(!r_cnt_en) </span><br><span class="line">            r_echo_cnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(i_clk_en) </span><br><span class="line">            r_echo_cnt &lt;= r_echo_cnt+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_echo_cnt &lt;= r_echo_cnt;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//对r_echo_cnt计数最大值做锁存</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            o_t_us &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(neg_echo)</span><br><span class="line">            o_t_us &lt;= r_echo_cnt;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子模块：cal_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> cal_design(</span><br><span class="line">    <span class="keyword">input</span> i_clk,</span><br><span class="line">    <span class="keyword">input</span> i_rst_n,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] i_t_us,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">13</span>:<span class="number">0</span>] o_s_mm</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s=0.173*t</span></span><br><span class="line">    <span class="comment">//s*4096=0.173*t*4096</span></span><br><span class="line">    <span class="comment">//s*4096=709*t</span></span><br><span class="line">    <span class="comment">//s=709*t/4096</span></span><br><span class="line">    <span class="comment">//s=709*t&gt;&gt;12</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">25</span>:<span class="number">0</span>] w_mult_result;</span><br><span class="line"></span><br><span class="line">    mult_gen_0 mult_gen_0_U1 (</span><br><span class="line">        <span class="variable">.CLK</span>(i_clk),  <span class="comment">// input wire CLK</span></span><br><span class="line">        <span class="variable">.A</span>(<span class="number">10&#x27;d709</span>),      <span class="comment">// input wire [9 : 0] A</span></span><br><span class="line">        <span class="variable">.B</span>(i_t_us),      <span class="comment">// input wire [15 : 0] B</span></span><br><span class="line">        <span class="variable">.P</span>(w_mult_result)      <span class="comment">// output wire [25 : 0] P</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> o_s_mm=w_mult_result[<span class="number">25</span>:<span class="number">12</span>];<span class="comment">//右移12bit，即除以4096</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-14"><a href="#3-Testbench-14" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> supersonic_wave_tb;</span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> CLK_PERIORD		20		</span><span class="comment">//时钟周期设置为20ns（50MHz）	</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//接口申明</span></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst_n;</span><br><span class="line">    <span class="keyword">wire</span> o_trig;</span><br><span class="line">    <span class="keyword">reg</span> i_echo;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">13</span>:<span class="number">0</span>] o_s_mm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////	</span></span><br><span class="line">    <span class="comment">//对被测试的设计进行例化    </span></span><br><span class="line">    supersonic_wave_design supersonic_wave_design_U1(</span><br><span class="line">        <span class="variable">.i_clk</span>(clk),</span><br><span class="line">        <span class="variable">.i_rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.i_echo</span>(i_echo),</span><br><span class="line">        <span class="variable">.o_trig</span>(o_trig),</span><br><span class="line">        <span class="variable">.o_s_mm</span>(o_s_mm)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//复位和时钟产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	clk &lt;= <span class="number">0</span>;</span><br><span class="line">    	rst_n &lt;= <span class="number">0</span>;</span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	rst_n &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIORD/2)</span> clk = ~clk;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//测试激励产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	i_echo = <span class="number">0</span>;</span><br><span class="line">    	@(<span class="keyword">posedge</span> rst_n);	<span class="comment">//等待复位完成</span></span><br><span class="line">    </span><br><span class="line">    	@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    	#<span class="number">400_000_000</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> tricnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">integer</span> dly_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> o_trig) <span class="keyword">begin</span></span><br><span class="line">    	tricnt = tricnt+<span class="number">1</span>;</span><br><span class="line">    	#<span class="number">5_000</span>;</span><br><span class="line">    	i_echo = <span class="number">1</span>;</span><br><span class="line">    	dly_time = <span class="number">11</span>+&#123;<span class="built_in">$random</span>&#125;%<span class="number">26001</span>;<span class="comment">//11 &lt; t &lt; 26011</span></span><br><span class="line">    	<span class="built_in">$display</span>(<span class="string">&quot;Test %0d:\ndistance of testbench = %0dmm&quot;</span>,tricnt,function_t2s(dly_time));</span><br><span class="line">    	<span class="variable">#(dly_time*1000)</span>;</span><br><span class="line">    	i_echo = <span class="number">0</span>;		</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	#<span class="number">1</span>;</span><br><span class="line">    	<span class="built_in">$monitor</span>(<span class="string">&quot;o_s_mm = %0dmm&quot;</span>,o_s_mm);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数实现运算 s=0.173t</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">real</span> function_t2s;</span><br><span class="line">    	<span class="keyword">input</span> <span class="keyword">real</span> t;</span><br><span class="line">    	<span class="keyword">begin</span></span><br><span class="line">    		function_t2s = <span class="number">0</span><span class="variable">.173</span>*t;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-14"><a href="#4-仿真结果-14" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><ul>
<li>RTL视图</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206165117621.png" alt="image-20230206165117621"></p>
<ul>
<li>打印输出的结果：</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206171150590.png" alt="image-20230206171150590"></p>
<hr>
<h1 id="自动售卖机状态机设计"><a href="#自动售卖机状态机设计" class="headerlink" title="自动售卖机状态机设计"></a>自动售卖机状态机设计</h1><ul>
<li>有纸币1/2/5，每次投一张，当总投入金额大于等于6时输出为1</li>
</ul>
<h2 id="1-关键点-15"><a href="#1-关键点-15" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li>状态机转换图的绘制</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/%E8%87%AA%E5%8A%A8%E5%94%AE%E5%8D%96%E6%9C%BA%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96%E5%9B%BE-1675676111194-8.png" alt="自动售卖机状态转化图"></p>
<h2 id="2-源代码-15"><a href="#2-源代码-15" class="headerlink" title="2.源代码"></a>2.源代码</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FSM_design(</span><br><span class="line">	<span class="keyword">input</span> i_clk,</span><br><span class="line">	<span class="keyword">input</span> i_rst_n,</span><br><span class="line">	<span class="keyword">input</span> i_1yuan,</span><br><span class="line">	<span class="keyword">input</span> i_2yuan,</span><br><span class="line">	<span class="keyword">input</span> i_5yuan,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> o_done</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//参数和变量的申明</span></span><br><span class="line">    <span class="keyword">localparam</span>	IDLE 	= <span class="number">4&#x27;d0</span>,</span><br><span class="line">    			IN_1	= <span class="number">4&#x27;d1</span>,</span><br><span class="line">    			IN_2	= <span class="number">4&#x27;d2</span>,</span><br><span class="line">    			IN_3	= <span class="number">4&#x27;d3</span>,</span><br><span class="line">    			IN_4	= <span class="number">4&#x27;d4</span>,</span><br><span class="line">    			IN_5	= <span class="number">4&#x27;d5</span>,</span><br><span class="line">    			IN_6	= <span class="number">4&#x27;d6</span>,</span><br><span class="line">    			DONE	= <span class="number">4&#x27;d7</span>;</span><br><span class="line">    <span class="keyword">localparam</span>	MONEY_PAY	= <span class="number">4&#x27;d6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] cstate,nstate;	</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] money_sum;		</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//时序逻辑，锁存状态</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            cstate &lt;= IDLE;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            cstate &lt;= nstate;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//组合逻辑实现状态变迁</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">case</span>(cstate)</span><br><span class="line">    		IDLE: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_1yuan || i_2yuan || i_5yuan) </span><br><span class="line">                    nstate = IN_1;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IDLE;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		IN_1: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_1yuan || i_2yuan || i_5yuan) </span><br><span class="line">                    nstate = IN_2;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IN_1;</span><br><span class="line">    		<span class="keyword">end</span>		</span><br><span class="line">    		IN_2: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(money_sum &gt;= MONEY_PAY) </span><br><span class="line">                    nstate = DONE;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span>(i_1yuan || i_2yuan || i_5yuan) </span><br><span class="line">                        nstate = IN_3;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IN_2;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		IN_3: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(money_sum &gt;= MONEY_PAY) </span><br><span class="line">                    nstate = DONE;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span>(i_1yuan || i_2yuan || i_5yuan) </span><br><span class="line">                    nstate = IN_4;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IN_3;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		IN_4: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(money_sum &gt;= MONEY_PAY) </span><br><span class="line">                    nstate = DONE;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span>(i_1yuan || i_2yuan || i_5yuan) </span><br><span class="line">                    nstate = IN_5;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IN_4;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		IN_5: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(money_sum &gt;= MONEY_PAY) </span><br><span class="line">                    nstate = DONE;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span>(i_1yuan || i_2yuan || i_5yuan) </span><br><span class="line">                    nstate = IN_6;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IN_5;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		IN_6: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(money_sum &gt;= MONEY_PAY) </span><br><span class="line">                    nstate = DONE;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span>(i_1yuan || i_2yuan || i_5yuan) </span><br><span class="line">                    nstate = DONE;</span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    nstate = IN_6;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		DONE: nstate = IDLE;</span><br><span class="line">    		<span class="keyword">default</span>: nstate = IDLE;</span><br><span class="line">    	<span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//当前状态输入钱币的累加计算</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)	<span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            money_sum &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(cstate)</span><br><span class="line">    			DONE: money_sum &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    			<span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(i_1yuan) </span><br><span class="line">                        money_sum &lt;= money_sum+<span class="number">1</span>;</span><br><span class="line">    				<span class="keyword">else</span> <span class="keyword">if</span>(i_2yuan) </span><br><span class="line">                        money_sum &lt;= money_sum+<span class="number">2</span>;</span><br><span class="line">    				<span class="keyword">else</span> <span class="keyword">if</span>(i_5yuan) </span><br><span class="line">                        money_sum &lt;= money_sum+<span class="number">5</span>;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        money_sum &lt;= money_sum;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//状态机的输出赋值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)	<span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            o_done &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(cstate == DONE) </span><br><span class="line">            o_done &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            o_done &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-15"><a href="#3-Testbench-15" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> FSM_tb;</span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> CLK_PERIORD		10		</span><span class="comment">//时钟周期设置为10ns（100MHz）	</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//接口申明</span></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst_n;</span><br><span class="line">    <span class="keyword">reg</span> i_1yuan;</span><br><span class="line">    <span class="keyword">reg</span> i_2yuan;</span><br><span class="line">    <span class="keyword">reg</span> i_5yuan;</span><br><span class="line">    <span class="keyword">wire</span> o_done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////	</span></span><br><span class="line">    <span class="comment">//对被测试的设计进行例化</span></span><br><span class="line">    FSM_design FSM_design_U1(</span><br><span class="line">    	<span class="variable">.i_clk</span>(clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(rst_n),</span><br><span class="line">    	<span class="variable">.i_1yuan</span>(i_1yuan),</span><br><span class="line">    	<span class="variable">.i_2yuan</span>(i_2yuan),</span><br><span class="line">    	<span class="variable">.i_5yuan</span>(i_5yuan),</span><br><span class="line">    	<span class="variable">.o_done</span>(o_done)</span><br><span class="line">        );	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//复位和时钟产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	clk &lt;= <span class="number">0</span>;</span><br><span class="line">    	rst_n &lt;= <span class="number">0</span>;</span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	rst_n &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIORD/2)</span> clk = ~clk;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//测试激励产生</span></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	i_1yuan = <span class="number">0</span>;</span><br><span class="line">    	i_2yuan = <span class="number">0</span>;</span><br><span class="line">    	i_5yuan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    	@(<span class="keyword">posedge</span> rst_n);	<span class="comment">//等待复位完成</span></span><br><span class="line">    </span><br><span class="line">    	@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">    		task_random_pay();</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    	#<span class="number">5000</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> task_random_pay;</span><br><span class="line">        <span class="keyword">integer</span> random_data;</span><br><span class="line">    	<span class="keyword">begin</span></span><br><span class="line">    		#<span class="number">1000</span>;</span><br><span class="line">    		random_data = &#123;<span class="built_in">$random</span>&#125;%<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    		@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    		<span class="keyword">if</span>(random_data == <span class="number">0</span>) </span><br><span class="line">                i_1yuan &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(random_data == <span class="number">1</span>) </span><br><span class="line">                i_2yuan &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(random_data == <span class="number">2</span>) </span><br><span class="line">                i_5yuan &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    		<span class="keyword">else</span> ;</span><br><span class="line">    </span><br><span class="line">    		@(<span class="keyword">posedge</span> clk);</span><br><span class="line">    		i_1yuan &lt;= <span class="number">0</span>;</span><br><span class="line">    		i_2yuan &lt;= <span class="number">0</span>;</span><br><span class="line">    		i_5yuan &lt;= <span class="number">0</span>;	</span><br><span class="line">    	<span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(i_1yuan) </span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;Pay 1 yuan.&quot;</span>);</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(i_2yuan) </span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;Pay 2 yuan.&quot;</span>);</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(i_5yuan) </span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;Pay 5 yuan.&quot;</span>);</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(o_done) </span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;Got you want.&quot;</span>);</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-15"><a href="#4-仿真结果-15" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206174427148.png" alt="image-20230206174427148"></p>
<hr>
<h1 id="串口指令帧解码设计"><a href="#串口指令帧解码设计" class="headerlink" title="串口指令帧解码设计"></a>串口指令帧解码设计</h1><ul>
<li>接收串口数据接收，串（8个1bit）转并（8bit）</li>
<li><p>译码串口（UART）命令帧，提取有效数据</p>
<ul>
<li>帧头（4个字节）：0xaa + 0x55 + 0xa5 + 0x5a</li>
<li>有效数据（10个字节）：beep_periord（4个字节）+ beep_high（4个字节）+ beep_num（2个字节）32bit/16bit传输时，高字节在前</li>
<li>帧尾（4个字节） ：0xcc + 0x33 + 0xc3 + 0x3c</li>
</ul>
</li>
<li><p>按照命令控制蜂鸣器</p>
</li>
</ul>
<h2 id="1-关键点-16"><a href="#1-关键点-16" class="headerlink" title="1.关键点"></a>1.关键点</h2><ul>
<li><p>UART</p>
<ul>
<li>UART（Universal Asynchronous Receiver/Transmitter），即通用异步收发，它的数据传输不需要时钟，只要两条信号线分别进行数据的收（RX）和发（TX）</li>
<li>收发双方首先需要约定好数据传输的速率（简单的讲就是约定好一个数据位传输的时间）和帧格式（即一帧的长短，一帧由哪些位组成，他们的功能都是什么</li>
</ul>
</li>
<li><p>串口（UART）协议：</p>
<ul>
<li>它由1个起始位（必须为0）、8个数据位（用户数据）、1个奇偶校验位（用于简单的纠错以保证传输可靠性）和1或2个停止位（必须为1）组成</li>
<li>除了奇偶校验位，其他三个部分都是必须的</li>
<li>当信号线空闲时，必须为高电平</li>
<li>要发起数据传输时，1个低电平的脉冲表示起始位，然后连续传输8个数据位和若干个高电平的停止位</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206175550881.png" alt="image-20230206175550881"></p>
</li>
<li><p><strong>模块划分与接口定义</strong>：</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.png" alt="模块划分与接口定义"></p>
</li>
<li><p><strong>串口数据串并转换模块时序分析</strong>：</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E4%B8%B2%E5%B9%B6%E8%BD%AC%E6%8D%A2%E6%97%B6%E5%BA%8F.png" alt="串口接收串并转换时序"></p>
</li>
<li><p><strong>指令译码模块的状态转换图</strong>：在状态的迁移过程中做判断</p>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/%E8%AF%91%E7%A0%81%E6%A8%A1%E5%9D%97%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="译码模块状态转换图"></p>
</li>
</ul>
<h2 id="2-源代码-16"><a href="#2-源代码-16" class="headerlink" title="2.源代码"></a>2.源代码</h2><ul>
<li>顶层模块：uart_decoder_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> uart_decoder_design(</span><br><span class="line">	<span class="keyword">input</span> i_clk,</span><br><span class="line">	<span class="keyword">input</span> i_rst_n,</span><br><span class="line">	<span class="keyword">input</span> i_uart_rx,</span><br><span class="line">	<span class="keyword">output</span> o_pwm</span><br><span class="line">    );</span><br><span class="line">		</span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> CLK_PERIORD		20		</span><span class="comment">//时钟周期设置为20ns（50MHz）	</span></span><br><span class="line">    <span class="keyword">parameter</span> UART_BPS_RATE = <span class="number">115200</span>;	<span class="comment">//串口波特率定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> w_bps_en;</span><br><span class="line">    <span class="keyword">wire</span> w_bps_done;</span><br><span class="line">    <span class="keyword">wire</span> w_rx_en;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] w_rx_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> w_beep_en;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">31</span>:<span class="number">0</span>] w_beep_periord;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">31</span>:<span class="number">0</span>] w_beep_high;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">15</span>:<span class="number">0</span>] w_beep_num;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//串口波特率控制模块例化	</span></span><br><span class="line">    bps_design	#(</span><br><span class="line">    	<span class="variable">.UART_BPS_RATE</span>(UART_BPS_RATE),	<span class="comment">//串口波特率设置（&lt;=115200），单位：bps</span></span><br><span class="line">    	<span class="variable">.CLK_PERIORD</span>(`CLK_PERIORD)		<span class="comment">//时钟周期设置，单位：ns</span></span><br><span class="line">    ) uut_bps_design(</span><br><span class="line">    	<span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">    	<span class="variable">.i_bps_en</span>(w_bps_en),</span><br><span class="line">    	<span class="variable">.o_bps_done</span>(w_bps_done)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//串口数据串并转换模块例化</span></span><br><span class="line">    s2p_design uut_s2p_design(</span><br><span class="line">    	<span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">    	<span class="variable">.i_uart_rx</span>(i_uart_rx),</span><br><span class="line">    	<span class="variable">.i_bps_done</span>(w_bps_done),	</span><br><span class="line">    	<span class="variable">.o_bps_en</span>(w_bps_en),</span><br><span class="line">    	<span class="variable">.o_rx_en</span>(w_rx_en),</span><br><span class="line">    	<span class="variable">.o_rx_data</span>(w_rx_data)</span><br><span class="line">        );	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//串口指令帧解码模块例化	</span></span><br><span class="line">    decoder_design uut_decoder_design(</span><br><span class="line">    	<span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">    	<span class="variable">.i_rx_en</span>(w_rx_en),</span><br><span class="line">    	<span class="variable">.i_rx_data</span>(w_rx_data),</span><br><span class="line">    	<span class="variable">.o_beep_en</span>(w_beep_en),</span><br><span class="line">    	<span class="variable">.o_beep_periord</span>(w_beep_periord),</span><br><span class="line">    	<span class="variable">.o_beep_high</span>(w_beep_high),</span><br><span class="line">    	<span class="variable">.o_beep_num</span>(w_beep_num)</span><br><span class="line">        );	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////	</span></span><br><span class="line">    <span class="comment">//PWM蜂鸣器控制模块例化</span></span><br><span class="line">    beep_design uut_beep_design(</span><br><span class="line">    	<span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">    	<span class="variable">.i_en</span>(w_beep_en),</span><br><span class="line">    	<span class="variable">.i_periord</span>(w_beep_periord),</span><br><span class="line">    	<span class="variable">.i_high</span>(w_beep_high),</span><br><span class="line">    	<span class="variable">.i_times</span>(w_beep_num),</span><br><span class="line">    	<span class="variable">.o_pwm</span>(o_pwm)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子模块：bps_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bps_design#(</span><br><span class="line">	<span class="keyword">parameter</span> UART_BPS_RATE	= <span class="number">115200</span>,	<span class="comment">//串口波特率设置（&lt;=115200），单位：bps</span></span><br><span class="line">	<span class="keyword">parameter</span> CLK_PERIORD	= <span class="number">20</span>		<span class="comment">//时钟周期设置，单位：ns</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">	<span class="keyword">input</span> i_clk,</span><br><span class="line">	<span class="keyword">input</span> i_rst_n,</span><br><span class="line">	<span class="keyword">input</span> i_bps_en,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> o_bps_done</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">localparam</span> BPS_CNT_MAX = <span class="number">1000_000_000</span>/UART_BPS_RATE/CLK_PERIORD-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">localparam</span> BPS_CNT_HALF = BPS_CNT_MAX/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] r_bps_cnt;	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//波特率的分频计数</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_bps_cnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(i_bps_en) <span class="keyword">begin</span></span><br><span class="line">    	    <span class="keyword">if</span>(r_bps_cnt &lt; BPS_CNT_MAX) </span><br><span class="line">                r_bps_cnt &lt;= r_bps_cnt+<span class="number">1</span>;</span><br><span class="line">    	    <span class="keyword">else</span> </span><br><span class="line">                r_bps_cnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_bps_cnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生o_bps_done信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(r_bps_cnt == BPS_CNT_HALF) </span><br><span class="line">            o_bps_done &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            o_bps_done &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子模块：s2p_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串并转化模块</span></span><br><span class="line"><span class="keyword">module</span> s2p_design(</span><br><span class="line">	<span class="keyword">input</span> i_clk,</span><br><span class="line">	<span class="keyword">input</span> i_rst_n,</span><br><span class="line">	<span class="keyword">input</span> i_uart_rx,</span><br><span class="line">	<span class="keyword">input</span> i_bps_done,	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> o_bps_en,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> o_rx_en,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] o_rx_data</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] r_bit_cnt;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] r_rx_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生i_uart_rx信号的下降沿</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] r_uart_rx;</span><br><span class="line">    <span class="keyword">wire</span> neg_uart_rx;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_uart_rx &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_uart_rx &lt;= &#123;r_uart_rx[<span class="number">0</span>],i_uart_rx&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> neg_uart_rx = r_uart_rx[<span class="number">1</span>] &amp; ~r_uart_rx[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生波特率计数使能信号o_bps_en</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            o_bps_en &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(neg_uart_rx &amp;&amp; !o_bps_en) </span><br><span class="line">            o_bps_en &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(i_bps_done &amp;&amp; (r_bit_cnt == <span class="number">4&#x27;d9</span>)) </span><br><span class="line">            o_bps_en &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            o_bps_en &lt;= o_bps_en;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//i_uart_rx的数据位进行计数</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_bit_cnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(!o_bps_en) </span><br><span class="line">            r_bit_cnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(i_bps_done) </span><br><span class="line">            r_bit_cnt &lt;= r_bit_cnt+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_bit_cnt &lt;= r_bit_cnt;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//对i_uart_rx的有效数据进行串并转换的锁存</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_rx_data &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(i_bps_done) <span class="keyword">begin</span></span><br><span class="line">    	    <span class="keyword">case</span>(r_bit_cnt)</span><br><span class="line">    	    	<span class="number">4&#x27;d1</span>: r_rx_data[<span class="number">0</span>] &lt;= i_uart_rx;</span><br><span class="line">    	    	<span class="number">4&#x27;d2</span>: r_rx_data[<span class="number">1</span>] &lt;= i_uart_rx;</span><br><span class="line">    	    	<span class="number">4&#x27;d3</span>: r_rx_data[<span class="number">2</span>] &lt;= i_uart_rx;</span><br><span class="line">    	    	<span class="number">4&#x27;d4</span>: r_rx_data[<span class="number">3</span>] &lt;= i_uart_rx;</span><br><span class="line">    	    	<span class="number">4&#x27;d5</span>: r_rx_data[<span class="number">4</span>] &lt;= i_uart_rx;</span><br><span class="line">    	    	<span class="number">4&#x27;d6</span>: r_rx_data[<span class="number">5</span>] &lt;= i_uart_rx;</span><br><span class="line">    	    	<span class="number">4&#x27;d7</span>: r_rx_data[<span class="number">6</span>] &lt;= i_uart_rx;</span><br><span class="line">    	    	<span class="number">4&#x27;d8</span>: r_rx_data[<span class="number">7</span>] &lt;= i_uart_rx;</span><br><span class="line">    	    	<span class="keyword">default</span>: ;</span><br><span class="line">    	    <span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生并行数据有效信号和并行数据锁存</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            o_rx_en &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(i_bps_done &amp;&amp; (r_bit_cnt == <span class="number">4&#x27;d9</span>)) </span><br><span class="line">            o_rx_en &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            o_rx_en &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(i_bps_done &amp;&amp; (r_bit_cnt == <span class="number">4&#x27;d9</span>)) </span><br><span class="line">            o_rx_data &lt;= r_rx_data;</span><br><span class="line">    	<span class="keyword">else</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子模块：beep_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> beep_design(</span><br><span class="line">	<span class="keyword">input</span> i_clk,	<span class="comment">//50MHz（20ns）时钟</span></span><br><span class="line">	<span class="keyword">input</span> i_rst_n,	<span class="comment">//复位</span></span><br><span class="line">	<span class="keyword">input</span> i_en,	<span class="comment">//使能</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>] i_periord,	<span class="comment">//PWM的周期</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>] i_high,	<span class="comment">//高电平时间</span></span><br><span class="line">	<span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] i_times,	<span class="comment">//次数</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> o_pwm		<span class="comment">//PWM信号</span></span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] r_en;</span><br><span class="line">    <span class="keyword">wire</span> w_pos_en;</span><br><span class="line">    <span class="keyword">wire</span> w_end_en;</span><br><span class="line">    <span class="keyword">reg</span> r_cnt_en;	<span class="comment">//内部各个计数器工作的使能信号</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] r_pcnt;	<span class="comment">//周期计数器</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] r_tcnt;	<span class="comment">//周期次数的计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生i_en的上升沿标志信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!i_rst_n)</span><br><span class="line">            r_en &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    	    r_en &lt;= &#123;r_en[<span class="number">0</span>],i_en&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> w_pos_en = ~r_en[<span class="number">1</span>] &amp; r_en[<span class="number">0</span>];	</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生内部PWM结束信号</span></span><br><span class="line">    <span class="keyword">assign</span> w_end_en = (r_pcnt == (i_periord-<span class="number">1</span>)) &amp;&amp; (r_tcnt == (i_times-<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//产生内部各个计数器工作的是能信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_cnt_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(w_pos_en) </span><br><span class="line">            r_cnt_en &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(w_end_en) </span><br><span class="line">            r_cnt_en &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_cnt_en &lt;= r_cnt_en;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//周期计数</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!r_cnt_en) </span><br><span class="line">            r_pcnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(r_pcnt &lt; (i_periord-<span class="number">1</span>)) </span><br><span class="line">            r_pcnt &lt;= r_pcnt+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_pcnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//周期次数计数	</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!r_cnt_en) </span><br><span class="line">            r_tcnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(r_pcnt == (i_periord-<span class="number">1</span>)) </span><br><span class="line">            r_tcnt &lt;= r_tcnt+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_tcnt &lt;= r_tcnt;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//输出PWM波形</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            o_pwm &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>((r_pcnt &gt; <span class="number">32&#x27;d0</span>) &amp;&amp; (r_pcnt &lt;= i_high)) </span><br><span class="line">            o_pwm &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            o_pwm &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子模块：decoder_design.v</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> decoder_design(</span><br><span class="line">	<span class="keyword">input</span> i_clk,</span><br><span class="line">	<span class="keyword">input</span> i_rst_n,</span><br><span class="line">	<span class="keyword">input</span> i_rx_en,</span><br><span class="line">	<span class="keyword">input</span>[<span class="number">7</span>:<span class="number">0</span>] i_rx_data,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> o_beep_en,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] o_beep_periord,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] o_beep_high,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] o_beep_num</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//帧头</span></span><br><span class="line">    <span class="keyword">localparam</span> DATA_SOF1	= <span class="number">8&#x27;haa</span>;	</span><br><span class="line">    <span class="keyword">localparam</span> DATA_SOF2	= <span class="number">8&#x27;h55</span>;</span><br><span class="line">    <span class="keyword">localparam</span> DATA_SOF3	= <span class="number">8&#x27;ha5</span>;</span><br><span class="line">    <span class="keyword">localparam</span> DATA_SOF4	= <span class="number">8&#x27;h5a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//帧尾</span></span><br><span class="line">    <span class="keyword">localparam</span> DATA_EOF1	= <span class="number">8&#x27;hcc</span>;	</span><br><span class="line">    <span class="keyword">localparam</span> DATA_EOF2	= <span class="number">8&#x27;h33</span>;</span><br><span class="line">    <span class="keyword">localparam</span> DATA_EOF3	= <span class="number">8&#x27;hc3</span>;</span><br><span class="line">    <span class="keyword">localparam</span> DATA_EOF4	= <span class="number">8&#x27;h3c</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">localparam</span> IDLE	= <span class="number">4&#x27;d0</span>;		</span><br><span class="line">    <span class="keyword">localparam</span> SOF1	= <span class="number">4&#x27;d1</span>;	</span><br><span class="line">    <span class="keyword">localparam</span> SOF2	= <span class="number">4&#x27;d2</span>;</span><br><span class="line">    <span class="keyword">localparam</span> SOF3	= <span class="number">4&#x27;d3</span>;</span><br><span class="line">    <span class="keyword">localparam</span> RXDB = <span class="number">4&#x27;d4</span>;           </span><br><span class="line">    <span class="keyword">localparam</span> EOF1	= <span class="number">4&#x27;d5</span>;	</span><br><span class="line">    <span class="keyword">localparam</span> EOF2	= <span class="number">4&#x27;d6</span>;</span><br><span class="line">    <span class="keyword">localparam</span> EOF3	= <span class="number">4&#x27;d7</span>;</span><br><span class="line">    <span class="keyword">localparam</span> EOF4	= <span class="number">4&#x27;d8</span>;</span><br><span class="line">    <span class="keyword">localparam</span> DONE	= <span class="number">4&#x27;d9</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] r_cstate,r_nstate;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] r_bytecnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//时序逻辑状态切换</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            r_cstate &lt;= IDLE;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_cstate &lt;= r_nstate;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//组合逻辑切换状态</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">case</span>(r_cstate)</span><br><span class="line">    		IDLE: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(i_rx_data == DATA_SOF1) </span><br><span class="line">                        r_nstate = SOF1;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        r_nstate = IDLE;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    r_nstate = IDLE;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		SOF1: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(i_rx_data == DATA_SOF2) </span><br><span class="line">                        r_nstate = SOF2;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        r_nstate = IDLE;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    r_nstate = SOF1;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		SOF2: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(i_rx_data == DATA_SOF3) </span><br><span class="line">                        r_nstate = SOF3;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        r_nstate = IDLE;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    r_nstate = SOF2;</span><br><span class="line">    		<span class="keyword">end</span>		</span><br><span class="line">    		SOF3: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(i_rx_data == DATA_SOF4) </span><br><span class="line">                        r_nstate = RXDB;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        r_nstate = IDLE;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    r_nstate = SOF3;</span><br><span class="line">    		<span class="keyword">end</span>	</span><br><span class="line"></span><br><span class="line">    		RXDB: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(r_bytecnt &gt;= <span class="number">4&#x27;d9</span>) </span><br><span class="line">                        r_nstate = EOF1;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        r_nstate = RXDB;</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    r_nstate = RXDB;</span><br><span class="line">    		<span class="keyword">end</span>	</span><br><span class="line">    </span><br><span class="line">    		EOF1: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(i_rx_data == DATA_EOF1) </span><br><span class="line">                        r_nstate = EOF2;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        r_nstate = IDLE;			</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    r_nstate = EOF1;</span><br><span class="line">    		<span class="keyword">end</span>	</span><br><span class="line">    		EOF2: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(i_rx_data == DATA_EOF2) </span><br><span class="line">                        r_nstate = EOF3;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        r_nstate = IDLE;			</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    r_nstate = EOF2;</span><br><span class="line">    		<span class="keyword">end</span>	</span><br><span class="line">    		EOF3: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(i_rx_data == DATA_EOF3) </span><br><span class="line">                        r_nstate = EOF4;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        r_nstate = IDLE;			</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    r_nstate = EOF3;</span><br><span class="line">    		<span class="keyword">end</span>			</span><br><span class="line">    		EOF4: <span class="keyword">begin</span></span><br><span class="line">    			<span class="keyword">if</span>(i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    				<span class="keyword">if</span>(i_rx_data == DATA_EOF4) </span><br><span class="line">                        r_nstate = DONE;</span><br><span class="line">    				<span class="keyword">else</span> </span><br><span class="line">                        r_nstate = IDLE;			</span><br><span class="line">    			<span class="keyword">end</span></span><br><span class="line">    			<span class="keyword">else</span> </span><br><span class="line">                    r_nstate = EOF4;</span><br><span class="line">    		<span class="keyword">end</span>	</span><br><span class="line"></span><br><span class="line">    		DONE: r_nstate = IDLE;</span><br><span class="line">    		<span class="keyword">default</span>: ;</span><br><span class="line">    	<span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//对10个有效数据字节进行计数</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(r_cstate == RXDB) <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">if</span>(i_rx_en) </span><br><span class="line">                r_bytecnt &lt;= r_bytecnt+<span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">else</span> </span><br><span class="line">                r_bytecnt &lt;= r_bytecnt;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            r_bytecnt &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//对有效数据进行锁存（采集）</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk) <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>((r_cstate == RXDB) &amp;&amp; i_rx_en) <span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">case</span>(r_bytecnt)</span><br><span class="line">    			<span class="number">4&#x27;d0</span>: o_beep_periord[<span class="number">31</span>:<span class="number">24</span>] &lt;= i_rx_data;</span><br><span class="line">    			<span class="number">4&#x27;d1</span>: o_beep_periord[<span class="number">23</span>:<span class="number">16</span>] &lt;= i_rx_data;</span><br><span class="line">    			<span class="number">4&#x27;d2</span>: o_beep_periord[<span class="number">15</span>:<span class="number">8</span>] &lt;= i_rx_data;</span><br><span class="line">    			<span class="number">4&#x27;d3</span>: o_beep_periord[<span class="number">7</span>:<span class="number">0</span>] &lt;= i_rx_data;</span><br><span class="line">    </span><br><span class="line">    			<span class="number">4&#x27;d4</span>: o_beep_high[<span class="number">31</span>:<span class="number">24</span>] &lt;= i_rx_data;</span><br><span class="line">    			<span class="number">4&#x27;d5</span>: o_beep_high[<span class="number">23</span>:<span class="number">16</span>] &lt;= i_rx_data;</span><br><span class="line">    			<span class="number">4&#x27;d6</span>: o_beep_high[<span class="number">15</span>:<span class="number">8</span>] &lt;= i_rx_data;</span><br><span class="line">    			<span class="number">4&#x27;d7</span>: o_beep_high[<span class="number">7</span>:<span class="number">0</span>] &lt;= i_rx_data;</span><br><span class="line"></span><br><span class="line">    			<span class="number">4&#x27;d8</span>: o_beep_num[<span class="number">15</span>:<span class="number">8</span>] &lt;= i_rx_data;</span><br><span class="line">    			<span class="number">4&#x27;d9</span>: o_beep_num[<span class="number">7</span>:<span class="number">0</span>] &lt;= i_rx_data;			</span><br><span class="line">    			<span class="keyword">default</span>: ;</span><br><span class="line">    		<span class="keyword">endcase</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//有效数据使能信号产生</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)	<span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">if</span>(!i_rst_n) </span><br><span class="line">            o_beep_en &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(r_cstate == DONE) </span><br><span class="line">            o_beep_en &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            o_beep_en &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Testbench-16"><a href="#3-Testbench-16" class="headerlink" title="3.Testbench"></a>3.Testbench</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> uart_decoder_tb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> CLK_PERIORD		20		</span><span class="comment">//时钟周期设置为20ns（50MHz）	</span></span><br><span class="line">    <span class="keyword">parameter</span> UART_BPS_RATE = <span class="number">115200</span>;</span><br><span class="line">    <span class="keyword">parameter</span> BPS_DLY_BIT	= <span class="number">1000000000</span>/UART_BPS_RATE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//接口申明</span></span><br><span class="line">    <span class="keyword">reg</span> i_clk;</span><br><span class="line">    <span class="keyword">reg</span> i_rst_n;</span><br><span class="line">    <span class="keyword">reg</span> i_uart_rx;</span><br><span class="line">    <span class="keyword">wire</span> o_pwm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////	</span></span><br><span class="line">    <span class="comment">//对被测试的设计进行例化</span></span><br><span class="line">    uart_decoder_design	uut_uart_decoder_design(</span><br><span class="line">    	<span class="variable">.i_clk</span>(i_clk),</span><br><span class="line">    	<span class="variable">.i_rst_n</span>(i_rst_n),</span><br><span class="line">    	<span class="variable">.i_uart_rx</span>(i_uart_rx),</span><br><span class="line">    	<span class="variable">.o_pwm</span>(o_pwm)</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//复位和时钟产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	i_clk &lt;= <span class="number">0</span>;</span><br><span class="line">    	i_rst_n &lt;= <span class="number">0</span>;</span><br><span class="line">    	#<span class="number">1000</span>;</span><br><span class="line">    	i_rst_n &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(`CLK_PERIORD/2)</span> i_clk &lt;= ~i_clk;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//测试激励产生</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	i_uart_rx &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">    	@(<span class="keyword">posedge</span> i_rst_n);	<span class="comment">//等待复位完成</span></span><br><span class="line">    </span><br><span class="line">    	@(<span class="keyword">posedge</span> i_clk);</span><br><span class="line">    </span><br><span class="line">    	#<span class="number">100_000</span>;</span><br><span class="line">    	task_cmd_tx(<span class="number">32&#x27;d1000</span>,<span class="number">32&#x27;d100</span>,<span class="number">16&#x27;d5</span>);</span><br><span class="line">    </span><br><span class="line">    	#<span class="number">1_000_000</span>;</span><br><span class="line">    	task_cmd_tx(<span class="number">32&#x27;d5000</span>,<span class="number">32&#x27;d1000</span>,<span class="number">16&#x27;d6</span>);	</span><br><span class="line"></span><br><span class="line">    	#<span class="number">1_000_000</span>;	</span><br><span class="line">    	<span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="comment">//模拟传输一个byte的任务</span></span><br><span class="line">    <span class="keyword">task</span> task_uart_tx;</span><br><span class="line">    	<span class="keyword">input</span>[<span class="number">7</span>:<span class="number">0</span>] tx_db;</span><br><span class="line">    	<span class="keyword">begin</span></span><br><span class="line">    		i_uart_rx &lt;= <span class="number">&#x27;b0</span>;</span><br><span class="line">    		#BPS_DLY_BIT;</span><br><span class="line">    		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">    			i_uart_rx &lt;= tx_db[i];</span><br><span class="line">    			#BPS_DLY_BIT;</span><br><span class="line">    		<span class="keyword">end</span></span><br><span class="line">    		i_uart_rx &lt;= <span class="number">&#x27;b1</span>;</span><br><span class="line">    		#BPS_DLY_BIT;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟一次完整的UART命令帧</span></span><br><span class="line">    <span class="keyword">task</span> task_cmd_tx;</span><br><span class="line">    	<span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>] tx_beep_periord;</span><br><span class="line">    	<span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>] tx_beep_high;</span><br><span class="line">    	<span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] tx_beep_num;</span><br><span class="line">    	<span class="keyword">begin</span></span><br><span class="line">    		task_uart_tx(<span class="number">8&#x27;haa</span>);</span><br><span class="line">    		task_uart_tx(<span class="number">8&#x27;h55</span>);</span><br><span class="line">    		task_uart_tx(<span class="number">8&#x27;ha5</span>);</span><br><span class="line">    		task_uart_tx(<span class="number">8&#x27;h5a</span>);</span><br><span class="line">    </span><br><span class="line">    		task_uart_tx(tx_beep_periord[<span class="number">31</span>:<span class="number">24</span>]);</span><br><span class="line">    		task_uart_tx(tx_beep_periord[<span class="number">23</span>:<span class="number">16</span>]);</span><br><span class="line">    		task_uart_tx(tx_beep_periord[<span class="number">15</span>:<span class="number">8</span>]);</span><br><span class="line">    		task_uart_tx(tx_beep_periord[<span class="number">7</span>:<span class="number">0</span>]);	</span><br><span class="line">    </span><br><span class="line">    		task_uart_tx(tx_beep_high[<span class="number">31</span>:<span class="number">24</span>]);</span><br><span class="line">    		task_uart_tx(tx_beep_high[<span class="number">23</span>:<span class="number">16</span>]);</span><br><span class="line">    		task_uart_tx(tx_beep_high[<span class="number">15</span>:<span class="number">8</span>]);</span><br><span class="line">    		task_uart_tx(tx_beep_high[<span class="number">7</span>:<span class="number">0</span>]);			</span><br><span class="line"></span><br><span class="line">    		task_uart_tx(tx_beep_num[<span class="number">15</span>:<span class="number">8</span>]);</span><br><span class="line">    		task_uart_tx(tx_beep_num[<span class="number">7</span>:<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    		task_uart_tx(<span class="number">8&#x27;hcc</span>);</span><br><span class="line">    		task_uart_tx(<span class="number">8&#x27;h33</span>);</span><br><span class="line">    		task_uart_tx(<span class="number">8&#x27;hc3</span>);</span><br><span class="line">    		task_uart_tx(<span class="number">8&#x27;h3c</span>);		</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="4-仿真结果-16"><a href="#4-仿真结果-16" class="headerlink" title="4.仿真结果"></a>4.仿真结果</h2><ul>
<li>RTL视图</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206210526508.png" alt="image-20230206210526508"></p>
<ul>
<li>仿真波形</li>
</ul>
<p><img src="/2023/01/05/Verilog%E4%B9%8B%E8%BE%B9%E7%A0%81%E8%BE%B9%E5%AD%A6/image-20230206211033267.png" alt="image-20230206211033267"></p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1Ve411x75W/?spm_id_from=333.337.search-card.all.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">特权同学《Verilog边码边学》基于Xilinx FPGA的Verilog编码、仿真与调试基础教程_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>小沈同学的日常分享2023</title>
    <url>/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/</url>
    <content><![CDATA[<p>Hello！这里是生活中的小沈同学……</p>
<span id="more"></span>
<h3 id="2023-01-01记录"><a href="#2023-01-01记录" class="headerlink" title="2023.01.01记录"></a>2023.01.01记录</h3><ul>
<li><p>首先，2022年确实经历了很多，遇到了很多挫折，有些事情甚至超出了我的接受程度，但也有收获的喜悦。现在，这些困难并没有结束，我也在不断的调整，没事，困难不会击垮我，反而让我变得更加的包容、理性，也学会了接受。还是要感谢生活的种种吧，毕竟生活有剥削，也会有馈赠。</p>
</li>
<li><p>特别想感谢这一年里给过我帮助和支持的所有朋友家人们，特别是志红阿姨、该牙，还有张总、惠清、624、集创小分队。这些人真的陪我度过了今年我特别特别难的日子。</p>
</li>
<li><p>同时很开心能搭建一个博客，让我的生活多了一个喘气的出口，也收获了一些学弟学妹的赞赏，让我觉得自己确实有点重要</p>
</li>
<li><p>十一月底从学校回来以后一直在家摆着，虽然摆得有点厉害，但我觉得这真的是我大学以来最放松的一个月，看了一些剧和综艺，其实也思考了很多问题，确实，很多东西只有自己想明白挺过来才行</p>
</li>
<li><p>希望自己新的一年，可以多一点快乐，多一点思考，多一点才华，少一点在乎，少一点焦虑，少一点纠结！！！最近确实有点丧，希望那个厉害的ssy快点回来，也希望自己可以快点强大到可以保护到想保护的人</p>
</li>
<li><p>世界在变，身边的人在变，虽然希望自己可以少一点真心，但真诚永远会是我最大的温柔</p>
</li>
<li><p>那最后祝大家未来都能好好活着，但不止于活着！！！</p>
</li>
<li><p>对了，今天很开心，有发小陪玩，见到了好久不见的与欧，也搓了真正意义上的麻将</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/image-20230102000422396.png" alt="image-20230102000422396" style="zoom:25%;"></p>
</li>
<li><p>希望自己可以做一个理性的人，没法祝万事顺意，但会相信美好的事情即将发生！！！</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/image-20230102000439761.png" alt="image-20230102000439761" style="zoom:25%;"></p>
</li>
</ul>
<hr>
<h3 id="2023-01-05记录"><a href="#2023-01-05记录" class="headerlink" title="2023.01.05记录"></a>2023.01.05记录</h3><ul>
<li><p>摆了这么久，终于要开始学一点点了</p>
</li>
<li><p>下面是小沈同学和小张同学的日常</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/image-20230105150027366.png" alt="image-20230105150027366" style="zoom: 50%;"></p>
</li>
</ul>
<hr>
<h3 id="2023-01-07记录"><a href="#2023-01-07记录" class="headerlink" title="2023.01.07记录"></a>2023.01.07记录</h3><ul>
<li><p>周末了，又到了开摆的时间了，今天的阳光真好！</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230109210448.jpg" alt="微信图片_20230109210448"></p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230109210504.jpg" alt="微信图片_20230109210504"></p>
</li>
</ul>
<hr>
<h3 id="2023-01-14记录"><a href="#2023-01-14记录" class="headerlink" title="2023.01.14记录"></a>2023.01.14记录</h3><ul>
<li><p>小沈同学的近期日常，欢迎点哥来长沙，也开心见到了老朋友们</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/image-20230114232507900.png" alt="image-20230114232507900" style="zoom: 25%;"></p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/image-20230114232448060.png" alt="image-20230114232448060" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h3 id="2023-02-02记录"><a href="#2023-02-02记录" class="headerlink" title="2023.02.02记录"></a>2023.02.02记录</h3><ul>
<li><p>最近有点玩得太嗨了，必须开始学习了，不然毕设都完不成了呜呜呜</p>
</li>
<li><p>还是分享一下游玩的照片嘻嘻</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230202160736.jpg" alt="微信图片_20230202160736" style="zoom:67%;"></p>
</li>
<li><p>特别感谢小王同学在郴州的热情款待，她害羞就不放图片啦哈哈</p>
</li>
</ul>
<hr>
<h3 id="2023-02-05分享"><a href="#2023-02-05分享" class="headerlink" title="2023.02.05分享"></a>2023.02.05分享</h3><ul>
<li><p>最近在看同哥的《一个人就一个人》，分享一些个看到的有意思的话：</p>
<ul>
<li>“我愿意为你做很多事，多年后也想得起来，就是我们的美好“</li>
<li>”虽然一个人很好，但如果多一个好朋友，可以让你看到更大的世界，就像陈默于我一样“</li>
</ul>
</li>
<li><p>抓住节日的尾巴，今天去看楠姐啦！一起回忆了初中我干过的那些傻事，那时候可真是一个容易发脾气闹情绪的叛逆小孩啊，一晃初中毕业都六七年啦，曾经那个觉得自己“无法无天”的小朋友也长大了，早已没有之前那样的锋芒毕露啦！如果是现在的我遇到当初那些事，也许还会生气但确实已经过了冲动不理智的年纪了吧哈哈，不过我还是有点想念当初那个自尊心强、受了委屈就要和全世界为敌的自己，也很羡慕当时无理取闹却被包容爱护的自己！时间过得可真快，每次回去很多东西都变了（比如楠姐升职啦，林总去长梅啦），但很多东西又没变（比如楠姐对我的爱哈哈），不过其实这些都不重要，真正重要的都已经变成了习惯，就像今天我冒着大雨又来到了这一样！</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/image-20230206010253849.png" alt="image-20230206010253849" style="zoom: 33%;"></p>
</li>
<li><p>下午干妈还带我去买衣服鞋子啦！晚上还放了小烟花，这个元宵很圆满很快乐！希望我可以带着假期汲取的能量勇敢向前，晚安！</p>
</li>
</ul>
<hr>
<h3 id="2023-02-13记录"><a href="#2023-02-13记录" class="headerlink" title="2023.02.13记录"></a>2023.02.13记录</h3><ul>
<li><p>记录一下上周末和老baby们聚会的时光</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230213234613.jpg" alt="微信图片_20230213234613" style="zoom: 67%;"></p>
</li>
<li><p>是那种每年只聚一两次，但见面就能很安心的友谊啦！也确实是那种彼此说话不用考虑细节的存在！就真的很幸运吧，那就浅浅祝福一下我的老baby们都能快乐幸福，如愿以偿！</p>
</li>
<li><p>所有聚会都结束了，接下来就真的是事业小沈了！</p>
</li>
</ul>
<hr>
<h3 id="2023-04-05记录"><a href="#2023-04-05记录" class="headerlink" title="2023.04.05记录"></a>2023.04.05记录</h3><ul>
<li>现在是2023年4月5日的零点过六分，很久没有记录我的日常了，那是因为最近一个月除了睡觉就是忙毕设，整得点焦头烂额了，但既然今天生日，那就浅浅出现一下</li>
<li>谢谢大家的礼物和记得，有点懒，就不发照片了！</li>
<li>今天也注定在搞毕设中度过了，等忙完这一阵，再来分享我有意思的日常吧，我继续干论文去了！</li>
</ul>
<hr>
<h3 id="2023-06-19记录"><a href="#2023-06-19记录" class="headerlink" title="2023.06.19记录"></a>2023.06.19记录</h3><ul>
<li><p>弄完毕设也休息好一阵了，算是给大学生活画上一个完美的句号了，其实本来想为大学这四年的经历单独写一篇感悟分享文章的，但可能对于我来说在2022.9.28号那一刻就已经毕业了，所以感觉毕业在我这里已经拖了很长时间了，就很多感受已经没有当初那么热烈了。不过在回去参加毕业典礼的那几天有些回忆又涌上来了，确实打心底又有了毕业分别的感觉了，果然仪式感在生活中还是很有分量的。</p>
</li>
<li><p>在朋友圈里我只写了感谢的对象，并没有写感谢的原因，那在这里就再好好谢谢各位吧！</p>
</li>
<li><p>谢谢河南大学迈阿密学院，在这里的四年，确实提高了我的自信和勇气，虽然咱学院真的很穷，要啥没啥，但学院该给的奖学金确实一分没少哈，开玩笑啦，在这遇到的老师和同学还是真心不错的，如果没有这‘’破‘’学院，我又怎能遇到大家呢？</p>
</li>
<li><p>谢谢导员，虽然整个本科期间交流得不是特别多，也不管别人对你的评价如何，但我觉得导员在我这，还是值得一个高分的，确实对我关照有加</p>
</li>
<li><p>谢谢老魏，魏老师，我大创的指导老师，打羽毛球的好伙伴，已婚高质量对象，是那种真的会一个一个字的帮你看计划书改错误的好老师，是会给每个队员都准备毕业礼物且写上毕业寄语的好老师，是未来亦师亦友的伙伴，从没上过魏老师一节课，但依旧被他踏实稳重的人格魅力所屈服</p>
</li>
<li><p>谢谢朱朱，搞毕设期间应该是跟朱朱交流得最多的时候，说实话，之前听朱朱上大学物理的课确实不咋地，但后面在毕设期间的相处，觉得朱朱人还是很不错的，这次没赶上朱朱请吃饭，下次回学校一定要宰朱朱一顿</p>
</li>
<li><p>谢谢老梁，我集创赛、蓝桥杯比赛的指导老师，想当年没上老梁课之前看到网上一条抨击老梁的帖子，害怕得不行，没想到最后老梁却成为了我大学四年最爱也最想感谢的老师，是老梁当初鼓励我参加蓝桥杯EDA赛道，没想到最后竟然拿到了省一，缓解了我当时因为竞赛分加不满的焦虑，也是老梁给了我参加集创赛的思路，本来抱着试试看的心态，后来越做越爱，就爱上了硬件这条路了，可以说老梁是决定我未来发展方向的关键人吧，其实我也不确定硬件这条路就一定适合自己，也不确定能否克服万难坚持下去，但至少我现在很坚定，想试试！还有老梁帮我报销、送我板子比赛等等就不细说了，总之，感谢的话已经说了，懂得都懂嘻嘻。</p>
</li>
<li><p>谢谢19电子，河南大学迈阿密学院2019级电子信息科学与技术专业的每一个同学，虽然不是跟每一个同学在这四年都说上话了，但每次民主投票我都通过了，而且越往后票数都越高，谢谢大家，以后大家来长沙玩，只要能开口找我，那都必须安排！在这里特别想谢谢惠清，谢谢她带我整学时，谢谢她总是不计回报无条件的帮我，谢谢她的真诚与信任，在这里也想对惠清说，真不用自卑，我一直一直都觉得你很棒，一个人就能把大创顶下来，真的，不光是我，其实大家都这么觉得，一次的失利不代表什么，你所有的努力和付出大家都看在眼里，我十分相信你，未来你想要的也会 一一实现的。</p>
</li>
<li><p>谢谢大创组，虽然在合作的过程中有些小摩擦，但我们也因为有这个项目充实了大学生活，也聚在一起参加了很多别的比赛，如今我们每个人都有了好的去处，属于是happy ending了。至于大创队长cc，真的想说，遇到cc这样的朋友超值啊，真想敬cc一杯，把感谢的话当面说出来，但每次都了嘴边又觉得太矫情，不好意思开口了，只能变成一句：懂的都懂</p>
</li>
<li><p>谢谢集创小分队，这个真的不用多说了，还是那句话，曾经是一起扛过事的队友，未来是值得信任的朋友。赵总应该永远都会记得生日时4点的河大，邱总应该永远都会记得长沙我们熬夜奋战而你自己摸鱼的夜晚。</p>
</li>
<li><p>谢谢电赛小分队，通过这次电赛才知道点哥内心也住着温柔感性的大男孩呀，迈阿密学院一楼那个会议室熬的夜不会忘，我记得那天好像还下雪了，我早上六点还去教苑给每个人都买了一个大包子，没想到你们竟然觉得不够吃哈哈</p>
</li>
<li><p>谢谢幼儿园郊游班，海南之旅还是很不错的，大家都是很优秀的人，借kc朋友圈的话：下一站一定是更远的远方</p>
</li>
<li><p>谢谢624，关于我的室友，我都写过一个pdf专门感谢过了，真的很幸运能遇到大家，是那种你在寝室随便唱什么歌都有人能接上的默契，是可以一起深夜小话题从emo到开怀大笑的存在，是整个河大对于我而言最安心的地方了，624缺了谁都不是2019~2023年的624啦，虽然下次624的门再被推开时又是另外四个女孩子的青春啦，但只要我们四个再在某个地方重聚，那依旧是624的青春，幸运的是我的青春里面有你们</p>
</li>
<li><p>谢谢坚持且努力的自己，确实，感觉大学四年经历了很多，有些只能在电视剧上看到的场景，也发生在我身边，好在时间是最温柔的武器，一切都在变好，也真的很谢谢能挺过来的自己</p>
</li>
<li><p>最后再次谢谢大家，让我仍有前程可奔赴</p>
</li>
<li><p>该说不说，我可是被校长亲自拨穗了哦，那就附上几张毕业照吧</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230619123922.jpg" alt="微信图片_20230619123922" style="zoom: 25%;"></p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230619123510-1687188264915-3.jpg" alt="微信图片_20230619123510" style="zoom: 50%;"></p>
</li>
<li><p>本科生涯正式结束了！！！</p>
</li>
</ul>
<hr>
<h3 id="2023-09-04记录"><a href="#2023-09-04记录" class="headerlink" title="2023.09.04记录"></a>2023.09.04记录</h3><ul>
<li><p>好久没在博客上分享日常了，一个是懒，一个是每天都过得挺平淡的，也没有什么特别可说</p>
</li>
<li><p>来厦大已有一个多月了，每天就是学学吃吃喝喝，日子过得不算充实但也精致，哦对了，还有运动，台球羽毛球健身房一手抓</p>
</li>
<li><p>平淡的生活让我的情绪也非常稳定，可能这也是我很久没有分享日常的原因吧，好像突然之间就不需要那么多的情绪出口了</p>
</li>
<li><p>最近一直在装饰我的寝室，寝室虽小但很温馨，适合养老哈哈，该说不说，厦门空气质量是真好，附上一张今日的晚霞吧，真美</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/17d4cd4f8071e9dd6e4a66dde942fad.jpg" alt="17d4cd4f8071e9dd6e4a66dde942fad"></p>
</li>
<li><p>对了，新室友也很不错，听说我是白羊，这是她花一个晚上给我拼的嘻嘻</p>
<p><img src="/2023/01/01/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2023/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230904003435.jpg" alt="微信图片_20230904003435" style="zoom: 80%;"></p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>生活碎片</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之内存模型与名称空间</title>
    <url>/2022/12/25/C++%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>C++之内存模型与名称空间……</p>
<span id="more"></span>
<h1 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h1><ul>
<li><p>头文件中常包含的内容：</p>
<ul>
<li>使用#define或const定义的符号常量</li>
<li>函数原型</li>
<li>结构声明</li>
<li>类声明</li>
<li>模板声明</li>
<li>内联函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COORDIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COORDIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">polar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> distance;</span><br><span class="line">    <span class="type">double</span> angle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rect</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">polar <span class="title">rect_to_polar</span><span class="params">(rect xypos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_polar</span><span class="params">(polar pplace)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>VScode中如何对多个CPP文件进行编译</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ 文件名<span class="number">1.</span>cpp 文件名<span class="number">2.</span>cpp -o 重命名</span><br><span class="line">.\重命名</span><br></pre></td></tr></table></figure>
<p>CPP文件：</p>
<ul>
<li>coordin.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;coordin.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">polar <span class="title">rect_to_polar</span><span class="params">(rect xypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    polar pplace;</span><br><span class="line">    pplace.distance=<span class="built_in">sqrt</span>(xypos.x*xypos.x+xypos.y*xypos.y);</span><br><span class="line">    pplace.angle=<span class="built_in">atan2</span>(xypos.y,xypos.x);<span class="comment">//返回的是弧度制</span></span><br><span class="line">    <span class="keyword">return</span> pplace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_polar</span><span class="params">(polar pplace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> Rad_to_deg=<span class="number">57.29577951</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Distance=&quot;</span>&lt;&lt;pplace.distance&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//将弧度制转化为角度制</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Angle=&quot;</span>&lt;&lt;pplace.angle*Rad_to_deg&lt;&lt;<span class="string">&quot; degree&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main1.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//编译器自带的用&lt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;coordin.h&quot;</span><span class="comment">//用户自己写的用&quot;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rect rplace;</span><br><span class="line">    polar pplace;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter x and y(q for quit):&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;rplace.x&gt;&gt;rplace.y)</span><br><span class="line">    &#123;</span><br><span class="line">        pplace=<span class="built_in">rect_to_polar</span>(rplace);</span><br><span class="line">        <span class="built_in">show_polar</span>(pplace);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Please enter x and y(q for quit):&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/25/C++%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/image-20230105135539339.png" alt="image-20230105135539339"></p>
</li>
</ul>
<hr>
<h1 id="Extern与-的使用"><a href="#Extern与-的使用" class="headerlink" title="Extern与::的使用"></a>Extern与::的使用</h1><ul>
<li><p><code>extern</code>访问别的源文件中的全局变量，通常在头文件中声明</p>
</li>
<li><p><code>::</code>强制访问全局变量，而不访问离得最近的局部变量</p>
</li>
<li><p>头文件：support.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SUPPORT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SUPPORT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> warming;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">double</span> dt)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">local</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>源文件：</p>
<ul>
<li>support.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;support.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">double</span> dt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    warming+=dt;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Updating global warming to &quot;</span>&lt;&lt;warming&lt;&lt;<span class="string">&quot; degrees&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">local</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> warming=<span class="number">0.8</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Local warming=&quot;</span>&lt;&lt;warming&lt;&lt;<span class="string">&quot; degrees&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Global warming in Local =&quot;</span>&lt;&lt;::warming&lt;&lt;<span class="string">&quot; degrees&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;support.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> warming=<span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Global warming is &quot;</span>&lt;&lt;warming&lt;&lt;<span class="string">&quot; degrees&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">0.1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Global warming is &quot;</span>&lt;&lt;warming&lt;&lt;<span class="string">&quot; degrees&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">local</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Global warming is &quot;</span>&lt;&lt;warming&lt;&lt;<span class="string">&quot; degrees&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2022/12/25/C++%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/image-20230105142522719.png" alt="image-20230105142522719"></p>
</li>
</ul>
<hr>
<h1 id="Static的使用"><a href="#Static的使用" class="headerlink" title="Static的使用"></a>Static的使用</h1><ul>
<li><p><strong>当对全局变量使用Static时，表示此全局变量只用于当前文件，不能被其他文件访问</strong></p>
</li>
<li><p><strong>在函数中使用Static时：只初始化一次，且在函数调用完后变量不会消失</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ArSize=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strcount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> input[ArSize];</span><br><span class="line">    <span class="type">char</span> next;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter a line:&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(input,ArSize);<span class="comment">//实际只会读取ArSize-1个char</span></span><br><span class="line">    <span class="keyword">while</span>(cin)</span><br><span class="line">    &#123;</span><br><span class="line">        cin.<span class="built_in">get</span>(next);<span class="comment">//读取缓冲区的换行符</span></span><br><span class="line">        <span class="keyword">while</span>(next!=<span class="string">&#x27;\n&#x27;</span>)<span class="comment">//如果读取的不是换行符，说明读取的字符超出了Arsize-1的范围</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin.<span class="built_in">get</span>(next);<span class="comment">//则把超出范围的字符全部读掉，直到读到换行符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcount</span>(input);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Enter next line(empty line to quit):&quot;</span>;</span><br><span class="line">        cin.<span class="built_in">get</span>(input,ArSize);        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test Over!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strcount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total=<span class="number">0</span>;<span class="comment">//static在函数中定义的变量，只初始化一次，且在函数调用完后变量不会消失</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*str++)<span class="comment">//++的优先级更高,且先使用后自加，即先*str，再str+1</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    total+=count;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;<span class="string">&quot; characters&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;total&lt;&lt;<span class="string">&quot; characters total&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/25/C++%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/image-20230105153222956.png" alt="image-20230105153222956"></p>
</li>
</ul>
<hr>
<h1 id="定位new运算符"><a href="#定位new运算符" class="headerlink" title="定位new运算符"></a>定位new运算符</h1><ul>
<li><p>首先需要包含头文件new，它提供了这种版本的new运算符的原型<code>#include&lt;new&gt;</code></p>
</li>
<li><p>与常规的new使用相比，在new后面用（起始地址）指定new出空间的起始地址</p>
</li>
<li>定位new不能使用delete删除，只有常规new需要使用delete删除</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF = <span class="number">512</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> buffer[BUF];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> *pd1, *pd2;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Calling new and placement new: &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pd1 = <span class="keyword">new</span> <span class="type">double</span>[N];</span><br><span class="line">	pd2 = <span class="built_in">new</span>(buffer) <span class="type">double</span>[N];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		pd2[i] = pd1[i] = <span class="number">1000</span> + <span class="number">20.0</span> * i;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pd1 = &quot;</span> &lt;&lt; pd1 &lt;&lt; <span class="string">&quot;, buffer = &quot;</span> &lt;&lt; (<span class="type">void</span> *)buffer &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; pd1[i] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;pd1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; pd2[i] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;pd2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\nCalling new and placement new a second time: &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">double</span> *pd3, *pd4;</span><br><span class="line">	pd3 = <span class="keyword">new</span> <span class="type">double</span>[N];</span><br><span class="line">	pd4 = <span class="built_in">new</span>(buffer) <span class="type">double</span>[N];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		pd4[i] = pd3[i] = <span class="number">1000</span> + <span class="number">40.0</span> * i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; pd3[i] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;pd3[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; pd4[i] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;pd4[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\nCalling new and placement new a third time: &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] pd1;</span><br><span class="line">	pd1 = <span class="keyword">new</span> <span class="type">double</span>[N];</span><br><span class="line">	pd2 = <span class="built_in">new</span>(buffer + N*<span class="built_in">sizeof</span>(<span class="type">double</span>)) <span class="type">double</span>[N];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		pd2[i] = pd1[i] = <span class="number">1000</span> + <span class="number">60.0</span> * i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; pd1[i] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;pd1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; pd2[i] &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;pd2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] pd1;</span><br><span class="line">	<span class="keyword">delete</span>[] pd3;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/25/C++%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/image-20230106231745122.png" alt="image-20230106231745122"></p>
<hr>
<h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><ul>
<li>使用新的关键字namespace创建名称空间</li>
<li><code>using 名称空间的名字::使用的名称空间中的某个内容</code>//会将同名变量覆盖</li>
<li><code>using namespace 名称空间的名字</code>//此时引用区域可以使用该名称空间的所有内容，隐藏有变量 名称空间名字::变量</li>
<li>namesp.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> pers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;<span class="comment">//使用名称空间std中某个内容</span></span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::string fname;</span><br><span class="line">        std::string lname;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getPerson</span><span class="params">(Person &amp;rp)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">(<span class="type">const</span> Person &amp;rp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> debts</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> pers;<span class="comment">//可以使用pers名称空间的所有内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Debt</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person name;</span><br><span class="line">        <span class="type">double</span> amount;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getDebt</span><span class="params">(Debt &amp;rd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDebt</span><span class="params">(<span class="type">const</span> Debt &amp;rd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">sumDebts</span><span class="params">(<span class="type">const</span> Debt ar[],<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>namesp.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;namesp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> pers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getPerson</span><span class="params">(Person &amp;rp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Enter first name:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;rp.fname;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Enter last name:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;rp.lname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">(<span class="type">const</span> Person &amp;rp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The last and first name is:&quot;</span>&lt;&lt;rp.lname&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;rp.fname&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> debts</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getDebt</span><span class="params">(Debt &amp;rd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">getPerson</span>(rd.name);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Enter debt:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;rd.amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDebt</span><span class="params">(<span class="type">const</span> Debt &amp;rd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">showPerson</span>(rd.name);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The debt money is:$&quot;</span>&lt;&lt;rd.amount&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">sumDebts</span><span class="params">(<span class="type">const</span> Debt ar[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">double</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            total+=ar[i].amount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;namesp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> debts::Debt;</span><br><span class="line">    <span class="keyword">using</span> debts::showDebt;</span><br><span class="line"></span><br><span class="line">    Debt golf=&#123;&#123;<span class="string">&quot;Micheal&quot;</span>,<span class="string">&quot;Jordan&quot;</span>&#125;,<span class="number">120.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showDebt</span>(golf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/25/C++%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/image-20230109215711229.png" alt="image-20230109215711229"></p>
<hr>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="1-多文件编译"><a href="#1-多文件编译" class="headerlink" title="1.多文件编译"></a>1.多文件编译</h2><ul>
<li><p>存储高尔夫选手的姓名及成绩并显示，且能修改</p>
</li>
<li><p>golf.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Len = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">golf</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> fullname[Len];</span><br><span class="line">	<span class="type">int</span> handicap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setgolf</span><span class="params">(golf &amp;g, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> hc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgolf</span><span class="params">(golf &amp;g)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handicap</span><span class="params">(golf &amp;g, <span class="type">int</span> hc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showgolf</span><span class="params">(<span class="type">const</span> golf &amp;g)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>golf.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;golf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setgolf</span><span class="params">(golf &amp;g, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> hc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(g.fullname, name);</span><br><span class="line">	g.handicap = hc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgolf</span><span class="params">(golf &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The fullname is: &quot;</span>;</span><br><span class="line">	cin.<span class="built_in">getline</span>(g.fullname, Len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(g.fullname, <span class="string">&quot;&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;The handicap is: &quot;</span>;</span><br><span class="line">		cin &gt;&gt; g.handicap;</span><br><span class="line">		cin.<span class="built_in">get</span>();</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handicap</span><span class="params">(golf &amp;g, <span class="type">int</span> hc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g.handicap = hc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showgolf</span><span class="params">(<span class="type">const</span> golf &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The fullname is: &quot;</span> &lt;&lt; g.fullname &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The handicap is: &quot;</span> &lt;&lt; g.handicap &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.c</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;golf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	golf g[SIZE];</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please enter the information of golf players: &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span>((count &lt; SIZE) &amp;&amp; (<span class="built_in">setgolf</span>(g[count])))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please enter next player: &quot;</span> &lt;&lt; endl;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\nShow all golf players informations: &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">		<span class="built_in">showgolf</span>(g[i]);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\nReset all the players information: &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">handicap</span>(g[i], <span class="number">90</span>);</span><br><span class="line">		<span class="built_in">showgolf</span>(g[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2022/12/25/C++%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/image-20230201230346528.png" alt="image-20230201230346528"></p>
</li>
</ul>
<h2 id="2-定位new运算符"><a href="#2-定位new运算符" class="headerlink" title="2.定位new运算符"></a>2.定位new运算符</h2><ul>
<li>体会普通new与定位new的区别</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chaff</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> dross[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> slag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF = <span class="number">512</span>;</span><br><span class="line"><span class="type">char</span> buffer[BUF];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> chaff &amp;p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> dross[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> slag;</span><br><span class="line"></span><br><span class="line">	chaff *pd1 = <span class="keyword">new</span> chaff[<span class="number">2</span>];</span><br><span class="line">	chaff *pd2 = <span class="built_in">new</span>(buffer) chaff[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;#&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter the dross: &quot;</span>;</span><br><span class="line">		cin.<span class="built_in">getline</span>(dross, <span class="number">20</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter the slag: &quot;</span>;</span><br><span class="line">		cin &gt;&gt; slag;</span><br><span class="line">		cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">strcpy</span>(pd1[i].dross, dross);</span><br><span class="line">		<span class="built_in">strcpy</span>(pd2[i].dross, dross);</span><br><span class="line"></span><br><span class="line">		pd1[i].slag = pd2[i].slag = slag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">show</span>(pd1[i]);</span><br><span class="line">		<span class="built_in">show</span>(pd2[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The address of buffer is:&quot;</span>&lt;&lt;&amp;buffer&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The address of pd2 point is:&quot;</span>&lt;&lt;pd2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] pd1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> chaff &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The address is: &quot;</span>&lt;&lt;&amp;p&lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The dross is: &quot;</span> &lt;&lt; p.dross &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The slag is: &quot;</span> &lt;&lt; p.slag &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/25/C++%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/image-20230201234040224.png" alt="image-20230201234040224"></p>
<h2 id="3-名称空间的使用"><a href="#3-名称空间的使用" class="headerlink" title="3.名称空间的使用"></a>3.名称空间的使用</h2><ul>
<li><p>利用名称空间SALES求商品的平均值、最大值与最小值</p>
</li>
<li><p>p3.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __P3_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P3_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SALES</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> QUARTERS = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Sales</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> sales[QUARTERS];</span><br><span class="line">		<span class="type">double</span> average;</span><br><span class="line">		<span class="type">double</span> max;</span><br><span class="line">		<span class="type">double</span> min;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setSales</span><span class="params">(Sales &amp;s, <span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setSales</span><span class="params">(Sales &amp;s)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showSales</span><span class="params">(<span class="type">const</span> Sales &amp;s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>p3.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;p3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SALES</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setSales</span><span class="params">(Sales &amp;s, <span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">double</span> total = <span class="number">0.0</span>;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n &amp;&amp; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			s.sales[i] = ar[i];</span><br><span class="line">			total += s.sales[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s.average = total / i;</span><br><span class="line">		s.max = s.sales[<span class="number">0</span>];</span><br><span class="line">		s.min = s.sales[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt; i; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			s.max = (s.max &gt; s.sales[k]) ? s.max : s.sales[k];</span><br><span class="line">			s.min = (s.min &lt; s.sales[k]) ? s.min : s.sales[k];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(n &lt; <span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = n; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">				s.sales[k] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setSales</span><span class="params">(Sales &amp;s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">double</span> total = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter 4 sales quarters: &quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; QUARTERS; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;#&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">			cin &gt;&gt; s.sales[i];</span><br><span class="line">			total += s.sales[i];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				s.max = s.sales[i];</span><br><span class="line">				s.min = s.sales[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				s.max = (s.max &gt; s.sales[i]) ? s.max : s.sales[i];</span><br><span class="line">				s.min = (s.min &lt; s.sales[i]) ? s.min : s.sales[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		s.average = total / QUARTERS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showSales</span><span class="params">(<span class="type">const</span> Sales &amp;s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Sales of 4 quarters: &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; QUARTERS;i ++)</span><br><span class="line">			cout &lt;&lt; s.sales[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Average = &quot;</span> &lt;&lt; s.average &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Max = &quot;</span> &lt;&lt; s.max &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Min = &quot;</span> &lt;&lt; s.min &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;p3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> SALES;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> ar[<span class="number">4</span>] = &#123;<span class="number">11.1</span>, <span class="number">22.2</span>, <span class="number">33.3</span>, <span class="number">44.4</span>&#125;;</span><br><span class="line">	Sales sl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">setSales</span>(sl, ar, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">showSales</span>(sl);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">setSales</span>(sl);</span><br><span class="line">	<span class="built_in">showSales</span>(sl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下：</p>
<p><img src="/2022/12/25/C++%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/image-20230202152638213.png" alt="image-20230202152638213"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之函数高级用法</title>
    <url>/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>C++之函数高级用法……</p>
<span id="more"></span>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><ul>
<li>内联扩展是一种特别的用于消除调用函数时所造成的固有的时间消耗方法。</li>
<li>一般用于能够快速执行的函数，因为在这种情况下函数调用的时间消耗显得更为突出。这种方法对于很小的函数也有空间上的益处，并且它也使得一些其他的优化成为可能</li>
<li>使用方式：在原函数前加上<code>inline</code>关键字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//内联函数，交换两个数的值</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter two numbers:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;m, &amp;n);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The swap answer is:&quot;</span>&lt;&lt;m&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221222184344724.png" alt="image-20221222184344724"></p>
<hr>
<h1 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul>
<li><p>C++给&amp;符号赋予了另一个含义，将其用来声明引用，例如，要将rodents作为rats变量的别名，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rats;</span><br><span class="line"><span class="type">int</span> &amp;rodents = rats;</span><br></pre></td></tr></table></figure>
<ul>
<li>就像声明中的char*指的是指向char的指针一样，int &amp;指的是指向int的引用</li>
<li>上述引用声明允许将rat和rodents互换，它们指向相同的值和内存单元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rats;</span><br><span class="line">    <span class="type">int</span> &amp;rodents = rats;</span><br><span class="line"></span><br><span class="line">    rats=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The rats is:&quot;</span>&lt;&lt;rats&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The rodents is:&quot;</span>&lt;&lt;rodents&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The &amp;rats is:&quot;</span>&lt;&lt;&amp;rats&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The &amp;rodents is:&quot;</span>&lt;&lt;&amp;rodents&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cats=<span class="number">50</span>;</span><br><span class="line">    rodents=cats;<span class="comment">//仅仅代表赋值操作</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The rats is:&quot;</span>&lt;&lt;rats&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The rodents is:&quot;</span>&lt;&lt;rodents&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221222190922339.png" alt="image-20221222190922339"></p>
</li>
<li><p>引用后变量就一直跟着最初引用指向的那个变量，如下例中rodents初始化为*pt使得rodents指向rats，接下来将pt改为指向bunnies，并不能改变这样的事实，即rodents引用的是rats</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rats=<span class="number">101</span>;</span><br><span class="line">    <span class="type">int</span> *pt=&amp;rats;</span><br><span class="line">    <span class="type">int</span> &amp;rodents=*pt;</span><br><span class="line">    <span class="type">int</span> bunnies=<span class="number">50</span>;</span><br><span class="line">    pt=&amp;bunnies;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The rodents is:&quot;</span>&lt;&lt;rodents&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221222191816487.png" alt="image-20221222191816487"></p>
</li>
</ul>
<h2 id="2-引用与结构体"><a href="#2-引用与结构体" class="headerlink" title="2.引用与结构体"></a>2.引用与结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">free_throws</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> made;</span><br><span class="line">    <span class="type">int</span> attempts;</span><br><span class="line">    <span class="type">float</span> percent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pc</span><span class="params">(free_throws &amp;ft)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> free_throws &amp;ft)</span></span>;</span><br><span class="line"><span class="function">free_throws &amp;<span class="title">accumulate</span><span class="params">(free_throws &amp;target,<span class="type">const</span> free_throws &amp;source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    free_throws one=&#123;<span class="string">&quot;Rick&quot;</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    free_throws two=&#123;<span class="string">&quot;Jack&quot;</span>,<span class="number">10</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    free_throws three=&#123;<span class="string">&quot;Jerry&quot;</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    free_throws four=&#123;<span class="string">&quot;Jason&quot;</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    free_throws five=&#123;<span class="string">&quot;Micheal&quot;</span>,<span class="number">6</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    free_throws team=&#123;<span class="string">&quot;class 1&quot;</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">display</span>(<span class="built_in">accumulate</span>(<span class="built_in">accumulate</span>(<span class="built_in">accumulate</span>(<span class="built_in">accumulate</span>(<span class="built_in">accumulate</span>(team,one),two),three),four),five));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pc</span><span class="params">(free_throws &amp;ft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ft.attempts!=<span class="number">0</span>)</span><br><span class="line">        ft.percent=<span class="number">100.0</span>*<span class="built_in">float</span>(ft.made)/<span class="built_in">float</span>(ft.attempts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> free_throws &amp;ft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Name:&quot;</span>&lt;&lt;ft.name&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Made:&quot;</span>&lt;&lt;ft.made&lt;&lt;<span class="string">&quot; \t&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Attempts:&quot;</span>&lt;&lt;ft.attempts&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Percent:&quot;</span>&lt;&lt;ft.percent&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">free_throws &amp;<span class="title">accumulate</span><span class="params">(free_throws &amp;target,<span class="type">const</span> free_throws &amp;source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    target.attempts+=source.attempts;</span><br><span class="line">    target.made+=source.made;</span><br><span class="line">    <span class="built_in">set_pc</span>(target);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221223223853436.png" alt="image-20221223223853436"></p>
<h2 id="3-引用与类对象"><a href="#3-引用与类对象" class="headerlink" title="3.引用与类对象"></a>3.引用与类对象</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">version1</span><span class="params">(<span class="type">const</span> string &amp;input,<span class="type">const</span> string &amp;add)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">version2</span><span class="params">(string &amp;input,<span class="type">const</span> string &amp;add)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    string result;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter a string:&quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Your string as entered:&quot;</span>&lt;&lt;input&lt;&lt;endl;</span><br><span class="line">    result=<span class="built_in">version1</span>(input,<span class="string">&quot;***&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Your string enhanced is:&quot;</span>&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Your string as entered:&quot;</span>&lt;&lt;input&lt;&lt;endl;</span><br><span class="line">    result=<span class="built_in">version2</span>(input,<span class="string">&quot;@@@&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Your string enhanced is:&quot;</span>&lt;&lt;result&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">version1</span><span class="params">(<span class="type">const</span> string &amp;input,<span class="type">const</span> string &amp;add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string temp;</span><br><span class="line">    temp=add+input+add;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">version2</span><span class="params">(string &amp;input,<span class="type">const</span> string &amp;add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input=add+input+add;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221223231512315.png" alt="image-20221223231512315"></p>
<h2 id="4-引用与继承"><a href="#4-引用与继承" class="headerlink" title="4.引用与继承"></a>4.引用与继承</h2><ul>
<li>ofstream对象可以使用ostream类的方法</li>
<li>ostream是基类，ofstream是派生类，派生类继承了基类的方法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(ostream &amp;os,<span class="type">double</span> arr[],<span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pt=<span class="string">&quot;scores.txt&quot;</span>;</span><br><span class="line">    ofstream outFile;</span><br><span class="line">    outFile.<span class="built_in">open</span>(pt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!outFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Could not open the file&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Program terminating&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> scores[MAX];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Please enter the score &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; is:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;scores[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">display</span>(cout,scores,MAX);</span><br><span class="line">    <span class="built_in">display</span>(outFile,scores,MAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(ostream &amp;os,<span class="type">double</span> arr[],<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        os&lt;&lt;<span class="string">&quot;The score &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; is:&quot;</span>&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221224220257166.png" alt="image-20221224220257166"></p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221224220214614.png" alt="image-20221224220214614"></p>
<hr>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><ul>
<li>可以通过函数重载来设计一系列函数：它们完成相同的工作，但使用不同的参数列表</li>
<li>函数重载的判断方法是函数的参数列表不同，即参数的数目和类型不同，与函数的返回值无关</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示字符串str的前n位</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str,<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//显示数字num的前ct位</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">left</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> num,<span class="type">unsigned</span> <span class="type">int</span> ct)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *trip=<span class="string">&quot;Hawaii&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> n=<span class="number">12345678</span>;</span><br><span class="line">    <span class="type">char</span> *temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">left</span>(n,i)&lt;&lt;endl;</span><br><span class="line">        temp=<span class="built_in">left</span>(trip,i);</span><br><span class="line">        cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;----------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span> [] temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m&lt;n &amp;&amp; str[m]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        m++;<span class="comment">//计算想要显示的字符串长度和真正的字符串长度哪个大，取最小的</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *p=<span class="keyword">new</span> <span class="type">char</span>[m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        p[i]=str[i];</span><br><span class="line">    p[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">left</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> num,<span class="type">unsigned</span> <span class="type">int</span> ct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> n=num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> digits=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>||ct==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n/=<span class="number">10</span>)</span><br><span class="line">        digits++;<span class="comment">//digits表示数字总共有几位</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(digits&gt;ct)<span class="comment">//ct表示想显示的位数</span></span><br><span class="line">    &#123;</span><br><span class="line">        ct=digits-ct;</span><br><span class="line">        <span class="keyword">while</span>(ct--)</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221225002135729.png" alt="image-20221225002135729"></p>
<hr>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><ul>
<li><p>函数模板的定义格式：<code>template&lt;typename T&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1,a2;</span><br><span class="line">    <span class="type">double</span> b1,b2;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter two integers:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;a1&gt;&gt;a2;</span><br><span class="line">    <span class="built_in">Swap</span>(a1,a2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After Swap,the two integers:&quot;</span>&lt;&lt;a1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter two double datas:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;b1&gt;&gt;b2;</span><br><span class="line">    <span class="built_in">Swap</span>(b1,b2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After Swap,the two double datas:&quot;</span>&lt;&lt;b1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221225160532727.png" alt="image-20221225160532727"></p>
</li>
<li><p>显示具体化：<code>template&lt;&gt; void Swap&lt;student&gt;(student &amp;a,student &amp;b)</code></p>
</li>
<li><p>具体化优先于常规模板，而非模板函数优先于具体化和常规模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">double</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> <span class="built_in">Swap</span>&lt;student&gt;(student &amp;a,student &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1=<span class="number">1</span>,a2=<span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> b1=<span class="number">9.77</span>,b2=<span class="number">7.99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Swap</span>(a1,a2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After Swap,the two integers:&quot;</span>&lt;&lt;a1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Swap</span>(b1,b2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After Swap,the two double datas:&quot;</span>&lt;&lt;b1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    student stu1=&#123;<span class="string">&quot;ssy&quot;</span>,<span class="number">99.87</span>&#125;;</span><br><span class="line">    student stu2=&#123;<span class="string">&quot;wcf&quot;</span>,<span class="number">68.94</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The original struct data:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;stu1.name&lt;&lt;<span class="string">&quot; gets scores at:&quot;</span>&lt;&lt;stu1.scores&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;stu2.name&lt;&lt;<span class="string">&quot; gets scores at:&quot;</span>&lt;&lt;stu2.scores&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">Swap</span>(stu1,stu2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After Swap,the result:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;stu1.name&lt;&lt;<span class="string">&quot; gets scores at:&quot;</span>&lt;&lt;stu1.scores&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;stu2.name&lt;&lt;<span class="string">&quot; gets scores at:&quot;</span>&lt;&lt;stu2.scores&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;<span class="comment">//如果数据类型为student的执行了这个函数，那么结构体内的name和scores都会交换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示具体化，即出现数据类型为student时，优先执行这个函数，而不是通用的Swap函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> <span class="built_in">Swap</span>&lt;student&gt;(student &amp;a,student &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> temp;</span><br><span class="line">    temp=a.scores;</span><br><span class="line">    a.scores=b.scores;</span><br><span class="line">    b.scores=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221225164329097.png" alt="image-20221225164329097"></p>
</li>
<li><p>使用<code>函数名&lt;&gt;</code>强行使得编译器调用模板函数，&lt;&gt;中可以加数据类型，表示指定模板变量为对应数据类型变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">lesser</span><span class="params">(T a,T b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lesser</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">10</span>,y=<span class="number">8</span>;</span><br><span class="line">    <span class="type">double</span> a=<span class="number">9.87</span>,b=<span class="number">7.56</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The lesser answer of x and y is:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">lesser</span>(x,y)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The lesser answer of a and b is:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">lesser</span>(a,b)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;lesser&lt;&gt;(x,y)&lt;&lt;endl;<span class="comment">//强制使用模板函数</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">lesser</span>&lt;<span class="type">int</span>&gt;(a,b)&lt;&lt;endl;<span class="comment">//使得传入的a,b强制转化为int类型</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">lesser</span>&lt;<span class="type">int</span>&gt;(a,x)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">lesser</span><span class="params">(T a,T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Using template lesser!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    T result;</span><br><span class="line">    result=a&gt;b?b:a;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lesser</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Using normal lesser!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result=a&gt;b?b:a;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/22/C++%E4%B9%8B%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/image-20221225191431660.png" alt="image-20221225191431660"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础之Transformer模型</title>
    <url>/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>本节主要介绍了Transformer模型的一些基本概念</p>
<span id="more"></span>
<h1 id="Transformer模型的基本概念"><a href="#Transformer模型的基本概念" class="headerlink" title="Transformer模型的基本概念"></a>Transformer模型的基本概念</h1><ul>
<li><p>Transformer 本质上是一个 Encoder-Decoder 架构。因此中间部分的 Transformer 可以分为两个部分：编码组件和解码组件</p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217222055449.png" alt="image-20221217222055449" style="zoom:50%;"></p>
</li>
<li><p>其中，编码组件由多层编码器（Encoder）组成（在论文中作者使用了 6 层编码器，在实际使用过程中你可以尝试其他层数），解码组件也是由相同层数的解码器（Decoder）组成（在论文也使用了 6 层）</p>
<p>  <img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217222210088.png" alt="image-20221217222210088" style="zoom:50%;"></p>
</li>
<li><p>每个编码器由两个子层组成：Self-Attention 层（自注意力层）和 Position-wise Feed Forward Network（前馈网络，缩写为 FFN），每个编码器的结构都是相同的，但是它们使用不同的权重参数</p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217222323365.png" alt="image-20221217222323365" style="zoom:50%;"></p>
<ul>
<li>编码器的输入会先流入 Self-Attention 层。它可以让编码器在对特定词进行编码时使用输入句子中的其他词的信息（可以理解为：当我们翻译一个词时，不仅只关注当前的词，而且还会关注其他词的信息）</li>
<li>然后，Self-Attention 层的输出会流入前馈网络</li>
</ul>
</li>
<li><p>解码器也有编码器中这两层，但是它们之间还有一个注意力层（即 Encoder-Decoder Attention），其用来帮忙解码器关注输入句子的相关部分（类似于 seq2seq 模型中的注意力）</p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217222452064.png" alt="image-20221217222452064" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="Self-attention（自注意力）"><a href="#Self-attention（自注意力）" class="headerlink" title="Self-attention（自注意力）"></a>Self-attention（自注意力）</h1><ul>
<li><p>简单理解：使用self-attention取代RNN，使得$b^1,b^2,b^3,b^4$可以同时被计算出</p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217222907057.png" alt="image-20221217222907057" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="1-计算步骤"><a href="#1-计算步骤" class="headerlink" title="1.计算步骤"></a>1.计算步骤</h2><ul>
<li><p><strong>计算词嵌入与</strong>$q,k,v$</p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217223414298.png" alt="image-20221217223414298" style="zoom:50%;"></p>
<ul>
<li>$a^i=Wx^i$</li>
<li>$q^i=W^qa^i$：q代表去匹配别的</li>
<li>$k^i=W^ka^i$：k代表被匹配</li>
<li>$v^i=W^va^i$：v代表被提取的信息</li>
</ul>
</li>
<li><p><strong>拿每个q与每个k做attention</strong>：</p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217223947675.png" alt="image-20221217223947675" style="zoom:50%;"></p>
<ul>
<li>$\alpha_{1,i}=\frac{q^1k^i}{\sqrt{d}}$，其中d为q，k的维度</li>
</ul>
</li>
<li><p><strong>对每一个attention做softmax</strong></p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217224402526.png" alt="image-20221217224402526" style="zoom: 33%;"></p>
</li>
<li><p><strong>将每一个</strong>$\hat{\alpha}$<strong>与</strong>$v^1$<strong>计算相乘后求和</strong></p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217224754176.png" alt="image-20221217224754176" style="zoom: 33%;"></p>
<ul>
<li>$b^1=\sum \hat{\alpha}_{1,i}v^i$</li>
</ul>
</li>
<li><p>同理，按上述步骤也可以算出$b^2,b^3,b^4$</p>
</li>
</ul>
<hr>
<h2 id="2-平行化处理机制（矩阵处理）"><a href="#2-平行化处理机制（矩阵处理）" class="headerlink" title="2.平行化处理机制（矩阵处理）"></a>2.平行化处理机制（矩阵处理）</h2><ul>
<li><strong>求</strong>$Q,K,V$:<ul>
<li>将$a^1,a^2,a^3,a^4$这四个列向量按列堆叠在一起组成一个矩阵$I$</li>
<li>将$I$分别与$W^q,W^k,W^v$矩阵相乘，就可以得到按列堆叠的向量$Q,K,V$</li>
</ul>
</li>
</ul>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217225449896.png" alt="image-20221217225449896" style="zoom: 50%;"></p>
<ul>
<li><p><strong>求所有attention</strong>：</p>
<ul>
<li>将矩阵$K$转置后得到的$K^T$与Q进行矩阵相乘即可以得到每一个attention（这里计算忽略了除以$\sqrt{d}$</li>
<li>之后再对得到的attention矩阵$A$按列求softmax，得到矩阵$\hat{A}$</li>
</ul>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217230056300.png" alt="image-20221217230056300" style="zoom:50%;"></p>
</li>
<li><p><strong>求输出</strong>$b^1,b^2,b^3,b^4$：</p>
<ul>
<li>将矩阵$V$与$\hat{A}$相乘得到输出矩阵O</li>
<li>其中输出矩阵O就是输出列向量$b^1,b^2,b^3,b^4$按列的堆叠</li>
</ul>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217230528431.png" alt="image-20221217230528431" style="zoom:50%;"></p>
</li>
<li><p><strong>总结</strong>：</p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217231305242.png" alt="image-20221217231305242" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="3-多头自注意力机制（Multi-head-Self-attention"><a href="#3-多头自注意力机制（Multi-head-Self-attention" class="headerlink" title="3.多头自注意力机制（Multi-head Self-attention)"></a>3.多头自注意力机制（Multi-head Self-attention)</h2><ul>
<li>每一个头只与对应相同系数的k做attention，即$q^{i,1}$只与$k^{i,1},k^{j,1}$相乘</li>
</ul>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217231550232.png" alt="image-20221217231550232" style="zoom:50%;"></p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217231647494.png" alt="image-20221217231647494" style="zoom:50%;"></p>
<ul>
<li><p>计算出$b^{i,1},b^{i,2}$后，将其按行堆叠，与矩阵$W^O$相乘达到降维目的，从而得到$b^i$：</p>
<p><img src="/2022/12/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8BTransformer%E6%A8%A1%E5%9E%8B/image-20221217232135260.png" alt="image-20221217232135260" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.youtube.com/watch?v=ugWDIIOHtPA&amp;list=PLJV_el3uVTsOK_ZK5L0Iv_EQoL1JefRL4&amp;index=61">(54) Transformer - YouTube</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础之自动编码器与生成对抗网络</title>
    <url>/2022/12/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本节主要介绍了自动编码器的基本原理及其变体，以及生成对抗网络的基本原理。</p>
<span id="more"></span>
<h1 id="自动编码器"><a href="#自动编码器" class="headerlink" title="自动编码器"></a>自动编码器</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul>
<li>自动编码器是一种<strong>无监督</strong>的神经网络模型，其目标是通过训练网络忽略信号“噪声”，从而学习数据的低纬度表示（编码）</li>
<li><p>通常分为两步：</p>
<ul>
<li>学习到输入数据的隐含特征，即编码（encoder）：$x\rightarrow z$</li>
<li>用隐含特征重构原始的输入数据，即解码（decoder）：$z\rightarrow x$</li>
</ul>
<p><img src="/2022/12/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20221215160742594.png" alt="image-20221215160742594" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-vanilla自编码器"><a href="#2-vanilla自编码器" class="headerlink" title="2.vanilla自编码器"></a>2.vanilla自编码器</h2><ul>
<li><p>在这种自编码器的最简单结构中，只有三个网络层，即只有一个隐藏层的神经网络。它的输入和输出是相同的，可通过使用Adam优化器和均方误差损失函数，来学习如何重构输入。</p>
</li>
<li><p>在这里，如果隐含层维数（64）小于输入维数（784），则称这个编码器是有损的。通过这个约束，来迫使神经网络来学习数据的压缩表征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_size = <span class="number">784</span></span><br><span class="line">hidden_size = <span class="number">64</span></span><br><span class="line">output_size = <span class="number">784</span></span><br><span class="line"> </span><br><span class="line">x = Input(shape=(input_size,))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Encoder</span></span><br><span class="line">h = Dense(hidden_size, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Decoder</span></span><br><span class="line">r = Dense(output_size, activation=<span class="string">&#x27;sigmoid&#x27;</span>)(h)</span><br><span class="line"> </span><br><span class="line">autoencoder = Model(<span class="built_in">input</span>=x, output=r)</span><br><span class="line">autoencoder.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-多层自编码器"><a href="#3-多层自编码器" class="headerlink" title="3.多层自编码器"></a>3.多层自编码器</h2><ul>
<li><p>如果一个隐含层还不够，显然可以将自动编码器的隐含层数目进一步提高。</p>
</li>
<li><p>在这里，实现中使用了3个隐含层，而不是只有一个。<strong>任意一个隐含层都可以作为特征表征</strong>，但是为了使网络对称，我们使用了最中间的网络层。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_size = <span class="number">784</span></span><br><span class="line">hidden_size = <span class="number">128</span></span><br><span class="line">code_size = <span class="number">64</span></span><br><span class="line"> </span><br><span class="line">x = Input(shape=(input_size,))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Encoder</span></span><br><span class="line">hidden_1 = Dense(hidden_size, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">h = Dense(code_size, activation=<span class="string">&#x27;relu&#x27;</span>)(hidden_1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Decoder</span></span><br><span class="line">hidden_2 = Dense(hidden_size, activation=<span class="string">&#x27;relu&#x27;</span>)(h)</span><br><span class="line">r = Dense(input_size, activation=<span class="string">&#x27;sigmoid&#x27;</span>)(hidden_2)</span><br><span class="line"> </span><br><span class="line">autoencoder = Model(<span class="built_in">input</span>=x, output=r)</span><br><span class="line">autoencoder.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-卷积自编码器"><a href="#4-卷积自编码器" class="headerlink" title="4.卷积自编码器"></a>4.卷积自编码器</h2><ul>
<li><p><strong>使用3D矢量（如图像）而不是展平后的一维矢量</strong>。</p>
</li>
<li><p>对输入图像进行<strong>下采样</strong>，以提供较小维度的潜在表征，来迫使自编码器从压缩后的数据进行学习。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Input(shape=(<span class="number">28</span>, <span class="number">28</span>,<span class="number">1</span>)) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Encoder</span></span><br><span class="line">conv1_1 = Conv2D(<span class="number">16</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">pool1 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>)(conv1_1)</span><br><span class="line">conv1_2 = Conv2D(<span class="number">8</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(pool1)</span><br><span class="line">pool2 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>)(conv1_2)</span><br><span class="line">conv1_3 = Conv2D(<span class="number">8</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(pool2)</span><br><span class="line">h = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>)(conv1_3)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Decoder</span></span><br><span class="line">conv2_1 = Conv2D(<span class="number">8</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(h)</span><br><span class="line">up1 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>))(conv2_1)</span><br><span class="line">conv2_2 = Conv2D(<span class="number">8</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(up1)</span><br><span class="line">up2 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>))(conv2_2)</span><br><span class="line">conv2_3 = Conv2D(<span class="number">16</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>)(up2)</span><br><span class="line">up3 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>))(conv2_3)</span><br><span class="line">r = Conv2D(<span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;sigmoid&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>)(up3)</span><br><span class="line"> </span><br><span class="line">autoencoder = Model(<span class="built_in">input</span>=x, output=r)</span><br><span class="line">autoencoder.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-正则自编码器"><a href="#5-正则自编码器" class="headerlink" title="5.正则自编码器"></a>5.正则自编码器</h2><ul>
<li><p>除了施加一个比输入维度小的隐含层，一些其他方法也可用来约束自编码器重构，如正则自编码器。</p>
</li>
<li><p>正则自编码器不需要使用浅层的编码器和解码器以及小的编码维数来限制模型容量，而是使用损失函数来鼓励模型学习其他特性（除了将输入复制到输出）。这些特性包括稀疏表征、小导数表征、以及对噪声或输入缺失的鲁棒性。</p>
</li>
<li><p>在实际应用中，常用到两种正则自编码器，分别是<strong>稀疏自编码器</strong>和<strong>降噪自编码器</strong>。</p>
</li>
</ul>
<h3 id="5-1稀疏自编码器"><a href="#5-1稀疏自编码器" class="headerlink" title="5.1稀疏自编码器"></a>5.1稀疏自编码器</h3><ul>
<li><p>通过对其损失函数施加约束。比如，可对<strong>损失函数添加一个正则化约束</strong>，这样能使自编码器学习到数据的稀疏表征。</p>
</li>
<li><p>在这里，隐含层中，还加入了<strong>L1正则化，作为优化阶段中损失函数的惩罚项</strong>。与vanilla自编码器相比，这样操作后的数据表征更为稀疏。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_size = <span class="number">784</span></span><br><span class="line">hidden_size = <span class="number">64</span></span><br><span class="line">output_size = <span class="number">784</span></span><br><span class="line"> </span><br><span class="line">x = Input(shape=(input_size,))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Encoder</span></span><br><span class="line">h = Dense(hidden_size, activation=<span class="string">&#x27;relu&#x27;</span>, activity_regularizer=regularizers.l1(<span class="number">10e-5</span>))(x)<span class="comment">#施加在输出上的L1正则项</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Decoder</span></span><br><span class="line">r = Dense(output_size, activation=<span class="string">&#x27;sigmoid&#x27;</span>)(h)</span><br><span class="line"> </span><br><span class="line">autoencoder = Model(<span class="built_in">input</span>=x, output=r)</span><br><span class="line">autoencoder.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-1降噪自编码器"><a href="#5-1降噪自编码器" class="headerlink" title="5.1降噪自编码器"></a>5.1降噪自编码器</h3><ul>
<li><p>这里不是通过对损失函数施加惩罚项，而是<strong>通过改变损失函数的重构误差项</strong>来学习一些有用信息</p>
</li>
<li><p>向训练数据加入噪声，并使自编码器学会去除这种噪声来获得没有被噪声污染过的真实输入</p>
</li>
<li><p>因此，这就迫使编码器学习提取最重要的特征并学习输入数据中更加鲁棒的表征，这也是它的泛化能力比一般编码器强的原因</p>
</li>
</ul>
<hr>
<h1 id="生成对抗网络（GAN）"><a href="#生成对抗网络（GAN）" class="headerlink" title="生成对抗网络（GAN）"></a>生成对抗网络（GAN）</h1><ul>
<li><strong>生成对抗网络(generative adversarial network, GAN)</strong>是通过对抗训练的方式来使得生成网络产生的样本服从真实数据分布</li>
<li>在生成对抗网络中，有 两个网络进行对抗训练。一个是<strong>判别网络</strong>，目标是尽量准确地判断一个样本是 来自于真实数据还是生成网络产生的；另一个是<strong>生成网络</strong>，目标是尽量生成判别 网络无法区分来源的样本</li>
<li>这两个目标相反的网络不断地进行交替训练，当最后收敛时，如果判别网络再也无法判断出一个样本的来源，那么也就等价于生成 网络可以生成符合真实数据分布的样本</li>
<li><strong>生成器</strong>：从随机噪声中生成图像（随机噪声通常从均匀分布或高斯分布中获取）</li>
<li><strong>判别器</strong>：其输入为生成器生成的图像和来自训练集中的真实图像，并对其进行判别</li>
</ul>
<p><img src="/2022/12/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/image-20221215171153268.png" alt="image-20221215171153268" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础之词嵌入</title>
    <url>/2022/12/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%8D%E5%B5%8C%E5%85%A5/</url>
    <content><![CDATA[<p>本节主要介绍了词嵌入的常用方法：Word2Vec。</p>
<span id="more"></span>
<h1 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h1><ul>
<li>利用中心词来预测上下文词</li>
</ul>
<h2 id="1-One-hot码"><a href="#1-One-hot码" class="headerlink" title="1.One-hot码"></a>1.One-hot码</h2><ul>
<li><p>假设字典中1000个单词，则任意一个单词的表示为[0 0 …… 1 0 0……]，即只在对应的单词为1，其他位置为0</p>
</li>
<li><p>例如：</p>
<p><img src="/2022/12/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%8D%E5%B5%8C%E5%85%A5/image-20221214092127822.png" alt="image-20221214092127822" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="2-嵌入矩阵"><a href="#2-嵌入矩阵" class="headerlink" title="2.嵌入矩阵"></a>2.嵌入矩阵</h2><p><img src="/2022/12/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%8D%E5%B5%8C%E5%85%A5/image-20221214092549834.png" alt="image-20221214092549834" style="zoom:50%;"></p>
<ul>
<li>若每个词对应300个特征，那么嵌入矩阵为$300\times1000$</li>
<li>表中的权重代表词与对应特征的相关程度</li>
</ul>
<h2 id="3-Skip-gram模型"><a href="#3-Skip-gram模型" class="headerlink" title="3.Skip-gram模型"></a>3.Skip-gram模型</h2><ul>
<li><p>shkip-gram模型是基于某个词来生成它在文本序列周围的词</p>
</li>
<li><p>而模型训练时“周围的词”取决于skip窗口的大小</p>
<ul>
<li><p>若文本序列为：you are the pretty sunshine of my life.</p>
</li>
<li><p>若skip窗口为2，那么中心词pretty、sunshine等的目标可能有如下：</p>
<p>| context  | Target   |<br>| ———— | ———— |<br>| pretty   | are      |<br>| pretty   | the      |<br>| pretty   | sunshine |<br>| pretty   | of       |<br>| sunshine | the      |<br>| sunshine | pretty   |<br>| sunshine | of       |<br>| sunshine | my       |<br>| ……       | ……       |</p>
</li>
</ul>
</li>
<li><p>模型结构：</p>
<p><img src="/2022/12/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%8D%E5%B5%8C%E5%85%A5/image-20221214094143707.png" alt="image-20221214094143707" style="zoom:50%;"></p>
<ul>
<li>将上表中每个context看成训练样本的输入x，每个target看成训练样本的输出y</li>
<li>Skip-gram可以表示为由输入层、隐藏层（不含激活函数）和输出层（激活函数为softmax）组成的神经网络</li>
<li>假设嵌入矩阵对应有300个特征，那么从输入层到隐藏层需要的权重矩阵（即为嵌入向量的转置）为$1000\times300$，从隐藏层到输出层需要的权重矩阵为$300\times1000$</li>
</ul>
</li>
</ul>
<h2 id="4-负采样"><a href="#4-负采样" class="headerlink" title="4.负采样"></a>4.负采样</h2><ul>
<li><p>针对计算softmax中分母计算量过大提出的一种解决方案</p>
</li>
<li><p>负采样的定义：在字典中随机选择一个词，标为0，即负样本</p>
<ul>
<li><p>若文本序列为：I want a glass of orange juice to go alone with my cereal</p>
</li>
<li><p>则生成的正负样本有如下可能：正样本的生成方式与介绍skip窗口时相同</p>
<p>| context | word  | target |<br>| ———- | ——- | ——— |<br>| orange  | juice | 1      |<br>| orange  | king  | 0      |<br>| orange  | book  | 0      |<br>| orange  | the   | 0      |<br>| orange  | of    | 0      |<br>| ……      | ……    | ……     |</p>
<ul>
<li>其中juice是给定的文本序列中抽取的，则orange-juice对为正样本，记为1</li>
<li>king、book、the、of等都是随机中字典中抽取的词，则为负样本，记为0</li>
<li>数据集越大，从字典中挑取的样本个数就越小，反之亦然</li>
</ul>
</li>
</ul>
</li>
<li><p>模型结构：</p>
<p><img src="/2022/12/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AF%8D%E5%B5%8C%E5%85%A5/image-20221214195517075.png" alt="image-20221214195517075" style="zoom:50%;"></p>
<ul>
<li>将每个单词所有可能的context与word共同看成训练样本的输入x</li>
<li>每个target看成训练样本的输出y</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之字符串的模式匹配</title>
    <url>/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>本节主要介绍了栈和队列的实现及其应用。</p>
<span id="more"></span>
<h1 id="朴素模式匹配"><a href="#朴素模式匹配" class="headerlink" title="朴素模式匹配"></a>朴素模式匹配</h1><p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/image-20221212123315037.png" alt="image-20221212123315037" style="zoom:50%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在主串s中找子串t，若找到返回字串在主串中的索引；若没找到返回-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> lens = s.<span class="built_in">length</span>();<span class="comment">//计算串s、t的长度</span></span><br><span class="line">	<span class="type">int</span> lent = t.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; lens&amp;&amp;j &lt; lent)&#123;<span class="comment">//如果i、j都各自小于lens和lent</span></span><br><span class="line">		<span class="keyword">if</span> (t[j] == s[i])&#123;<span class="comment">//如果子串的t[j]和主串的s[i]相等</span></span><br><span class="line">			++i;<span class="comment">//各自索引都自增</span></span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">//否则，主串的索引比刚开始后移一个；子串的索引变为0</span></span><br><span class="line">			i = i - j + <span class="number">1</span>;</span><br><span class="line">			j = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == lent)&#123;<span class="comment">//如果最后j和lent的大小一样，证明找到了，返回子串在主串中的索引</span></span><br><span class="line">		<span class="keyword">return</span> i - lent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">//否则返回-1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;goodgoogle&quot;</span>;</span><br><span class="line">	string t = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = <span class="built_in">Index</span>(s, t);</span><br><span class="line">	<span class="keyword">if</span> (pos != <span class="number">-1</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;find &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; at the index &quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot; of &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;can&#x27;t find &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find google at the index 4 of goodgoogle</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><ul>
<li><p>算法核心：通过next数组控制出现不匹配时字串回退的位置</p>
</li>
<li><p>next数组中存储的值为最长公共前后缀+1</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/image-20221212161105967.png" alt="image-20221212161105967" style="zoom:50%;"></p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/image-20221212161233960.png" alt="image-20221212161233960" style="zoom: 50%;"></p>
</li>
<li><p>公共前后缀：</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/image-20221212160823648.png" alt="image-20221212160823648" style="zoom: 33%;"></p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/image-20221212160844675.png" alt="image-20221212160844675" style="zoom: 33%;"></p>
</li>
<li><p>具体原理解释见：<a href="https://www.bilibili.com/video/BV1jb411V78H/?spm_id_from=333.337.search-card.all.click&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">【天勤考研】KMP算法易懂版_哔哩哔哩_bilibili</a></p>
</li>
<li><p>设置next[0]=0时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在主串s中找子串t，若找到返回字串在主串中的索引；若没找到返回-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(string t, <span class="type">int</span> *next)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(string s, string t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;ababaacababaaababaa&quot;</span>;</span><br><span class="line">	string t = <span class="string">&quot;ababaaababaa&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = <span class="built_in">Index_KMP</span>(s, t);</span><br><span class="line">	<span class="keyword">if</span> (pos != <span class="number">-1</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;find &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; at the index &quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot; of &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;can&#x27;t find &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> lens = s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> lent = t.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> *next = <span class="keyword">new</span> <span class="type">int</span>[lent];</span><br><span class="line">	<span class="built_in">get_next</span>(t, next); <span class="comment">//对子串t作分析，得到next数组</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;next: &quot;</span>;    <span class="comment">//输出next测试而已</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lent; ++i)&#123;</span><br><span class="line">		cout &lt;&lt; next[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; lens&amp;&amp;j &lt; lent)&#123;<span class="comment">//两字母相等则继续，与朴素算法增加了j==0的判断</span></span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">0</span> || t[j] == s[i])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			j = next[j]<span class="number">-1</span>;<span class="comment">//j退回合适位置，i值不变</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;new j:&quot;</span>&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == lent)&#123;<span class="comment">//如果最j和lent的大小一样，证明找到了，返回子串在主串中的索引</span></span><br><span class="line">		<span class="keyword">return</span> i - lent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">//否则返回-1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(string t, <span class="type">int</span> *next)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> lent = t.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; lent)&#123;<span class="comment">//i小于t的长度</span></span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">0</span> || t[i] == t[j - <span class="number">1</span>])&#123;<span class="comment">//t[i]表示后缀的单个字符</span></span><br><span class="line">			++i;                      <span class="comment">//t[j]表示前缀的单个字符</span></span><br><span class="line">			++j;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			j = next[j - <span class="number">1</span>];   <span class="comment">//若字符不相同，则j值回溯</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next: 011234223456</span><br><span class="line">new j:1</span><br><span class="line">new j:0</span><br><span class="line">new j:0</span><br><span class="line">find ababaaababaa at the index 7 of ababaacababaaababaa</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置next[0]=-1时</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在主串s中找子串t，若找到返回字串在主串中的索引；若没找到返回-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(string t, <span class="type">int</span> *next)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(string s, string t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;ababaacababaaababaa&quot;</span>;</span><br><span class="line">	string t = <span class="string">&quot;ababaaababaa&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = <span class="built_in">Index_KMP</span>(s, t);</span><br><span class="line">	<span class="keyword">if</span> (pos != <span class="number">-1</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;find &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; at the index &quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot; of &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;can&#x27;t find &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> lens = s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> lent = t.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> *next = <span class="keyword">new</span> <span class="type">int</span>[lent];</span><br><span class="line">	<span class="built_in">get_next</span>(t, next); <span class="comment">//对子串t作分析，得到next数组</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;next: &quot;</span>;    <span class="comment">//输出next测试而已</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lent; ++i)&#123;</span><br><span class="line">		cout &lt;&lt; next[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; lens&amp;&amp;j &lt; lent)&#123;<span class="comment">//两字母相等则继续，与朴素算法增加了j==-1的判断</span></span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || t[j] == s[i])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			j = next[j];<span class="comment">//j退回合适位置，i值不变</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;new j:&quot;</span>&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == lent)&#123;<span class="comment">//如果最j和lent的大小一样，证明找到了，返回子串在主串中的索引</span></span><br><span class="line">		<span class="keyword">return</span> i - lent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;<span class="comment">//否则返回-1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(string t, <span class="type">int</span> *next)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> lent = t.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; lent<span class="number">-1</span>)&#123;<span class="comment">//i小于t的长度</span></span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || t[i] == t[j])&#123;<span class="comment">//t[i]表示后缀的单个字符,t[j]表示前缀的单个字符</span></span><br><span class="line">			next[++i] = ++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			j = next[j];   <span class="comment">//若字符不相同，则j值回溯</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next: -100123112345</span><br><span class="line">new j:1</span><br><span class="line">new j:0</span><br><span class="line">new j:-1</span><br><span class="line">find ababaaababaa at the index 7 of ababaacababaaababaa</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之函数</title>
    <url>/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>C++之函数……</p>
<span id="more"></span>
<h1 id="函数与数组"><a href="#函数与数组" class="headerlink" title="函数与数组"></a>函数与数组</h1><h2 id="1-参数传递"><a href="#1-参数传递" class="headerlink" title="1.参数传递"></a>1.参数传递</h2><ul>
<li><p>传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组</p>
</li>
<li><p>为将数组类型和元素个数告诉数组处理函数，需通过两个不同的参数来传递它们，一个是数组的首地址，一个是数组的大小</p>
</li>
<li><p>函数中的数组名实际上是一个指向数组的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ArSize=<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cookies[ArSize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;cookies address:&quot;</span>&lt;&lt;cookies&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size of cookies:&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(cookies)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="built_in">sum_arr</span>(cookies,ArSize);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The sum of cookies is:&quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;arr address:&quot;</span>&lt;&lt;arr&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size of arr:&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(arr)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        total+=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221216184155698.png" alt="image-20221216184155698"></p>
</li>
</ul>
<h2 id="2-数组与指针"><a href="#2-数组与指针" class="headerlink" title="2.数组与指针"></a>2.数组与指针</h2><ul>
<li><p>参数入口有数组的函数的声明，通常用const修饰，这是为了在函数中无法通过指针修改数组中的值</p>
</li>
<li><p>例如下例中的<code>const double arr[]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fill_array</span><span class="params">(<span class="type">double</span> arr[],<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_array</span><span class="params">(<span class="type">const</span> <span class="type">double</span> arr[],<span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> properties[Max];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> number=<span class="built_in">fill_array</span>(properties,Max);<span class="comment">//number表示成功输入的个数</span></span><br><span class="line">    <span class="built_in">show_array</span>(properties,number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fill_array</span><span class="params">(<span class="type">double</span> arr[],<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Enter value #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        <span class="keyword">if</span>(!cin)<span class="comment">//当输入出现错误：类型不匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span>(cin.<span class="built_in">get</span>()!=<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Bad input:input process terminated!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            arr[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_array</span><span class="params">(<span class="type">const</span> <span class="type">double</span> arr[],<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Property #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;:$&quot;</span>&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221216221816394.png" alt="image-20221216221816394"></p>
</li>
</ul>
<h2 id="3-使用数组区间的函数"><a href="#3-使用数组区间的函数" class="headerlink" title="3.使用数组区间的函数"></a>3.使用数组区间的函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ArSize=<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *begin,<span class="type">const</span> <span class="type">int</span> *end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cookies[ArSize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="built_in">sum_arr</span>(cookies,cookies+ArSize);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The sum of cookies is:&quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *begin,<span class="type">const</span> <span class="type">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pt;</span><br><span class="line">    <span class="keyword">for</span>(pt=begin;pt!=end;pt++)</span><br><span class="line">    &#123;</span><br><span class="line">        total+=*pt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The sum of cookies is:255</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="函数与C-type字符串"><a href="#函数与C-type字符串" class="headerlink" title="函数与C-type字符串"></a>函数与C-type字符串</h1><ul>
<li><p><strong>函数的参数入口传递的是C-type字符串时，传入的值也是地址，即将地址传给了指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">ch_number</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arr,<span class="type">char</span> ch)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c_array[]=<span class="string">&quot;milmimm&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pt=<span class="string">&quot;uloinuu&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m=<span class="built_in">ch_number</span>(c_array,<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u=<span class="built_in">ch_number</span>(pt,<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m happens &quot;</span>&lt;&lt;m&lt;&lt;<span class="string">&quot; times&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;u happens &quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot; times&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">ch_number</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arr,<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*arr==ch)</span><br><span class="line">            count++;</span><br><span class="line">        arr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221218155231611.png" alt="image-20221218155231611"></p>
</li>
<li><p><strong>函数返回字符串时返回的是地址</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">buildstr</span><span class="params">(<span class="type">char</span> ch,<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> times;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enther a character:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter an integer:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;times;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *pt=<span class="built_in">buildstr</span>(ch,times);</span><br><span class="line">    cout&lt;&lt;pt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span> [] pt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">buildstr</span><span class="params">(<span class="type">char</span> ch,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *pt=<span class="keyword">new</span> <span class="type">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    pt[n]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pt[i]=ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221218160254652.png" alt="image-20221218160254652"></p>
</li>
</ul>
<hr>
<h1 id="函数与结构体"><a href="#函数与结构体" class="headerlink" title="函数与结构体"></a>函数与结构体</h1><ul>
<li><p>直接将结构体的名字当成一个数据类型，像传递整数等其他正常数据类型一样操作就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//实现将直角坐标转化为极坐标</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">polar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> distance;</span><br><span class="line">    <span class="type">double</span> angle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rect</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">polar <span class="title">rect_to_polar</span><span class="params">(rect xypos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_polar</span><span class="params">(polar pplace)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rect rplace;</span><br><span class="line">    polar pplace;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter x and y(q for quit):&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;rplace.x&gt;&gt;rplace.y)</span><br><span class="line">    &#123;</span><br><span class="line">        pplace=<span class="built_in">rect_to_polar</span>(rplace);</span><br><span class="line">        <span class="built_in">show_polar</span>(pplace);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Please enter x and y(q for quit):&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">polar <span class="title">rect_to_polar</span><span class="params">(rect xypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    polar pplace;</span><br><span class="line">    pplace.distance=<span class="built_in">sqrt</span>(xypos.x*xypos.x+xypos.y*xypos.y);</span><br><span class="line">    pplace.angle=<span class="built_in">atan2</span>(xypos.y,xypos.x);<span class="comment">//返回的是弧度制</span></span><br><span class="line">    <span class="keyword">return</span> pplace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_polar</span><span class="params">(polar pplace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> Rad_to_deg=<span class="number">57.29577951</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Distance=&quot;</span>&lt;&lt;pplace.distance&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//将弧度制转化为角度制</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Angle=&quot;</span>&lt;&lt;pplace.angle*Rad_to_deg&lt;&lt;<span class="string">&quot; degree&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221218173336809.png" alt="image-20221218173336809"></p>
</li>
<li><p><strong>通常需要传递结构体的地址而不是整个结构体以节省时间和空间，故使用指向结构体的指针来传递参数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//实现将直角坐标转化为极坐标</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">polar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> distance;</span><br><span class="line">    <span class="type">double</span> angle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rect</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rect_to_polar</span><span class="params">(<span class="type">const</span> rect *pxy,polar *pda)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_polar</span><span class="params">(<span class="type">const</span> polar *pda)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rect rplace;</span><br><span class="line">    polar pplace;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter x and y(q for quit):&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;rplace.x&gt;&gt;rplace.y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">rect_to_polar</span>(&amp;rplace,&amp;pplace);</span><br><span class="line">        <span class="built_in">show_polar</span>(&amp;pplace);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Please enter x and y(q for quit):&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rect_to_polar</span><span class="params">(<span class="type">const</span> rect *pxy,polar *pda)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pda-&gt;distance=<span class="built_in">sqrt</span>(pxy-&gt;x*pxy-&gt;x+pxy-&gt;y*pxy-&gt;y);</span><br><span class="line">    pda-&gt;angle=<span class="built_in">atan2</span>(pxy-&gt;y,pxy-&gt;x);<span class="comment">//返回的是弧度制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_polar</span><span class="params">(<span class="type">const</span> polar *pda)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> Rad_to_deg=<span class="number">57.29577951</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Distance=&quot;</span>&lt;&lt;pda-&gt;distance&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//将弧度制转化为角度制</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Angle=&quot;</span>&lt;&lt;pda-&gt;angle*Rad_to_deg&lt;&lt;<span class="string">&quot; degree&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221218174215417.png" alt="image-20221218174215417"></p>
</li>
</ul>
<hr>
<h1 id="函数与string对象"><a href="#函数与string对象" class="headerlink" title="函数与string对象"></a>函数与string对象</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_list</span><span class="params">(<span class="type">const</span> string list[],<span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string list[SIZE];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter &quot;</span>&lt;&lt;SIZE&lt;&lt;<span class="string">&quot; food&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin,list[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">show_list</span>(list,SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_list</span><span class="params">(<span class="type">const</span> string list[],<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The list is:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;list[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221218180046573.png" alt="image-20221218180046573"></p>
<hr>
<h1 id="函数与array对象"><a href="#函数与array对象" class="headerlink" title="函数与array对象"></a>函数与array对象</h1><ul>
<li>在函数中对array对象进行传递时，若直接将array对象的名字传递给函数，那么传递的将是array对象的复制版本，并不是直接改变了array对象里面的值，所以下面例子中使用传递地址的方式对数据进行写入操作</li>
<li>指向array对象的指针不能直接通过指针pa[i]去改变array对象中的值，只能通过<code>(*pa)[i]</code>的方式去访问array对象中的值</li>
<li>函数中参数的形式为：<code>array&lt;double,Seasons&gt; *pa</code></li>
<li>其实有点类似于函数与结构体的使用，只是array对象不存在-&gt;与.的使用方式，但都可以通过(*pa)访问指针指向的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Seasons=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> array&lt;string,Seasons&gt; Snames=&#123;<span class="string">&quot;Spring&quot;</span>,<span class="string">&quot;Summer&quot;</span>,<span class="string">&quot;Fall&quot;</span>,<span class="string">&quot;Winter&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(array&lt;<span class="type">double</span>,Seasons&gt; *pa)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(array&lt;<span class="type">double</span>,Seasons&gt; data_array)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">double</span>,Seasons&gt; expenses;</span><br><span class="line">    <span class="built_in">fill</span>(&amp;expenses);</span><br><span class="line">    <span class="built_in">show</span>(expenses);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(array&lt;<span class="type">double</span>,Seasons&gt; *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Seasons;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Please Enter the &quot;</span>&lt;&lt;Snames[i]&lt;&lt;<span class="string">&quot; expenses:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;(*pa)[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(array&lt;<span class="type">double</span>,Seasons&gt; data_array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Seasons;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;Snames[i]&lt;&lt;<span class="string">&quot;:$&quot;</span>&lt;&lt;data_array[i]&lt;&lt;endl;</span><br><span class="line">        sum+=data_array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The sum is:&quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*或者通过指针的方式去访问数组也可</span></span><br><span class="line"><span class="comment">void show(const array&lt;double,Seasons&gt; *data_array)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    double sum;</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;Seasons;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;Snames[i]&lt;&lt;&quot;:$&quot;&lt;&lt;(*data_array)[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        sum+=(*data_array)[i];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;The sum is:&quot;&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221218184518981.png" alt="image-20221218184518981"></p>
<hr>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Lens=<span class="number">66</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Times=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subdivide</span><span class="params">(<span class="type">char</span> arr[],<span class="type">int</span> min,<span class="type">int</span> max,<span class="type">int</span> levels)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ruler[Lens];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Lens;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ruler[i]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> min=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max=Lens<span class="number">-2</span>;</span><br><span class="line">    ruler[Lens<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//字符数组需要以&#x27;\0&#x27;结尾</span></span><br><span class="line">    <span class="comment">// ruler[min]=&#x27;|&#x27;;</span></span><br><span class="line">    <span class="comment">// ruler[max]=&#x27;|&#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Times;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">subdivide</span>(ruler,min,max,i);</span><br><span class="line">        cout&lt;&lt;ruler&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">subdivide</span><span class="params">(<span class="type">char</span> arr[],<span class="type">int</span> min,<span class="type">int</span> max,<span class="type">int</span> levels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=(min+max)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(levels==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[min]=<span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        arr[max]=<span class="string">&#x27;|&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        arr[mid]=<span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        <span class="built_in">subdivide</span>(arr,min,mid,levels<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">subdivide</span>(arr,mid,max,levels<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221218220727018.png" alt="image-20221218220727018"></p>
<hr>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><ul>
<li><p>函数指针：<code>double (*pt)(int)</code>，可以指向输入参数为一个整数，输出为double类型的函数</p>
</li>
<li><p>在函数中用<code>(*pt)</code>表示对应函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Jack</span><span class="params">(<span class="type">int</span> L)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Rick</span><span class="params">(<span class="type">int</span> L)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computes</span><span class="params">(<span class="type">int</span> L,<span class="type">double</span> (*pt)(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> lines;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter the Lines:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;lines;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The times computes by Jack is:&quot;</span>;</span><br><span class="line">    <span class="built_in">computes</span>(lines,Jack);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The times computes by Rick is:&quot;</span>;</span><br><span class="line">    <span class="built_in">computes</span>(lines,Rick);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Jack</span><span class="params">(<span class="type">int</span> L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L*<span class="number">0.05</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Rick</span><span class="params">(<span class="type">int</span> L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L*<span class="number">0.03</span>+<span class="number">0.0004</span>*L*L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computes</span><span class="params">(<span class="type">int</span> L,<span class="type">double</span> (*pt)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;(*pt)(L)&lt;&lt;<span class="string">&quot; seconds&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221218223557271.png" alt="image-20221218223557271"></p>
</li>
<li><p>若想表达指向数组（数组中的元素为指向函数的指针）的指针：则例如<code>const double *(*(*pd)[3])(const double *,int)=&amp;pa;</code>，其中<code>(*pd)</code>表示指针，<code>[3]</code>表示指向的是一个数组，<code>*(*pd)[3]</code>表示指向一个数组中有3个元素（每个元素为指向函数的指针）的指针，可以理解为指向指针的指针</p>
</li>
<li><p>下例中：<code>const double *(*(*pd)[3])(const double *,int)=&amp;pa</code>的&amp;pa为取数组pa整体的首地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> *<span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *ar,<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> *<span class="title">f2</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[],<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> *<span class="title">f3</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[],<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> av[<span class="number">3</span>]=&#123;<span class="number">1112.3</span>,<span class="number">1542.6</span>,<span class="number">2227.9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Part1:</span></span><br><span class="line">    <span class="comment">//p1(p2):pointer to a function</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> *(*p1)(<span class="type">const</span> <span class="type">double</span> *,<span class="type">int</span>)=f1;</span><br><span class="line">    <span class="keyword">auto</span> p2=f2;<span class="comment">//编译器会根据f2的值自己得出p2的数据类型,并将f2赋值给p2</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Part1:----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Address\t value&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;(*p1)(av,<span class="number">3</span>)&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;*((*p1)(av,<span class="number">3</span>))&lt;&lt;endl;<span class="comment">//这里*((*p1)(av,3))不加最外层括号也可以，因为()的优先级高于*</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">p2</span>(av,<span class="number">3</span>)&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;*<span class="built_in">p2</span>(av,<span class="number">3</span>)&lt;&lt;endl;<span class="comment">//*pt也可以直接用pt表示，故这里p2用最简单的形式表示出来了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Part2:</span></span><br><span class="line">    <span class="comment">//pa(pb) is an array of pointers</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> *(*pa[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span> *,<span class="type">int</span>)=&#123;f1,f2,f3&#125;;</span><br><span class="line">    <span class="keyword">auto</span> pb=pa;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Part2:----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Address\t Value&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;pa[i](av,<span class="number">3</span>)&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;*pa[i](av,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;pb[i](av,<span class="number">3</span>)&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;*pb[i](av,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Part3:</span></span><br><span class="line">    <span class="comment">//pc(pd) is a pointer to an array of function pointers</span></span><br><span class="line">    <span class="keyword">auto</span> pc=&amp;pa;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> *(*(*pd)[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span> *,<span class="type">int</span>)=&amp;pa;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Part3:----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Address\t Value&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;(*pc)[<span class="number">0</span>](av,<span class="number">3</span>)&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;*(*pc)[<span class="number">0</span>](av,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> *pdb=(*pd)[<span class="number">1</span>](av,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;pdb&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;*pdb&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;(*(*pd)[<span class="number">2</span>])(av,<span class="number">3</span>)&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;*(*(*pd)[<span class="number">2</span>])(av,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> *<span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *ar,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> *<span class="title">f2</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ar+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> *<span class="title">f3</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ar+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/10/C++%E4%B9%8B%E5%87%BD%E6%95%B0/image-20221219211422256.png" alt="image-20221219211422256"></p>
</li>
<li><p>使用<code>typedef const double *(*p1)(const double *,int)</code>后p1称为了指代此函数指针的数据类型</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之栈与队列</title>
    <url>/2022/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>本节主要介绍了栈和队列的实现及其应用。</p>
<span id="more"></span>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul>
<li><p>后进先出：一种限制访问端口的线性表</p>
</li>
<li><p><strong>引理：设k是最后一个出栈的，那么k把序列一分为二；在k之前入栈的元素，一定比在k之后入栈的元素要提前出栈</strong></p>
<p><img src="/2022/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20221209140126898.png" alt="image-20221209140126898" style="zoom:50%;"></p>
</li>
<li><p>给定一个入栈序列，序列长度为N，共有$f(N)$种出栈序列：</p>
<script type="math/tex; mode=display">
f(N)=\frac1{N+1}\times C_{2N}^N</script></li>
</ul>
<hr>
<h1 id="栈的实现方式"><a href="#栈的实现方式" class="headerlink" title="栈的实现方式"></a>栈的实现方式</h1><h2 id="1-顺序栈"><a href="#1-顺序栈" class="headerlink" title="1.顺序栈"></a>1.顺序栈</h2><ul>
<li>用一块连续的内存存储数据，即用一维数组来实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearStack.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinearStack</span>(<span class="type">int</span> LSMaxSize);<span class="comment">// 构造函数，创建栈</span></span><br><span class="line">    ~<span class="built_in">LinearStack</span>();  <span class="comment">//析构函数，删除栈</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;  <span class="comment">//判断栈是否为空，栈空返回true，否则返回false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;   <span class="comment">//判断栈是否已满</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetElementNumber</span><span class="params">()</span></span>; <span class="comment">//求栈中元素个数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>; <span class="comment">//在栈顶插入元素，成功返回true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Top</span><span class="params">(T&amp; x)</span></span>;       <span class="comment">//求栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; x)</span></span>; <span class="comment">//从栈顶删除一个元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OutPut</span><span class="params">(ostream&amp; out)</span></span>; <span class="comment">//将顺序栈输出</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> top;     <span class="comment">//用来表示栈顶</span></span><br><span class="line">    <span class="type">int</span> MaxSize; <span class="comment">//栈中最大元素个数</span></span><br><span class="line">    T* element;  <span class="comment">//一维动态数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinearStack&lt;T&gt;::<span class="built_in">LinearStack</span>(<span class="type">int</span> LSMaxSize)</span><br><span class="line">&#123;</span><br><span class="line">    MaxSize = LSMaxSize;</span><br><span class="line">    element = <span class="keyword">new</span> T[LSMaxSize];</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinearStack&lt;T&gt;::~<span class="built_in">LinearStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> []element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinearStack&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈是否已满</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinearStack&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((top + <span class="number">1</span>) == MaxSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现进栈</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinearStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        top++;</span><br><span class="line">        element[top] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求栈顶元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinearStack&lt;T&gt;::<span class="built_in">Top</span>(T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = element[top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现出栈</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinearStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = element[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现顺序栈的输出，栈底到栈顶。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinearStack&lt;T&gt;::<span class="built_in">OutPut</span>(ostream&amp; out)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top; i++)</span><br><span class="line">        out &lt;&lt; element[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载&lt;&lt;运算符</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> LinearStack&lt;T&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    x.<span class="built_in">OutPut</span>(cout);</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用顺序栈实现十进制转其他进制</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearStack_appliction.cpp</span></span><br><span class="line"><span class="comment">//将十进制数转换为其他进制</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;LinearStack.h&quot;</span><span class="comment">//包含之前写的类的定义和实现</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">con</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base)</span><span class="comment">//转换函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    y = n;</span><br><span class="line">    LinearStack&lt;<span class="type">int</span>&gt;<span class="built_in">s</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">Push</span>(y % base);</span><br><span class="line">        y = y / base;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;转换后的数为:&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">IsEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">Pop</span>(x);</span><br><span class="line">        cout &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, base;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入十进制数和要转换的数的基数:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; base;</span><br><span class="line">    <span class="built_in">con</span>(n, base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20221209152352220.png" alt="image-20221209152352220"></p>
<h2 id="2-链式栈"><a href="#2-链式栈" class="headerlink" title="2.链式栈"></a>2.链式栈</h2><ul>
<li>相比顺序栈，链式栈不需要事先确定栈大小的问题，栈的大小随着出入栈操作不断的自己改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LINKED_STACK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LINKED_STACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈元素节点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">LinkStack</span>&lt;T&gt;;<span class="comment">//声明栈类为节点类的友元，以便访问其私有数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StackNode</span>()&#123;&#125;;</span><br><span class="line">	<span class="built_in">StackNode</span>(T _data) :<span class="built_in">data</span>(_data), <span class="built_in">link</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">	~<span class="built_in">StackNode</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T data;</span><br><span class="line">	StackNode&lt;T&gt;* link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="built_in">LinkStack</span>();</span><br><span class="line">	~<span class="built_in">LinkStack</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; _data)</span></span>;<span class="comment">//入栈</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>;<span class="comment">//删除</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">Top</span><span class="params">()</span></span>;<span class="comment">//返回栈顶数据</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">()</span></span>;<span class="comment">//返回栈的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	StackNode&lt;T&gt; *top;<span class="comment">//栈顶指针</span></span><br><span class="line">	<span class="type">int</span> size;<span class="comment">//栈当前的大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数和析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::<span class="built_in">LinkStack</span>()</span><br><span class="line">:<span class="built_in">top</span>(<span class="literal">nullptr</span>), <span class="built_in">size</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::~<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">Empty</span>())&#123;</span><br><span class="line">		<span class="built_in">Pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; _data)</span><br><span class="line">&#123;</span><br><span class="line">	StackNode&lt;T&gt; *tmp = <span class="keyword">new</span> <span class="built_in">StackNode</span>&lt;T&gt;(_data);<span class="comment">//生成一个新的栈元素节点，并赋初值_data</span></span><br><span class="line">	tmp-&gt;link = top;<span class="comment">//push的元素节点指向原来的栈顶</span></span><br><span class="line">	top = tmp;<span class="comment">//push的元素节点做为栈顶</span></span><br><span class="line"></span><br><span class="line">	size++;<span class="comment">//栈的大小+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkStack&lt;T&gt;::<span class="built_in">Pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">Empty</span>())&#123;</span><br><span class="line">		StackNode&lt;T&gt; *tmp = top-&gt;link;<span class="comment">//保存栈顶的下一个元素，因为它将成为栈顶</span></span><br><span class="line">		<span class="keyword">delete</span> top;</span><br><span class="line">		top = tmp;</span><br><span class="line"></span><br><span class="line">		size--;<span class="comment">//栈大小-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈顶数据</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; LinkStack&lt;T&gt;::<span class="built_in">Top</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">Empty</span>())</span><br><span class="line">		<span class="keyword">return</span> top-&gt;data;<span class="comment">//栈不空返回栈顶数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查栈是否为空</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈的大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkStack&lt;T&gt;::<span class="built_in">Size</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>main.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LinkedStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkStack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++)&#123;</span><br><span class="line">		st.<span class="built_in">Push</span>(i); <span class="comment">//入栈</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">Empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; st.<span class="built_in">Size</span>() &lt;&lt; <span class="string">&quot;\t&quot;</span>; <span class="comment">//打印当前栈的大小</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;top = &quot;</span> &lt;&lt; st.<span class="built_in">Top</span>() &lt;&lt; endl; <span class="comment">//打印当前栈顶数据</span></span><br><span class="line">		st.<span class="built_in">Pop</span>();<span class="comment">//出栈</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size = 11       top = 11</span><br><span class="line">size = 10       top = 10</span><br><span class="line">size = 9        top = 9</span><br><span class="line">size = 8        top = 8</span><br><span class="line">size = 7        top = 7</span><br><span class="line">size = 6        top = 6</span><br><span class="line">size = 5        top = 5</span><br><span class="line">size = 4        top = 4</span><br><span class="line">size = 3        top = 3</span><br><span class="line">size = 2        top = 2</span><br><span class="line">size = 1        top = 1</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="栈的应用—表达式求值"><a href="#栈的应用—表达式求值" class="headerlink" title="栈的应用—表达式求值"></a>栈的应用—表达式求值</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     <span class="comment">//输入的表达式要以&#x27;#&#x27;结尾，如‘5+6*3/(3-1)#’</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">stack&lt;<span class="type">char</span>&gt; opter;    <span class="comment">//运算符栈</span></span><br><span class="line">stack&lt;<span class="type">double</span>&gt; opval;  <span class="comment">//操作数栈</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getIndex</span><span class="params">(<span class="type">char</span> theta)</span>   <span class="comment">//获取theta所对应的索引</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span> (theta)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">		index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">		index = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">		index = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">		index = <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">		index = <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">		index = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">		index = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">getPriority</span><span class="params">(<span class="type">char</span> theta1, <span class="type">char</span> theta2)</span>   <span class="comment">//获取theta1与theta2之间的优先级</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> priority[][<span class="number">7</span>] =     <span class="comment">//算符间的优先级关系</span></span><br><span class="line">	&#123;</span><br><span class="line">		&#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">		&#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">		&#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">		&#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">		&#123; <span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;0&#x27;</span> &#125;,</span><br><span class="line">		&#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">		&#123; <span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;=&#x27;</span> &#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> index1 = <span class="built_in">getIndex</span>(theta1);</span><br><span class="line">	<span class="type">int</span> index2 = <span class="built_in">getIndex</span>(theta2);</span><br><span class="line">	<span class="keyword">return</span> priority[index1][index2];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculate</span><span class="params">(<span class="type">double</span> b, <span class="type">char</span> theta, <span class="type">double</span> a)</span>   <span class="comment">//计算b theta a</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (theta)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> b + a;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> b - a;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> b * a;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> b / a;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getAnswer</span><span class="params">()</span>   <span class="comment">//表达式求值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	opter.<span class="built_in">push</span>(<span class="string">&#x27;#&#x27;</span>);      <span class="comment">//首先将&#x27;#&#x27;入栈opter</span></span><br><span class="line">	<span class="type">int</span> counter = <span class="number">0</span>;      <span class="comment">//添加变量counter表示有多少个数字相继入栈，实现多位数的四则运算</span></span><br><span class="line">	<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c != <span class="string">&#x27;#&#x27;</span> || opter.<span class="built_in">top</span>() != <span class="string">&#x27;#&#x27;</span>)   <span class="comment">//终止条件</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))   <span class="comment">//如果c在&#x27;0&#x27;~&#x27;9&#x27;之间</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (counter == <span class="number">1</span>)   <span class="comment">//counter==1表示上一字符也是数字，所以要合并，比如12*12，要算12，而不是单独的1和2</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">double</span> t = opval.<span class="built_in">top</span>();</span><br><span class="line">				opval.<span class="built_in">pop</span>();</span><br><span class="line">				opval.<span class="built_in">push</span>(t * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">				counter = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				opval.<span class="built_in">push</span>(c - <span class="string">&#x27;0&#x27;</span>);     <span class="comment">//将c对应的数值入栈opval</span></span><br><span class="line">				counter++;</span><br><span class="line">			&#125;</span><br><span class="line">			c = <span class="built_in">getchar</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			counter = <span class="number">0</span>;   <span class="comment">//counter置零</span></span><br><span class="line">			<span class="keyword">switch</span> (<span class="built_in">getPriority</span>(opter.<span class="built_in">top</span>(), c))   <span class="comment">//获取运算符栈opter栈顶元素与c之间的优先级，用&#x27;&gt;&#x27;，&#x27;&lt;&#x27;，&#x27;=&#x27;表示</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:               <span class="comment">//&lt;则将c入栈opter</span></span><br><span class="line">				opter.<span class="built_in">push</span>(c);</span><br><span class="line">				c = <span class="built_in">getchar</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:               <span class="comment">//=将opter栈顶元素弹出，用于括号的处理</span></span><br><span class="line">				opter.<span class="built_in">pop</span>();</span><br><span class="line">				c = <span class="built_in">getchar</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:               <span class="comment">//&gt;则计算</span></span><br><span class="line">				<span class="type">char</span> theta = opter.<span class="built_in">top</span>();</span><br><span class="line">				opter.<span class="built_in">pop</span>();<span class="comment">//出栈操作只是删除栈顶元素，并不返回该元素的值</span></span><br><span class="line">				<span class="type">double</span> a = opval.<span class="built_in">top</span>();</span><br><span class="line">				opval.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="type">double</span> b = opval.<span class="built_in">top</span>();</span><br><span class="line">				opval.<span class="built_in">pop</span>();</span><br><span class="line">				opval.<span class="built_in">push</span>(<span class="built_in">calculate</span>(b, theta, a));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> opval.<span class="built_in">top</span>();   <span class="comment">//返回opval栈顶元素的值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="type">int</span> t;     <span class="comment">// 需要计算的表达式的个数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enther the comput times:&quot;</span>;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="built_in">getchar</span>();<span class="comment">//将空格读掉</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (!opter.<span class="built_in">empty</span>())opter.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">while</span> (!opval.<span class="built_in">empty</span>())opval.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The expression &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; is:&quot;</span>;</span><br><span class="line">		<span class="type">double</span> ans = <span class="built_in">getAnswer</span>();</span><br><span class="line">        <span class="built_in">getchar</span>();<span class="comment">//将空格读掉</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;The answer of expression &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; is:&quot;</span>&lt;&lt;ans&lt;&lt; endl;</span><br><span class="line">        i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20221209170543118.png" alt="image-20221209170543118"></p>
<hr>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul>
<li><p>先进先出</p>
</li>
<li><p>限制访问点的线性表：</p>
<ul>
<li>按照到达的顺序来释放元素</li>
<li>所有的插入在表的一端进行，所有的删除都在表的另一端进行</li>
</ul>
</li>
<li><p>顺序队列示意图：</p>
<p><img src="/2022/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20221209175359377.png" alt="image-20221209175359377" style="zoom: 50%;"></p>
</li>
<li><p>循环队列示意图：</p>
<p><img src="/2022/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20221209175447316.png" alt="image-20221209175447316" style="zoom: 50%;"></p>
<ul>
<li>入队：$r=(r+1)\%N$</li>
<li>出队：$f=(f+1)\%N$</li>
<li>队满：$(r+1)\%N=f$</li>
<li>队空：$r=f$</li>
</ul>
</li>
</ul>
<hr>
<h1 id="列表的实现方式"><a href="#列表的实现方式" class="headerlink" title="列表的实现方式"></a>列表的实现方式</h1><h2 id="1-循环队列"><a href="#1-循环队列" class="headerlink" title="1.循环队列"></a>1.循环队列</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">循环队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10 <span class="comment">// 队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SqQueue</span> &#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 队列中元素的最多个数</span></span><br><span class="line">    <span class="type">int</span> front, rear;        <span class="comment">// 队头指针，队尾指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123; Q.front = Q.rear = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">// 队列判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front) &#123; <span class="comment">// 队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q.data[Q.rear] = x; <span class="comment">// 赋值给下一队尾</span></span><br><span class="line">        Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize; <span class="comment">// 在逻辑上将存储空间变为“环状”，物理上仍然是静态数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front) &#123; <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = Q.data[Q.front];</span><br><span class="line">        Q.front = (Q.front + <span class="number">1</span>) % MaxSize; <span class="comment">// 队头指针后移</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取队头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front) &#123; <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = Q.data[Q.front];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取队列长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetLength</span><span class="params">(SqQueue &amp;Q, ElemType &amp;len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len = Q.front; <span class="comment">// 指向队头</span></span><br><span class="line">        <span class="keyword">while</span> ((len + <span class="number">1</span>) % MaxSize != Q.rear) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        len = len - Q.front + <span class="number">1</span>; <span class="comment">// 如果有元素出队，会导致Q.front不为0，影响长度的判断，且初始化队列时，Q.front置为0，同样影响长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    ElemType head, pop, length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">EnQueue</span>(Q, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GetHead</span>(Q, head);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队头元素：&quot;</span> &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">GetLength</span>(Q, length);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列长度：&quot;</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">DeQueue</span>(Q, pop);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;出队元素：&quot;</span> &lt;&lt; pop &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">GetHead</span>(Q, head);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队头元素：&quot;</span> &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">GetLength</span>(Q, length);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列长度：&quot;</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20221209181437866.png" alt="image-20221209181437866"></p>
<h2 id="2-链式队列"><a href="#2-链式队列" class="headerlink" title="2.链式队列"></a>2.链式队列</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    node * next;</span><br><span class="line">    node * prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    node * head;<span class="comment">//首节点</span></span><br><span class="line">    node * tail;<span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(<span class="type">int</span> data)</span></span>;</span><br><span class="line">    <span class="function">node * <span class="title">outQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;<span class="comment">//循序打印</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue::<span class="built_in">queue</span>()&#123;<span class="comment">//初始化</span></span><br><span class="line">    head=<span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">    tail=<span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">    head-&gt;next=tail;</span><br><span class="line">    head-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;prev=head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">queue::enQueue</span><span class="params">(<span class="type">int</span> data)</span></span>&#123;<span class="comment">//入队</span></span><br><span class="line">    node * n=<span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">    n-&gt;data=data;</span><br><span class="line">    n-&gt;next=head-&gt;next;</span><br><span class="line">    n-&gt;prev=head;</span><br><span class="line">    head-&gt;next-&gt;prev=n;</span><br><span class="line">    head-&gt;next=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">queue::print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node * n=head;</span><br><span class="line">    <span class="keyword">while</span>(n-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;n-&gt;next-&gt;data&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">        n=n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node * <span class="title">queue::outQueue</span><span class="params">()</span></span>&#123;<span class="comment">//出队</span></span><br><span class="line">    node * n=tail-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span>(n-&gt;prev==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        n-&gt;next-&gt;prev=n-&gt;prev;</span><br><span class="line">        n-&gt;prev-&gt;next=n-&gt;next;</span><br><span class="line">        n-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        n-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queue::isEmpty</span><span class="params">()</span></span>&#123;<span class="comment">//判断队列是否为空</span></span><br><span class="line">    node * n=tail-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span>(n-&gt;prev==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//测试</span></span><br><span class="line">    queue * q=<span class="keyword">new</span> <span class="built_in">queue</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;入队:1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    q-&gt;<span class="built_in">enQueue</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;入队:2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    q-&gt;<span class="built_in">enQueue</span>(<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;入队:3&quot;</span>&lt;&lt;endl;</span><br><span class="line">    q-&gt;<span class="built_in">enQueue</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;入队:4&quot;</span>&lt;&lt;endl;</span><br><span class="line">    q-&gt;<span class="built_in">enQueue</span>(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;打印:&quot;</span>;</span><br><span class="line">    q-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;<span class="built_in">isEmpty</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;出队:&quot;</span>&lt;&lt;q-&gt;<span class="built_in">outQueue</span>()-&gt;data&lt;&lt;endl;    </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;打印&quot;</span>;</span><br><span class="line">    q-&gt;<span class="built_in">print</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;入队:5&quot;</span>&lt;&lt;endl;</span><br><span class="line">    q-&gt;<span class="built_in">enQueue</span>(<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;打印:&quot;</span>;</span><br><span class="line">    q-&gt;<span class="built_in">print</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20221209182332363.png" alt="image-20221209182332363"></p>
<hr>
<h1 id="列表的应用—农夫过河"><a href="#列表的应用—农夫过河" class="headerlink" title="列表的应用—农夫过河"></a>列表的应用—农夫过河</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//农夫过河问题</span></span><br><span class="line"><span class="comment">//问题描述：</span></span><br><span class="line"><span class="comment">//有一个农夫带一只羊、一筐菜和一只狼过河</span></span><br><span class="line"><span class="comment">//如果没有农夫看管，则狼要吃羊，羊要吃菜</span></span><br><span class="line"><span class="comment">//但是船很小，只够农夫带一样东西过河</span></span><br><span class="line"><span class="comment">//问农夫该如何解此难题？</span></span><br><span class="line"><span class="comment">//解题思路：</span></span><br><span class="line"><span class="comment">//农夫过河问题，用0000的二进制分别代表河的一岸的农夫、羊、菜、狼，假如农夫带狼过河则0000变为1001。</span></span><br><span class="line"><span class="comment">//总共有16种状态，每次过河的操作(8种操作)都会变成另外一个状态，直到得到1111，可以得到一个状态树，保存满足条件的路径。</span></span><br><span class="line"><span class="comment">//不满足题目要求的状态有1001(9),0110(6),1000(8),1010(10),0101(5),0111(7),即5~10都不合法。</span></span><br><span class="line"><span class="comment">//建立一个当前搜索队列，保存遍历的状态，出现重复的状态则不进行这次变化（避免死循环），若队尾出现0，退出搜索。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> visit[<span class="number">20</span>];<span class="comment">//用来保存当前状态的前一状态，注意不能直接int visit[20]=&#123;-1&#125;初始化，初始化成0可以，但其他数字要用循环老老实实一个一个赋值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">8</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">9</span>&#125;;<span class="comment">//用来表示4种状态转换操作：8(1000)——nothing；12(1100)——sheep；10(1010)——vegetable；9(1001)——wolf。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//用来判断是否为合法状态</span></span><br><span class="line">     <span class="keyword">if</span>(x&gt;=<span class="number">5</span>&amp;&amp;x&lt;=<span class="number">10</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">15</span> || x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(visit[x]!=<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123; <span class="comment">//树的广度搜索，寻找最短路径</span></span><br><span class="line">     <span class="type">int</span> current=q.<span class="built_in">front</span>();</span><br><span class="line">     q.<span class="built_in">pop</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++ )&#123;  <span class="comment">//每次有四种选择，空船，带羊，带菜，带狼</span></span><br><span class="line">         <span class="type">int</span> next=a[i]^current; <span class="comment">//异或运算，相同为0，不同为1，即求出当前的运动状态</span></span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">judge</span>(next))&#123;    </span><br><span class="line">	         q.<span class="built_in">push</span>(next);</span><br><span class="line">	         visit[next]=current; <span class="comment">//visit[当前状态]=当前状态的前一个状态</span></span><br><span class="line">	         <span class="keyword">if</span>(next == <span class="number">15</span>) <span class="keyword">return</span>; <span class="comment">//15(1111)</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">BFS</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_result</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(b-a)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-8</span>:cout&lt;&lt;<span class="string">&quot;nothing_come&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-12</span>:cout&lt;&lt;<span class="string">&quot;sheep_come&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-10</span>:cout&lt;&lt;<span class="string">&quot;vegetable_come&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-9</span>:cout&lt;&lt;<span class="string">&quot;wolf_come&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:cout&lt;&lt;<span class="string">&quot;nothing_go&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:cout&lt;&lt;<span class="string">&quot;sheep_go&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:cout&lt;&lt;<span class="string">&quot;vegetable_go&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:cout&lt;&lt;<span class="string">&quot;wolf_go&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++) visit[i]=<span class="number">-1</span>; <span class="comment">//初始化16种状态</span></span><br><span class="line">    q.<span class="built_in">push</span>(start); <span class="comment">//从0000开始</span></span><br><span class="line">    visit[start]=<span class="number">-2</span>; <span class="comment">//标记源节点</span></span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="type">int</span> x=<span class="number">15</span>; <span class="comment">//15(1111)</span></span><br><span class="line">    <span class="type">int</span> re[<span class="number">20</span>];<span class="comment">//根据visit数组来获得路径顺序，即状态序列</span></span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">-2</span>)&#123;</span><br><span class="line">        re[index++]=x;</span><br><span class="line">        x=visit[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=index<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">//根据a数组即状态序列的变换打印状态转换过程</span></span><br><span class="line">           <span class="built_in">print_result</span>(re[i],re[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;succeed&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sheep_go</span><br><span class="line">nothing_come</span><br><span class="line">vegetable_go</span><br><span class="line">sheep_come</span><br><span class="line">wolf_go</span><br><span class="line">nothing_come</span><br><span class="line">sheep_go</span><br><span class="line">succeed</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础之循环神经网络及其变体</title>
    <url>/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/</url>
    <content><![CDATA[<p>本节主要介绍了RNN、LSTM与BRNN</p>
<span id="more"></span>
<h1 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h1><ul>
<li><p>用于处理序列模型</p>
<p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208160500015.png" alt="image-20221208160500015" style="zoom:50%;"></p>
</li>
<li><p>数学表示符号：</p>
<p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208161313985.png" alt="image-20221208161313985" style="zoom: 50%;"></p>
<ul>
<li><p>$x^{(i)<t>}$：表示第i个样本的第t个元素</t></p>
</li>
<li><p>$T_x^{(i)}$：表示第i个样本输入序列x的长度</p>
</li>
<li>$y^{(i)<t>}$：表示第i个样本输出的第t个元素</t></li>
<li>$T_y^{(i)}$：表示第i个样本输出序列y的长度</li>
</ul>
</li>
<li><p>单词的表示：</p>
<p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208161250784.png" alt="image-20221208161250784"></p>
</li>
<li><p><strong>循环神经网络的结构与计算</strong></p>
<p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208162619154.png" alt="image-20221208162619154"></p>
<p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208162932876.png" alt="image-20221208162932876"></p>
<ul>
<li><p>一般假设$a^{<0>}$为0的行向量，即：</0></p>
<script type="math/tex; mode=display">
a^{<0>}=\mathop{0}^\rightarrow</script></li>
<li><p>$a^{<1>}、\widehat{y}^{<1>}$的计算，即：</1></1></p>
<script type="math/tex; mode=display">
a^{<1>}=g_1(W_{aa}a^{<0>}+W_{ax}X^{<1>}+b_a)\\
\widehat{y}^{<1>}=g_2(W_{ya}a^{<1>}+b_y)</script></li>
<li><p>则推导可得$a^{<t>}、\widehat{y}^{<t>}$的计公式：</t></t></p>
<script type="math/tex; mode=display">
a^{<t>}=g_1(W_{aa}a^{<t-1>}+W_{ax}X^{<t>}+b_a)\\
\widehat{y}^{<t>}=g_2(W_{ya}a^{<t>}+b_y)\\
其中,激活函数g1通常使用tanh/Relu,激活函数g2通常使用sigmoid/softmax</script></li>
<li><p>RNN的简化表示：</p>
<script type="math/tex; mode=display">
a^{<t>}=g(W_a\begin{bmatrix}
a^{<t-1>}\\
x^{<t>}
\end{bmatrix}+b_a)\\
其中,W_a=\begin{bmatrix}
W_{aa} & W_{ax}
\end{bmatrix}</script><script type="math/tex; mode=display">
\widehat{y}^{<t>}=g(W_ya^{<t>}+b_y)</script></li>
</ul>
</li>
<li><p><strong>不同类型的循环神经网络</strong>：</p>
<p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208174432112.png" alt="image-20221208174432112"></p>
</li>
<li><p><strong>RNN单元</strong>：</p>
<p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208200447733.png" alt="image-20221208200447733" style="zoom: 50%;"></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1JP4y117mX?p=1&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">46. 49 循环神经网络RNN_哔哩哔哩_bilibili</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1JP4y117mX?p=2&amp;vd_source=221b76534ba13cfad544149d75ce9b6c">47. 50 不同类型的RNN模型_哔哩哔哩_bilibili</a></p>
</li>
</ul>
<hr>
<h1 id="长短期记忆LSTM"><a href="#长短期记忆LSTM" class="headerlink" title="长短期记忆LSTM"></a>长短期记忆LSTM</h1><ul>
<li><strong>在网络结构很深（很多层）的情况下，也能保留重要信息</strong></li>
<li><strong>解决了普通RNN求解过程中的梯度消失问题</strong></li>
</ul>
<script type="math/tex; mode=display">
{\mathop c^{\sim}}^{<t>}=tanh(W_c[a^{<t-1>},x^{<t>}]+b_c)\\
其中:[a^{<t-1>},x^{<t>}]代表\begin{bmatrix}
a^{<t-1>}\\
x^{<t>}
\end{bmatrix}</script><script type="math/tex; mode=display">
c^{<t>}=\Gamma_u\cdot{\mathop c^{\sim}}^{<t>}+\Gamma_f\cdot{\mathop c^{\sim}}^{<t-1>}\\
其中\,\cdot代表对应元素相乘</script><script type="math/tex; mode=display">
a^{<t>}=\Gamma_o\cdot tanh\,c^{<t>}</script><script type="math/tex; mode=display">
更新门:\Gamma_u=\sigma(W_u[a^{<t-1>},x^{<t>}]+b_u)\\
遗忘门:\Gamma_f=\sigma(W_f[a^{<t-1>},x^{<t>}]+b_f)\\
输出门:\Gamma_o=\sigma(W_o[a^{<t-1>},x^{<t>}]+b_o)</script><p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208203507229.png" alt="image-20221208203507229" style="zoom: 67%;"></p>
<p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208203655582.png" alt="image-20221208203655582"></p>
<hr>
<h1 id="双向循环神经网络BRNN"><a href="#双向循环神经网络BRNN" class="headerlink" title="双向循环神经网络BRNN"></a>双向循环神经网络BRNN</h1><ul>
<li><strong>做判断时，把后部序列信息也考虑</strong></li>
</ul>
<p><img src="/2022/12/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/image-20221208204756805.png" alt="image-20221208204756805"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之线性表</title>
    <url>/2022/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>本节主要介绍了顺序表与链表的C++实现。</p>
<span id="more"></span>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><ul>
<li>把线性表中的所有表项按照其逻辑顺序依次存储到从计算机存储中指定存储位置开始的一块连续的存储空间中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20<span class="comment">//最大存储容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqList</span>();<span class="comment">//</span></span><br><span class="line">    <span class="built_in">SqList</span>(ElemType elems[],<span class="type">int</span> n);<span class="comment">//有参构造器</span></span><br><span class="line">    ~<span class="built_in">SqList</span>();<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CreatList</span><span class="params">()</span></span>;<span class="comment">//新建一个顺序表</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">UnionList</span><span class="params">(SqList L1,SqList L2)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(ElemType e)</span></span>;<span class="comment">//按元素查找：成功则返回元素的序号（从1开始）,失败则返回0</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">//顺序表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, ElemType&amp; e)</span></span>;<span class="comment">//查找第i个位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i,ElemType e)</span></span>;<span class="comment">//在第i个位置插入元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i,ElemType&amp; e)</span></span>;<span class="comment">//删除第i个位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListEmpty</span><span class="params">()</span></span>;<span class="comment">//判空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearList</span><span class="params">()</span></span>;<span class="comment">//清空顺序表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;<span class="comment">//显示当前的顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ElemType data[MAXSIZE];<span class="comment">//下标从0开始，但是对线性表的操作中的下标从1开始：第1个元素其实就是下标为0的元素</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SqList::<span class="built_in">SqList</span>()<span class="comment">//初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    length=<span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqList::<span class="built_in">SqList</span>(ElemType elems[],<span class="type">int</span> n)<span class="comment">//有参构造器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;传入的顺序表长度超出最大范围，只接收了前&quot;</span>&lt;&lt;MAXSIZE&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">        length=MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        length=n;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        data[i]=elems[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqList::~<span class="built_in">SqList</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SqList::CreatList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;插入多少个元素(0-20)?&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;length;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">0</span>||length&gt;MAXSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        length=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;&quot;请输入顺序线性表的第&quot;&lt;&lt;i&lt;&lt;&quot;个元素：&quot;;</span></span><br><span class="line"><span class="comment">//        cin&gt;&gt;L-&gt;data[i-1];</span></span><br><span class="line">        data[i<span class="number">-1</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SqList::UnionList</span><span class="params">(SqList L1,SqList L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L1.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=L1.data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;L2.length;j++)</span><br><span class="line">        <span class="keyword">if</span>(L1.<span class="built_in">LocateElem</span>(L2.data[j])==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=MAXSIZE)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            data[i]=L2.data[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    length=i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">SqList::LocateElem</span><span class="params">(ElemType e)</span><span class="comment">//成功则返回元素的序号（从1开始）,失败则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        <span class="keyword">if</span>(data[i]==e)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">SqList::ListLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SqList::GetElem</span><span class="params">(<span class="type">int</span> i, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span> || i&lt;<span class="number">1</span>|| i&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SqList::ListInsert</span><span class="params">(<span class="type">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length==MAXSIZE || i&lt;<span class="number">1</span>|| i&gt;length+<span class="number">1</span>)<span class="comment">//线性表满，或者i的范围不在合理范围内时返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=length)<span class="comment">//不在表尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//插入位置的后续元素后移一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)</span><br><span class="line">            data[k+<span class="number">1</span>]=data[k];<span class="comment">// 倒序挪动位置，避免覆盖问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    data[i<span class="number">-1</span>]=e;<span class="comment">//插入元素</span></span><br><span class="line">    length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SqList::ListDelete</span><span class="params">(<span class="type">int</span> i,ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span> || i&lt;<span class="number">1</span>|| i&gt;length)<span class="comment">//线性表满，或者i的范围不在合理范围内时返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=data[i<span class="number">-1</span>];<span class="comment">//取出元素</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;=length)<span class="comment">//不在表尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//插入位置的后续元素前移一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i<span class="number">-1</span>;k&lt;length<span class="number">-1</span>;k++)</span><br><span class="line">            data[k]=data[k+<span class="number">1</span>];<span class="comment">// 倒序挪动位置，避免覆盖问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SqList::ListEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqList::clearList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqList::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        cout&lt;&lt;data[i]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList list;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    ElemType elem;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;1.顺序表的创建与显示&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(!list.<span class="built_in">CreatList</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;顺序表创建失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;顺序表创建成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//顺序表的显示</span></span><br><span class="line">    list.<span class="built_in">display</span>();</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;2.按元素查找&quot;</span>&lt;&lt;endl;</span><br><span class="line">    num=list.<span class="built_in">LocateElem</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;3是顺序表的第&quot;</span>&lt;&lt;num&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;3.按位置查找&quot;</span>&lt;&lt;endl;</span><br><span class="line">    list.<span class="built_in">GetElem</span>(<span class="number">4</span>,elem);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;顺序表的第四个元素是:&quot;</span>&lt;&lt;elem&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;4.顺序表的插入&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(list.<span class="built_in">ListInsert</span>(<span class="number">2</span>,<span class="number">10</span>))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;插入成功!在第2个位置插入10后:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;插入失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    list.<span class="built_in">display</span>();</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;5.删除元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">    list.<span class="built_in">ListDelete</span>(<span class="number">5</span>,elem);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;删除第5个元素:&quot;</span>&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该表的长度为:&quot;</span>&lt;&lt;list.<span class="built_in">ListLength</span>()&lt;&lt;endl;</span><br><span class="line">    list.<span class="built_in">display</span>();</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;6.清空顺序表&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;清空顺序表前-----------&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!list.<span class="built_in">ListEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前顺序表不是空表！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        list.<span class="built_in">clearList</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;清空顺序表后-----------&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(list.<span class="built_in">ListEmpty</span>())</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;当前顺序表是空表！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;7.合并顺序表&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ElemType elems1[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    ElemType elems2[<span class="number">9</span>]=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">    SqList list1=&#123;elems1,<span class="number">8</span>&#125;;</span><br><span class="line">    SqList list2=&#123;elems2,<span class="number">9</span>&#125;;</span><br><span class="line">    SqList list3;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;合并前的两个表为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    list1.<span class="built_in">display</span>();</span><br><span class="line">    list2.<span class="built_in">display</span>();</span><br><span class="line">    flag=list3.<span class="built_in">UnionList</span>(list1,list2);</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;合并后，顺序表的长度超过最大范围&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该表的长度为:&quot;</span>&lt;&lt;list3.<span class="built_in">ListLength</span>()&lt;&lt;endl;</span><br><span class="line">    list3.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.顺序表的创建与显示</span><br><span class="line">插入多少个元素(0-20)?</span><br><span class="line">9</span><br><span class="line">顺序表创建成功！</span><br><span class="line">1  2  3  4  5  6  7  8  9  </span><br><span class="line"></span><br><span class="line">2.按元素查找</span><br><span class="line">3是顺序表的第3个元素</span><br><span class="line"></span><br><span class="line">3.按位置查找</span><br><span class="line">顺序表的第四个元素是:4</span><br><span class="line"></span><br><span class="line">4.顺序表的插入</span><br><span class="line">插入成功!在第2个位置插入10后:</span><br><span class="line">1  10  2  3  4  5  6  7  8  9  </span><br><span class="line"></span><br><span class="line">5.删除元素</span><br><span class="line">删除第5个元素:4</span><br><span class="line">该表的长度为:9</span><br><span class="line">1  10  2  3  5  6  7  8  9  </span><br><span class="line"></span><br><span class="line">6.清空顺序表</span><br><span class="line">清空顺序表前-----------当前顺序表不是空表！</span><br><span class="line">清空顺序表后-----------当前顺序表是空表！</span><br><span class="line"></span><br><span class="line">7.合并顺序表</span><br><span class="line">合并前的两个表为:</span><br><span class="line">0  1  2  3  4  5  6  7  </span><br><span class="line">5  6  7  8  9  10  11  1  12  </span><br><span class="line">该表的长度为:13</span><br><span class="line">0  1  2  3  4  5  6  7  8  9  10  11  12  </span><br></pre></td></tr></table></figure>
<hr>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> da = <span class="number">0</span>, Node *p = <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = da;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *head, *tail;</span><br><span class="line">    <span class="type">int</span> position;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>() &#123; head = tail = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">List</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;<span class="comment">//链表的打印</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> da = <span class="number">0</span>)</span></span>;<span class="comment">//链表的插入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> da = <span class="number">0</span>)</span></span>;<span class="comment">//链表的删除</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Search</span><span class="params">(<span class="type">int</span> da = <span class="number">0</span>)</span></span>;<span class="comment">//链表的查找</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValueAt</span><span class="params">(<span class="type">int</span> position)</span></span>;<span class="comment">//查找特定位置对应的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValueAt</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> da)</span></span>;<span class="comment">//更新特定位置的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">List::getValueAt</span><span class="params">(<span class="type">int</span> position)</span> </span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The List is Empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> posi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; posi != position) &#123;</span><br><span class="line">            posi++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;There is no value of this position in this List!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;In this Position,the value is:&quot;</span> &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List::setValueAt</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> da)</span> </span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The List is Empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> posi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; posi != position) &#123;</span><br><span class="line">            posi++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;There is No Position in this List!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;data = da;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;The Value in this position has been Updated!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List::Search</span><span class="params">(<span class="type">int</span> da)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sorry, The List is Empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != da) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the value you want to search is at position &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List::Delete</span><span class="params">(<span class="type">int</span> da)</span> </span>&#123;</span><br><span class="line">    Node *p = head, *q = head;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sorry, The List is Empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != da) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;next = p-&gt;next;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The Deletion Operation had been finished!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List::Insert</span><span class="params">(<span class="type">int</span> da)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        head = tail = <span class="keyword">new</span> <span class="built_in">Node</span>(da);</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *p = <span class="keyword">new</span> <span class="built_in">Node</span>(da);</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">        tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; \a&quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Linked list test!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    List l1;</span><br><span class="line">    l1.<span class="built_in">Insert</span>(<span class="number">1</span>);</span><br><span class="line">    l1.<span class="built_in">Insert</span>(<span class="number">2</span>);</span><br><span class="line">    l1.<span class="built_in">Insert</span>(<span class="number">3</span>);</span><br><span class="line">    l1.<span class="built_in">Insert</span>(<span class="number">4</span>);</span><br><span class="line">    l1.<span class="built_in">Insert</span>(<span class="number">5</span>);</span><br><span class="line">    l1.<span class="built_in">Insert</span>(<span class="number">6</span>);</span><br><span class="line">    l1.<span class="built_in">Insert</span>(<span class="number">7</span>);</span><br><span class="line">    l1.<span class="built_in">print</span>();</span><br><span class="line">    l1.<span class="built_in">Search</span>(<span class="number">4</span>);</span><br><span class="line">    l1.<span class="built_in">Delete</span>(<span class="number">6</span>);</span><br><span class="line">    l1.<span class="built_in">print</span>();</span><br><span class="line">    l1.<span class="built_in">getValueAt</span>(<span class="number">3</span>);</span><br><span class="line">    l1.<span class="built_in">setValueAt</span>(<span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">    l1.<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The End!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20221207202053089.png" alt="image-20221207202053089"></p>
<hr>
<h1 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h1><ul>
<li><p>存储方面：</p>
<ul>
<li><p>顺序表为静态结构，而链表为动态结构</p>
</li>
<li><p>数组从栈中申请空间，而链表从堆空间申请</p>
</li>
<li><p>单链表的存储密度比顺序表低：</p>
<script type="math/tex; mode=display">
存储密度=\frac{数据本身所占存储}{整个数据结构所占存储}</script></li>
<li><p>字符串往往用字符数组来实现</p>
</li>
</ul>
</li>
<li><p>运算方面：</p>
<ul>
<li>定位操作：<ul>
<li>顺序表，通过定位公式可以随机访问任一元素</li>
<li>单链表中，需要顺链逐个查找</li>
</ul>
</li>
<li>修改操作：<ul>
<li>顺序表数据元素移动，而链表修改指针</li>
<li>在单链表里进行插入、删除运算比在顺序表容易</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础之信息熵与感知机</title>
    <url>/2022/12/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BF%A1%E6%81%AF%E7%86%B5%E4%B8%8E%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    <content><![CDATA[<p>本节主要介绍了信息熵的计算与感知机算法</p>
<span id="more"></span>
<h1 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h1><ul>
<li><p>信息熵的计算：</p>
<script type="math/tex; mode=display">
H(U)=\sum_{i=1}^np_ilog(\frac1{p_i})</script></li>
<li><p>交叉熵：用于表征两个变量概率分布P、Q（假设P表示真实分布、Q为模型预测的分布）的差异性</p>
<ul>
<li><p>交叉熵越大，两个变量差异程度越大</p>
</li>
<li><p>交叉熵公式：</p>
<script type="math/tex; mode=display">
H(P,Q)=\sum_{x\in X}P(x)log\frac{1}{Q(x)}</script></li>
</ul>
</li>
<li><p>相对熵：是交叉熵与信息熵的差值</p>
<ul>
<li><p>表示用分布Q模拟真实分布P，所需的额外信息</p>
</li>
<li><p>计算公式：</p>
<script type="math/tex; mode=display">
D_{KL}(P||Q)=\sum_{x\in X}P(x)log\frac1{Q(x)}-\sum_{x\in X}P(x)log\frac1{P(x)}=\sum_{x\in X}P(x)log\frac{P(x)}{Q(x)}</script></li>
<li><p>性质：</p>
<ul>
<li><p>相对熵(KL散度)不具有对称性，即：</p>
<script type="math/tex; mode=display">
D_{KL}(P||Q)\neq D_{KL}(Q||P)</script></li>
<li><p>相对熵具有非负性</p>
<script type="math/tex; mode=display">
D_{KL}(P||Q)\ge0</script></li>
</ul>
</li>
</ul>
</li>
<li><p>JS散度：具有对称性，现有两个分布$p1,p2$，其JS散度公式为：</p>
<script type="math/tex; mode=display">
JS(P1||P2)=\frac12KL(P1||\frac{P_1+P_2}{2})+\frac12KL(P_2|\frac{P_1+P_2}2)</script></li>
</ul>
<hr>
<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><ul>
<li><p>感知机是两类分类的线性分类模型，假设输入样本的特征向量x，输出实例样本的类别y，有：</p>
<script type="math/tex; mode=display">
y=g(w\cdot x+b)\\
g为激励函数</script><p><img src="/2022/12/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BF%A1%E6%81%AF%E7%86%B5%E4%B8%8E%E6%84%9F%E7%9F%A5%E6%9C%BA/image-20221207141334347.png" alt="image-20221207141334347" style="zoom: 50%;"></p>
</li>
<li><p>感知机的算法</p>
<p><img src="/2022/12/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BF%A1%E6%81%AF%E7%86%B5%E4%B8%8E%E6%84%9F%E7%9F%A5%E6%9C%BA/image-20221207143108429.png" alt="image-20221207143108429" style="zoom:50%;"></p>
</li>
<li><p>例：</p>
<p><img src="/2022/12/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BF%A1%E6%81%AF%E7%86%B5%E4%B8%8E%E6%84%9F%E7%9F%A5%E6%9C%BA/image-20221207143404643.png" alt="image-20221207143404643" style="zoom:50%;"></p>
<p><img src="/2022/12/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BF%A1%E6%81%AF%E7%86%B5%E4%B8%8E%E6%84%9F%E7%9F%A5%E6%9C%BA/image-20221207143217695.png" alt="image-20221207143217695" style="zoom:50%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之面向对象与流</title>
    <url>/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%B5%81/</url>
    <content><![CDATA[<p>本节主要介绍了C++中面向对象与流的最基本操作。</p>
<span id="more"></span>
<h1 id="类的定义与使用"><a href="#类的定义与使用" class="headerlink" title="类的定义与使用"></a>类的定义与使用</h1><ul>
<li>看上去像“带函数的结构体”</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的定义</span></span><br><span class="line"><span class="comment">// class Rectangle&#123;</span></span><br><span class="line"><span class="comment">//     public:</span></span><br><span class="line"><span class="comment">//         int w,h;//成员变量</span></span><br><span class="line"><span class="comment">//         int Area()//成员函数：求面积</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             return w*h;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         int Perimeter()//成员函数：求周长</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             return 2*(w+h);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         void Init(int w_,int h_)//成员函数：设置长宽</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             w=w_;h=h_;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">// &#125;;//必须有分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明与定义分离的定义方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> w,h;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Perimeter</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> w_,<span class="type">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rectangle::Area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rectangle::Perimeter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*(w+h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rectangle::Init</span><span class="params">(<span class="type">int</span> w_,<span class="type">int</span> h_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w=w_;</span><br><span class="line">    h=h_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> w,h;</span><br><span class="line">    <span class="comment">//类的使用</span></span><br><span class="line">    <span class="comment">//1.对象名.成员名</span></span><br><span class="line">    Rectangle r;<span class="comment">//r是一个对象</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter the w and h:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;w&gt;&gt;h;</span><br><span class="line">    r.<span class="built_in">Init</span>(w,h);</span><br><span class="line">    cout&lt;&lt;r.<span class="built_in">Area</span>()&lt;&lt;endl&lt;&lt;r.<span class="built_in">Perimeter</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//2.指针-&gt;成员名</span></span><br><span class="line">    Rectangle r1,r2;</span><br><span class="line">    Rectangle *p1=&amp;r1;</span><br><span class="line">    Rectangle *p2=&amp;r2;</span><br><span class="line">    p1-&gt;w=<span class="number">5</span>;</span><br><span class="line">    p1-&gt;h=<span class="number">6</span>;</span><br><span class="line">    p2-&gt;<span class="built_in">Init</span>(<span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p1-&gt;Area() is:&quot;</span>&lt;&lt;p1-&gt;<span class="built_in">Area</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="string">&quot;p1-&gt;Perimeter() is:&quot;</span>&lt;&lt;p1-&gt;<span class="built_in">Perimeter</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p2-&gt;Area() is:&quot;</span>&lt;&lt;p2-&gt;<span class="built_in">Area</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="string">&quot;p2-&gt;Perimeter() is:&quot;</span>&lt;&lt;p2-&gt;<span class="built_in">Perimeter</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//3.引用名.成员名</span></span><br><span class="line">    Rectangle &amp;rr=r2;<span class="comment">//rr相当于r2的别名</span></span><br><span class="line">    rr.w=<span class="number">5</span>;rr.h=<span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt;rr.<span class="built_in">Area</span>()&lt;&lt;endl&lt;&lt;r2.<span class="built_in">Perimeter</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%B5%81/image-20221206141613337.png" alt="image-20221206141613337"></p>
<ul>
<li>访问权限：<ul>
<li>private：私有成员，只能在成员函数中访问（默认）</li>
<li>public：共有成员，可以在任何地方访问</li>
<li>protected：保护成员</li>
</ul>
</li>
</ul>
<hr>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><h2 id="1-标准输入流"><a href="#1-标准输入流" class="headerlink" title="1.标准输入流"></a>1.标准输入流</h2><ul>
<li><p><code>cin&gt;&gt;x;</code></p>
<ul>
<li>读入整数时以第一个非数字为终结</li>
<li>读入字符串时以第一个空格、tab或换行符为终结</li>
</ul>
</li>
<li><p><code>cin.getline(str,len,ch);</code></p>
<ul>
<li>读入一个字符串</li>
<li>ch被从流中提出，不存入str</li>
</ul>
</li>
<li><p><code>ch=cin.get();</code></p>
<ul>
<li>读入一个单独的字符</li>
</ul>
</li>
<li><p><code>cin.ignore(int n =1, int delim = EOF)</code></p>
<ul>
<li>此函数的作用是跳过输入流中的 n 个字符，或跳过 delim 及其之前的所有字符，哪个条件先满足就按哪个执行</li>
<li>两个参数都有默认值，因此 cin.ignore() 就等效于 cin.ignore(1, EOF)， 即跳过一个字符</li>
</ul>
</li>
<li><p><code>cin.width(num)</code></p>
<ul>
<li>设置域宽</li>
<li>宽度为num</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string string;</span><br><span class="line">    cin.<span class="built_in">width</span>(<span class="number">5</span>);</span><br><span class="line">    cin&gt;&gt;string;</span><br><span class="line">    cout&lt;&lt;string&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;string;</span><br><span class="line">    cout&lt;&lt;string&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%B5%81/image-20221206150213207.png" alt="image-20221206150213207"></p>
</li>
</ul>
<h2 id="2-标准输出流"><a href="#2-标准输出流" class="headerlink" title="2.标准输出流"></a>2.标准输出流</h2><ul>
<li><p><code>cout&lt;&lt;y;</code></p>
</li>
<li><p><code>cout.put(&#39;A&#39;).put(&#39;a&#39;)</code>//使用put输出一个字符</p>
</li>
<li><p>控制输出浮点数的精度</p>
<ul>
<li>头文件：<code>#include&lt;iomanip&gt;</code></li>
<li>精度设置：<code>setprecision(num)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x=<span class="number">1234567.89</span>,y=<span class="number">12.34567</span>;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">1234567</span>;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">12</span>;</span><br><span class="line">    <span class="comment">//setiosflags(ios::fixed)表示设置成小数的形式</span></span><br><span class="line">    <span class="comment">//此时setprecision(6)表示保留小数点后6位</span></span><br><span class="line">    <span class="comment">//若只有setprecision(6)作用，则表示整数和小数一共占6位</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;x:&quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;y:&quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;n:&quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="comment">//精度的设置对整数不起作用</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m:&quot;</span>&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%B5%81/image-20221206150120684.png" alt="image-20221206150120684"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础之范数及正则化</title>
    <url>/2022/12/06/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%8C%83%E6%95%B0%E5%8F%8A%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    <content><![CDATA[<p>本节主要介绍了R方的计算步骤、范数以及正则化。</p>
<span id="more"></span>
<h1 id="R方的计算步骤"><a href="#R方的计算步骤" class="headerlink" title="R方的计算步骤"></a>R方的计算步骤</h1><ul>
<li><p>R方可以用于评估回归模型对现实数据的拟合程度</p>
</li>
<li><p>设$y_i$是测试集第$i$个样本的价格，$\bar y$是真实价格的均值，$f(x_i)$是模型对第$i$个样本的预测价格，$n$是样本数量，则$R$方的计算步骤为：</p>
<ul>
<li><p>计算残差平方和$SS_{res}$：</p>
<script type="math/tex; mode=display">
SS_{res}=\sum_{i=1}^n(y_i-f(x_i))^2</script></li>
<li><p>计算样本总离差平方和$SS_{tss}$：</p>
<script type="math/tex; mode=display">
SS_{tss}=\sum_{i=1}^n(y_i-\bar y)^2</script></li>
<li><p>最后得到$R$方：</p>
<script type="math/tex; mode=display">
R^2=1-\frac{SS_{res}}{SS_{tss}}</script></li>
</ul>
</li>
<li><p>$R$方的取值越大，说明模型的效果越好</p>
</li>
</ul>
<hr>
<h1 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h1><h2 id="1-向量范数"><a href="#1-向量范数" class="headerlink" title="1.向量范数"></a>1.向量范数</h2><ul>
<li><p>L1-范数：即向量与元素绝对值之和</p>
<script type="math/tex; mode=display">
||x||_1=\sum_{i=1}^N|x_i|</script></li>
<li><p>L2-范数：即向量元素绝对值的平方和再开方</p>
<script type="math/tex; mode=display">
||x||_2=(\sum_{i=1}^N|x_i|^2)^{\frac12}</script></li>
<li><p>$\infty$-范数：即所有向量元素绝对值中的最大值</p>
<script type="math/tex; mode=display">
||x||_{\infty}=\mathop{max}_i|x_i|</script></li>
<li><p>$-\infty$-范数：即所有向量元素绝对值中的最小值</p>
<script type="math/tex; mode=display">
||x||_{-\infty}=\mathop{min}_i|x_i|</script></li>
<li><p>$p$-范数：即向量元素绝对值的$p$次方和的$\frac1p$次幂</p>
<script type="math/tex; mode=display">
||x||_p=(\sum_{i=1}^N|x_i|^p)^{\frac1p}</script></li>
</ul>
<h2 id="2-矩阵范数"><a href="#2-矩阵范数" class="headerlink" title="2.矩阵范数"></a>2.矩阵范数</h2><p>假设矩阵A为$m\cdot n$，即m行n列</p>
<ul>
<li><p>L1-范数：即矩阵的所有列元素绝对值之和的最大值</p>
<script type="math/tex; mode=display">
||A||_1=\mathop{max}_j\sum_{i=1}^m|a_{ij}|</script></li>
<li><p>L2-范数：即$A^TA$矩阵的最大特征值开平方</p>
<script type="math/tex; mode=display">
||A||_2=\sqrt{\lambda_1},\lambda_1为A^TA的最大特征值</script></li>
<li><p>$\infty$-范数：即矩阵的所有行向量元素绝对值之和的最大值</p>
<script type="math/tex; mode=display">
||A||_{\infty}=\mathop{max}_i\sum_{j=1}^n|a_{ij}|</script></li>
<li><p>F-范数：即矩阵元素绝对值的平方和再开平方</p>
<script type="math/tex; mode=display">
||A||_F=(\sum_{i=1}^m\sum_{j=1}^n|a_{ij}|^2)^{\frac12}</script></li>
</ul>
<hr>
<h1 id="线性回归的正则化"><a href="#线性回归的正则化" class="headerlink" title="线性回归的正则化"></a>线性回归的正则化</h1><ul>
<li><p>其目的是应用过拟合</p>
</li>
<li><p>在原有损失函数中加入正则化项：</p>
<script type="math/tex; mode=display">
J(\theta)=\frac1{2m}[\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2+\alpha\sum_{j=1}^n\theta_j^2]</script></li>
<li><p>其中$\alpha$是正则化参数</p>
</li>
<li><p>可以通过交叉验证的方式设置调整超参数$\alpha$</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之分支语句与简单文件输入输出</title>
    <url>/2022/12/05/C++%E4%B9%8B%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E4%B8%8E%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>C++之分支语句与简单文件输入输出</p>
<span id="more"></span>
<h1 id="字符函数库cctype"><a href="#字符函数库cctype" class="headerlink" title="字符函数库cctype"></a>字符函数库cctype</h1><div class="table-container">
<table>
<thead>
<tr>
<th>函数名称</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>isalnum()</td>
<td>如果参数是字母数字，即字母或数字，该函数返回true</td>
</tr>
<tr>
<td>isalpha()</td>
<td>如果参数是字母，该函数返回true</td>
</tr>
<tr>
<td>iscntrl()</td>
<td>如果参数是控制字符，该函数返回true</td>
</tr>
<tr>
<td>isdigit()</td>
<td>如果参数是数字（0~9），该函数返回true</td>
</tr>
<tr>
<td>isgraph()</td>
<td>如果参数是除空格之外的打印字符，该函数返回true</td>
</tr>
<tr>
<td>islower()</td>
<td>如果参数是小写字母，该函数返回true</td>
</tr>
<tr>
<td>isprint()</td>
<td>如果参数是打印字符（包括空格），该函数返回true</td>
</tr>
<tr>
<td>ispunct()</td>
<td>如果参数是标点符号，该函数返回true</td>
</tr>
<tr>
<td>isspace()</td>
<td>如果参数是标准空白字符，如空格、换行符、回车、水平制表符等，该函数返回true</td>
</tr>
<tr>
<td>isupper()</td>
<td>如果参数是大写字母，该函数返回true</td>
</tr>
<tr>
<td>isxdigit()</td>
<td>如果参数是十六进制数字，该函数返回true</td>
</tr>
<tr>
<td>tolower()</td>
<td>如果参数是大写字符，则返回其小写，否则返回该参数</td>
</tr>
<tr>
<td>toupper()</td>
<td>如果参数是小写字符，则返回其大写，否则返回该参数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> whitespace=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> digits=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chars=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> punct=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> others=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter text for analysis,and type @ to terminate the input&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch))</span><br><span class="line">            chars++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isspace</span>(ch))</span><br><span class="line">            whitespace++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">            digits++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">ispunct</span>(ch))</span><br><span class="line">            punct++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            others++;</span><br><span class="line">        cin.<span class="built_in">get</span>(ch);    </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;chars&lt;&lt;<span class="string">&quot; letters&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;whitespace&lt;&lt;<span class="string">&quot; whitespace&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;digits&lt;&lt;<span class="string">&quot; digits&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;punct&lt;&lt;<span class="string">&quot; punctuations&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;others&lt;&lt;<span class="string">&quot; others&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/05/C++%E4%B9%8B%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E4%B8%8E%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20221205145331903.png" alt="image-20221205145331903"></p>
<hr>
<h1 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h1><ul>
<li>switch语句中的每一个case标签都必须是一个单独的值，且这个值必须是整数（包括char），因此switch无法处理浮点测试</li>
<li>若每个case语句后不加break，则程序会一直执行下一个case的内容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;red,orange,yellow,green,blue,violet,indigo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举量用作标签</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter colot code(0~6):&quot;</span>;</span><br><span class="line">    cin&gt;&gt;code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(code&gt;=red &amp;&amp; code&lt;=indigo)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(code)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> red:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;You choose red!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> orange:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;You choose orange!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> yellow:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;You choose yellow!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> green:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;You choose green!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> blue:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;You choose blue!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> violet:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;You choose violet!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> indigo:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;You choose indigo!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Impossible!&quot;</span>&lt;&lt;endl; </span><br><span class="line">                <span class="keyword">break</span>;                                                                             </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Enter colot code(0~6):&quot;</span>;</span><br><span class="line">        cin&gt;&gt;code;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Bye!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/05/C++%E4%B9%8B%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E4%B8%8E%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20221205152024353.png" alt="image-20221205152024353"></p>
<hr>
<h1 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入/输出"></a>简单文件输入/输出</h1><h2 id="1-输出内容至文件"><a href="#1-输出内容至文件" class="headerlink" title="1.输出内容至文件"></a>1.输出内容至文件</h2><ul>
<li>首先需包含头文件：<code>#include&lt;fstream&gt;</code></li>
<li>其次对输出文件流创建对象：<code>ofstream outFile</code></li>
<li>接着将此对象与某个文件关联：<code>outFile.open(&quot;文件名&quot;)</code></li>
<li>关闭文件：<code>outFile.close()</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span><span class="comment">//需要包括&lt;fstream&gt;头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> automobile[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">double</span> a_price;</span><br><span class="line">    <span class="type">double</span> d_price;</span><br><span class="line"></span><br><span class="line">    ofstream outFile;<span class="comment">//对输出文件流创建对象</span></span><br><span class="line">    outFile.<span class="built_in">open</span>(<span class="string">&quot;carinfo.txt&quot;</span>);<span class="comment">//将outFile与某个文件相关联</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter the make and model of automobile:&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(automobile,<span class="number">50</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter the model year:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;year;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter the orignal asking price:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;a_price;</span><br><span class="line">    d_price=a_price*<span class="number">0.913</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出到屏幕上</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Make and model:&quot;</span>&lt;&lt;automobile&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Year:&quot;</span>&lt;&lt;year&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Was asking:&quot;</span>&lt;&lt;a_price&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Now asking:&quot;</span>&lt;&lt;d_price&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出到文件中</span></span><br><span class="line">    <span class="comment">//cout怎么用outFile就怎么用</span></span><br><span class="line">    outFile&lt;&lt;<span class="string">&quot;Make and model:&quot;</span>&lt;&lt;automobile&lt;&lt;endl;</span><br><span class="line">    outFile&lt;&lt;<span class="string">&quot;Year:&quot;</span>&lt;&lt;year&lt;&lt;endl;</span><br><span class="line">    outFile&lt;&lt;<span class="string">&quot;Was asking:&quot;</span>&lt;&lt;a_price&lt;&lt;endl;</span><br><span class="line">    outFile&lt;&lt;<span class="string">&quot;Now asking:&quot;</span>&lt;&lt;d_price&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/05/C++%E4%B9%8B%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E4%B8%8E%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20221210025134082.png" alt="image-20221210025134082"></p>
<p><img src="/2022/12/05/C++%E4%B9%8B%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E4%B8%8E%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20221210025343690.png" alt="image-20221210025343690"></p>
<h2 id="2-读取文件内容"><a href="#2-读取文件内容" class="headerlink" title="2.读取文件内容"></a>2.读取文件内容</h2><ul>
<li>首先需包含头文件：<code>#include&lt;fstream&gt;</code></li>
<li>其次对输入文件流创建对象：<code>ifstream inFile</code></li>
<li>接着将此对象与某个文件关联：<code>inFile.open(&quot;文件名&quot;)</code></li>
<li>判断文件是否打开成功：<code>inFile.is_open()</code></li>
<li>判断从文件中读取数据是否成功：<code>inFile.good()</code></li>
<li>判断是否读取到文件尾部：<code>inFile.eof()</code></li>
<li>判断读取数据与变量是否匹配：<code>inFile.fail()</code></li>
<li>关闭文件：<code>inFile.close()</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//因为使用了exit</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE=<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> filename[SIZE];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter the filename:&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(filename,SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件输入流对象</span></span><br><span class="line">    ifstream inFile;</span><br><span class="line">    inFile.<span class="built_in">open</span>(filename);<span class="comment">//对象与文件名关联</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Could not open the file&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Program terminating&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Sucess open the txt file.&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    inFile&gt;&gt;value;</span><br><span class="line">    <span class="keyword">while</span>(inFile.<span class="built_in">good</span>())<span class="comment">//判断从文件中读取数据是否成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">        sum+=value;</span><br><span class="line">        inFile&gt;&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(inFile.<span class="built_in">eof</span>())<span class="comment">//读到文件末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;End of file reached&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(inFile.<span class="built_in">fail</span>())<span class="comment">//读取的类型不匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Input terminated by data mismachted&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//其他不知名原因</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Input terminated by unknow reason&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算数据平均值</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No data processed&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Items read:&quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Sum:&quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Average:&quot;</span>&lt;&lt;sum/count&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter the filename:score.txt</span><br><span class="line">Sucess open the txt file.</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">18.5</span><br><span class="line">13.5</span><br><span class="line">14</span><br><span class="line">16</span><br><span class="line">19.5</span><br><span class="line">20</span><br><span class="line">18</span><br><span class="line">20</span><br><span class="line">18</span><br><span class="line">12</span><br><span class="line">17.5</span><br><span class="line">18.5</span><br><span class="line">End of file reached</span><br><span class="line">Items read:12</span><br><span class="line">Sum:204.5Average:17.0417</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="输出控制iomanip"><a href="#输出控制iomanip" class="headerlink" title="输出控制iomanip"></a>输出控制iomanip</h1><ul>
<li><p><code>setw(n)</code>：每个数占n个字节的宽度，<strong>setw()只对紧接着的输出有效，紧接着的输出结束后又会变回默认的域宽</strong></p>
</li>
<li><p><code>setiosflags(ios::right)</code> ：</p>
<ul>
<li><p>ios::right代表右对齐</p>
</li>
<li><p>iso::fixed 是操作符setiosflags 的参数之一，该参数指定的动作是以带小数点的形式表示浮点数，并且在允许的精度范围内尽可能的把数字移向小数点右侧；</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读入三个整数，按每个整数占8个字符的宽度，右对齐输出它们</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>	<span class="comment">//对输入输出操纵的头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">	cin &gt;&gt; a[<span class="number">0</span>] &gt;&gt; a[<span class="number">1</span>] &gt;&gt; a[<span class="number">2</span>];</span><br><span class="line">	cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::right)		<span class="comment">//输出数据右对齐</span></span><br><span class="line">	    &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span>		<span class="comment">//setw(n) 设置字段宽度为n位</span></span><br><span class="line">		&lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span>	    <span class="comment">//注意：setw()只对紧接着的输出有效，紧接着的输出结束后又会变回默认的域宽</span></span><br><span class="line">		&lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; endl;			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：123456789 -1 0</span><br><span class="line">输出：123456789       -1        0</span><br><span class="line"></span><br><span class="line">输入：876 12 0</span><br><span class="line">输出：     876       12        0 </span><br></pre></td></tr></table></figure>
<ul>
<li><code>setprecision(n)</code> ：控制小数点输出的精度，即是小数点右面的数字的个数为n。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>	<span class="comment">//对输入输出操纵的头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    cin&gt;&gt;d;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">12</span>)&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：3.7826478265786475864376783</span><br><span class="line">输出：3.782647826579</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础之特征工程</title>
    <url>/2022/12/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<p>本节主要介绍了特征工程中特征处理这一核心部分，包括特征值的缩放、归一化、特征选择与降维等</p>
<span id="more"></span>
<h1 id="特征工程的基本概念"><a href="#特征工程的基本概念" class="headerlink" title="特征工程的基本概念"></a>特征工程的基本概念</h1><ul>
<li>定义：其本质是一项工程活动，目的是最大限度地从原始数据中提取特征以供算法和模型使用</li>
<li>特征处理是特征工程的核心部分，其包括特征缩放、特征选择及降维</li>
<li>目的：如何能够分解和聚合原始数据，以更好的表达问题的本质</li>
</ul>
<hr>
<h1 id="特征值的缩放"><a href="#特征值的缩放" class="headerlink" title="特征值的缩放"></a>特征值的缩放</h1><h2 id="1-标准化法"><a href="#1-标准化法" class="headerlink" title="1.标准化法"></a>1.标准化法</h2><ul>
<li><p>标准化的前提是特征值服从正态分布</p>
</li>
<li><p>标准化需要计算特征的均值和标准差，其公式为：</p>
<script type="math/tex; mode=display">
X_{scale}=\frac{(X(axis=0)-X.mean(axis=0))}{X.std(axis=0)}</script></li>
</ul>
<h2 id="2-区间缩放法"><a href="#2-区间缩放法" class="headerlink" title="2.区间缩放法"></a>2.区间缩放法</h2><ul>
<li><p>区间缩放利用了边界值信息，将特征的取值区间缩放到某个特定范围，假设max和min为希望的调整后的范围，则：</p>
<script type="math/tex; mode=display">
X_{scaled}=\frac{(X(axis=0)-X.min(axis=0))}{(X.max(axis=0)-X.min(axis=0))}\times (max-min)+min</script></li>
<li><p>由于希望的调整后范围一般为$[0,1]$，则公式变为：</p>
<script type="math/tex; mode=display">
X_{scaled}=\frac{(X(axis=0)-X.min(axis=0))}{(X.max(axis=0)-X.min(axis=0))}</script></li>
</ul>
<hr>
<h1 id="特征值的归一化"><a href="#特征值的归一化" class="headerlink" title="特征值的归一化"></a>特征值的归一化</h1><ul>
<li><p>归一化是依照特征矩阵的行（样本）处理数据，其目的在于样本向量在点乘运算或计算相似性时，拥有统一的标准，也就是说都转化为“单位向量”</p>
</li>
<li><p>规则为L1 norm的归一化公式如下：</p>
<script type="math/tex; mode=display">
x'=\frac{x}{\sum_{j=0}^{n-1}|x_j|}</script></li>
<li><p>规则为L2 norm的归一化公式如下：</p>
<script type="math/tex; mode=display">
x'=\frac{x}{\sqrt{\sum_{j=0}^{n-1}x_j^2}}</script></li>
</ul>
<hr>
<h1 id="创建多项式特征"><a href="#创建多项式特征" class="headerlink" title="创建多项式特征"></a>创建多项式特征</h1><ul>
<li>如果基于线性特征的模型不够理想，也可以尝试创建多项式特征<ul>
<li>例如，两个特征$(X_1,X_2)$，它的平方展开式便转化成$(1,X_1,X_2,X_1X_2,X_1^2,X_2^2)$</li>
<li>也可以自定义选择只保留特征相乘的多项式项，即将特征$(X_1,X_2)$转化成$(1,X_1,X_2,X_1X_2)$</li>
</ul>
</li>
<li>得到多项式特征后，只是特征空间发生了变化</li>
</ul>
<hr>
<h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><ul>
<li>单纯地从提取到的所有特征中选择部分特征作为训练集特征，特征在选择前和选择后不改变值</li>
</ul>
<h2 id="1-方差选择法"><a href="#1-方差选择法" class="headerlink" title="1.方差选择法"></a>1.方差选择法</h2><ul>
<li>使用方差选择法，先要计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征</li>
</ul>
<h2 id="2-皮尔森相关系数法"><a href="#2-皮尔森相关系数法" class="headerlink" title="2.皮尔森相关系数法"></a>2.皮尔森相关系数法</h2><ul>
<li><p>皮尔森相关系数显示两个随机变量之间线性关系的强度和方向，其计算公式为：</p>
<script type="math/tex; mode=display">
\rho_{X,Y}=\frac{cov(X,Y)}{\sigma_X\sigma_Y}=\frac{E[(X-\mu_X)(Y-\mu_Y)]}{\sigma_X\sigma_Y}\\
\sigma_X是X的均方差，\mu_X是X的均值</script></li>
<li><p>将与目标值相关性较小的特征过滤掉</p>
</li>
<li>Pearson相关系数对线性关系比较敏感，如果关系是非线性的，即使两个变量具有一一对应的关系，Pearson相关性也可能接近0</li>
</ul>
<h2 id="3-基于森林的特征选择法"><a href="#3-基于森林的特征选择法" class="headerlink" title="3.基于森林的特征选择法"></a>3.基于森林的特征选择法</h2><ul>
<li>其原理是某些分类器，自身提供了特征的重要性分值，因此可以直接调用这些分类器，得到特征重要性分值并排序</li>
</ul>
<p><img src="/2022/12/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/image-20221204220229202.png" alt="image-20221204220229202" style="zoom:50%;"></p>
<h2 id="4-递归特征消除"><a href="#4-递归特征消除" class="headerlink" title="4.递归特征消除"></a>4.递归特征消除</h2><ul>
<li>首先在初始特征或权重特征集合上训练，通过学习器返回的属性来获取每个特征的重要程度</li>
<li>选择最小权重的特征移除</li>
<li>这个过程递归进行，直到希望的特征数目满足为止</li>
</ul>
<hr>
<h1 id="特征降维"><a href="#特征降维" class="headerlink" title="特征降维"></a>特征降维</h1><ul>
<li>本质上是从一个维度空间映射到另一个维度空间，但是在映射的过程中特征值会相应的变化</li>
</ul>
<h2 id="1-线性判别分析法（LDA）"><a href="#1-线性判别分析法（LDA）" class="headerlink" title="1.线性判别分析法（LDA）"></a>1.线性判别分析法（LDA）</h2><ul>
<li>线性判别分析（LDA）是一种监督学习的降维技术，即数据集的每个样本都有类别输出</li>
<li>LDA的借本思想：“投影后类内方差最小，类间方差最大”，即将数据在低维度上进行投影，投影后希望同类数据的投影点尽可能接近，而不同类数据的类别中心之间的距离尽可能的大</li>
<li>下图中，右图要更好</li>
</ul>
<p><img src="/2022/12/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/image-20221204220801322.png" alt="image-20221204220801322" style="zoom: 67%;"></p>
<h2 id="2-主成分分析（PCA）"><a href="#2-主成分分析（PCA）" class="headerlink" title="2.主成分分析（PCA）"></a>2.主成分分析（PCA）</h2><ul>
<li>主成分分析是一种无监督的降维方法</li>
<li><p>方法：寻找使方差最大的方向（数学上用方差来表达投影后分散的程度），并在该方向上投影</p>
</li>
<li><p><a href="https://kdocs.cn/l/cv4iZs9MpU4t?f=201">点击此处获取 PCA的原理解释与算法流程</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之循环</title>
    <url>/2022/12/03/C++%E4%B9%8B%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>C++之循环……，包括for循环与while循环、break与continue、读取数字的循环。</p>
<span id="more"></span>
<h1 id="For循环与二维数组"><a href="#For循环与二维数组" class="headerlink" title="For循环与二维数组"></a>For循环与二维数组</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Cities=<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Years=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for循环与二维数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//指针数组</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * cities[Cities]=</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Changsha&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Xiamenll&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Kaifeng&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Shenzheng&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Shanghai&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//二维数组</span></span><br><span class="line">    <span class="type">int</span> maxtemps[Years][Cities]=</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">96</span>,<span class="number">100</span>,<span class="number">87</span>,<span class="number">101</span>,<span class="number">105</span>&#125;,</span><br><span class="line">        &#123;<span class="number">96</span>,<span class="number">98</span>,<span class="number">91</span>,<span class="number">107</span>,<span class="number">104</span>&#125;,</span><br><span class="line">        &#123;<span class="number">97</span>,<span class="number">101</span>,<span class="number">93</span>,<span class="number">108</span>,<span class="number">107</span>&#125;,</span><br><span class="line">        &#123;<span class="number">98</span>,<span class="number">103</span>,<span class="number">95</span>,<span class="number">109</span>,<span class="number">108</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//二维数组的遍历访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> city=<span class="number">0</span>;city&lt;Cities;city++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;cities[city]&lt;&lt;<span class="string">&quot;:\t&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> year=<span class="number">0</span>;year&lt;Years;year++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;maxtemps[year][city]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/03/C++%E4%B9%8B%E5%BE%AA%E7%8E%AF/image-20221203174550427.png" alt="image-20221203174550427"></p>
<ul>
<li><p>练习1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter the number of rows:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;row;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;row-i<span class="number">-1</span>;j++)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/03/C++%E4%B9%8B%E5%BE%AA%E7%8E%AF/image-20221203185125019.png" alt="image-20221203185125019"></p>
<p><img src="/2022/12/03/C++%E4%B9%8B%E5%BE%AA%E7%8E%AF/image-20221203185159015.png" alt="image-20221203185159015"></p>
</li>
</ul>
<hr>
<h1 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用while循环实现延时控制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter the delay time,in seconds:&quot;</span>;</span><br><span class="line">    <span class="type">float</span> secs;</span><br><span class="line">    cin&gt;&gt;secs;</span><br><span class="line"></span><br><span class="line">    <span class="type">clock_t</span> delay=secs*CLOCKS_PER_SEC;<span class="comment">//CLOCKS_PER_SEC表示每秒对应的系统时间</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;starting\n&quot;</span>;</span><br><span class="line">    <span class="type">clock_t</span> start=<span class="built_in">clock</span>();<span class="comment">//clock()返回程序开始后执行的系统时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">clock</span>()-start&lt;delay);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;done\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Break与Continue"><a href="#Break与Continue" class="headerlink" title="Break与Continue"></a>Break与Continue</h1><ul>
<li>break是退出当前循环</li>
<li>Continue是回到循环开始处继续执行<ul>
<li>在for循环中，continue语句使程序直接跳到更新表达式处，即下面程序中的i++处</li>
<li>对于while循环，continue语句直接跳转到判断表达式处，即下面程序中i&lt;name.size()处</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string name=<span class="string">&quot;ssyttmsl&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;name.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(name[i]!=<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">            cout&lt;&lt;name[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;name.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(name[i]!=<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">            cout&lt;&lt;name[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;name.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(name[i]!=<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">            cout&lt;&lt;name[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/03/C++%E4%B9%8B%E5%BE%AA%E7%8E%AF/image-20221207172547747.png" alt="image-20221207172547747"></p>
<h1 id="读取数字的循环"><a href="#读取数字的循环" class="headerlink" title="读取数字的循环"></a>读取数字的循环</h1><ul>
<li><p>若用户输入的类型与定义的类型不匹配，那么cin对象中的一个错误标记将被设置，对cin方法的调用将返回false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;right!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;wrong!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/03/C++%E4%B9%8B%E5%BE%AA%E7%8E%AF/image-20221207173342647.png" alt="image-20221207173342647"></p>
</li>
<li><p>当程序发现用户输入错误内容想跳过重新输入时，应采取3个步骤</p>
<ul>
<li><code>cin.clear()</code>重置cin的错误标记位</li>
<li><code>while(cin.get()!=&#39;\n&#39;);</code>删除错误输入</li>
<li>提示用户再输入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max=<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> golf[Max];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter your golf scores.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;You must enter &quot;</span>&lt;&lt;Max&lt;&lt;<span class="string">&quot; rounds&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Max;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Round #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(cin&gt;&gt;golf[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            cin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (cin.<span class="built_in">get</span>()!=<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Please enter a number:&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> total=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Max;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        total+=golf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Average score:&quot;</span>&lt;&lt;total/Max&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/12/03/C++%E4%B9%8B%E5%BE%AA%E7%8E%AF/image-20221207174811462.png" alt="image-20221207174811462"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI DSP之信道编码与解码</title>
    <url>/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>本节主要介绍了线性分组码、循环码、卷积码的编码与译码。</p>
<span id="more"></span>
<h1 id="信道编码的基本概念"><a href="#信道编码的基本概念" class="headerlink" title="信道编码的基本概念"></a>信道编码的基本概念</h1><ul>
<li><p>信道编码的<strong>目的</strong>：提高信号传输的可靠性</p>
</li>
<li><p>信道编码的<strong>方法</strong>：增加冗余比特，以发现或纠正错误</p>
</li>
<li><p>信道编码的<strong>实质</strong>：在信息码中增加一定数量的多余码元（称为监督码元），是它们满足一定的约束关系</p>
<ul>
<li>发送端将信息码元和监督码元共同组成一个由信道传输的码字</li>
<li>一旦传输过程中发生错误，则信息码元和监督码元间的约束关系被破坏</li>
<li>在接收端按既定的规则校验这种约束关系，从而可达到发现和纠正错误的目的</li>
</ul>
</li>
<li><p>信道编码的<strong>分类</strong>：</p>
<ul>
<li>线性与非线性码：<ul>
<li>线性码：信息码与监督码之间的关系为线性关系</li>
<li>非线性码：信息码与监督码之间的关系为非线性关系</li>
</ul>
</li>
<li>分组码与卷积码：<ul>
<li>分组码：信息码与监督码以组为单位建立关系</li>
<li>卷积码：监督码与本组和前面码组中的信息码有关</li>
</ul>
</li>
<li>系统码与非系统码：<ul>
<li>系统码：编码后码组中信息码保持原图样顺序不变</li>
<li>非系统码：编码后码组中原信息码原图样发生变化</li>
</ul>
</li>
</ul>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203192909916.png" alt="image-20221203192909916" style="zoom: 50%;"></p>
</li>
<li><p><strong>误码的主要形式</strong>：</p>
<ul>
<li>随机错误：误码的位置随机（误码间无关联），随机误码主要由白噪声引起</li>
<li>突发错误：误码成串出现，主要由强脉冲及雷电等突发的强干扰引起的</li>
<li>混合错误：以上两种误码及产生原因的组合</li>
</ul>
</li>
<li><p><strong>编码效率与冗余度</strong>：</p>
<ul>
<li>假设分组码的长度为n，其中信息位为k，相应的监督位为n-k</li>
</ul>
<script type="math/tex; mode=display">
编码效率=\frac kn</script><ul>
<li>编码效率越高，意味着冗余度越低</li>
</ul>
</li>
<li><p><strong>基本术语</strong>：</p>
<ul>
<li>码重W：码组/码字中非零码元的数目</li>
<li>码距d(Hamming距)：两码组/码字中对应码元位置上取值不同的个数称为码组/码字间的距离，简称码距</li>
<li>最小码距$d_{min}$：准用码组/码字空间中任意两码组间的最小距离</li>
</ul>
</li>
<li><p><strong>一般情况下，编码后，在同样的</strong>$\frac {E_b}{N_0}$<strong>下，编码后系统有更好的性能</strong></p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203194014922.png" alt="image-20221203194014922" style="zoom: 50%;"></p>
</li>
</ul>
<hr>
<h1 id="线性分组码"><a href="#线性分组码" class="headerlink" title="线性分组码"></a>线性分组码</h1><ul>
<li><p>定义：</p>
<ul>
<li>把信源输出的k位信息序列，通过编码器产生r个监督位，输出长为n=k+r的码字，所得码字的全体，称为(n,k)线性分组码</li>
<li>码组中的信息位与监督位之间的关系由线性方程确定</li>
</ul>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203200415291.png" alt="image-20221203200415291" style="zoom: 33%;"></p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
p_1=m_1\oplus m_3\\
p_2=m_1\oplus m_2\\
p_3=m_2\oplus m_3
\end{aligned}
\end{cases}</script></li>
<li><p><strong>生成矩阵</strong>：从(n,k)线性分组码中任取k个线性无关的码字，按行的形式写出矩阵G，则称该线性分组码为生成矩阵</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203201029350.png" alt="image-20221203201029350" style="zoom: 50%;"></p>
</li>
<li><p><strong>通过</strong>$U=mG$<strong>(m为输入信息）便能计算出编码后的码字</strong>$U$</p>
<script type="math/tex; mode=display">
若生成矩阵G= \begin{pmatrix}
1 & 1 & 0 & 1 & 0 & 0\\
0 & 1 & 1 & 0 & 1 & 0\\
1 & 0 & 1 & 0 & 0 & 1
\end{pmatrix}=\begin{pmatrix}
V_1\\
V_2\\
V_3
\end{pmatrix}</script><script type="math/tex; mode=display">
若输入信息m=\begin{pmatrix}
1&1&0
\end{pmatrix}</script><script type="math/tex; mode=display">
则:U=m\cdot G=\begin{pmatrix}
1&1&0
\end{pmatrix}\begin{pmatrix}
V_1\\
V_2\\
V_3
\end{pmatrix}=1\cdot V_1+1\cdot V_2+0\cdot V_3\\=
\begin{pmatrix}
1&1&0&1&0&0
\end{pmatrix}+\begin{pmatrix}
0&1&1&0&1&0
\end{pmatrix}+\begin{pmatrix}
 0&0&0&0&0&0
\end{pmatrix}=\begin{pmatrix}
1&0&1&1&1&0
\end{pmatrix}</script></li>
<li><p><strong>监督矩阵</strong>：</p>
<script type="math/tex; mode=display">
若(n,k)线性分组码的生成矩阵G形如:\\
G=(P|I_k)\\
其中G为k\times n阶矩阵,I_k是k阶单位阵，P为k\times (n-k)阶子阵\\
则其对应的监督矩阵为:\\
H=(I_{(n-k)}|P^T)\\
其中H为(n-k)\times n阶矩阵</script></li>
<li><p>在无误码存在的条件下，存在如下约束关系：</p>
<script type="math/tex; mode=display">
GH^T=[0]</script></li>
<li><p><strong>伴随式</strong>：</p>
<script type="math/tex; mode=display">
S=rH^T\\
其中:r为接收码字</script></li>
<li><p>$(n,k)$<strong>线性分组码的译码方法</strong>：</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203210713180.png" alt="image-20221203210713180" style="zoom:50%;"></p>
<ul>
<li><p>由$eH^T(e为错误图样)$构建伴随式错误图样查询表</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203210109047.png" alt="image-20221203210109047" style="zoom:50%;"></p>
</li>
<li><p>例：</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203210539296.png" alt="image-20221203210539296" style="zoom:33%;"></p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203210634566.png" alt="image-20221203210634566" style="zoom: 33%;"></p>
</li>
</ul>
</li>
<li><p><strong>线性分组码的检错与纠错能力</strong>：任意一个$(n,k)$分组码，若要在任何码字内：</p>
<ul>
<li>能检测e个随机错误，则要求最小Hamming距离$d\ge e+1$</li>
<li>能纠正t个随机错误，则要求$d\ge 2t+1$</li>
<li>能纠正t个随机错误，同时检测出$e(\ge t)$个错误，则要求$d\ge t+e+1$</li>
</ul>
</li>
</ul>
<hr>
<h1 id="循环码"><a href="#循环码" class="headerlink" title="循环码"></a>循环码</h1><ul>
<li><p>定义：码长为n，信息位为k的$(n,k)$线性分组码，若具有下列属性：</p>
<script type="math/tex; mode=display">
如果U=[u_0,u_1,u_2,\cdots,u_{n-1}]是子空间S的一个码字，经过i次循环移位得到:\\
U^{(i)}=[u_{n-i},u_{n-i+1},\cdots,u_{n-1},u_0,u_1,\cdots,u_{n-i-1}]也是S中的一个码字(i\ge 0)\\
这种具有循环移位特点的码被称为循环码</script></li>
<li><p><strong>生成多项式</strong>$g(x)$<strong>与码字多项式</strong>$U(x)$<strong>存在约束关系</strong>：</p>
<script type="math/tex; mode=display">
U(x)\; mod\; g(x)=0</script><ul>
<li><p>例：</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203214504458.png" alt="image-20221203214504458" style="zoom: 33%;"></p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203214832804.png" alt="image-20221203214832804" style="zoom: 33%;"></p>
</li>
</ul>
</li>
<li><p><strong>伴随式</strong>：伴随式可以由$r(x)$对生成多项式$g(x)$取模计算得到：</p>
<script type="math/tex; mode=display">
S(x)=r(x)\;mod\;g(x)=[U(x)+e(x)]\;mod\;g(x)=e(x)\;mod\;g(x)\\
其中:e(x)为错误图样</script></li>
<li><p><strong>译码方法</strong>：</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203215510012.png" alt="image-20221203215510012" style="zoom:50%;"></p>
<ul>
<li><p>构建伴随式查询表：</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203215745265.png" alt="image-20221203215745265" style="zoom: 33%;"></p>
</li>
<li><p>例：</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203215959010.png" alt="image-20221203215959010" style="zoom: 33%;"></p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221203220026425.png" alt="image-20221203220026425" style="zoom:33%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="卷积码的基本概念"><a href="#卷积码的基本概念" class="headerlink" title="卷积码的基本概念"></a>卷积码的基本概念</h1><ul>
<li><p>卷积码：通过将输入信息序列与编码器做卷积运算，将k位信息编成n比特，此n比特不仅与当前k位信息有关，还与前面(m-1)段的信息有关</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221205154422965.png" alt="image-20221205154422965" style="zoom:33%;"></p>
</li>
<li><p>卷积码$(n,k,m)$的参数：</p>
<ul>
<li>$k$：输入比特信息</li>
<li>$n$：输出码字</li>
<li>$m$：约束长度，即移位寄存器的级数</li>
<li>$R$：码率，表示传输信息的有效性$R=\frac kn$</li>
</ul>
</li>
</ul>
<h2 id="1-卷积码的编码方法—冲击响应"><a href="#1-卷积码的编码方法—冲击响应" class="headerlink" title="1.卷积码的编码方法—冲击响应"></a>1.卷积码的编码方法—冲击响应</h2><ul>
<li><p>假设为卷积码$(2,1,3)$，即输入1bit，输出2bit，移位寄存器的个数为3</p>
</li>
<li><p>输入”1”时对应的输出序列为：<code>11 10 11</code></p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221205162501011.png" alt="image-20221205162501011" style="zoom: 50%;"></p>
</li>
<li><p>则当输入序列为m=101时对应的输出可按照输入的线性叠加方式得到：<code>11 10 00 10 11</code></p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221205162650768.png" alt="image-20221205162650768" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="2-卷积码的编码方法—状态描述和状态图"><a href="#2-卷积码的编码方法—状态描述和状态图" class="headerlink" title="2.卷积码的编码方法—状态描述和状态图"></a>2.卷积码的编码方法—状态描述和状态图</h2><ul>
<li><p>可以用当前输入和之前（m-1）个输入来预测输出</p>
</li>
<li><p>卷积编码器中，状态共有$2^{m-1}$个</p>
</li>
<li><p>$(2,1,3)$卷积码的编码方法</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221205163334403.png" alt="image-20221205163334403" style="zoom:50%;"></p>
</li>
<li><p>$(2,1,3)$卷积编码的状态图</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221205163513133.png" alt="image-20221205163513133" style="zoom:50%;"></p>
</li>
<li><p>网格图分析——</p>
<ul>
<li><strong>输入中最后2bit是补零操作，是为了让状态寄存器器能恢复成初始状态（X00），不影响下一次序列的输入</strong></li>
</ul>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221205163635185.png" alt="image-20221205163635185"></p>
</li>
</ul>
<hr>
<h1 id="卷积码的译码方法—维特比译码"><a href="#卷积码的译码方法—维特比译码" class="headerlink" title="卷积码的译码方法—维特比译码"></a>卷积码的译码方法—维特比译码</h1><ul>
<li><p>维特比译码是基于动态规划的方法：</p>
<ul>
<li>动态规划思想：当前最优路径=上一步最优路径+当前组合</li>
<li>维特比译码思想：译码器每接收一段，就计算比较判决</li>
</ul>
</li>
<li><p><strong>分支度量</strong>：某时刻输出子码与接收子码之间的汉明距离</p>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221205180444265.png" alt="image-20221205180444265" style="zoom:50%;"></p>
</li>
<li><p><strong>路径度量</strong>：</p>
<ul>
<li>该路径输出序列与接收序列之间的汉明距离，是分支度量的和</li>
<li>则上述的路径度量=0+0+0+0+1+0+1=2</li>
</ul>
</li>
<li><p><strong>维特比译码步骤</strong>：</p>
<ul>
<li>计算到达当前节点的分支度量</li>
<li>取出到达上一节点对应的路径度量</li>
<li>相加得到两个新路径度量，比较，选择汉明距离较小者，被称为幸存路径</li>
<li>具体解释可见：<a href="https://www.icourse163.org/learn/SJTU-1449270161?tid=1463620444#/learn/content?type=detail&amp;id=1241732491&amp;cid=1264287105&amp;replay=true">VLSI数字通信原理与设计_中国大学MOOC(慕课) (icourse163.org)</a></li>
</ul>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221206010526855.png" alt="image-20221206010526855" style="zoom: 33%;"></p>
</li>
<li><p><strong>维特比译码的特点</strong>：</p>
<ul>
<li>维特比算法是最大似然译码算法</li>
<li>运算量和存储量与状态数$2^{km}$呈线性关系</li>
<li>运算量和存储量与码长L呈线性关系</li>
</ul>
</li>
<li><p>截尾译码：</p>
<ul>
<li><p>分段译码，降低复杂度</p>
</li>
<li><p>译码深度h，其中m-1为编码器记忆深度</p>
<script type="math/tex; mode=display">
h=(5\sim10)(m-1)</script></li>
</ul>
</li>
</ul>
<hr>
<h1 id="卷积码的性能"><a href="#卷积码的性能" class="headerlink" title="卷积码的性能"></a>卷积码的性能</h1><ul>
<li><p><strong>自由距离</strong>$d_f$<strong>的确定</strong>：</p>
<ul>
<li>卷积码属于线性码，所以任意两个码序列按位模二加仍然是一个许用码，而它的重量（1的个数）就等于这两个码序列之间的汉明距离</li>
<li>只要在所有的码序列中找到最小重量的许用码，它的重量就是卷积码的最小汉明距离</li>
<li>任意许用码序列的重量又等于它与全0码之间的汉明距离</li>
<li>只要在格图上找到一条离全零距离最近的、从0状态出发又回到0状态的非全0路径，那么这条路径所代表的码序列的重量就等于自由距离</li>
</ul>
<p><img src="/2022/12/03/VLSI%20DSP%E4%B9%8B%E4%BF%A1%E9%81%93%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/image-20221208141239867.png" alt="image-20221208141239867" style="zoom:50%;"></p>
<ul>
<li>则上述中重量最小的路径为：$S_0\xrightarrow{11}S_1\xrightarrow{10}S_2\xrightarrow{11}S_0$<script type="math/tex; mode=display">
d_f=5</script></li>
</ul>
</li>
<li><p>在译码深度长度内，可以纠正$\lfloor\frac{(d_f-1)}{2}\rfloor$个随机错误</p>
</li>
<li><p><strong>卷积码的编码增益</strong>：</p>
<ul>
<li>编码增益$dB=[\frac{E_b}{N_0}dB]_{未编码}-[\frac{E_b}{N_0}dB]_{编码}$</li>
<li>硬件判决编码增益$dB:10log_{10}(\frac{Rd_f}{2})$</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI DSP之带通调制与解调</title>
    <url>/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/</url>
    <content><![CDATA[<p>本节主要介绍了数字带通调制中的高阶调制技术，以及OFDM调制与解调、CORDIC的硬件设计方法。</p>
<span id="more"></span>
<h1 id="数字带通调制的基本概念"><a href="#数字带通调制的基本概念" class="headerlink" title="数字带通调制的基本概念"></a>数字带通调制的基本概念</h1><ul>
<li><p>载波的一般表达式</p>
<script type="math/tex; mode=display">
s(t)=A(t)cos[w_0t+\Phi(t)]</script></li>
<li><p><strong>波形振幅系数</strong>：</p>
<script type="math/tex; mode=display">
\because P=\frac{A^2}{2}=\frac ET</script><script type="math/tex; mode=display">
\therefore A=\sqrt{\frac{2E}{T}}</script><script type="math/tex; mode=display">
其中:E为码元能量,T为码元周期</script></li>
<li><p><strong>基本键控方式</strong>：</p>
<ul>
<li>振幅键控（ASK）：利用载波的幅度变化来传递数字信息，而其频率和初始相位保持不变</li>
<li>频移键控（FSK）：利用载波的频率变化来传递数字信息</li>
<li>相移键控（PSK）：利用载波的相位变化来传递数字信息，而振幅和频率保持不变</li>
</ul>
<p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202133255807.png" alt="image-20221202133255807" style="zoom:50%;"></p>
</li>
<li><p><strong>多进制数字调制</strong></p>
<ul>
<li><p>定义：在码元间隔$0\leq t\leq T_s$内，可能发送的码元有M种，M通常为2的整数幂，则称为M进制数字调制</p>
</li>
<li><p>误码率取决于信噪比$r$：</p>
<script type="math/tex; mode=display">
r=\frac{A^2}{2\sigma_n^2}=\frac E{n_0}</script></li>
<li><p>设多进制码元的进制数为M，码元能量为E，一个码元中包含信息k比特，则有：</p>
<script type="math/tex; mode=display">
k=log_2M</script></li>
<li><p>若码元能量E平均分配给每个比特，则每比特的能量$E_b$等于$\frac Ek$：</p>
<script type="math/tex; mode=display">
\frac{E_b}{n_0}=\frac{E}{kn_0}=r_b</script></li>
</ul>
</li>
</ul>
<hr>
<h1 id="高阶调制与解调技术"><a href="#高阶调制与解调技术" class="headerlink" title="高阶调制与解调技术"></a>高阶调制与解调技术</h1><h2 id="1-多进制调制"><a href="#1-多进制调制" class="headerlink" title="1.多进制调制"></a>1.多进制调制</h2><ul>
<li><p>原理：</p>
<script type="math/tex; mode=display">
\because R_b=R_Blog_2M</script><script type="math/tex; mode=display">
\therefore R_B一定时，增加调制阶数M，可以的增大R_b</script></li>
<li><p>故在相同带宽内传输更多比特的信息，信道的频率效率提高至$log_2M$倍</p>
</li>
<li><p>但噪声容限会降低</p>
</li>
<li>暴露问题：随着M增加，距离减小，误码率增加</li>
</ul>
<h2 id="2-MQAM调制"><a href="#2-MQAM调制" class="headerlink" title="2.MQAM调制"></a>2.MQAM调制</h2><ul>
<li><p><strong>振幅和相位联合键控的调制方式</strong></p>
</li>
<li><p>MQAM调制星座图（M=4,16,64,256）</p>
<ul>
<li><strong>随着调制阶数M增加：传输速率提升，相邻信号点距离减小，误码率提升</strong></li>
</ul>
<p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202152932288.png" alt="image-20221202152932288" style="zoom: 50%;"></p>
</li>
<li><p><strong>16QAM信号的产生方法</strong>：</p>
<ul>
<li><p>正交调幅法：用两路独立的正交4ASK信号叠加，形成16QAM信号</p>
<p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202153301199.png" alt="image-20221202153301199" style="zoom: 50%;"></p>
</li>
<li><p>复合相移法：用两路独立的QPSK信号叠加，形成16QAM信号</p>
<p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202153456786.png" alt="image-20221202153456786" style="zoom: 50%;"></p>
</li>
</ul>
</li>
<li><p><strong>16QAM与16PSK的对比</strong>：</p>
<p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202153709312.png" alt="image-20221202153709312" style="zoom: 33%;"></p>
</li>
<li><p>MQAM解调系统仍是一种线性系统，解调后叠加的噪声仍为高斯白噪声</p>
</li>
<li><p>同相和正交信号电平数为：</p>
<script type="math/tex; mode=display">
L=\sqrt M</script></li>
<li><p><strong>AWGN信道下的误比特率</strong>：</p>
<ul>
<li>MPSK与MQAM的误比特率随着M的增大而增大</li>
<li>M相同时，MQAM的误比特率比MPSK小</li>
</ul>
</li>
</ul>
<hr>
<h1 id="OFDM调制与解调的原理"><a href="#OFDM调制与解调的原理" class="headerlink" title="OFDM调制与解调的原理"></a>OFDM调制与解调的原理</h1><ul>
<li><p>OFDM系统把高速数据流通过串并转换，分解成若干低速的子数据流，用多个正交子载波去调制</p>
<p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202170259222.png" alt="image-20221202170259222"></p>
<script type="math/tex; mode=display">
s(t)=\sum_{n=0}^{N-1}x(n)e^{j2\pi f_nt}</script><script type="math/tex; mode=display">
r_m=\frac 1T\int_0^Ts(t)e^{-j2\pi f_mt}dt=\sum_{n=0}^{N-1}x(n)\frac 1T\int_0^Te^{j2\pi f_nt}e^{-j2\pi f_mt}dt</script></li>
<li><p>信号的正交性：对于任意两个函数$S_1(t)$和$S_2(t)$，如果有$\int_0^TS_1(t)S_2(t)dt=0$，则函数$S_1(t)$和$S_2(t)$在区间$(0,T)$上正交</p>
</li>
<li><p>对于OFDM：若相邻子载波的频率间隔$\Delta f=\frac 1T$，则子载波相互正交，有：</p>
<script type="math/tex; mode=display">
\frac1T\int_0^Te^{j2\pi f_nt}e^{-j2\pi f_mt}dt=\delta_{mn}=0(n≠m) \quad or\quad 1(n=m)</script><p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202171223266.png" alt="image-20221202171223266" style="zoom: 33%;"></p>
</li>
<li><p>OFDM系统频谱：每个载波在其自身取最大值时，其他载波都取0，降低了带宽</p>
<p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202171528968.png" alt="image-20221202171528968" style="zoom: 50%;"></p>
</li>
</ul>
<hr>
<h1 id="OFDM调制与解调的实现"><a href="#OFDM调制与解调的实现" class="headerlink" title="OFDM调制与解调的实现"></a>OFDM调制与解调的实现</h1><ul>
<li><p>OFDM调制通过IFFT实现，解调通过FFT实现</p>
<p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202225312360.png" alt="image-20221202225312360" style="zoom: 33%;"></p>
<p><img src="/2022/12/02/VLSI%20DSP%E4%B9%8B%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/image-20221202225342274.png" alt="image-20221202225342274" style="zoom: 33%;"></p>
</li>
<li><p>系统设计需考虑的参数：</p>
<ul>
<li><p>明确系统参数：比特速率、带宽、误码率要求、根均方时延</p>
</li>
<li><p>保护时隙长度：2-4倍信道的扩展时延</p>
</li>
<li><p>符号长度：OFDM符号长度一般选择时保护时隙的5倍，以尽量减小SNR损失</p>
</li>
<li><p>子载波个数：</p>
<ul>
<li>各子载波间距的大小也受到载波偏移及相位稳定度的影响</li>
<li>子载波的数量根据信道带宽、数据速率以及符号周期来确定</li>
</ul>
<script type="math/tex; mode=display">
两个最近子载波的间隔=\frac1{OFDM符号长度}</script><script type="math/tex; mode=display">
子载波个数=\frac{带宽}{两个最近子载波的间距}</script></li>
<li><p>调制与信道编码：</p>
<ul>
<li>由误码率决定</li>
<li>一个OFDM符号承载的比特数</li>
</ul>
</li>
<li><p>保护时间：在OFDM系统中，保护时间的引入会引起带宽利用率的下降</p>
</li>
<li><p>符号周期：</p>
<ul>
<li><p>为了减小保护时间引起的信噪比性能损失，符号周期必须大于保护时间，但符号周期的增加意味着子载波数量的增加以及系统复杂度的上升</p>
</li>
<li><p>实际系统设计时，符号周期至少时保护周期的4~5倍</p>
</li>
</ul>
</li>
<li><p>调制方式：</p>
<ul>
<li>OFDM系统采用的调制方式应根据功率及频谱利用率的要求来确定，常用QPSK和16QAM</li>
<li>不同子信道可采用不同调制方式。性能较好的子信道应采用频谱利用率高的方式，而衰落较大的子信道应采用功率利用率较高的方式</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI DSP之衰落信道</title>
    <url>/2022/12/01/VLSI%20DSP%E4%B9%8B%E8%A1%B0%E8%90%BD%E4%BF%A1%E9%81%93/</url>
    <content><![CDATA[<p>本节主要介绍了衰落信道的多径效应与多普勒效应，以及相干带宽与相干时间。</p>
<span id="more"></span>
<h1 id="无线信道的多径效应"><a href="#无线信道的多径效应" class="headerlink" title="无线信道的多径效应"></a>无线信道的多径效应</h1><h2 id="1-多径效应的基本概念与产生原因"><a href="#1-多径效应的基本概念与产生原因" class="headerlink" title="1.多径效应的基本概念与产生原因"></a>1.多径效应的基本概念与产生原因</h2><ul>
<li><p><strong>信道的衰落</strong>：无线通信中信道特征的变化，引起接收机接收到的信号强度随时间而变化的现象</p>
</li>
<li><p><strong>多径衰落</strong>：无线通信接收机接收到的多个子径信号所合成的信号，在不同的时间、地点上会时大时小的现象</p>
<p><img src="/2022/12/01/VLSI%20DSP%E4%B9%8B%E8%A1%B0%E8%90%BD%E4%BF%A1%E9%81%93/image-20221201202614344.png" alt="image-20221201202614344" style="zoom:50%;"></p>
</li>
<li><p><strong>多径衰落的原因</strong>：</p>
<ul>
<li><p>发射的电波经历了不同路径，导致传播时间和相位均不相同</p>
</li>
<li><p>合成的接收信号幅度在较短时间内急剧变化，产生了衰落</p>
</li>
</ul>
</li>
<li><p><strong>多径衰落引起了码间串扰</strong></p>
</li>
</ul>
<h2 id="2-时延扩展"><a href="#2-时延扩展" class="headerlink" title="2.时延扩展"></a>2.时延扩展</h2><ul>
<li><p><strong>时延扩展</strong>：时延扩展是对多径信道的统计描述</p>
</li>
<li><p><strong>平均附加时延</strong>：</p>
<script type="math/tex; mode=display">
\bar{\tau}=\frac{\sum_k{P(\tau_k)}\cdot\tau_k}{\sum_{k}P(\tau_k)}</script><script type="math/tex; mode=display">
其中:\tau_k是接收到的第k个时延信号的延迟时间;P(\tau_k)是接收到的第k个时延信号的功率</script><p><img src="/2022/12/01/VLSI%20DSP%E4%B9%8B%E8%A1%B0%E8%90%BD%E4%BF%A1%E9%81%93/image-20221201204327892.png" alt="image-20221201204327892" style="zoom:50%;"></p>
</li>
<li><p><strong>时延扩展的描述方法</strong>：平均附加时延扩展标准差</p>
<script type="math/tex; mode=display">
\sigma_\tau=\tau_{RMS}=\sqrt{\bar{\tau^2}-(\bar{\tau})^2}</script></li>
<li><p><strong>时延扩展小好，其意味着多径信号延迟相当</strong></p>
</li>
</ul>
<h2 id="3-相干带宽"><a href="#3-相干带宽" class="headerlink" title="3.相干带宽"></a>3.相干带宽</h2><ul>
<li><p><strong>相干带宽</strong>：接收信号在频带内任两个频率分量的信号，相关系数不小于0.5</p>
</li>
<li><p><strong>在相干带宽范围内，两个频率分量有很强的相关性</strong></p>
<script type="math/tex; mode=display">
B_c≈\frac{1}{5\sigma_\tau}</script></li>
</ul>
<p><img src="/2022/12/01/VLSI%20DSP%E4%B9%8B%E8%A1%B0%E8%90%BD%E4%BF%A1%E9%81%93/image-20221201204945516.png" alt="image-20221201204945516" style="zoom: 33%;"></p>
<h2 id="4-平衰落与频率选择性衰落"><a href="#4-平衰落与频率选择性衰落" class="headerlink" title="4.平衰落与频率选择性衰落"></a>4.平衰落与频率选择性衰落</h2><ul>
<li><strong>平衰落</strong>：<ul>
<li>在相干带宽内，信号的所有频率分量经历相同的衰落</li>
<li>码间串扰小</li>
<li>条件：信号带宽&lt;相干带宽</li>
</ul>
</li>
<li><strong>频率选择性衰落</strong>：<ul>
<li>在相干带宽外，信号的不同频率分量经历不同的衰落</li>
<li>码间串扰大</li>
<li>条件：信号带宽&lt;相干带宽</li>
</ul>
</li>
</ul>
<p><img src="/2022/12/01/VLSI%20DSP%E4%B9%8B%E8%A1%B0%E8%90%BD%E4%BF%A1%E9%81%93/image-20221201205434545.png" alt="image-20221201205434545" style="zoom:50%;"></p>
<ul>
<li><strong>对抗频率选择性衰落的方法</strong>：<ul>
<li>均衡器</li>
<li>OFDM技术（正交频分复用）</li>
</ul>
</li>
</ul>
<hr>
<h1 id="无线信道的多普勒效应"><a href="#无线信道的多普勒效应" class="headerlink" title="无线信道的多普勒效应"></a>无线信道的多普勒效应</h1><h2 id="1-多普勒频率"><a href="#1-多普勒频率" class="headerlink" title="1.多普勒频率"></a>1.多普勒频率</h2><ul>
<li><p><strong>多普勒频率</strong>：</p>
<script type="math/tex; mode=display">
f_d=\frac{v}{c}f_tcos\theta</script></li>
<li><p><strong>接收信号频率</strong>：</p>
<script type="math/tex; mode=display">
f_r=f_t(1-\frac vccos\theta)</script></li>
<li><p><strong>移动速度增大，多普勒频移变大，导致误码率上升</strong></p>
</li>
</ul>
<h2 id="2-相干时间"><a href="#2-相干时间" class="headerlink" title="2.相干时间"></a>2.相干时间</h2><ul>
<li><strong>无线信道的相干时间</strong>：在此时间间隔内任两个时刻对接收信号的复包络采样，各频率分量信号的相关系数不小于0.5</li>
<li><strong>在相干时间间隔内，接收的信号的幅值有很强的相关性</strong></li>
</ul>
<script type="math/tex; mode=display">
T_c≈\frac{0.5}{f_d}</script><ul>
<li><p><strong>相干时间度量了信道的时变特性</strong></p>
<ul>
<li>相干时间$T_c$大意味着信道变化慢</li>
<li>相干时间$T_c$小意味着信道变化快</li>
</ul>
</li>
<li><p><strong>信号幅值的相干性</strong></p>
<ul>
<li>在相干时间的时间间隔内，接收信号幅值有很强的相关性</li>
<li>在相干时间的时间间隔外，接收信号幅值得相关性不明显</li>
</ul>
<p><img src="/2022/12/01/VLSI%20DSP%E4%B9%8B%E8%A1%B0%E8%90%BD%E4%BF%A1%E9%81%93/image-20221201221409445.png" alt="image-20221201221409445" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="3-快衰落与慢衰落"><a href="#3-快衰落与慢衰落" class="headerlink" title="3.快衰落与慢衰落"></a>3.快衰落与慢衰落</h2><ul>
<li><p><strong>快衰落</strong>：相干时间$T_c$小于码元周期$T_s$，该信道即为快衰落</p>
<script type="math/tex; mode=display">
T_c<T_s</script><ul>
<li><strong>衰落特性将在码元周期内改变多次，误码率提升</strong></li>
</ul>
</li>
<li><p><strong>慢衰落</strong>：相干时间$T_c$大于码元周期$T_s$，该信道即为慢衰落</p>
<script type="math/tex; mode=display">
T_c>T_s</script><ul>
<li><strong>慢衰落信道误码率性能降低的主要原因是信噪比的损失</strong></li>
</ul>
</li>
<li><p><strong>无线信道快衰落的解决办法</strong></p>
<ul>
<li>导频：是在数据帧中加入一段接收端的发射端均已知的数据，估计无线信道特征，用来频偏校正</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI DSP之脉动阵列</title>
    <url>/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/</url>
    <content><![CDATA[<p>本节主要介绍了VLSI DSP中脉动阵列基本概念与设计方法。</p>
<span id="more"></span>
<h1 id="脉动阵列的基本概念"><a href="#脉动阵列的基本概念" class="headerlink" title="脉动阵列的基本概念"></a>脉动阵列的基本概念</h1><ul>
<li><p><strong>脉动架构是在规则依赖图（DG）上，利用线性映射技术来设计的</strong></p>
</li>
<li><p><strong>规则DG</strong>：若在DG中的任意节点沿某方向的一个边代表DG中所有节点沿相同方向的边，称为规则DG</p>
</li>
<li><p>二维坐标系中，节点标号为$(i,j)$，$[1,0]$表示$x$方向，$[0,1]$表示$y$方向</p>
<p><img src="/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20221128204616702.png" alt="image-20221128204616702" style="zoom: 33%;"></p>
</li>
<li><p><strong>矢量定义</strong>：</p>
<ul>
<li>节点标号矢量：$I^T=(i,j)$</li>
<li>投影矢量（迭代矢量）：$d^T=(d_1,d_2)$给出投影方向，长度为该方向上节点间距</li>
<li>PE空间矢量（处理器矢量）：$p^T=(p_1,p_2)$，节点$I^T=(i,j)$被分配到标号为$p^TI=(p_1i+p_2j)$的PE执行</li>
<li>调度矢量：$S^T=(s_1,s_2)$，节点$I$在时刻$s^TI$被PE执行</li>
<li>选择$d^T=(1,0),p^T=(0,1),s^T=(1,0)$，使得$s^Td=1$时，硬件利用率$HUE=\frac1{|s^|}$可以达到100%</li>
</ul>
<p><img src="/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20221128211032383.png" alt="image-20221128211032383" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="脉动阵列的设计方法"><a href="#脉动阵列的设计方法" class="headerlink" title="脉动阵列的设计方法"></a>脉动阵列的设计方法</h1><ul>
<li>绘制算法的规则依赖图（Regular DC）</li>
<li>添加投影、PE空间矢量和调度矢量</li>
<li>边缘映射</li>
<li>构造最终脉动阵列电路</li>
</ul>
<h2 id="1-绘制算法的规则DG"><a href="#1-绘制算法的规则DG" class="headerlink" title="1.绘制算法的规则DG"></a>1.绘制算法的规则DG</h2><p><img src="/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20221128211539791.png" alt="image-20221128211539791" style="zoom:33%;"></p>
<h2 id="2-添加投影、PE空间矢量和调度矢量"><a href="#2-添加投影、PE空间矢量和调度矢量" class="headerlink" title="2.添加投影、PE空间矢量和调度矢量"></a>2.添加投影、PE空间矢量和调度矢量</h2><ul>
<li><p>PE分配：</p>
<script type="math/tex; mode=display">
p^T=(0,1)</script><script type="math/tex; mode=display">
p^TI=j</script><ul>
<li>则说明每个节点的纵坐标就决定着处理器的编号</li>
</ul>
<p><img src="/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20221128213224577.png" alt="image-20221128213224577" style="zoom: 33%;"></p>
</li>
<li><p>调度分配：</p>
<script type="math/tex; mode=display">
S^T=(1,0)</script><script type="math/tex; mode=display">
S^TI=i</script><ul>
<li>则说明每个节点的横坐标就决定着调度的时刻</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20221128214059458.png" alt="image-20221128214059458" style="zoom:50%;"></p>
<h2 id="3-边缘映射"><a href="#3-边缘映射" class="headerlink" title="3.边缘映射"></a>3.边缘映射</h2><p><img src="/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20221128214341690.png" alt="image-20221128214341690" style="zoom:50%;"></p>
<ul>
<li><p>例：</p>
<p><img src="/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20221128214724260.png" alt="image-20221128214724260" style="zoom:50%;"></p>
</li>
<li><p>边缘映射表</p>
</li>
</ul>
<p><img src="/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20221128214822525.png" alt="image-20221128214822525" style="zoom: 50%;"></p>
<h2 id="4-构造最终脉动阵列"><a href="#4-构造最终脉动阵列" class="headerlink" title="4.构造最终脉动阵列"></a>4.构造最终脉动阵列</h2><p><img src="/2022/11/28/VLSI%20DSP%E4%B9%8B%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97/image-20221128215416406.png" alt="image-20221128215416406" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI DSP之折叠</title>
    <url>/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/</url>
    <content><![CDATA[<p>本节主要介绍了VLSI DSP中折叠的基本概念、折叠变换的基本方法（折叠方程）、寄存器最小化技术以及折叠结构的寄存器最小化技术的步骤。</p>
<span id="more"></span>
<h1 id="折叠的基本概念"><a href="#折叠的基本概念" class="headerlink" title="折叠的基本概念"></a>折叠的基本概念</h1><ul>
<li><strong>折叠</strong>：把多个相同运算操作，通过时分复用在单个功能单元上执行，达到资源共享</li>
<li><strong>折叠的目的</strong>：减小功能单元数目，从而减少面积</li>
<li><strong>硬件开销</strong>：功能单元减少为$\frac1N$</li>
<li><strong>速度代价</strong>：处理时间增加为$N$倍</li>
</ul>
<hr>
<h1 id="折叠变换"><a href="#折叠变换" class="headerlink" title="折叠变换"></a>折叠变换</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><ul>
<li><p>考虑节点$U$到$V$延时为$w(e)$的边$U\rightarrow V$，其功能单元分别为$H_u$和$H_v$</p>
</li>
<li><p>折叠因子$N$：折叠到单个功能单元的运算数目</p>
</li>
<li><p>节点$U、V$在硬件中调度执行的时间划分，$0 \sim N-1$</p>
</li>
<li><p>$u、v$是时间分割的顺序标号，节点$U、V$按此顺序被调度执行</p>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125150018589.png" alt="image-20221125150018589" style="zoom:50%;"></p>
</li>
<li><p><strong>折叠集</strong>：执行相同运算功能操作的有序集</p>
<ul>
<li>折叠集中包含N个元素，表示N个运算，其中的一些可能是空运算</li>
<li>折叠集中处于第$j(0,1,\cdots,N-1)$个位置的运算，其在第$j$个时间段执行</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125153228205.png" alt="image-20221125153228205" style="zoom: 33%;"></p>
</li>
</ul>
<h2 id="2-折叠方程"><a href="#2-折叠方程" class="headerlink" title="2.折叠方程"></a>2.折叠方程</h2><script type="math/tex; mode=display">
D_F(U\rightarrow V)=Nw(e)-P_u+v-u</script><ul>
<li>$D_F(U\rightarrow V)$表示有向边$U\rightarrow V$的折叠延时</li>
<li>$N$为折叠因子</li>
<li>$w(e)$为$U\rightarrow V$本来的延时数目、</li>
<li>$p_u$为输入节点的流水线级数</li>
<li>$v$为输出节点调用时刻</li>
<li>$u$为输入节点调用时刻</li>
</ul>
<h2 id="3-画折叠结构"><a href="#3-画折叠结构" class="headerlink" title="3.画折叠结构"></a>3.画折叠结构</h2><ul>
<li><p>设置折叠集的执行顺序，但前提是需使得折叠系统DFG中所有边都必须满足$D_F(U\rightarrow V)\ge0$</p>
</li>
<li><p>根据折叠方程计算所有路径的折叠延时</p>
</li>
<li><p>根据折叠延时画出折叠结构</p>
</li>
<li><p>以Biquad滤波器为例：以N=4为折叠因子进行折叠</p>
<ul>
<li><p>指定两个折叠集：加法折叠集（设置流水线为1），乘法折叠集（设置流水线为2）</p>
<ul>
<li>$S1=\{4,2,3,1\}$：加法运算由同一个硬件加法器执行</li>
<li>$S2=\{5,8,6,7\}$：乘法运算由同一个硬件乘法器执行</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125161428708.png" alt="image-20221125161428708" style="zoom:50%;"></p>
</li>
<li><p>根据折叠方程计算所有边的折叠延时</p>
<script type="math/tex; mode=display">
D_F(1\rightarrow 2)=4\times 1-1+1-3=1</script><script type="math/tex; mode=display">
D_F(1\rightarrow 5)=4\times 1-1+0-3=0</script><script type="math/tex; mode=display">
D_F(1\rightarrow 6)=4\times 1-1+2-3=2</script><script type="math/tex; mode=display">
D_F(1\rightarrow 7)=4\times1 -1+3-3=3</script><script type="math/tex; mode=display">
D_F(1\rightarrow 8)=4\times 2-1+1-3=5</script><script type="math/tex; mode=display">
D_F(3\rightarrow 1)=4\times 0-1+3-2=0</script><script type="math/tex; mode=display">
D_F(4\rightarrow 2)=4\times 0-1+1-0=0</script><script type="math/tex; mode=display">
D_F(5\rightarrow 3)=4\times 0-2+2-0=0</script><script type="math/tex; mode=display">
D_F(6\rightarrow 4)=4\times 1-2+0-2=0</script><script type="math/tex; mode=display">
D_F(7\rightarrow 3)=4\times 1-2+2-3=1</script><script type="math/tex; mode=display">
D_F(8\rightarrow 4)=4\times 1-2+0-1=1</script></li>
<li><p>画折叠结构：先画出基本的运算单元，然后一个节点一个节点的看其输入边的折叠延时{}中表示调用时间</p>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125162417873.png" alt="image-20221125162417873" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="寄存器最小化技术"><a href="#寄存器最小化技术" class="headerlink" title="寄存器最小化技术"></a>寄存器最小化技术</h1><h2 id="1-寿命分析"><a href="#1-寿命分析" class="headerlink" title="1.寿命分析"></a>1.寿命分析</h2><ul>
<li>定义：折叠会插入寄存器，寿命分析是计算用硬件实现DSP算法所需的最少寄存器数的过程</li>
<li>在寿命分析中，算出每个单位时间里的激活变量数，就可以确定任意单位时间里的最大激活变量数，此最大激活变量数则是实现DSP程序所需的最小寄存器数</li>
</ul>
<h2 id="2-线性寿命图"><a href="#2-线性寿命图" class="headerlink" title="2.线性寿命图"></a>2.线性寿命图</h2><ul>
<li>不将变量产生的时钟周期算入激活中</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125164234733.png" alt="image-20221125164234733" style="zoom: 33%;"></p>
<ul>
<li><p>DSP程序通常为周期性的，在考虑迭代时：</p>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125164515049.png" alt="image-20221125164515049" style="zoom: 33%;"></p>
</li>
<li><p>可以仅考虑首次迭代计算出最大激活变量数：</p>
<ul>
<li>因为此时迭代周期N=6，则从第6个时钟周期开始对原有激活数依次加上迭代的激活数直到与上一次数据无重合</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125164641750.png" alt="image-20221125164641750" style="zoom:33%;"></p>
</li>
</ul>
<h2 id="3-寿命表"><a href="#3-寿命表" class="headerlink" title="3.寿命表"></a>3.寿命表</h2><ul>
<li>$T_{input}$：输入时间</li>
<li>$T_{zlout}$：0延时输出时间</li>
<li>$T_{diff}=T_{zlout}-T_{input}$</li>
<li>$T_{lat}=T_{diff}最大负值的绝对值$</li>
<li>$T_{output}=T_{zlout}+T_{lat}$：输出时间</li>
<li>寿命：$T_{input}\sim T_{output}$</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125165548613.png" alt="image-20221125165548613"></p>
<ul>
<li><p>根据寿命表求得的每个变量的寿命，画出线性寿命图从而求出最大激活寄存器数：</p>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125170527456.png" alt="image-20221125170527456"></p>
</li>
</ul>
<h2 id="4-前向-后向分配技术"><a href="#4-前向-后向分配技术" class="headerlink" title="4.前向-后向分配技术"></a>4.前向-后向分配技术</h2><ul>
<li>按逐级前项移位的方式进行数据的传播，直至数据被用到输出端</li>
<li>$R1、R2、R3、R4$表示四个寄存器</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125171058471.png" alt="image-20221125171058471" style="zoom:50%;"></p>
<ul>
<li>通过上述寄存器分配表可以得到折叠后的架构为：</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125173030231.png" alt="image-20221125173030231" style="zoom:50%;"></p>
<hr>
<h1 id="折叠结构的寄存器最小化"><a href="#折叠结构的寄存器最小化" class="headerlink" title="折叠结构的寄存器最小化"></a>折叠结构的寄存器最小化</h1><ul>
<li><strong>当折叠延迟存在负数时，按以下六个步骤完成折叠架构的寄存器最小化设计</strong>：<ul>
<li>进行折叠的重定时</li>
<li>写出折叠方程</li>
<li>用折叠方程构造寿命表</li>
<li>画出寿命图并确定所需寄存器数</li>
<li>进行前向-后向寄存器分配</li>
<li>画出最小寄存器数的折叠架构</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125174927346.png" alt="image-20221125174927346" style="zoom:50%;"></p>
<h2 id="1-进行折叠的重定时"><a href="#1-进行折叠的重定时" class="headerlink" title="1.进行折叠的重定时"></a>1.进行折叠的重定时</h2><p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125175024284.png" alt="image-20221125175024284"></p>
<h2 id="2-写出折叠方程"><a href="#2-写出折叠方程" class="headerlink" title="2.写出折叠方程"></a>2.写出折叠方程</h2><p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125175059168.png" alt="image-20221125175059168" style="zoom:50%;"></p>
<h2 id="3-用折叠方程构造寿命表"><a href="#3-用折叠方程构造寿命表" class="headerlink" title="3.用折叠方程构造寿命表"></a>3.用折叠方程构造寿命表</h2><ul>
<li>$T_{output}=T_{input}+max\{D_F(U\rightarrow V)\}$</li>
<li>$T_{input}=u+P_u(流水线级数)$</li>
<li>寿命：$T_{input}\sim T_{output}$</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125175419249.png" alt="image-20221125175419249" style="zoom:50%;"></p>
<h2 id="4-画出寿命图并确定所需寄存器数"><a href="#4-画出寿命图并确定所需寄存器数" class="headerlink" title="4.画出寿命图并确定所需寄存器数"></a>4.画出寿命图并确定所需寄存器数</h2><ul>
<li>则所需最小寄存器数为2</li>
</ul>
<p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125180022852.png" alt="image-20221125180022852" style="zoom:50%;"></p>
<h2 id="5-进行前向-后向寄存器分配"><a href="#5-进行前向-后向寄存器分配" class="headerlink" title="5.进行前向-后向寄存器分配"></a>5.进行前向-后向寄存器分配</h2><p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125180827165.png" alt="image-20221125180827165" style="zoom:50%;"></p>
<h2 id="6-画出最小寄存器数的折叠架构"><a href="#6-画出最小寄存器数的折叠架构" class="headerlink" title="6.画出最小寄存器数的折叠架构"></a>6.画出最小寄存器数的折叠架构</h2><p><img src="/2022/11/25/VLSI%20DSP%E4%B9%8B%E6%8A%98%E5%8F%A0/image-20221125181444059.png" alt="image-20221125181444059"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI DSP之展开</title>
    <url>/2022/11/24/VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>本节主要介绍了VLSI DSP中展开这一方法的基本概念与性质。</p>
<span id="more"></span>
<h1 id="展开的基本概念"><a href="#展开的基本概念" class="headerlink" title="展开的基本概念"></a>展开的基本概念</h1><ul>
<li><p>展开：是一种转换技术，它产生一个新的程序来描述原有程序的多次迭代，J称为展开因子，表示迭代次数</p>
<p><img src="/2022/11/24/VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/image-20221124153356266.png" alt="image-20221124153356266"></p>
</li>
<li><p><strong>展开方法</strong>：</p>
<ul>
<li><p>符号：</p>
<ul>
<li>$\lfloor x \rfloor$：表示对x向下取整，即取小于或等于x的最大整数</li>
<li>$\lceil x \rceil$：表示对x向上取整，即取大于或等于x的最大整数</li>
<li>$a \% b$：表示a除以b的余数，其中a和b是整数</li>
</ul>
</li>
<li><p>J阶展开DFG的节点与边：</p>
<ul>
<li>节点U：有J个具有相同功能的节点$U_i(i=0,1,\cdots,j-1)$</li>
<li>边：有J条相应的边</li>
<li>即：J阶展开后的DFG总是包含了相当于原始DFG的J倍数量的节点和边</li>
</ul>
</li>
<li><p><strong>构建一个J阶展开DFG</strong>：</p>
<ul>
<li><p>对原始DFG中的每个节点U，画J个节点$U_0,U1,\cdots,U_{J-1}$</p>
</li>
<li><p>对原始DFG中的每个延时为w的边$U\rightarrow V$，画延时为：</p>
<script type="math/tex; mode=display">
W_{new}=\lfloor \frac{(i+w)}{J} \rfloor的J个边U_i\rightarrow V_{(i+w)\%J}(i=0,1,\cdots,J-1)</script></li>
</ul>
</li>
</ul>
</li>
<li><p>例：3阶展开</p>
<p><img src="/2022/11/24/VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/image-20221124162001562.png" alt="image-20221124162001562" style="zoom: 33%;"></p>
</li>
</ul>
<p><img src="/2022/11/24/VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/image-20221124160629482.png" alt="image-20221124160629482" style="zoom: 33%;"></p>
<p><img src="/2022/11/24/VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/image-20221124160847869.png" alt="image-20221124160847869" style="zoom: 50%;"></p>
<p><img src="/2022/11/24/VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/image-20221124161717499.png" alt="image-20221124161717499" style="zoom:50%;"></p>
<hr>
<h1 id="展开的基本性质"><a href="#展开的基本性质" class="headerlink" title="展开的基本性质"></a>展开的基本性质</h1><ul>
<li><p>展开保留原DFG中各边的优先约束</p>
</li>
<li><p>展开保持原DFG中个边的延迟数</p>
</li>
<li><p><strong>展开对关键路径的影响</strong>：</p>
<ul>
<li>原图G中$w&lt;J$的边在J阶展开中生成$J-w$条无延迟的边和$w$条延迟为1的边（无延迟边的增加意味着关键路径可能增加导致时钟周期增加、频率降低）</li>
<li>原图G中$w\ge J$的边在J阶展开中生成J条延迟$\ge1$的边，不会生成无延迟边，则不会增加关键路径</li>
</ul>
</li>
<li><p><strong>展开环路的影响</strong>：</p>
<ul>
<li>原图G中延时为$w_l$的环路l，在J阶展开中有$gcd(w_l,J)$（gcd为最大公约数）个环路，每个环路包含了$\frac{w_1}{gcd(w_1,J)}$个延迟</li>
<li>展开环路使得迭代边界增加：迭代边界为$T_{\infty}$的原图G中的J阶展开的迭代边界为$JT_{\infty}$</li>
</ul>
</li>
<li><p>例：</p>
<p><img src="/2022/11/24/VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/image-20221124165812147.png" alt="image-20221124165812147" style="zoom: 33%;"></p>
<p><img src="/2022/11/24/VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/image-20221124165945249.png" alt="image-20221124165945249" style="zoom: 33%;"></p>
</li>
<li><p><strong>提高采样速度，让采样周期逼近原始环路的迭代边界（展开后的关键路径等于迭代边界），实现性能极限</strong></p>
<ul>
<li><p>情况1：原始DFG中存在节点的计算时间$T_U&gt;T_{\infty}$</p>
<ul>
<li>此时：<script type="math/tex; mode=display">
J=\lceil \frac{T_U}{T_\infty}\rceil</script></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>&lt;img src=&quot;VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/image-20221124172334012.png&quot; alt=&quot;image-20221124172334012&quot; style=&quot;zoom: 33%;&quot; /&gt;
</code></pre><ul>
<li><p>情况2：迭代边界$T_{\infty}$不是整数</p>
<ul>
<li>此时：<script type="math/tex; mode=display">
J=\frac{w_l}{gcd(T_l,w_l)},T_l为环路的执行时间，w_l为环路的延时</script></li>
</ul>
<p><img src="/2022/11/24/VLSI%20DSP%E4%B9%8B%E5%B1%95%E5%BC%80/image-20221124172952295.png" alt="image-20221124172952295" style="zoom:33%;"></p>
</li>
<li><p>情况3：最长的节点计算时间大于迭代边界$T_{\infty}$，同时$T_{\infty}$也不是整数（情况1、2的混合）</p>
<ul>
<li><p>此时：</p>
<script type="math/tex; mode=display">
J\times T_{\infty}=整数</script><script type="math/tex; mode=display">
J\times T_{\infty}\ge T_u</script><p>通过满足上述不等式求得最小的$J$</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/</url>
    <content><![CDATA[<p>本节主要介绍了毫米波雷达的测距测速测角的原理，以及距离分辨率、速度分辨率、角度分辨率等。</p>
<span id="more"></span>
<h1 id="距离测量与距离分辨率"><a href="#距离测量与距离分辨率" class="headerlink" title="距离测量与距离分辨率"></a>距离测量与距离分辨率</h1><h2 id="1-测距原理"><a href="#1-测距原理" class="headerlink" title="1.测距原理"></a>1.测距原理</h2><ul>
<li>采用频率线性调制的连续波</li>
</ul>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124102606989.png" alt="image-20221124102606989" style="zoom:50%;"></p>
<ul>
<li><p>将回波信号与发射信号的差称为中频信号（IF signal）</p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124102943161.png" alt="image-20221124102943161" style="zoom: 67%;"></p>
<ul>
<li><p>则雷达前方的单个物体产生恒定频率的中频信号，其频率为 （根据雷达原理之目标距离测量中的三角波测距原理可推导出来）：</p>
<script type="math/tex; mode=display">
f=\frac{2Sd}{C}</script><script type="math/tex; mode=display">
其中:S=\frac B{T_c},d为目标到雷达的初始距离</script></li>
</ul>
</li>
</ul>
<h2 id="2-距离分辨率"><a href="#2-距离分辨率" class="headerlink" title="2.距离分辨率"></a>2.距离分辨率</h2><ul>
<li><p>根据傅里叶相关知识可知：<strong>观察周期越长，分辨率越高。观察周期T可以分辨出频率相差至少为$\frac1T$的信号</strong></p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124103901261.png" alt="image-20221124103901261"></p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124104010016.png" alt="image-20221124104010016"></p>
</li>
<li><p>根据上述傅里叶知识，通过下面分析可知，<strong>想要T越长，则B需扩大，故说明B越大，距离分辨率越小</strong></p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124104342227.png" alt="image-20221124104342227" style="zoom:50%;"></p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124104537072.png" alt="image-20221124104537072"></p>
</li>
<li><p>距离分辨率$d_{res}$的推导：</p>
<script type="math/tex; mode=display">
\Delta f=\frac{2S\Delta d}{C}</script><script type="math/tex; mode=display">
\Delta f>\frac1{T_c}</script><script type="math/tex; mode=display">
\frac{2S\Delta d}{C}>\frac1{T_c}</script><script type="math/tex; mode=display">
\Delta d>\frac{C}{2ST_c}</script><script type="math/tex; mode=display">
\Delta d>\frac{C}{2B}</script><script type="math/tex; mode=display">
故距离分辨率为：d_{res}=\frac C{2B}</script></li>
</ul>
<ul>
<li><strong>说明B越大，距离分辨率越好</strong></li>
</ul>
<h2 id="3-中频信号的最大带宽"><a href="#3-中频信号的最大带宽" class="headerlink" title="3.中频信号的最大带宽"></a>3.中频信号的最大带宽</h2><p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221125100340762.png" alt="image-20221125100340762" style="zoom:50%;"></p>
<script type="math/tex; mode=display">
f_{IF{\_max}}=\frac{2Sd_{max}}{C}</script><ul>
<li><p>其中$f_{IF_max}$表示中频信号的最大带宽</p>
</li>
<li><p>$d_{max}$表示想要的雷达最大测距范围</p>
</li>
<li><p>故<strong>对于给定的$T_c$通常需要在最大测距范围与距离分辨率之间做取舍</strong></p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221125100647111.png" alt="image-20221125100647111"></p>
</li>
</ul>
<hr>
<h1 id="速度测量与速度分辨率"><a href="#速度测量与速度分辨率" class="headerlink" title="速度测量与速度分辨率"></a>速度测量与速度分辨率</h1><h2 id="1-测速原理"><a href="#1-测速原理" class="headerlink" title="1.测速原理"></a>1.测速原理</h2><ul>
<li><p>根据傅里叶相关知识可知：<strong>傅里叶变换后的峰值的相位就等于正弦曲线的初始相位</strong></p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221125100748513.png" alt="image-20221125100748513" style="zoom:50%;"></p>
</li>
<li><p><strong>如果物体相对初始位置运动了，那么初始相位会发生变化</strong>：</p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124105636971.png" alt="image-20221124105636971" style="zoom: 50%;"></p>
</li>
<li><p>变化的相位大小为：</p>
<script type="math/tex; mode=display">
\Delta\Phi=2\pi f_c\Delta\tau=\frac{4\pi\Delta d}{\lambda}</script></li>
<li><p>则速度测量方法为：</p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124111018206.png" alt="image-20221124111018206" style="zoom:67%;"></p>
<ul>
<li><p>间隔时间$T_c$发送两个线性调频脉冲</p>
</li>
<li><p>其中每个线性调频脉冲对应的FFT在相同的位置具有峰值，但其具有不同的相位</p>
</li>
<li><p>设物体的运动速度为$v$，则在$T_c$时间内变化的距离为$vT_c$，故有：</p>
<script type="math/tex; mode=display">
\Delta\Phi=\frac{4\pi \Delta d}{\lambda}=\frac{4\pi vT_c}{\lambda}</script><script type="math/tex; mode=display">
则:v=\frac{\lambda\Delta\Phi}{4\pi T_c}</script></li>
</ul>
</li>
<li><p><strong>$\Delta d$对频率差影响很小，却对相位差影响很大</strong></p>
</li>
</ul>
<h2 id="2-最大速度"><a href="#2-最大速度" class="headerlink" title="2.最大速度"></a>2.最大速度</h2><ul>
<li><p>通过测量相位差进而计算速度，只有当相位差位于$-\pi \sim \pi$时才能正确测得速度，否则会产生模糊，不知道目标是远离雷达还是靠近雷达</p>
<ul>
<li>$w&gt;0$：目标远离雷达</li>
<li>$w&lt;0$：目标靠近雷达</li>
</ul>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124132439341.png" alt="image-20221124132439341"></p>
</li>
<li><p>则需满足$|w|&lt;\pi$，即：</p>
<script type="math/tex; mode=display">
\frac{4\pi vT_c}{\lambda}<\pi \Rightarrow v<\frac\lambda{4T_c}</script></li>
<li><p>故最大速度$v_{max}$为：</p>
<script type="math/tex; mode=display">
v_{max}=\frac{\lambda}{4T_c}</script></li>
<li><p><strong>说明$T_c$越小，最大无模糊速度才越大</strong></p>
</li>
</ul>
<h2 id="3-速度分辨率"><a href="#3-速度分辨率" class="headerlink" title="3.速度分辨率"></a>3.速度分辨率</h2><ul>
<li><p>若离散信号中的每个样本的相位以$w$的恒定速率旋转，那么这一系列样本点进行FFT将产生一个峰值，峰值对应于$w$</p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124131017264.png" alt="image-20221124131017264" style="zoom:50%;"></p>
</li>
<li><p><strong>序列长度越长，分辨率就越高，序列为N的样本点，可以用来分辨旋转角频率相至少差为$\frac {2\pi}{N}$的两个相量</strong></p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124131535976.png" alt="image-20221124131535976" style="zoom:50%;"></p>
</li>
<li><p><strong>当出现多个目标时，通过发送一系列等间隔的线性调频脉冲，对得到的中频信号进行FFT获取多个目标的各自相位差</strong></p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124134317909.png" alt="image-20221124134317909" style="zoom:50%;"></p>
<ul>
<li><p>根据测速原理中的公式，有：</p>
<script type="math/tex; mode=display">
v_1=\frac{\lambda w_1}{4\pi T_c}</script><script type="math/tex; mode=display">
v_2=\frac{\lambda w_2}{4\pi T_c}</script></li>
</ul>
</li>
<li><p>速度分辨率$v_{res}$的推导：</p>
<script type="math/tex; mode=display">
\Delta w=\frac{4\pi \Delta v T_c}{\lambda}</script><script type="math/tex; mode=display">
\Delta w>\frac{2\pi}{N}</script><script type="math/tex; mode=display">
\Delta v>\frac{\lambda}{2NT_c}</script><script type="math/tex; mode=display">
则速度分辨率为:V_{res}=\frac\lambda{2T_f}</script><p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221124135511793.png" alt="image-20221124135511793" style="zoom:50%;"></p>
</li>
<li><p><strong>说明$T_f$越大，速度分辨率越好</strong></p>
</li>
</ul>
<hr>
<h1 id="角度测量与角度分辨率"><a href="#角度测量与角度分辨率" class="headerlink" title="角度测量与角度分辨率"></a>角度测量与角度分辨率</h1><h2 id="1-测角原理"><a href="#1-测角原理" class="headerlink" title="1.测角原理"></a>1.测角原理</h2><p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221125104800371.png" alt="image-20221125104800371" style="zoom:50%;"></p>
<ul>
<li><p>假设两天线之间的距离$d$，远远小于目标到振源的距离，则可以认为到达接收点的目标所反射的电磁波近似为平面波。</p>
</li>
<li><p>目标到$A，B$两点的距离相等，回波到$A，B$两点的相位也相等，回波到接收点的距离相差$dsin(θ)$，对应相位相差$\phi$，有：</p>
<script type="math/tex; mode=display">
\frac{\phi}{2\pi}=\frac{dsin\theta}{\lambda}\Rightarrow \phi=\frac{2\pi dsin\theta}{\lambda}\Rightarrow\theta=arcsin(\frac{\phi\lambda}{2\pi d})</script></li>
<li><p>则<strong>测量相位差$\phi$就能测量角度了</strong></p>
</li>
</ul>
<h2 id="2-最大角度"><a href="#2-最大角度" class="headerlink" title="2.最大角度"></a>2.最大角度</h2><ul>
<li><p>当$ϕ∈[−π,π]$时，$θ$取值无模糊。$θ$对应的取值范围$[−θ_{max},θ_{max}]$</p>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221125105447209.png" alt="image-20221125105447209"></p>
</li>
<li><p>则<strong>最大测角范围</strong>，由$\phi=\frac{2\pi dsin\theta}{\lambda}$可得：</p>
<script type="math/tex; mode=display">
\theta_{max}=arcsin(\frac{\lambda}{2d})</script></li>
<li><p><strong>从上式可知，只要$d$越小，对应的$θ_{max}$就越大。则短基线保证大的无模糊测角范围。</strong></p>
</li>
</ul>
<h2 id="3-角度分辨率"><a href="#3-角度分辨率" class="headerlink" title="3.角度分辨率"></a>3.角度分辨率</h2><ul>
<li><strong>当出现多个目标时，通过一系列等间隔为d的接收机接收信号，对得到的中频信号进行FFT变化获取多个目标的雷达接收机之间各自相位差</strong></li>
</ul>
<p><img src="/2022/11/24/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/image-20221125105748152.png" alt="image-20221125105748152" style="zoom:50%;"></p>
<script type="math/tex; mode=display">
\theta_1=arcsin(\frac{\lambda w_1}{2\pi d})</script><script type="math/tex; mode=display">
\theta_2=arcsin(\frac{\lambda w_2}{2\pi d})</script><ul>
<li><p>角度分辨率$\theta_{res}$的推导：</p>
<script type="math/tex; mode=display">
\Delta w=\frac{2\pi d}{\lambda}(sin(\theta+\Delta\theta)-sin(\theta))≈\frac{2\pi d}{\lambda}cos(\theta)\Delta\theta</script><script type="math/tex; mode=display">
\Delta w>\frac{2\pi}{N}</script><script type="math/tex; mode=display">
\frac{2\pi d}{\lambda}cos(\theta)\Delta\theta>\frac{2\pi}{N}</script><script type="math/tex; mode=display">
\Delta\theta>\frac{\lambda}{Ndcos(\theta)}</script><script type="math/tex; mode=display">
则角度分辨率为:\theta_{res}=\frac{\lambda}{Ndcos(\theta)}</script></li>
<li><p><strong>说明$Nd$越大，角度分辨率越好</strong>                             </p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI DSP之重定时</title>
    <url>/2022/11/23/VLSI%20DSP%E4%B9%8B%E9%87%8D%E5%AE%9A%E6%97%B6/</url>
    <content><![CDATA[<p>本节主要介绍了VLSI DSP中重定时的基本概念及其使用方法，包括割重定时与K倍降速。</p>
<span id="more"></span>
<h1 id="重定时的基本概念"><a href="#重定时的基本概念" class="headerlink" title="重定时的基本概念"></a>重定时的基本概念</h1><ul>
<li><p><strong>重定时（Retiming）</strong>：是一种变换技术，在不改变系统的输入输出特性的前提下，改变电路延迟元件的配置</p>
</li>
<li><p>延时单元可以在所有输出与所有输入之间移动：</p>
<ul>
<li><strong>改变关键路径，从而提高时钟频率</strong></li>
<li><strong>改变寄存器数量，从而能够减小面积</strong></li>
<li><strong>不改变环路中的延迟</strong></li>
<li><strong>不改变迭代边界</strong></li>
</ul>
</li>
<li><p>重定时后电路功能不变：</p>
<p><img src="/2022/11/23/VLSI%20DSP%E4%B9%8B%E9%87%8D%E5%AE%9A%E6%97%B6/image-20221123193816893.png" alt="image-20221123193816893" style="zoom:50%;"></p>
<script type="math/tex; mode=display">
左图:w(n)=ay(n-1)+by(n-2)</script><script type="math/tex; mode=display">
y(n)=x(n)+w(n-1)=x(n)+ay(n-2)+by(n-3)</script><script type="math/tex; mode=display">
右图:w_1(n)=ay(n-1)</script><script type="math/tex; mode=display">
w_2(n)=by(n-2)</script><script type="math/tex; mode=display">
y(n)=x(n)+w_1(n-1)+w_2(n-1)=x(n)+ay(n-2)+by(n-3)</script></li>
</ul>
<hr>
<h1 id="重定时求解方法"><a href="#重定时求解方法" class="headerlink" title="重定时求解方法"></a>重定时求解方法</h1><h2 id="1-割集重定时"><a href="#1-割集重定时" class="headerlink" title="1.割集重定时"></a>1.割集重定时</h2><ul>
<li><strong>若在一个方向的边上增加延时，则在另外方向的边上减少同样的延时</strong></li>
</ul>
<p><img src="/2022/11/23/VLSI%20DSP%E4%B9%8B%E9%87%8D%E5%AE%9A%E6%97%B6/image-20221123203257658.png" alt="image-20221123203257658" style="zoom:50%;"></p>
<ul>
<li><p>重定时前：关键路径为$T_M+T_A=3ut$，延时单元为4</p>
</li>
<li><p>重定时后：关键路径为$T_M+2T_A=4ut$，延时单元为5</p>
</li>
</ul>
<h2 id="2-节点重定时"><a href="#2-节点重定时" class="headerlink" title="2.节点重定时"></a>2.节点重定时</h2><p><img src="/2022/11/23/VLSI%20DSP%E4%B9%8B%E9%87%8D%E5%AE%9A%E6%97%B6/image-20221123203944106.png" alt="image-20221123203944106" style="zoom:50%;"></p>
<ul>
<li><p>重定时前：关键路径为$T_M+T_A=3ut$，延时单元为4</p>
</li>
<li><p>重定时后：关键路径为$T_M=2ut$，延时单元为5</p>
</li>
</ul>
<h2 id="3-重定时的数学求解"><a href="#3-重定时的数学求解" class="headerlink" title="3.重定时的数学求解"></a>3.重定时的数学求解</h2><ul>
<li><p>用有向图G表示电路：</p>
<ul>
<li>节点：表示算法中功能的执行，包含计算时间（数字）</li>
<li>有向边：表示节点间通信关系</li>
<li>权重：表示有向边的寄存器数</li>
</ul>
<p><img src="/2022/11/23/VLSI%20DSP%E4%B9%8B%E9%87%8D%E5%AE%9A%E6%97%B6/image-20221123204514343.png" alt="image-20221123204514343" style="zoom:50%;"></p>
</li>
<li><p>重定时值$r(v)$：</p>
<script type="math/tex; mode=display">
r(v)=0 \Rightarrow 不操作</script><script type="math/tex; mode=display">
r(v)>0 \Rightarrow 节点的每条输入边增加r(v)延时，同时节点的每条输出边减少r(v)延时</script><script type="math/tex; mode=display">
r(v)<0 \Rightarrow 节点的每条输入边减少r(v)延时，同时节点的每条输出边增加r(v)延时</script></li>
<li><p><strong>重定时方程：用来确定节点u到u——&gt;v重定时后的权重</strong></p>
<script type="math/tex; mode=display">
w_r(e)=w(e)+r(v)-r(u),w_r(e)\ge0</script><p><img src="/2022/11/23/VLSI%20DSP%E4%B9%8B%E9%87%8D%E5%AE%9A%E6%97%B6/image-20221123205429536.png" alt="image-20221123205429536" style="zoom:50%;"></p>
<ul>
<li>$w(e)$为原始权重</li>
<li>$r(v)$为目的节点的重定时值</li>
<li>$r(u)$为原始节点的重定时值</li>
</ul>
<p><img src="/2022/11/23/VLSI%20DSP%E4%B9%8B%E9%87%8D%E5%AE%9A%E6%97%B6/image-20221123211240138.png" alt="image-20221123211240138" style="zoom: 33%;"></p>
<ul>
<li>对于重定时的求解，需结合$w_r(e)\ge 0$以及设定多个目标，比如系统时钟周期和寄存器个数等，在此不等式方程组的约束条件下，搜索出使得规定目标最小化的解</li>
</ul>
</li>
</ul>
<h2 id="4-K倍降速与割集重定时"><a href="#4-K倍降速与割集重定时" class="headerlink" title="4.K倍降速与割集重定时"></a>4.K倍降速与割集重定时</h2><ul>
<li><p>首先用K个延时取代DFG中的每个延时，以产生DFG的K倍减速系统，然后对K倍减速的DFG进行割集重定时</p>
<p><img src="/2022/11/23/VLSI%20DSP%E4%B9%8B%E9%87%8D%E5%AE%9A%E6%97%B6/image-20221123213823901.png" alt="image-20221123213823901" style="zoom:50%;"></p>
<p><img src="/2022/11/23/VLSI%20DSP%E4%B9%8B%E9%87%8D%E5%AE%9A%E6%97%B6/image-20221123213844651.png" alt="image-20221123213844651" style="zoom:50%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之常见变换</title>
    <url>/2022/11/22/MATLAB%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>本节主要介绍了MATLAB中常见的变换，包括Laplace变化、Fourier变换、Z变换。此外还介绍了双线性变换映射与部分分式展开。</p>
<span id="more"></span>
<h1 id="Laplace变换"><a href="#Laplace变换" class="headerlink" title="Laplace变换"></a>Laplace变换</h1><h2 id="1-正变换"><a href="#1-正变换" class="headerlink" title="1.正变换"></a>1.正变换</h2><ul>
<li><code>laplace(f)</code> </li>
<li><code>laplace(f,u)</code> %u为频域变量（默认为s）</li>
<li><code>laplace(f,v,u)</code> %v为时域变量（默认为t），u为s域变量（默认为s）</li>
</ul>
<p><img src="/2022/11/22/MATLAB%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2/image-20221122164008424.png" alt="image-20221122164008424" style="zoom:50%;"></p>
<h2 id="2-逆变换"><a href="#2-逆变换" class="headerlink" title="2.逆变换"></a>2.逆变换</h2><ul>
<li><code>ilaplace(f)</code> </li>
<li><code>ilaplace(f,u)</code> %u为时域变量（默认为t）</li>
<li><code>ilaplace(f,v,u)</code> %v为s域变量（默认为s），u为时域变量（默认为t）</li>
</ul>
<p><img src="/2022/11/22/MATLAB%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2/image-20221122164654944.png" alt="image-20221122164654944" style="zoom:50%;"></p>
<hr>
<h1 id="Fourier变换"><a href="#Fourier变换" class="headerlink" title="Fourier变换"></a>Fourier变换</h1><h2 id="1-正变换-1"><a href="#1-正变换-1" class="headerlink" title="1.正变换"></a>1.正变换</h2><ul>
<li><code>fourier(f)</code> </li>
<li><code>fourier(f,u)</code> %u为频域变量（默认为w）</li>
<li><code>fourier(f,v,u)</code> %v为时域变量（默认为x），u为频域变量（默认为w）</li>
</ul>
<p><img src="/2022/11/22/MATLAB%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2/image-20221122170731312.png" alt="image-20221122170731312" style="zoom:50%;"></p>
<h2 id="2-逆变换-1"><a href="#2-逆变换-1" class="headerlink" title="2.逆变换"></a>2.逆变换</h2><ul>
<li><code>ifourier(f)</code> </li>
<li><code>ifourier(f,u)</code> %u为时域变量（默认为x）</li>
<li><code>ifourier(f,v,u)</code> %v为频域变量（默认为w），u为时域变量（默认为x）</li>
</ul>
<p><img src="/2022/11/22/MATLAB%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2/image-20221122171206600.png" alt="image-20221122171206600" style="zoom:50%;"></p>
<hr>
<h1 id="Z变换"><a href="#Z变换" class="headerlink" title="Z变换"></a>Z变换</h1><h2 id="1-正变换-2"><a href="#1-正变换-2" class="headerlink" title="1.正变换"></a>1.正变换</h2><ul>
<li><code>ztrans(f)</code> %n从零到无穷大</li>
<li><code>ztrans(f,u)</code> %u为z域变量（默认为z）</li>
<li><code>ztrans(f,v,u)</code> %v为时域变量（默认为n），u为z域变量（默认为z）</li>
</ul>
<p><img src="/2022/11/22/MATLAB%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2/image-20221122173617246.png" alt="image-20221122173617246" style="zoom:50%;"></p>
<h2 id="2-逆变换-2"><a href="#2-逆变换-2" class="headerlink" title="2.逆变换"></a>2.逆变换</h2><ul>
<li><code>iztrans(f)</code> </li>
<li><code>iztrans(f,u)</code> %u为时域变量（默认为n）</li>
<li><code>iztrans(f,v,u)</code> %v为z域变量（默认为z），u为时域变量（默认为n）</li>
</ul>
<p><img src="/2022/11/22/MATLAB%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2/image-20221122173927328.png" alt="image-20221122173927328" style="zoom:50%;"></p>
<hr>
<h1 id="复数映射"><a href="#复数映射" class="headerlink" title="复数映射"></a>复数映射</h1><ul>
<li><p><code>subs(f,old,new)</code></p>
</li>
<li><p>双线性变换映射</p>
<p><img src="/2022/11/22/MATLAB%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2/image-20221122203518642.png" alt="image-20221122203518642" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="部分分式展开"><a href="#部分分式展开" class="headerlink" title="部分分式展开"></a>部分分式展开</h1><ul>
<li><code>partfrac(f,var)</code> %var代表变量，对哪一个变量部分分式展开</li>
</ul>
<p><img src="/2022/11/22/MATLAB%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2/image-20221122204914502.png" alt="image-20221122204914502" style="zoom:50%;"></p>
<hr>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI DSP之流水线与并行处理</title>
    <url>/2022/11/22/VLSI%20DSP%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>本节主要介绍了VLSI DSP中的流水线与并行处理技术，以提高处理效率或降低功耗。</p>
<span id="more"></span>
<h1 id="并行处理技术"><a href="#并行处理技术" class="headerlink" title="并行处理技术"></a>并行处理技术</h1><ul>
<li><p>以三抽头的滤波器为例：$y(n)=b_0x(n)+b_1x(n-1)+b_2x(n-2)$</p>
<p><img src="/2022/11/22/VLSI%20DSP%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/image-20221122112136499.png" alt="image-20221122112136499" style="zoom:50%;"></p>
<ul>
<li>在下一个时钟周期计算$y(n+1)=b_0x(n+1)+b_1x(n)+b_2x(n-1)$</li>
</ul>
</li>
<li><p>三抽头滤波器的两级并行：用$2k$代替上面两式中的$n$</p>
<script type="math/tex; mode=display">
y(2k)=b_0x(2k)+b_1x(2k-1)+b_2x(2k-2)</script><script type="math/tex; mode=display">
y(2k+1)=b_0x(2k+1)+b_1x(2k)+b_2x(2k-1)</script><p><img src="/2022/11/22/VLSI%20DSP%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/image-20221122113600626.png" alt="image-20221122113600626" style="zoom: 50%;"></p>
</li>
<li><p>三抽头滤波器的三级并行：</p>
<p><img src="/2022/11/22/VLSI%20DSP%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/image-20221122113651121.png" alt="image-20221122113651121" style="zoom: 50%;"></p>
</li>
<li><p><strong>并行处理技术的特点</strong>：</p>
<ul>
<li>并行处理系统的关键路径保持不变</li>
<li>L级并行处理的一个时钟周期处理L个样点，则迭代（或采样）周期缩小为$\frac1L$</li>
<li>L级并行系统的时钟周期：$T_{clk}=LT_{sample}$</li>
<li>时钟频率不变</li>
</ul>
</li>
</ul>
<hr>
<h1 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h1><ul>
<li><p><strong>技术关键</strong>：通过在数据通路中插入寄存器，减少关键路径长度，从而提高时钟频率</p>
<p><img src="/2022/11/22/VLSI%20DSP%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/image-20221122114600063.png" alt="image-20221122114600063" style="zoom: 33%;"></p>
</li>
<li><p><strong>割集与前馈割集</strong>：</p>
<ul>
<li>割集：是图的一组边，若从图中移走这些边，则图被拆分为互不相连的两个子图或孤立节点</li>
<li>前馈割集：数据沿割集所有同向移动，即割出来的边要么都是输入边要么都是输出边</li>
</ul>
<p><img src="/2022/11/22/VLSI%20DSP%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/image-20221122121628662.png" alt="image-20221122121628662" style="zoom: 67%;"></p>
</li>
<li><p><strong>流水线技术是在前馈割集所有边插入寄存器，减少关键路径</strong></p>
<p><img src="/2022/11/22/VLSI%20DSP%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/image-20221122122236342.png" alt="image-20221122122236342" style="zoom:50%;"></p>
</li>
<li><p><strong>流水线的优缺点</strong>：</p>
<ul>
<li>优点：缩短关键路径、提高时钟频率</li>
<li>缺点：增加寄存器的硬件开销，增加输出延迟</li>
</ul>
</li>
<li><p><strong>在M级流水线系统中，从输入到输出任一路径的延迟数比原系统中一路径的延迟数多</strong>$(M-1)$</p>
</li>
</ul>
<hr>
<h1 id="流水线技术降低功耗"><a href="#流水线技术降低功耗" class="headerlink" title="流水线技术降低功耗"></a>流水线技术降低功耗</h1><p><img src="/2022/11/22/VLSI%20DSP%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/image-20221122144527682.png" alt="image-20221122144527682" style="zoom:50%;"></p>
<ul>
<li><p>流水线技术斩断了原始系统的有效关键路径，也相当于分解了原始系统的有效关键路径充电电容。约定以下符号：</p>
</li>
<li><p>$C_{o-charge}$：为旧电路关键路径上的等价充放电电容，上图的整段红线所代表的电容</p>
</li>
<li><p>$C_{n-charge}$：为新电路关键路径上的等价充放电电容，上图一小段蓝线所代表的电容</p>
</li>
<li><p>$V_0$：为旧电路工作电压</p>
</li>
<li><p>$\beta V_0$：为新电路工作电压，通过使得 $\beta$小于1降低工作电压的方法来降低功耗</p>
</li>
<li><p>$P_o$：为旧电路功耗</p>
</li>
<li><p>$P_n$：为新电路功耗</p>
</li>
<li><p>由于“理想”M级流水线的插入，使得$C_{n-charge}=\frac{C_{o-charge}}M$</p>
</li>
<li><p>传输延时公式中的充放电电容变小，而我们又不需要改变传输延时$T_{pd}$（$f=\frac1{max(T_{pd})}$）那么肯定能带来工作电压的减小，新旧电路传播延时相等</p>
<script type="math/tex; mode=display">
T_{pd}=\frac{C_{o-charge}V_0}{k( V_0-V_t)^2}</script><script type="math/tex; mode=display">
T_{pd}'=\frac{\frac{C_{o-charge}}{M}\beta V_0}{k(\beta V_0-V_t)^2}</script></li>
<li><p>有$T_{pd}=T_{pd}’$，则：</p>
<script type="math/tex; mode=display">
\beta (V_0-V_t)^2=M(\beta V_0-V_t)^2</script></li>
<li><p>通过上式可以求出$\beta$，进而改变工作电压从而降低电路功耗，此时的电路功耗为（总电容不变，时钟频率也不变）：</p>
<script type="math/tex; mode=display">
P_n=C_{total}(\beta V_0)^2f=\beta^2C_{total}V_0^2f=\beta^2P_0</script></li>
</ul>
<hr>
<h1 id="并行处理技术降低功耗"><a href="#并行处理技术降低功耗" class="headerlink" title="并行处理技术降低功耗"></a>并行处理技术降低功耗</h1><p><img src="/2022/11/22/VLSI%20DSP%E4%B9%8B%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86/image-20221122152129260.png" alt="image-20221122152129260" style="zoom: 50%;"></p>
<ul>
<li><p>为保持原来的采样速率不变，L级并行处理系统的时钟周期增加为$LT_{seq}$，则电源电压可以降低到$\beta V_0$</p>
<script type="math/tex; mode=display">
原时钟周期:T_{seq}=\frac{C_{charge}V_0}{k(V_0-V_t)^2}</script><script type="math/tex; mode=display">
新时钟周期:T_{seq}'=\frac{C_{charge}\beta V_0}{k(\beta V_0-V_t)^2}</script></li>
<li><p>有：$T_{seq}’=NT_{seq}$，则：</p>
<script type="math/tex; mode=display">
N(\beta V_0-V_t)^2=\beta(V_0-V_t)^2</script></li>
<li><p>则新的电路功耗为（总电容变为原来的N倍，时钟频率变为原来的1/N）：</p>
<script type="math/tex; mode=display">
P_n=NC_{total}(\beta V_0)^2\frac fN=C_{total}(\beta V_0)^2f=\beta^2P_0</script></li>
<li><p><strong>可以看到，</strong>$M$<strong>级流水线和</strong>$L$<strong>级并行处理的采用在不改变原始时序电路性能的情况下有相同的功耗降低能力</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI DSP之迭代边界</title>
    <url>/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/</url>
    <content><![CDATA[<p>本节主要介绍了VLSI DSP中的迭代边界相关知识，包括DSP算法的四种表示方法、迭代边界的基本概念以及用LPM求解迭代边界。</p>
<span id="more"></span>
<h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><ul>
<li><p><strong>路径</strong>：数据在任意两个节点间经有向边和中间节点的通路</p>
</li>
<li><p><strong>关键路径</strong>：没有延时单元的最长路径（DFG中在不包含延迟单元的路径中执行计算时间最长的路径$T_c$）</p>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121151920311.png" alt="image-20221121151920311" style="zoom:50%;"></p>
</li>
<li><p>关键路径确定了最小可行的时钟周期</p>
</li>
<li><p>时钟速度被关键路径限制</p>
<script type="math/tex; mode=display">
T_{clk}\ge T_{critical}</script></li>
<li><p>以4阶FIR为例：红色与紫色所示为关键路径，均包含1个乘法器和3个加法器</p>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121110000319.png" alt="image-20221121110000319" style="zoom: 67%;"></p>
<ul>
<li><p>将其推广到N阶FIR，则：</p>
<script type="math/tex; mode=display">
T_{critical}=T_M+(N-1)T_A</script><script type="math/tex; mode=display">
其中,N为抽头系数</script></li>
</ul>
</li>
</ul>
<hr>
<h1 id="DSP算法的表示方法"><a href="#DSP算法的表示方法" class="headerlink" title="DSP算法的表示方法"></a>DSP算法的表示方法</h1><h2 id="1-框图"><a href="#1-框图" class="headerlink" title="1.框图"></a>1.框图</h2><ul>
<li>常用于图形化地描述DSP系统，由功能块和有向边组成</li>
<li>有向边：表示从输入到输出的数据流动</li>
</ul>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121110712904.png" alt="image-20221121110712904"></p>
<h2 id="2-信号流图（SFG）"><a href="#2-信号流图（SFG）" class="headerlink" title="2.信号流图（SFG）"></a>2.信号流图（SFG）</h2><ul>
<li>信号流图是一组节点和有向边的集合</li>
<li>用于分析、表示、评估线性数字网络结构</li>
</ul>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121111534784.png" alt="image-20221121111534784" style="zoom:50%;"></p>
<h2 id="3-数据流图（DFG）"><a href="#3-数据流图（DFG）" class="headerlink" title="3.数据流图（DFG）"></a>3.数据流图（DFG）</h2><ul>
<li><p><strong>节点</strong>：</p>
<ul>
<li>表示算法中计算（或功能）执行</li>
<li>包含关联的计算时间：（数字）</li>
<li>细粒度：节点简单的基本运算单元，如乘、加等</li>
<li>粗粒度：节点为子任务以上层次的复杂功能块，如滤波、FFT等</li>
</ul>
</li>
<li><p><strong>有向边</strong>：</p>
<ul>
<li>包含节点间通信关系</li>
<li>包含关联的非负延迟$z^{-1}$或D</li>
<li>每条边描述了两节点间执行的优先顺序约束<ul>
<li>边无延迟：描述<strong>迭代内</strong>优先顺序约束</li>
<li>边有延迟：描述<strong>迭代间</strong>优先顺序约束</li>
</ul>
</li>
</ul>
</li>
<li><p>同步DFG表示：</p>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121150732638.png" alt="image-20221121150732638" style="zoom:33%;"></p>
</li>
</ul>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121150657618.png" alt="image-20221121150657618" style="zoom: 33%;"></p>
<h2 id="4-依赖图（Dependence-Graph）"><a href="#4-依赖图（Dependence-Graph）" class="headerlink" title="4.依赖图（Dependence Graph）"></a>4.依赖图（Dependence Graph）</h2><ul>
<li><p>依赖图是一种有向图，表示算法计算间的依赖关系（脉动阵列常用）</p>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121151219068.png" alt="image-20221121151219068" style="zoom: 50%;"></p>
</li>
</ul>
<hr>
<h1 id="迭代边界"><a href="#迭代边界" class="headerlink" title="迭代边界"></a>迭代边界</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul>
<li><p><strong>迭代</strong>：DFG中所有节点执行一次</p>
</li>
<li><p><strong>迭代周期</strong>$T_{it}$：是处理一次输入样点并输出一个结果所需要的时间</p>
</li>
<li><p><strong>时钟周期</strong>$T_{clock}$：系统按拍工作的周期，由关键路径$T_c$决定</p>
</li>
<li><p><strong>系统时钟频率</strong>$f$：$f=\frac1{T_{clock}}$</p>
</li>
<li><p><strong>环路</strong>：开始与结束于同一节点的有向路径</p>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121153445674.png" alt="image-20221121153445674" style="zoom:50%;"></p>
</li>
<li><p><strong>环路边界</strong>：第L个环路的环路边界为：</p>
<script type="math/tex; mode=display">
T_{LoopBond}=\frac{T_L}{W_L}</script></li>
</ul>
<script type="math/tex; mode=display">
其中,T_L是环路运行时间,W_L是环路中延迟数</script><p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121153518090.png" alt="image-20221121153518090" style="zoom:50%;"></p>
<ul>
<li><p><strong>关键环路</strong>：具有最大环路边界的环路</p>
</li>
<li><p><strong>迭代边界</strong>：关键环路对应的环路边界值$T_{\infty}$</p>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121154307985.png" alt="image-20221121154307985" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-迭代边界的特点"><a href="#2-迭代边界的特点" class="headerlink" title="2.迭代边界的特点"></a>2.迭代边界的特点</h2><ul>
<li>环路必须有延迟元件</li>
<li>必须是因果系统，非因果系统系统无法硬件实现</li>
<li>给出DFG所有环路迭代周期的下限</li>
<li>决定带反馈环路DSP算法性能的重要参数，反映了硬件实现DSP程序能有多快</li>
<li>即使DSP系统无限提高计算能力，迭代周期$\ge$迭代边界</li>
</ul>
<h2 id="3-最长路径矩阵（LPM）求迭代边界"><a href="#3-最长路径矩阵（LPM）求迭代边界" class="headerlink" title="3.最长路径矩阵（LPM）求迭代边界"></a>3.最长路径矩阵（LPM）求迭代边界</h2><ul>
<li><p>建立一系列矩阵$L^{(m)},m=1,2,\cdots,d$，取每个矩阵对角线的非-1元素除以寄存器数目，最终求它们的最大值即为迭代边界</p>
</li>
<li><p>$L^{(m)}$中的m表示此矩阵都是包含m-1个延迟的，d为寄存器数</p>
</li>
<li><p>矩阵中元素下标$(i,j)$表示从寄存器$i$到寄存器$j$的包含$m-1$个延迟的最大运算时间</p>
</li>
<li><p>如果这样的路径不存在，那么$L_{i,j}^{(m)}=-1$</p>
</li>
<li><p>具体求解步骤：</p>
<ul>
<li><p>先计算$L^{(1)}$：</p>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121162232884.png" alt="image-20221121162232884" style="zoom: 67%;"></p>
</li>
<li><p>通过如下公式求得其他延时下的矩阵：</p>
<script type="math/tex; mode=display">
L_{i,j}^{(m+1)}=max(-1,L_{i,k}^{(1)}+L_{k,j}^{(m)})</script><p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121162903924.png" alt="image-20221121162903924" style="zoom: 67%;"></p>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121162957174.png" alt="image-20221121162957174"></p>
</li>
<li><p>则最终迭代边界为：</p>
<p><img src="/2022/11/21/VLSI%20DSP%E4%B9%8B%E8%BF%AD%E4%BB%A3%E8%BE%B9%E7%95%8C/image-20221121163042631.png" alt="image-20221121163042631" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="周期相关的基本概念"><a href="#周期相关的基本概念" class="headerlink" title="周期相关的基本概念"></a>周期相关的基本概念</h1><ul>
<li><strong>采样周期</strong>：<ul>
<li>输入信号样点间隔的时间</li>
<li>取决于应用需要：语言、图像等各不相同</li>
</ul>
</li>
<li><strong>迭代周期</strong>：<ul>
<li>完成一次迭代的时间</li>
<li>取决于时钟周期和产生输出样点数</li>
</ul>
</li>
<li><strong>时钟周期</strong>：<ul>
<li>DSP系统工作所用的时钟周期</li>
<li>取决于DSP的关键路径</li>
</ul>
</li>
<li><strong>关键路径</strong>：<ul>
<li>DFG中执行计算时间最长的无延迟路径</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>雷达原理之运动目标检测及测速</title>
    <url>/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/</url>
    <content><![CDATA[<p>本节主要介绍了运动目标检测及测速的方法，包括多普勒效应测速与信息提取、MTI与MTD、盲速盲相等问题。</p>
<span id="more"></span>
<h1 id="多普勒效应及应用"><a href="#多普勒效应及应用" class="headerlink" title="多普勒效应及应用"></a>多普勒效应及应用</h1><h2 id="1-多普勒效应"><a href="#1-多普勒效应" class="headerlink" title="1.多普勒效应"></a>1.多普勒效应</h2><ul>
<li>多普勒效应是指当发射源和接收者之间有相对径向运动时，接收到的信号频率将发生变化</li>
</ul>
<h3 id="1-1-连续波雷达"><a href="#1-1-连续波雷达" class="headerlink" title="1.1 连续波雷达"></a>1.1 连续波雷达</h3><ul>
<li><p><strong>对于连续波雷达而言，收发天线是无法共用的</strong></p>
</li>
<li><p><strong>发射信号</strong>：$S_t(t)=Acos(w_0t+\phi)$</p>
</li>
<li><p><strong>回波信号</strong>：$S_r(t)=kAcos(w_0(t-\frac{2(R_0-v_rt)}{C})+\phi)$</p>
</li>
<li><p>由于接收信号的频率为：$f_r=f_t+\frac{2v_r}{\lambda}$，带入$S_r(t)$，得到：</p>
<script type="math/tex; mode=display">
S_r(t)=kAcos(2\pi f_0t+2\pi f_dt+\phi-\phi_0)</script><script type="math/tex; mode=display">
其中,\phi_0=\frac{4\pi R_0}{\lambda}</script></li>
</ul>
<h3 id="1-2-脉冲雷达"><a href="#1-2-脉冲雷达" class="headerlink" title="1.2 脉冲雷达"></a>1.2 脉冲雷达</h3><ul>
<li><p><strong>发射信号</strong>：</p>
<script type="math/tex; mode=display">
S_t(t)=\sum_{n}Arect(t-nT_r,\tau)cos(w_0t+\phi)</script><p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221118213120922.png" alt="image-20221118213120922" style="zoom:50%;"></p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221118213223236.png" alt="image-20221118213223236" style="zoom:50%;"></p>
</li>
<li><p><strong>回波信号</strong>：</p>
<script type="math/tex; mode=display">
S_r(t)=\sum_nkArect(t-t_r-nT_r,\tau)cos(2\pi f_0t+2\pi f_dt+\phi-\phi_0)</script></li>
</ul>
<h2 id="2-多普勒信息的提取"><a href="#2-多普勒信息的提取" class="headerlink" title="2.多普勒信息的提取"></a>2.多普勒信息的提取</h2><h3 id="2-1-连续波雷达"><a href="#2-1-连续波雷达" class="headerlink" title="2.1 连续波雷达"></a>2.1 连续波雷达</h3><ul>
<li><p>就是<strong>将发射信号$s_t(t)$和回波信号$s_r(t)$相乘</strong>（混频），根据三角公式，将会产生一个高频分量和一个低频分量，然后进行低通滤波就可以得到$f_d$ </p>
</li>
<li><p>最后得到的多普勒频率信号为:</p>
<script type="math/tex; mode=display">
u_rcos(w_dt-\phi_0)</script></li>
</ul>
<h3 id="2-2-脉冲雷达"><a href="#2-2-脉冲雷达" class="headerlink" title="2.2 脉冲雷达"></a>2.2 脉冲雷达</h3><ul>
<li><p>$\because$雷达接收信号为：$S_r(t)=\sum_nkArect(t-t_r-nT_r,\tau)cos(2\pi f_0t+2\pi f_dt+\phi-\phi_0)$</p>
</li>
<li><p>将脉冲雷达接收信号与连续波信号$S_t(t)=Acos(w_0t+\phi)$进行混频，得到：</p>
<script type="math/tex; mode=display">
u_r\sum_nrect(t-t_r-nT_r,\tau)cos(w_dt-\phi_0)</script></li>
<li><p>则对于固定目标，$w_d=0$，输出结果为等幅脉冲序列</p>
</li>
<li><p>对于运动目标，$w_d\neq0$，$f_d$相对于$f_r=\frac1{T_r}$比较小，则整个表达式可以看作式连续波充当了周期脉冲的包络，也就是回波脉冲的包括调制频率即多普勒频率</p>
</li>
</ul>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221118215325448.png" alt="image-20221118215325448" style="zoom: 50%;"></p>
<ul>
<li>对于脉冲雷达，相位检波器输出可以看作是对连续波进行了采样，所以可以通过$FFT$求得$f_d$</li>
</ul>
<h2 id="3-盲速和频闪"><a href="#3-盲速和频闪" class="headerlink" title="3.盲速和频闪"></a>3.盲速和频闪</h2><ul>
<li>当雷达处于<strong>脉冲工作</strong>状态时，将发生区别于连续工作状态的特殊问题，即盲速和频闪效应</li>
</ul>
<h3 id="3-1-盲速"><a href="#3-1-盲速" class="headerlink" title="3.1 盲速"></a>3.1 盲速</h3><p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221118220940245.png" alt="image-20221118220940245" style="zoom:50%;"></p>
<ul>
<li>当$f_d=kf_r,k=\pm1,\pm2,\cdots$时，就会出现盲速</li>
<li>当$k=1$，即$f_d=f_r=\frac{2v_r}{\lambda} \Rightarrow 第一盲速v_r=\frac{f_d\lambda}{2}$</li>
<li>当存在盲速时，就需要采取相应的方法消除盲速。所说的消除盲速，并不是指完全将盲速消除，而是增大第一盲速，只要目标速度小于第一盲速，就不会出现盲速</li>
</ul>
<h3 id="3-2-频闪"><a href="#3-2-频闪" class="headerlink" title="3.2 频闪"></a>3.2 频闪</h3><ul>
<li><p>当$f_{d1}=nf_r±f_{d2}$时，就会出现频闪现象，直观来讲就是脉冲包络存在多种拟合方式</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221118221553372.png" alt="image-20221118221553372" style="zoom:50%;"></p>
</li>
<li><p>避免频闪需要满足的条件：</p>
<script type="math/tex; mode=display">
|f_d|<\frac12f_r</script><ul>
<li>其中，$f_r$可以看作是对连续波进行采样的频率，$f_d$可以看作是连续波的频率。也就是说，只要满足<strong>奈奎斯特采样定理</strong>就不会出现频闪</li>
</ul>
</li>
</ul>
<hr>
<h1 id="动目标显示雷达MTI"><a href="#动目标显示雷达MTI" class="headerlink" title="动目标显示雷达MTI"></a>动目标显示雷达MTI</h1><ul>
<li>经过相位检波之后，去除固定目标的回波，只保留运动目标的回波</li>
</ul>
<h2 id="1-中频部分进行相检的原理"><a href="#1-中频部分进行相检的原理" class="headerlink" title="1.中频部分进行相检的原理"></a>1.中频部分进行相检的原理</h2><ul>
<li>相位检波通常是在中频进行的</li>
<li>发射信号的相位：$ω_0t+ϕ$</li>
<li>回波信号的相位：$ω_0t+ω_dt+ϕ−ϕ_0$</li>
<li>本振信号的相位：$ω_Lt+ϕ_L$</li>
<li>发射信号和本振混频之后的相位：$(ω_L−ω_0)t+(ϕ_L−ϕ)$</li>
<li>回波信号和本振混频之后的相位：$(ω_L−ω_0−ω_d)t+ϕ_L−ϕ+ϕ_0$</li>
<li><strong>相位检波器就是将发射信号的中频和回波的中频再进行混频，再通过低通滤波器就得到$f_d$</strong></li>
<li>相位检波之后得到：$ω_dt−ϕ_0$</li>
</ul>
<h2 id="2-消除固定目标回波"><a href="#2-消除固定目标回波" class="headerlink" title="2.消除固定目标回波"></a>2.消除固定目标回波</h2><ul>
<li><p>在相位检波器输出端，固定目标的回波是一串振幅不变的脉冲，而运动目标的回波是一串振幅调制 的脉冲。据此，将相位检波器输出通过相消器，就可以消除固定目标回波，保留运动目标回波</p>
</li>
<li><p>一次相消器：</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221118225220159.png" alt="image-20221118225220159" style="zoom:50%;"></p>
</li>
<li><p>对于固定目标的回波，脉冲多普勒雷达经过相位检波之后的输出为一串等幅脉冲，脉冲间隔为$T_r$。如果脉冲序列足够长，将其迟延$T_r$之后得到的脉冲序列，和原来的脉冲序列将会重合到一起，将两个相减输出$Δu=0$</p>
</li>
<li><p>对于运动目标，除开盲速的情况，输出$Δu≠0$</p>
</li>
<li><p>有：$u_o=u_i-u_ie^{-jwT_r}$</p>
</li>
<li><p>其传递响应函数为：</p>
<script type="math/tex; mode=display">
H(jw)=\frac{u_o}{u_i}=1-e^{-jwT_r}=1-cos(wT_r)+jsin(wT_r)=2sin(\pi fT_r)e^{j(\pi/2-\pi fT_r)}</script><ul>
<li>其幅频特性为：<script type="math/tex; mode=display">
|H(jw)|=|2sin(\pi fT_r)|</script><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221118225745213.png" alt="image-20221118225745213" style="zoom:50%;"></li>
</ul>
</li>
<li><p>从幅频特性角度来看，$|H(jω)|$就是一个滤波器，相当于将$f_d=0$的固定目标，及以盲速运动的目标就全部过滤掉了</p>
</li>
</ul>
<hr>
<h1 id="盲速、盲相的影响及其解决途径"><a href="#盲速、盲相的影响及其解决途径" class="headerlink" title="盲速、盲相的影响及其解决途径"></a>盲速、盲相的影响及其解决途径</h1><h2 id="1-盲速"><a href="#1-盲速" class="headerlink" title="1.盲速"></a>1.盲速</h2><ul>
<li><p>盲速是指目标实际上有运动速度，但对于雷达来说经过相检之后的输出和固定目标相检之后的输出都是等幅的脉冲串，导致无法区分</p>
</li>
<li><p>当目标的多普勒频率满足：$f_d=nf_r,n=\pm1,\pm2,\cdots$时就会产生盲速</p>
</li>
<li><p>第一盲速$v_r=\frac{\lambda f_r}2$</p>
</li>
<li><p>要想不出现盲速，并不是要彻底消除盲速问题，是要想办法将第一盲速的值扩大</p>
</li>
<li><p><strong>从公式可知，只要增大$f_r$就可以增大$v_r$，但是，$f_r$增大，$T_r$就减小，就与无模糊距离矛盾了，即增大$f_r$虽然使第一盲速增大了，但是最大无模糊距离就减小了</strong></p>
</li>
<li><p>可以采用<strong>重频参差</strong>的方法扩大第一盲速，对于两重频，有：</p>
<script type="math/tex; mode=display">
f_d=n\times(f_{r1}与f_{r2}的最小公倍数)</script></li>
</ul>
<h2 id="2-盲相"><a href="#2-盲相" class="headerlink" title="2.盲相"></a>2.盲相</h2><p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119121743435.png" alt="image-20221119121743435" style="zoom:50%;"></p>
<ul>
<li><p>$A$点和$B$点幅度相同，经过相消器处理，就是将图形迟延$T_r$，从图上来说，就是将$A$点移到了$B$点，然后再相减，$B$点就减为$0$了，这一点的相位信息也就损失掉了。这种情况称之为<strong>点盲相</strong></p>
</li>
<li><p>出现原因：相检过后某一特殊时刻，前后间隔$T_r$是等幅的，消相器将其当作了静止目标，将其消掉</p>
</li>
<li><p><strong>解决办法</strong>：先消相再相检（<strong>中频对消</strong>）</p>
<ul>
<li><p>不通过相位检波器，直接将中频输出结果进行对消</p>
</li>
<li><p>中频输出$u_{r1}$：</p>
<script type="math/tex; mode=display">
u_{r1}=u_rcos[(w_i+w_d)t+\phi']</script><ul>
<li>$w_i$为中频角频率，只写出了连续波信号部分，实际上这里应该是以连续波为包络的一个个脉冲串</li>
</ul>
</li>
<li><p>将$u_{r1}$延迟$T_r$后得到：</p>
<script type="math/tex; mode=display">
u_{r2}=u_rcos[(w_i+w_d)(t-T_r)+\phi_0']</script></li>
<li><p>将$u_{r1}$和$u_{r2}$进行对消之后得到：</p>
<script type="math/tex; mode=display">
\Delta u= u_{r1}-u_{r2}=-2u_rsin(\pi f_iT_r+\pi f_dT_r)sin((w_i+w_d)t+\phi)</script></li>
<li><p>对消的目的就是将固定目标回波相除，即在$f_d=0$时，使对消器输出$\Delta u=0$</p>
</li>
<li><p>对于固定目标而言$f_d=0$，想要在中频进行对消（即消除固定目标回波），$f_i$就不能随便选，需要满足如下条件：</p>
<script type="math/tex; mode=display">
f_i=nf_r</script></li>
</ul>
</li>
<li><p>此外，还可以通过零中频的方式解决盲相，其思路是： $I，Q$双通道处理，正交双通道由两路相同的支路组成，差别只是其基准的相参电压相位差 90°，这两路分别称为同相支路（ I 支路）和正交支路（ Q 支路）。</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119132351768.png" alt="image-20221119132351768" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="回波和杂波的频谱及动目标显示器"><a href="#回波和杂波的频谱及动目标显示器" class="headerlink" title="回波和杂波的频谱及动目标显示器"></a>回波和杂波的频谱及动目标显示器</h1><ul>
<li>运动目标检测的任务就是根据运动目标回波和杂波在频谱结构上的差别，从频率上将它们区分，以达到抑制固定杂波而显示运动目标回波的目的</li>
</ul>
<h2 id="1-雷达回波信号的频谱"><a href="#1-雷达回波信号的频谱" class="headerlink" title="1.雷达回波信号的频谱"></a>1.雷达回波信号的频谱</h2><ul>
<li><p>雷达回波：</p>
<script type="math/tex; mode=display">
u_r(t)=ku_t(t-t_r)</script></li>
<li><p>回波频谱：</p>
<script type="math/tex; mode=display">
U_r(f)=kU_t(f)e^{-jwt_r}</script></li>
<li><p>接收信号的幅频特性和发射信号的幅频特性基本相同，只是优于回波多了一个$k$导致其幅频特性的高低有差别。如果目标运动，接收信号和发射信号的载频就相差一个多普勒频率$f_d$。所以，只要将发射信号的频谱分析清楚就能得到接收信号的频谱</p>
</li>
<li><p>雷达发射相参脉冲串，其脉冲宽度为$τ$，脉冲重复频率为$f_r$。当天线不扫描而对准目标时，所得脉冲为无限脉冲串。此时，雷达发射信号为：</p>
<script type="math/tex; mode=display">
u(t)=E\sum_{-\infty}^{\infty}rect(t-nT_r,\tau)cos(w_0t+\phi_0)</script><p>其中：</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119140455218.png" alt="image-20221119140455218" style="zoom:50%;"></p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119140536598.png" alt="image-20221119140536598" style="zoom:50%;"></p>
</li>
<li><p>可以先不考虑后面的余弦项，只考虑$rect$项，如下所示。最后乘以$cos$项，相当于将$rect$项的频谱进行搬移即可得到$u(t)$的频谱</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119140817445.png" alt="image-20221119140817445" style="zoom:50%;"></p>
</li>
<li><p>周期函数的傅里叶变换是通过傅里叶级数来实现的，周期函数的傅里叶级数是一根根离散的$\delta$函数，$\delta$函数的间隔就是周期的倒数。$\delta$函数的包络就和一个周期内部的信号的傅里叶变换有关。门函数的傅里叶变换是一个辛克函数，所以这些 delta 函数的包络就是辛克函数。如下图所示，幅频特性是取了绝对值的，所以图中只有正值没有负值</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119141022022.png" alt="image-20221119141022022" style="zoom:50%;"></p>
</li>
<li><p>最后，将$rect$项乘以$cos$项，相当于将上述频谱往左右搬移，得到：</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119141109877.png" alt="image-20221119141109877" style="zoom:50%;"></p>
</li>
<li><p>雷达工作时，天线总是以各种方式进行扫描。这时收到的回波脉冲为有限数，且其振幅受天线方向图调制。雷达实际的接收信号可表示为：</p>
<script type="math/tex; mode=display">
u_m(t)=m(t)u_r(t)</script><ul>
<li><p>其中，$m(t)$为天线的扫描函数，实际就是一个高斯函数，图形如下所示。注意，天线方向图是角度$θ$的函数，扫描的过程就是$θ$随$t$线性变化的过程</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119141418160.png" alt="image-20221119141418160" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>则回波信号$u_m(t)$的频谱：</p>
<script type="math/tex; mode=display">
U_m(f)=M(f)\ast U_r(f)</script><ul>
<li><p>其中：$\ast$表示卷积</p>
</li>
<li><p>天线的扫描函数$m(t)$的频谱为：$M(f)=e^{-\frac{f^2}{2\sigma^2}}$</p>
<ul>
<li><p>$\sigma=\frac{0.256f_r}{n}$</p>
</li>
<li><p>$n$表示在天线扫描期间接收到的回波脉冲个数</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119142211969.png" alt="image-20221119142211969" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>因此，回波信号的频谱就是$M(f)$和一串$\delta$谱线的卷积，相当于将$M(f)$搬移到每根$\delta$谱线位置</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119142412323.png" alt="image-20221119142412323" style="zoom:50%;"></p>
</li>
<li><p>如果目标在运动，接收信号相对于发射信号就会存在一个多普勒频率$f_d$，因此，对于动目标接收信号频谱为：</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119142522685.png" alt="image-20221119142522685" style="zoom:50%;"></p>
</li>
<li><p>回波中频对应的频谱：</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119142921507.png" alt="image-20221119142921507" style="zoom:50%;"></p>
</li>
<li><p>对中频信号进一步进行处理，相位检波器将中频回波和相干电压进行相干检波后（图中虚线表示单路相位检波所产生的频谱折叠情况，是由负频率轴频谱差拍而产生的）：</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119142814040.png" alt="image-20221119142814040" style="zoom:50%;"></p>
</li>
<li><p>实际在处理的时候，通过得到$e^{jω_0t}$这样的信号从而消除虚线部分，可以利用$I,Q$双路处理。一路$cos(ω_0t)$表示信号的实部，另外一路$sin(ω_0t)$表示信号的虚部，就可以得到$e^{jω_0t}$。再进行相干检波出来的结果，就只有$nf_r+f_d$</p>
</li>
</ul>
<h2 id="2-杂波的频谱"><a href="#2-杂波的频谱" class="headerlink" title="2.杂波的频谱"></a>2.杂波的频谱</h2><script type="math/tex; mode=display">
G(f)=G_0e^{-\frac{f^2}{2\sigma}}</script><h2 id="3-动目标显示滤波器"><a href="#3-动目标显示滤波器" class="headerlink" title="3.动目标显示滤波器"></a>3.动目标显示滤波器</h2><ul>
<li><p>动目标显示滤波器利用运动目标回波和杂波在频谱上的区别，可有效地抑制杂波而提取信号</p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119145106810.png" alt="image-20221119145106810" style="zoom:50%;"></p>
<p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119145147260.png" alt="image-20221119145147260" style="zoom:50%;"></p>
</li>
<li><p>在脉冲雷达中MTI滤波器就是利用<strong>杂波</strong>与<strong>运动目标</strong>的<strong>多普勒频率的差异</strong>，使得滤波器的频率响应在<strong>杂波谱的位置形成“凹口”</strong>，以抑制杂波，而让动目标回波通过后的损失尽量小或没有损失</p>
</li>
</ul>
<hr>
<h1 id="动目标检测MTD"><a href="#动目标检测MTD" class="headerlink" title="动目标检测MTD"></a>动目标检测MTD</h1><ul>
<li>MTD是在MTI的性能基础上进一步完善和提高</li>
</ul>
<h2 id="1-动目标检测的特点"><a href="#1-动目标检测的特点" class="headerlink" title="1.动目标检测的特点"></a>1.动目标检测的特点</h2><ul>
<li><p>动态范围更大</p>
</li>
<li><p>改善因子提高</p>
<script type="math/tex; mode=display">
I=\frac{s_0/c_0}{s_i/c_i}</script><ul>
<li>需要和噪声系数的定义区别开，噪声系数的定义是输入的信噪比与输出的信噪比的比值</li>
<li>改善因子的定义是，输出信杂比与输入信杂比的比值</li>
<li>主要体现在对杂波的改善上。通过动目标检测雷达合理的设计，可以使得输出的杂波比输入的杂波要小，即将杂波消除的更多一些</li>
</ul>
</li>
<li><p>增加多普勒滤波器组</p>
<ul>
<li>对动目标检测雷达来讲，通过滤波器组将运动目标多普勒频率测量出来。</li>
</ul>
</li>
<li><p>抑制地杂波</p>
</li>
<li><p>增加杂波图</p>
<ul>
<li>不同地方的地物杂波是不一样的。</li>
<li>相当于把不同区域的地物杂波的特性存储下来，对于杂波比较强得地方，把杂波门限提高，对杂波比较弱的地方门限降低</li>
<li>有了杂波图之后，相应的门限就不再是一个固定门限，检测起来就有一定的灵活性</li>
</ul>
</li>
</ul>
<h2 id="2-多普勒滤波器组"><a href="#2-多普勒滤波器组" class="headerlink" title="2.多普勒滤波器组"></a>2.多普勒滤波器组</h2><p><img src="/2022/11/19/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%B5%8B%E9%80%9F/image-20221119150024136.png" alt="image-20221119150024136" style="zoom:50%;"></p>
<ul>
<li><p>多普勒滤波器组就是用来测量多普勒频率的</p>
</li>
<li><p>其输入就是相位检波之后的输出信号</p>
</li>
<li><p>横向滤波器的总输出:</p>
<script type="math/tex; mode=display">
X(k)=\sum_{n=0}^{N-1}X(n)e^{-j2\pi n\frac kN}</script><script type="math/tex; mode=display">
其中,k=0,1,\cdots ,N-1(N为X(n)中的脉冲个数)</script></li>
<li><p>每一个值实际上对应的是一个频率，$0$对应的频率是$\frac0Nf_r$，$1$对应的频率是$\frac1Nf_r$，$2$对应的频率是$\frac2Nf_r$以此类推。</p>
</li>
<li><p>求出所有$X(k)$之后，找出$X(k)$里面哪一个$k$对应的值最大，频率就是$k$对应的频率，该频率就是回波脉冲的包络调制频率即多普勒频率，根据多普勒频率就可以求得目标的速度</p>
</li>
</ul>
<hr>
<h1 id="CFAR检测算法"><a href="#CFAR检测算法" class="headerlink" title="CFAR检测算法"></a>CFAR检测算法</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/508870274">干货 | FMCW雷达信号处理的二维CFAR（2D CFAR、十字CFAR）检测算法 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.zhihu.com/tardis/zm/art/269840008?source_id=1003">雷达系统必备知识——恒虚警检测器CFAR (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_44296793/article/details/130161960">CFAR(恒虚警率)目标检测算法_cfar检测_huhaoming-dd的博客-CSDN博客</a></li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/256371753">八、多普勒效应及应用 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之文件操作</title>
    <url>/2022/11/19/MATLAB%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>本节主要介绍了MATLAB中基本的文件操作方法，包括文本文件的读写、二进制文件的读写、数据文件定位等。</p>
<span id="more"></span>
<h1 id="文件打开与关闭"><a href="#文件打开与关闭" class="headerlink" title="文件打开与关闭"></a>文件打开与关闭</h1><h2 id="1-fopen函数"><a href="#1-fopen函数" class="headerlink" title="1.fopen函数"></a>1.fopen函数</h2><ul>
<li><code>fid=fopen(filename,permission)</code></li>
<li>filename为待操作的文件名</li>
<li>permission为对文件的允许使用方式<ul>
<li><code>&#39;r&#39;</code>：以读方式打开一个文件</li>
<li><code>&#39;w&#39;</code>：以写方式打开一个文件</li>
<li><code>&#39;a&#39;</code>：在该文件尾添加数据</li>
<li><code>&#39;r+&#39;</code>：以读和写方式打开一个文件</li>
</ul>
</li>
<li>fid为文件识别号，打开文件成功时，fid返回一整数，用来标识该文件；打开文件不成功时，fid值为-1</li>
</ul>
<h2 id="2-fclose函数"><a href="#2-fclose函数" class="headerlink" title="2.fclose函数"></a>2.fclose函数</h2><ul>
<li><code>status=fclose(fid)</code></li>
<li>fid是要关闭文件的标识号，如果fid为all则表示关闭所有已打开的文件，但标准文件除外，即键盘、屏幕</li>
<li>返回0表示关闭成功，返回-1表示关闭不成功</li>
</ul>
<hr>
<h1 id="文本文件的读写"><a href="#文本文件的读写" class="headerlink" title="文本文件的读写"></a>文本文件的读写</h1><h2 id="1-fscanf函数"><a href="#1-fscanf函数" class="headerlink" title="1.fscanf函数"></a>1.fscanf函数</h2><ul>
<li><code>[A,count]=fscanf(fid,fmt,size)</code></li>
<li>fscanf函数用于读取文本文件的内容</li>
<li>A用于存放读写的数据</li>
<li>count返回成功读写的数据元素个数</li>
<li>fid为文件标识号</li>
<li>fmt用于控制读取的数据格式<ul>
<li><code>&#39;%d&#39;</code>：整数</li>
<li><code>&#39;%f&#39;</code>：浮点数</li>
<li><code>&#39;%c&#39;</code>：字符</li>
<li><code>&#39;%s&#39;</code>：字符串</li>
<li>要指定一次读取的最大位数或文本字符数，请在百分比符号后插入数字。例如，<code>%10c</code> 一次最多读取 10 个字符，包括空白。<code>%4f</code> 一次最多读取 4 位数，包括小数点</li>
</ul>
</li>
<li>size用于指定A的大小<ul>
<li><code>n</code>：指定读取n个数据</li>
<li><code>Inf</code>：指定读取到文件末尾</li>
<li><code>[m,n]</code>：指定读取$m\times n$个数据，数据按列顺序存放到矩阵A</li>
</ul>
</li>
</ul>
<h2 id="2-fprintf函数"><a href="#2-fprintf函数" class="headerlink" title="2.fprintf函数"></a>2.fprintf函数</h2><ul>
<li><code>count=fprintf(fid,fmt,A)</code></li>
</ul>
<h2 id="3-简单示例"><a href="#3-简单示例" class="headerlink" title="3.简单示例"></a>3.简单示例</h2><p><img src="/2022/11/19/MATLAB%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20221119212512297.png" alt="image-20221119212512297"></p>
<p>结果如下：</p>
<p><img src="/2022/11/19/MATLAB%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20221119212619440.png" alt="image-20221119212619440"></p>
<hr>
<h1 id="二进制文件的读写"><a href="#二进制文件的读写" class="headerlink" title="二进制文件的读写"></a>二进制文件的读写</h1><h2 id="1-fread函数"><a href="#1-fread函数" class="headerlink" title="1.fread函数"></a>1.fread函数</h2><ul>
<li><code>[A,count]=fread(fid,size,precision,skip)</code></li>
<li>fread函数用于读取二进制文件</li>
<li>A用于存放读写的数据</li>
<li>count返回成功读写的数据元素个数</li>
<li>fid为文件标识号</li>
<li>size用于指定A的大小</li>
<li>precision指定读写数据的类型</li>
<li>skip指定按比例周期性地跳过一些数据</li>
</ul>
<h2 id="2-fwrite函数"><a href="#2-fwrite函数" class="headerlink" title="2.fwrite函数"></a>2.fwrite函数</h2><ul>
<li><code>count=fwrite(fid,A,precision)</code></li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%计算y=exp(x)sinx，其中x∈[0,2π]。将x、y写入二进制文件&quot;模拟数据.dat”。</span></span><br><span class="line">fid=fopen(<span class="string">&#x27;模拟数据.dat&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">y=<span class="built_in">exp</span>(x).*<span class="built_in">sin</span>(x);</span><br><span class="line">count=fwrite(fid, [x; y], <span class="string">&#x27;double&#x27;</span>);</span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数据文件定位"><a href="#数据文件定位" class="headerlink" title="数据文件定位"></a>数据文件定位</h1><h2 id="1-fseek函数"><a href="#1-fseek函数" class="headerlink" title="1.fseek函数"></a>1.fseek函数</h2><ul>
<li><code>fseek(fid,offset,origin)</code></li>
<li>用于改变文件位置指针的位置</li>
<li>fid是文件识别号</li>
<li>offset表示位置指针相对移动的字节数</li>
<li>origin表示位置指针移动的参照位置<ul>
<li><code>&#39;cof&#39;：或0</code>表示文件指针的当前位置</li>
<li><code>&#39;bof&#39;：或-1</code>表示文件的开始位置</li>
<li><code>&#39;eof&#39;：或1</code>表示文件的结束位置</li>
</ul>
</li>
</ul>
<h2 id="2-ftell函数"><a href="#2-ftell函数" class="headerlink" title="2.ftell函数"></a>2.ftell函数</h2><ul>
<li><code>position=ftell(fid)</code></li>
<li>用于查询文件指针的当前位置</li>
<li>返回值为文件头到指针当前位置的字节数，若返回值为-1则表示获取文件当前位置失败</li>
</ul>
<h2 id="3-feof函数"><a href="#3-feof函数" class="headerlink" title="3.feof函数"></a>3.feof函数</h2><ul>
<li><code>status=feof(fid)</code></li>
<li>用于判断当前的文件位置是否到达文件尾部</li>
<li>当到达文件结束位置时，返回值为1，否则为0</li>
</ul>
<p><img src="/2022/11/19/MATLAB%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20221119215827606.png" alt="image-20221119215827606"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>雷达原理之目标角度测量</title>
    <url>/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/</url>
    <content><![CDATA[<p>本节主要介绍了雷达目标角度测量的基本方法，包括相位法与振幅法，以及圆锥扫描自动测角系统与单脉冲自动扫描测角系统。</p>
<span id="more"></span>
<h1 id="天线方向图的一般性质"><a href="#天线方向图的一般性质" class="headerlink" title="天线方向图的一般性质"></a>天线方向图的一般性质</h1><ul>
<li><p>雷达天线方向函数：</p>
<script type="math/tex; mode=display">
F(\theta)=|F(\theta)|e^{j\phi(\theta)}</script><ul>
<li>其中$|F(\theta)|$是天线方向图函数的振幅响应</li>
<li>$\phi(\theta)$是天线方向图函数的相位响应</li>
</ul>
</li>
<li><p>只考虑振幅响应，有：</p>
<ul>
<li>$F(0)\ge F(\theta),∀θ∈[−π，π]$</li>
<li>$F(\theta)=F(-\theta)$</li>
<li>$|\theta_1|&gt;|\theta_2|,且\theta_1,\theta_2在主瓣内，则F(\theta_1)&lt;F(\theta_2)$</li>
<li>$\frac{F_电(\frac{\theta_{0.5}}{2})}{F(0)}=\frac{\sqrt2}2$</li>
<li>$F_{功-t}(\theta_1)=F_{电-t}^2(\theta1)$</li>
<li>$F_{功-r}(\theta_1)=F_{电-r}^2(\theta1)$</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118145144773.png" alt="image-20221118145144773" style="zoom: 33%;"></p>
<hr>
<h1 id="相位法测角"><a href="#相位法测角" class="headerlink" title="相位法测角"></a>相位法测角</h1><h2 id="1-两天线相位法测角原理"><a href="#1-两天线相位法测角原理" class="headerlink" title="1.两天线相位法测角原理"></a>1.两天线相位法测角原理</h2><p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118145524628.png" alt="image-20221118145524628" style="zoom:50%;"></p>
<ul>
<li><p>假设两天线之间的距离$d$，远远小于目标到振源的距离，则可以认为到达接收点的目标所反射的电磁波近似为平面波。</p>
</li>
<li><p>目标到$A，B$两点的距离相等，回波到$A，B$两点的相位也相等，回波到接收点的距离相差$dsin(θ)$，对应相位相差$\phi$，有：</p>
<script type="math/tex; mode=display">
\frac{\phi}{2\pi}=\frac{dsin\theta}{\lambda}\Rightarrow \phi=\frac{2\pi dsin\theta}{\lambda}</script></li>
<li><p>则测量相位差$\phi$就能测量角度了</p>
</li>
<li><p>当$ϕ∈[−π,π]$时，$θ$取值无模糊。$θ$对应的取值范围$[−θ_{max},θ_{max}]$，由$\phi=\frac{2\pi dsin\theta}{\lambda}$可得：</p>
<script type="math/tex; mode=display">
\theta_{max}=arcsin(\frac{\lambda}{2d})</script></li>
<li><p>从上式可知，只要$d$越小，对应的$θ_{max}$就越大。则短基线保证大的无模糊测角范围。</p>
</li>
</ul>
<h2 id="2-测角误差分析与多值性"><a href="#2-测角误差分析与多值性" class="headerlink" title="2.测角误差分析与多值性"></a>2.测角误差分析与多值性</h2><ul>
<li><p>对$\phi=\frac{2\pi dsin\theta}{\lambda}$两边同时微分，有：</p>
<script type="math/tex; mode=display">
d\phi=\frac{2\pi dcos\theta}{\lambda}d\theta \Rightarrow d\theta=\frac{\lambda}{2\pi dcos\theta}d\phi</script></li>
<li><p>采用读数精度高（$dϕ$小）的相位计，可以提高测角精度</p>
</li>
<li><p>增大$\frac dλ$的值，即<strong>长基线保证高的测角精度</strong></p>
</li>
<li><p>$\theta=0°$时，$d\theta$最小</p>
</li>
<li>$\theta=\pm90°$时，$d\theta$最大</li>
</ul>
<h2 id="3-多基线测角"><a href="#3-多基线测角" class="headerlink" title="3.多基线测角"></a>3.多基线测角</h2><ul>
<li><strong>短基线保证最大无模糊测角范围；长基线保证高的测角精度</strong>，故采用多基线测角结合二者优点。</li>
</ul>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118152009476.png" alt="image-20221118152009476" style="zoom:50%;"></p>
<ul>
<li><p>$1$和$2$之间的间距$d_{12}$比较短，$θ_{max}$ 就比较大，以保证比较大的无模糊测角范围，长基线$d_{13}$保证高的测角精度，有：</p>
<script type="math/tex; mode=display">
\phi_{12}=\frac{2\pi d_{12}sin\theta}{\lambda}</script><script type="math/tex; mode=display">
\phi_{13}=\frac{2\pi d_{13}sin\theta}{\lambda}</script></li>
<li><p>要使$ϕ_{12}$无模糊测角，$ϕ_{12}$就不能超过$2π$。因此，$ϕ_{12}$就是鉴相器能测出来的值。对于$ϕ_{13}$来讲，因为$ϕ_{13}$比较大，所以 $ϕ_{13}$一般大于 $2π$，有：</p>
<script type="math/tex; mode=display">
\phi_{13}=2\pi N+\phi</script></li>
<li><p>因为长基线$d_{13}$算出来的$θ$精度更高，所以有：</p>
<script type="math/tex; mode=display">
\theta=arcsin(\frac{\phi_{13}\lambda}{2\pi d_{13}})</script></li>
<li><p>式中，$λ$和$d_{13}$已知。因为只能测得$ϕ$，而$N$不知道，所以$ϕ_{13}$未知。只要求得$N$，就可以求出$ϕ_{13}$</p>
</li>
<li><p>将$\phi_{13},\phi_{12}$相比，有：</p>
<script type="math/tex; mode=display">
\frac{\phi_{13}}{\phi_{12}}=\frac{d_{13}}{d_{12}}=\frac{2\pi N+\phi}{\phi_{12}} \Rightarrow \frac{d_{13}}{d_{12}}\phi_{12}=2\pi N+\phi \Rightarrow \phi_{12}\frac{d_{13}}{d_{12}}\frac{1}{2\pi}=N+\frac{\phi}{2\pi}</script></li>
<li><p>上式中的$ϕ$是可测量的，其值满足$ϕ&lt;2π$。因此，$\frac{ϕ}{2π}&lt;1$，则$N$：</p>
<script type="math/tex; mode=display">
N=INT[\phi_{12}\frac{d_{13}}{d_{12}}\frac{1}{2\pi}]</script><script type="math/tex; mode=display">
其中,INT表示取整</script></li>
<li><p>根据已知的$ϕ_{12}，d_{13}，d_{12}$，可以求出$N$，进而可以得到$ϕ_{13}=2πN+ϕ$。最后根据公式$\phi_{13}=\frac{2\pi d_{13}sin\theta}{\lambda}$就可以求得$θ$：</p>
</li>
</ul>
<hr>
<h1 id="振幅法测角"><a href="#振幅法测角" class="headerlink" title="振幅法测角"></a>振幅法测角</h1><ul>
<li>振幅法测角是用天线收到的回波信号幅度值来做角度测量的，该幅度值的变化规律取决于天线方向图以及天线扫描方式</li>
<li>振幅法测角可分为最大信号法和等信号法两大类</li>
</ul>
<h2 id="1-最大信号法"><a href="#1-最大信号法" class="headerlink" title="1.最大信号法"></a>1.最大信号法</h2><ul>
<li>天线扫描的过程就是雷达天线方向图函数最大值指向不断发生变化的过程</li>
<li>如果把从扫描起始时刻到扫描结束时刻，雷达收到目标回波的幅度作图，其幅度的变化过程就类似于天线方向图函数的变化过程，开始比较小，然后逐渐增大，到最大值再慢慢减小</li>
<li><strong>最大信号法就是在找幅度变化过程中的极大值所在的位置</strong></li>
</ul>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118154913552.png" alt="image-20221118154913552" style="zoom: 50%;"></p>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118154955574.png" alt="image-20221118154955574" style="zoom:50%;"></p>
<ul>
<li><p>波束宽度、信噪比都会影响最大信号法测角的精度，测角精度满足如下公式：</p>
<script type="math/tex; mode=display">
\delta_{\theta}=\frac{0.5\theta_B}{\sqrt {(\frac{S}{N})_m^n}}</script></li>
<li><p>其中，$θ_B$为天线波束宽度，$(\frac SN)_m$为中心脉冲的信噪比，$n$为单程半功率点波束宽度内的脉冲数。</p>
</li>
</ul>
<h2 id="2-等信号法"><a href="#2-等信号法" class="headerlink" title="2.等信号法"></a>2.等信号法</h2><ul>
<li>等信号法测角釆用两个相同且彼此部分重叠的波束，两个天线方向图交叠处大概在 3dB 点处</li>
<li><strong>如果目标处在两波束的交叠轴方向，则由两波束收到的信号强度相等，否则一个波束收到的信号强度高于另一个</strong></li>
<li>故常常称 0A 为等信号轴。<strong>当两个波束收到的回波信号相等时，等信号轴所指方向即为目标方向</strong></li>
</ul>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118155608746.png" alt="image-20221118155608746" style="zoom: 50%;"></p>
<ul>
<li>设天线电压方向性函数为$F(θ)$，等信号轴$OA$的指向为$θ_0$，$\theta_k$为$\theta_0$与最大方向的偏角，有：<script type="math/tex; mode=display">
\theta_0-\theta_1=\theta_2-\theta_0=\theta_k</script></li>
</ul>
<script type="math/tex; mode=display">
F_1(\theta)=F(\theta-\theta_1)=F(\theta-\theta_0+\theta_k)</script><ul>
<li><p>假设$\theta_t=\theta-\theta_0$为目标与等信号轴的夹角，则有：</p>
<script type="math/tex; mode=display">
F_1(\theta)=F(\theta-\theta_1)=F(\theta-\theta_0+\theta_k)=F(\theta_t+\theta_k)</script><script type="math/tex; mode=display">
F_2(\theta)=F(\theta-\theta_2)=F(\theta-\theta_0+\theta_k)=F(\theta_t-\theta_k)</script></li>
</ul>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118160139982.png" alt="image-20221118160139982" style="zoom:50%;"></p>
<ul>
<li>故只要求得$\theta_t$就可以得到$\theta$</li>
</ul>
<h3 id="2-1-比幅法"><a href="#2-1-比幅法" class="headerlink" title="2.1 比幅法"></a>2.1 比幅法</h3><ul>
<li><p>根据雷达方程可以算得到达天线口面的回波信号功率，然后开方就可以得到幅度，因为两个相同且彼此部分重叠的波束的雷达方程中只有$F(\theta)$不同，其他相同部分均用用$K$统一表示，则有：</p>
<script type="math/tex; mode=display">
u_1(\theta)=KF(\theta_t+\theta_k)</script><script type="math/tex; mode=display">
u_2(\theta)=KF(\theta_t-\theta_k)</script></li>
<li><p>比幅法就是将二者相比，得到：</p>
<script type="math/tex; mode=display">
\frac{u_1(\theta)}{u_2(\theta)}=\frac{F(\theta_t+\theta_k)}{F(\theta_t-\theta_k)}</script></li>
<li><p>式中，$u_1$和$u_2$是可以测量出来的值；$θ_k$为天线方向图最大值与等信号轴夹角已知。只有$θ_t$是未知量，因此可以求得最终角度</p>
</li>
</ul>
<h3 id="2-2-和差法"><a href="#2-2-和差法" class="headerlink" title="2.2 和差法"></a>2.2 和差法</h3><ul>
<li><p>和信号为两个天线接收到信号之和，差信号为两个天线接收到信号之差</p>
</li>
<li><p><strong>差信号</strong>：</p>
<script type="math/tex; mode=display">
\Delta(\theta_t)=u_1(\theta)-u_2(\theta)=K[F(\theta_t+\theta_k)-F(\theta_t-\theta_k)]</script><p>在$\theta_0$附近做级数展开，得到：</p>
<script type="math/tex; mode=display">
\Delta\theta_t=2K\theta_tF'(\theta_0)</script></li>
<li><p><strong>和信号</strong>：</p>
<script type="math/tex; mode=display">
\Sigma(\theta_t)=u_1(\theta)+u_2(\theta)=K[F(\theta_t+\theta_k)+F(\theta_t-\theta_k)]=2KF(\theta_0)</script></li>
<li><p>将和、差信号相比：</p>
<script type="math/tex; mode=display">
\frac{\Delta}{\Sigma}=\frac{\theta_t}{F(\theta_0)}F'(\theta_0)</script></li>
<li><p>只有$θ_t$是未知量，因此可以求得最终角度</p>
</li>
</ul>
<hr>
<h1 id="自动测角的原理与方法"><a href="#自动测角的原理与方法" class="headerlink" title="自动测角的原理与方法"></a>自动测角的原理与方法</h1><h2 id="1-圆锥扫描自动测角系统"><a href="#1-圆锥扫描自动测角系统" class="headerlink" title="1.圆锥扫描自动测角系统"></a>1.圆锥扫描自动测角系统</h2><ul>
<li>圆锥扫描波束</li>
</ul>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118184018318.png" alt="image-20221118184018318" style="zoom:50%;"></p>
<ul>
<li>垂直于等信号轴的截面</li>
</ul>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118184042690.png" alt="image-20221118184042690" style="zoom: 33%;"></p>
<ul>
<li><p>$\delta$：对应前面的$θ_k$，即等信号轴与波束最大值方向的偏角。</p>
</li>
<li><p>$ϵ$：对应前面的$θ_t$，即目标与等信号轴的夹角，是自动测角系统想要测量的值。只要$ϵ$不为 0 ，就要调整旋转轴的指向，使其指向目标的方向。</p>
</li>
<li><p>$θ$：表示目标方向与波束最大值方向的夹角</p>
</li>
<li><p>接收信号电压振幅大小为：</p>
<script type="math/tex; mode=display">
U=KF_电^2(\theta)</script><ul>
<li>根据雷达方程推导，$K$包含了距离、功率等因素</li>
<li>如果目标与天线最大增益处的夹角为$θ$，假设电磁波发射到接收过程中，角度$θ$没有发生变化，发射有一个$F_电(θ)$，接收再乘以一个$F_电(θ)$，所以有一个平方项</li>
</ul>
</li>
<li><p>根据余弦定理有：</p>
<script type="math/tex; mode=display">
R^2\theta^2=R^2\delta^2+R^2\epsilon^2-2R^2\delta\epsilon cos(w_st-\phi_0)</script><p>近似可得：</p>
<script type="math/tex; mode=display">
\theta=\delta-\epsilon cos(w_s-\phi_0)</script></li>
<li><p>将$\theta$带入U：</p>
<script type="math/tex; mode=display">
U=KF_电^2(\delta-\epsilon cos(w_s-\phi_0))</script></li>
<li><p>将上式在$\delta$处展开为泰勒级数并忽略高次项，有：</p>
<script type="math/tex; mode=display">
U=U_0[1+\eta\epsilon cos(w_st-\phi_0)]</script><ul>
<li>$U_0=KF_电^2(\delta)$</li>
<li>$\eta=\frac{-2F_电’(\delta)}{F(\delta)}$</li>
</ul>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118190940403.png" alt="image-20221118190940403" style="zoom:50%;"></p>
</li>
<li><p>$U$反映的是回波信号的幅度，且随着时间 t 在发生变化。当$ϵ=0$的时候，$U$为一常数，说明此时目标就在旋转轴上，为一等幅信号。$\epsilon\neq0$的时候，$U$为一调幅信号</p>
</li>
<li><p>取出回波信号的包络，消除直流分量，则可以测得信号的包络为$U_0\eta\epsilon cos(w_st-\phi_0)$</p>
</li>
<li><p>真正进行角度跟踪，光知道$ϵ$并不能唯一确定目标位置。需要知道方位和俯仰误差两部分，即$U_0\eta\epsilon cos(\phi_0)、U_0\eta\epsilon sin(\phi_0)$</p>
<ul>
<li>误差电压分解的办法是采用两个相位鉴别器，相位鉴别器的基准电压分别为$cos(ω_st)$和$sin(ω_st)$ </li>
<li>将这两项分别与前面的包络项相混频（相乘），然后过低通滤波器，就可以得到方位和俯仰误差两部分分量</li>
</ul>
</li>
<li><p>前面的推导是假设$U_0$为一常数，即$K$为常数，也就是说假设目标是静止不动的。如果目标远离雷达或者向着雷达运动，$K$就会发生变化，不再是一个常数。如果目标向着雷达运动，$K$就会逐渐变大</p>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118193055329.png" alt="image-20221118193055329" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="2-单脉冲自动测角系统"><a href="#2-单脉冲自动测角系统" class="headerlink" title="2.单脉冲自动测角系统"></a>2.单脉冲自动测角系统</h2><ul>
<li><p>在一个角平面内，两个相同的波束部分重叠，其交叠方向即为等信号轴。将两个波束同时接收到的回波信号振幅进行比较，即可取得目标在该平面上的角误差信号，然后将此误差信号电压放大变换后加到驱动电机，控制天线向减小误差的方向运动</p>
</li>
<li><p>和差比较器是单脉冲雷达的重要部件，由它完成和、差处理，形成和差波束。用得较多的是双T接头</p>
<p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118193310164.png" alt="image-20221118193310164" style="zoom:50%;"></p>
</li>
</ul>
<h3 id="2-1-雷达发射过程"><a href="#2-1-雷达发射过程" class="headerlink" title="2.1 雷达发射过程"></a>2.1 雷达发射过程</h3><ul>
<li><p>发射时，从发射机来的信号加到和差比较器的$Σ$端，$Δ$端无输出，$1,2$两端输出同幅同相信号</p>
<script type="math/tex; mode=display">
F_\Sigma(\theta)=F_1(\theta)+F_2(\theta)</script><script type="math/tex; mode=display">
F_\Delta(\theta)=F_2(\theta)-F_1(\theta)</script></li>
<li><p>两个馈源被同相激励并辐射相同的功率，结果两波束在空间各点产生的场强同相相加，形成发射和波束$F_Σ(θ)$[以下都是电压天线图]</p>
<script type="math/tex; mode=display">
AF_1(\theta)+AF_2(\theta)=A(F_1(\theta)+F_2(\theta))=AF_\Sigma(\theta)</script></li>
</ul>
<h3 id="2-2-雷达接收过程"><a href="#2-2-雷达接收过程" class="headerlink" title="2.2 雷达接收过程"></a>2.2 雷达接收过程</h3><ul>
<li><p>双 T 接头的$1,2$端输入，$Δ$端输出差信号，$Σ$端输出和信号。到达$1,2$的回波信号为$K_FΣ(θ)$，振幅用$K$表示</p>
<script type="math/tex; mode=display">
\Delta=KF_\Sigma(\theta)F_2(\theta)-KF_\Sigma(\theta)F_1(\theta)=KF_\Sigma(\theta)[F_2(\theta)-F_1(\theta)]=KF_\Sigma(\theta)F_\Delta(\theta)</script><script type="math/tex; mode=display">
\Sigma=KF_\Sigma(\theta)F_2(\theta)+KF_\Sigma(\theta)F_1(\theta)=KF_\Sigma(\theta)[F_2(\theta)+F_1(\theta)]=KF_\Sigma^2(\theta)</script></li>
</ul>
<h3 id="2-3-理论分析"><a href="#2-3-理论分析" class="headerlink" title="2.3 理论分析"></a>2.3 理论分析</h3><p><img src="/2022/11/18/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%A7%92%E5%BA%A6%E6%B5%8B%E9%87%8F/image-20221118194933733.png" alt="image-20221118194933733" style="zoom: 33%;"></p>
<ul>
<li><p>雷达通过和天线方向图将信号发射出去，接收时，得到$Δ$和$Σ$信号，需通过$Δ$和$Σ$将目标所在位置$θ$求出来，就达到了自动测角的目的</p>
<script type="math/tex; mode=display">
F_\Sigma(\theta)=F(\theta-\delta)+F(\theta+\delta)</script><script type="math/tex; mode=display">
F_\Delta(\theta)=F(\theta-\delta)-F(\theta+\delta)</script><ul>
<li><p>将$F(\theta+\delta)$与$F(\theta-\delta)$在$\delta$处做泰勒展开，忽略高阶项得到：</p>
<script type="math/tex; mode=display">
F(\theta+\delta)=F(\delta)+F'(\delta)\theta</script><script type="math/tex; mode=display">
F(\theta-\delta)=F(\delta)-F'(\delta)\theta</script></li>
</ul>
</li>
<li><p>将$F(θ±δ) 、 F_Σ 、 F_Δ$带入到$Σ$和$Δ$的表达式中，得到：</p>
<script type="math/tex; mode=display">
\Sigma=4KF^2(\delta)</script><script type="math/tex; mode=display">
\Delta=-4KF(\delta)F'(\delta)\theta</script></li>
<li><p>式中，$Σ 、 Δ 、 δ 、 F$函数均为已知项，$K$和$θ$为未知项，将两式相比得到:</p>
<script type="math/tex; mode=display">
\frac{\Delta}{\Sigma}=-\frac{F'(\delta)}{F(\delta)}\theta=\eta\theta</script></li>
<li><p>最终得到$\theta$：</p>
<script type="math/tex; mode=display">
\theta=\frac{1}{\eta}\frac{\Delta}{\Sigma}</script></li>
<li><p>只要收到一个脉冲，就能输出$Σ$信号和$Δ$信号，将两者相比就能得到$θ$</p>
<ul>
<li>$Σ$和$Δ$同相，$θ$就为正；</li>
<li>$Σ$和$Δ$反相，$θ$就为负。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/256359707">七、角度测量 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>雷达原理之目标距离测量</title>
    <url>/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%B7%9D%E7%A6%BB%E6%B5%8B%E9%87%8F/</url>
    <content><![CDATA[<p>本节主要介绍了雷达目标距离测量的两种方式：脉冲法与调频法。</p>
<span id="more"></span>
<h1 id="脉冲法测距"><a href="#脉冲法测距" class="headerlink" title="脉冲法测距"></a>脉冲法测距</h1><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h2><ul>
<li><p>目标到雷达的距离的计算公式为$R=\frac{1}{2}Ct_R$，时间$t_R$就是回波相对于发射信号的延迟，因此，目标距离测量就是要精确测量延迟时间$t_R$</p>
</li>
<li><p>有两种定义回波到达时间$t_R$的方法：一种是以目标回波脉冲的前沿作为它的到达时刻；另一种是以回波脉冲的<strong>中心（或最大值）</strong> 作为它的到达时刻</p>
</li>
<li><p>回波脉冲中心估计</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%B7%9D%E7%A6%BB%E6%B5%8B%E9%87%8F/image-20221117231223154.png" alt="image-20221117231223154" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-影响测距精度的因素"><a href="#2-影响测距精度的因素" class="headerlink" title="2.影响测距精度的因素"></a>2.影响测距精度的因素</h2><ul>
<li><p>$\because R=\frac{1}{2}Ct_R,\therefore dR=\frac12Cdt_R+\frac12t_RdC=\frac12Cdt_R+\frac RCdC$</p>
</li>
<li><p>时间差的影响：$d{t_R}\downarrow,d{R}\downarrow$</p>
</li>
<li>传播速度变化的影响：$\frac{dR}R\propto \frac{dC}C$</li>
<li>大气折射的影响</li>
<li>测读方法误差</li>
</ul>
<h2 id="3-距离分辨率"><a href="#3-距离分辨率" class="headerlink" title="3.距离分辨率"></a>3.距离分辨率</h2><ul>
<li><p>距离分辨率$\Delta R$是指同一方向上两个大小相等点目标之间的最小可区分距离</p>
<script type="math/tex; mode=display">
\Delta R=\frac12C(\tau+\frac d{V_n})</script><script type="math/tex; mode=display">
其中，d:光电直径(m);V_n:扫掠速度(m/s)</script></li>
<li><p>通常希望距离分辨率$\Delta R$越小越好，但$\Delta R\downarrow,\Rightarrow\tau\downarrow,\Rightarrow  R_{max}\downarrow$，故存在距离分辨力和最大作用距离的矛盾问题</p>
</li>
<li><p>解决上述问题的办法：<strong>发射脉冲压缩波形，比如线性调频信号，接收时对回波进行匹配滤波</strong></p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%B7%9D%E7%A6%BB%E6%B5%8B%E9%87%8F/image-20221117234512550.png" alt="image-20221117234512550" style="zoom:33%;"></p>
<ul>
<li>采用-4dB的点的宽度来表示辛克函数的宽度，此时对应的时间为$\frac1B$</li>
<li>则脉压雷达的距离分辨率为：$\Delta R=\frac12C\cdot\frac1B$</li>
<li>线性调频信号的带宽：$B=\mu\tau$</li>
<li>故线性调频信号经过匹配滤波器后距离分辨率为：$\Delta R=\frac C{2\mu\tau}$</li>
<li>对于普通雷达，$τ$增大，$ΔR$增大； 对于线性调频信号，$τ$增大，$ΔR$减小</li>
<li><strong>匹配滤波对于普通雷达而言，可以达到输出信噪比最大的作用；对于脉压雷达，还可以提高距离分辨力</strong></li>
</ul>
</li>
</ul>
<h2 id="4-最大无模糊测距范围"><a href="#4-最大无模糊测距范围" class="headerlink" title="4.最大无模糊测距范围"></a>4.<strong>最大无模糊测距范围</strong></h2><ul>
<li><p>最小测距范围：$R_{min}=\frac12C(\tau+t_0),其中t_0为收发开关的转换时间$</p>
</li>
<li><p>最大无模糊作用距离：$R_{max}=\frac12CT_r$，<strong>其出现原因是最大距离大于脉冲重复周期$T_r$，不能确定距离跨越了几个$T_r$周期</strong></p>
</li>
<li><p>雷达探测目标，首先应该考虑达到最大作用距离，这时$T_r$就确定下来了。再来考虑是否满足最大无模糊距离。如果不满足，就需要解模糊</p>
<script type="math/tex; mode=display">
R=\frac12Ct_R=\frac12C(mT_r+t_r);0\le t_r<T_r</script><ul>
<li><p>$R$：目标到雷达的距离</p>
</li>
<li><p>$m$：假设跨了$m$个周期</p>
</li>
<li><p>$t_r$：回波离它最近主波之间的时间差</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-距离模糊的判决方法（重频参差（两重频））"><a href="#5-距离模糊的判决方法（重频参差（两重频））" class="headerlink" title="5.距离模糊的判决方法（重频参差（两重频））"></a>5.距离模糊的判决方法（重频参差（两重频））</h2><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%B7%9D%E7%A6%BB%E6%B5%8B%E9%87%8F/image-20230917160314632.png" alt="image-20230917160314632" style="zoom: 67%;"></p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%B7%9D%E7%A6%BB%E6%B5%8B%E9%87%8F/image-20230917160245645.png" alt="image-20230917160245645" style="zoom: 33%;"></p>
<ul>
<li><p>$t_1,t_2$是发射脉冲1和发射脉冲2接收到的回波与最近的发射脉冲之间的时间差，<strong>应满足如下条件</strong>：</p>
<script type="math/tex; mode=display">
0\le t_1\le T_{r1}</script><script type="math/tex; mode=display">
0\le t_2\le T_{r2}</script><ul>
<li>两种PRF下发射的脉冲数目互斥，如选取：$f_{r1} = N\cdot f_{rd}、f_{r2}=(N+1)\cdot f_{rd}$</li>
<li><strong>在一个期望的脉冲重复周期（PRI）内，两种发射信号的回波仅在一个时延位置上重合，这就是真正的目标位置</strong></li>
</ul>
</li>
<li><p>设$n_1,n_2$为两组发射脉冲的跨周期数</p>
</li>
<li><p>则当两发射信号的回波在同一个时刻重合时，有：</p>
<script type="math/tex; mode=display">
t_R=t_1+n1\frac1{f_{r1}}=t_2+n_2\frac1{f_{r2}}</script></li>
<li><p><strong>两种发射信号的回波仅在一个时延位置上重合，这就是真正的目标位置（因为目标与雷达之间的距离是确定的，无论脉冲重复频率怎么变，同一时间发出的脉冲，回波到达雷达的时间是相等的）</strong></p>
</li>
<li><p>$f_{r1},f_{r2}$可以看成一个基础频率$f_r$上的倍频，有：</p>
<script type="math/tex; mode=display">
f_{r1}=(N+a)f_r</script><script type="math/tex; mode=display">
f_{r2}=Nf_r</script></li>
<li><p>通常取$a=1$（图中$N=4$），则有：</p>
<script type="math/tex; mode=display">
\frac{f_{r1}}{f_{r2}}=\frac{N+1}{N}</script></li>
<li><p>当$a=1$时，$n_1,n_2$的关系有两种可能，即$n_1=n_2$和$n_1=n_2+1$：</p>
<ul>
<li><p>当$n_1=n_2(t_1&gt;t_2)$时，可得：</p>
<script type="math/tex; mode=display">
t_R=\frac{t_1f_{r1}-t_2f_{r2}}{f_{r1}-f_{r2}}</script></li>
<li><p>当$n_1=n_2+1(t_1&lt;t_2)$时，可得：</p>
<script type="math/tex; mode=display">
t_R=\frac{t_1f_{r1}-t_2f_{r2}+1}{f_{r1}-f_{r2}}</script></li>
</ul>
</li>
<li><p><strong>重频参差的最大模糊距离</strong>：</p>
<script type="math/tex; mode=display">
R_{max}=\frac12c(T_{r1}和T_{r2}的最小公倍数)</script></li>
<li><p><strong>重频参差并没有消除距离模糊的问题，而是将最大模糊距离扩大了</strong></p>
</li>
</ul>
<hr>
<h1 id="调频法测距（三角形波调制测距）"><a href="#调频法测距（三角形波调制测距）" class="headerlink" title="调频法测距（三角形波调制测距）"></a>调频法测距（三角形波调制测距）</h1><ul>
<li><p>发射频率按周期性三角波形的规律变化：</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%B7%9D%E7%A6%BB%E6%B5%8B%E9%87%8F/image-20221118111033034.png" alt="image-20221118111033034" style="zoom:50%;"></p>
</li>
<li><p><strong>正程</strong>：</p>
<ul>
<li><p>发射频率：$f(t)=f_0+\mu t$，其对应的发射信号的时域表达式为：$S_t(t)=Acos(2\pi f_0t+\pi\mu t^2)$</p>
</li>
<li><p>则接收信号的时域表示：</p>
<script type="math/tex; mode=display">
S_r(t)=kS_t(t-t_r)=kAcos(2\pi f_0(t-\frac{2(R_0-v_tt)}{C})+\pi\mu(t-\frac{2(R_0-v_tt)}{C})^2)</script><ul>
<li>$v_t$：目标相对于雷达的径向速度</li>
<li>$R_0$：目标到雷达的初始距离</li>
</ul>
</li>
<li><p>$S_r(t)$对时间求导，可以得到接收信号的频率$f_r$：</p>
<script type="math/tex; mode=display">
f_r=f_0+\frac{2v_t}{\lambda}+\mu(t-\frac{2R_0}{C})(1+\frac{2v_t}{C})</script><ul>
<li>由于多普勒频率$f_d=\frac{2v_t}{\lambda}$，$C&gt;&gt;v$</li>
<li>则：</li>
</ul>
<script type="math/tex; mode=display">
f_r=f_0+f_d+\mu(t-\frac{2R_0}C)</script></li>
</ul>
</li>
<li><p><strong>逆程</strong>：</p>
<ul>
<li><p>发射频率：$f_t=f_0-\mu t$</p>
</li>
<li><p>与正程推理相同，则可得到接收频率$f_r$：</p>
<script type="math/tex; mode=display">
f_r=f_0-\mu(t-\frac{2R_0}C)+f_d</script></li>
</ul>
</li>
<li><p>则物体无运动，忽略$f_d$，有：</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E7%9B%AE%E6%A0%87%E8%B7%9D%E7%A6%BB%E6%B5%8B%E9%87%8F/image-20221118112818465.png" alt="image-20221118112818465" style="zoom:50%;"></p>
</li>
<li><p>求差频的平均值：</p>
<ul>
<li><p>正程频率差$f_{b^+}$：</p>
<script type="math/tex; mode=display">
f_{b^+}=f_t-f_r=\frac{2\mu R_0}{C}-f_d</script></li>
<li><p>负程频率差$f_{b^-}$：</p>
<script type="math/tex; mode=display">
f_{b^-}=f_r-f_t=\frac{2\mu R_0}{C}+f_d</script></li>
<li><p>频率计测得的差频的平均值$F_{bav}$：</p>
<script type="math/tex; mode=display">
F_{bav}=\frac{f_{b^+}+f_{b^-}}{2}=\frac{2\mu R_0}C</script></li>
<li><p>则：</p>
<script type="math/tex; mode=display">
R_0=\frac{CF_{bav}}{2\mu}</script></li>
</ul>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/343220940">六，目标距离测量 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>雷达原理之雷达作用距离</title>
    <url>/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p>本节主要介绍了雷达作用距离的影响因素，包括最小可检测信号、脉冲积累、目标截面积、系统损耗等，以及不同形式的雷达方程。</p>
<span id="more"></span>
<h1 id="雷达方程"><a href="#雷达方程" class="headerlink" title="雷达方程"></a>雷达方程</h1><h2 id="1-基本雷达方程"><a href="#1-基本雷达方程" class="headerlink" title="1.基本雷达方程"></a>1.基本雷达方程</h2><ul>
<li><p>雷达基本方程，也叫做最大作用距离方程</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221116111811248.png" alt="image-20221116111811248" style="zoom:50%;"></p>
</li>
<li><p>$P_t$：雷达发射机发射信号的功率</p>
</li>
<li><p>$G_t$：发射天线增益，这里假设目标与雷达天线的连线正好穿过天线方向图最大增益处</p>
</li>
<li><p>$G_r$：接收天线增益，若天线为收发共用，有$G_r$=$G_t$</p>
</li>
<li><p>$\sigma$：表示目标的雷达截面积（RCS），<strong>其反映入射电磁波照射到目标上之后发射回来的电磁波的大小</strong>。隐身飞机就是将 σ 做的很小。当雷达电磁波照射到目标上之后，反射回来的电磁波功率很弱，就达到了目标对雷达隐身的目的。</p>
</li>
<li><p>$S_{imin}$表示接收手机灵敏度，即最小可检测信号</p>
</li>
<li><p>假设电磁波反射回来之后，经过接收天线主瓣最大值（接收天线方向图最大增益为$G_r$），接收机接收到的信号功率就等于反射回来的信号功率乘以接收天线的有效面积$A_r$。此时，接收机能否检测到信号跟$S_{imin}$有关。</p>
</li>
<li><p>如果满足，$P_r≥S_{imin}$，雷达就可以探测到目标</p>
</li>
</ul>
<h2 id="2-方程公式推导"><a href="#2-方程公式推导" class="headerlink" title="2.方程公式推导"></a>2.方程公式推导</h2><ul>
<li><p>到达目标的入射功率密度为:</p>
<script type="math/tex; mode=display">
\frac{P_tG_t}{4\pi R^2}</script></li>
<li><p>目标反射回来的功率为：</p>
<script type="math/tex; mode=display">
\frac{P_tG_t\sigma}{4\pi R^2}</script></li>
<li><p>假设接收天线的有效面积为$A_r$：</p>
<script type="math/tex; mode=display">
\frac{P_tG_t\sigma}{4\pi R^2}\times\frac{A_r}{4\pi R^2}</script></li>
<li><p>由于<strong>$A_r$与$G_r$的关系</strong>为：</p>
<script type="math/tex; mode=display">
G_r=\frac{4\pi A_r}{\lambda^2}</script></li>
<li><p>故最终接收到的功率为：</p>
<script type="math/tex; mode=display">
P_r=\frac{P_tG_tG_r\lambda^2\sigma}{(4\pi)^3R^4}</script></li>
<li><p><strong>而当$P_r$=$S_{simin}$时，R就取得最大值</strong>：</p>
<script type="math/tex; mode=display">
R_{max}=[\frac{P_tG_tG_r\lambda^2\sigma}{(4\pi)^3S_{simin}}]^{1/4}</script><ul>
<li><p>若雷达的检测门限设置为最小输出信噪比$(SNR)_{omin}$，则最小可检测信号功率为：</p>
<script type="math/tex; mode=display">
S_{min} = kT_0 BF(SNR)_{omin}(W)</script></li>
<li><p><strong>将上式代入雷达方程$R_{max}$，并用$L$表示雷达各部分的功耗</strong>（用L表示损耗而加在雷达方程的分母中，<strong>L是大于1的值</strong>。损耗L包括许多比较容易确定的值，诸如波导传输损耗、接收机失配损耗、天线波束形状损耗等，损耗L中还包括一些不易估计的值，例如操纵员损耗、设备工作不完善损耗等，这些因素要根据经验和实验测定来估计），<strong>可得到</strong>：</p>
<script type="math/tex; mode=display">
R_{max}=[\frac{P_tG_tG_r\lambda^2\sigma}{(4\pi)^3kT_0 BFL(SNR)_{omin}}]^{1/4}</script></li>
</ul>
</li>
<li><p><strong>一般情况下，可近似认为带宽为时宽的倒数</strong>，即$B\approx \frac{1}{\tau}$</p>
</li>
</ul>
<h2 id="3-单基地雷达方程"><a href="#3-单基地雷达方程" class="headerlink" title="3.单基地雷达方程"></a>3.单基地雷达方程</h2><ul>
<li><p><strong>理想无损耗</strong>、<strong>自由空间传播</strong>的<strong>单基地</strong>雷达方程，且假设信号从天线方向图最大增益处发射、接收</p>
<script type="math/tex; mode=display">
P_r=\frac{P_tG_t}{4\pi R^2}\times\sigma\times\frac{A_r}{4\pi R^2}</script></li>
<li><p>收发不同天线：</p>
<script type="math/tex; mode=display">
R_{max}=[\frac{P_tG_tG_r\lambda^2\sigma}{(4\pi)^3S_{simin}}]^{1/4}</script></li>
<li><p>收发天线共用：</p>
<script type="math/tex; mode=display">
R_{max}=[\frac{P_tG_r^2\lambda^2\sigma}{(4\pi)^3S_{simin}}]^{1/4}</script></li>
</ul>
<h1 id="目标的散射截面积-RCS"><a href="#目标的散射截面积-RCS" class="headerlink" title="目标的散射截面积(RCS)"></a>目标的散射截面积(RCS)</h1><ul>
<li>定义式</li>
</ul>
<script type="math/tex; mode=display">
\sigma=\frac{P_2}{S_1}</script><ul>
<li><p>其中，$P_2$为散射总功率，$S_1$为入射功率密度</p>
</li>
<li><p>$P_2=4\pi\times返回接收机每单位立体角内的回波功率$</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117123419319.png" alt="image-20221117123419319" style="zoom: 33%;"></p>
</li>
<li><p><strong>测量</strong>：</p>
<ul>
<li><p>标准截面积$\sigma_0$满足：</p>
<script type="math/tex; mode=display">
P_{ro}=k\frac{\sigma_0}{R_0^4}</script></li>
<li><p>若未知目标处于R处，测$P_r$：</p>
<script type="math/tex; mode=display">
P_r=k\frac{\sigma}{R_0^4}</script></li>
<li><p>将上式两式相比，可以得到$\sigma$：</p>
<script type="math/tex; mode=display">
\sigma=\frac{P_r}{P_{r0}}\cdot\frac{R^4}{R_0^4}\cdot\sigma_0</script></li>
</ul>
</li>
</ul>
<hr>
<h1 id="最小可检测信号"><a href="#最小可检测信号" class="headerlink" title="最小可检测信号"></a>最小可检测信号</h1><h2 id="1-最小可检测信号与信噪比"><a href="#1-最小可检测信号与信噪比" class="headerlink" title="1.最小可检测信号与信噪比"></a>1.最小可检测信号与信噪比</h2><ul>
<li><p>如果只有信号而没有噪声，任何微弱信号在理论上都可以经过任意放大之后被检测到，因此，雷达检测能力实际上取决于信号噪声比</p>
</li>
<li><p>$S_{imin}=kT_0BFM$，其中<strong>M又称为检测因子$D_0$​</strong>。<strong>定义为接收机匹配滤波器输出端（检波器输入端）测量的信号噪声功率比</strong></p>
<script type="math/tex; mode=display">
M=(\frac{S}{N})_{omin}</script></li>
<li><p>将$S_{imin}$带入雷达方程，得到：</p>
<script type="math/tex; mode=display">
R_{max}=[\frac{P_tG_tG_r\lambda^2\sigma}{(4\pi)^3kT_0BFD_0}]^{1/4}</script></li>
</ul>
<h2 id="2-门限检测"><a href="#2-门限检测" class="headerlink" title="2.门限检测"></a>2.门限检测</h2><ul>
<li><p>由于噪声的存在，判断信号是否出现就成了一个统计问题，必须根据某种统计检测标准进行判断</p>
</li>
<li><p><strong>奈曼-皮尔逊准则</strong>：要求在给定信噪比条件下，<strong>满足一定虚警概率$P_{fa}$时的发现概率$P_d$ 最大。</strong></p>
</li>
<li>接收检测系统首先在中频部分对<strong>单个脉冲信号进行匹配滤波</strong>，接着进行检波，通常是在n个脉冲积累后再检测，将积累输出与某一门限电压进行比较，若输出包络超过门限，则认为有目标存在，否则认为没有目标，这就是<strong>检测门限</strong>。</li>
<li>门限检测是一种统计检测，由于信号叠加有噪声，因而总输出是一个随机量。在输出端根据输出振幅是否超过门限来判断有无目标存在，可能出现以下四种情况:<ul>
<li>无目标时：<ul>
<li>$V\ge V_T$：判断为有目标，此时称为虚警，则有虚警概率$P_{fa}$</li>
<li>$V&lt;V_T$：判断为无目标，此时称为正确不发现，则有正确不发现概率$P_{an}=1-P_a$</li>
</ul>
</li>
<li>有目标时：<ul>
<li>$V\ge V_T$：判断为有目标，此时称为正确发现，则有发现概率$P_{d}$</li>
<li>$V&lt;V_T$：判断为无目标，此时称为漏报，则有漏报概率$P_{la}=1-P_d$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-检测性能与信噪比"><a href="#3-检测性能与信噪比" class="headerlink" title="3.检测性能与信噪比"></a>3.检测性能与信噪比</h2><h3 id="3-1-虚警概率"><a href="#3-1-虚警概率" class="headerlink" title="3.1 虚警概率"></a>3.1 虚警概率</h3><ul>
<li><p>$P_{fa}=\int_{V_T}^\infty w(x|无目标)dx$，其中高斯噪声的包络服从瑞利分布$w(x|无目标)=\frac{x}{\sigma^2}e^{-\frac{x^2}{2\sigma^2}}$</p>
</li>
<li><p>则$P_{fa}=e^{-\frac{V_T^2}{2\sigma}}$，$\sigma$为噪声的均方根值，</p>
</li>
<li><p>虚警时间与虚警概率的关系</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117132424244.png" alt="image-20221117132424244" style="zoom:50%;"></p>
</li>
<li><p>虚警数：$n_f=\frac{1}{P_{fa}}$，出现一次虚警所需要的次数</p>
</li>
</ul>
<h3 id="3-2-发现概率"><a href="#3-2-发现概率" class="headerlink" title="3.2 发现概率"></a>3.2 发现概率</h3><ul>
<li><p>$P_{fa}=\int_{V_T}^\infty w(x|有目标)dx$</p>
</li>
<li><p>此时有目标，$w(x|有目标)$服从广义瑞利分布，通过查表查找</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117133259094.png" alt="image-20221117133259094" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h1 id="脉冲积累对作用距离的改善"><a href="#脉冲积累对作用距离的改善" class="headerlink" title="脉冲积累对作用距离的改善"></a>脉冲积累对作用距离的改善</h1><h2 id="1-相参积累"><a href="#1-相参积累" class="headerlink" title="1.相参积累"></a>1.相参积累</h2><ul>
<li><p>假设$ω$为天线扫描角速度。$\frac{θ_{0.5}}{ω}$ 为扫过3dB带宽所需时间，在此时间接收机都能接收到回波信号。</p>
</li>
<li><p>则能接收到的脉冲积累个数为：</p>
<script type="math/tex; mode=display">
w=\frac{\theta_{0.5}}{w}f_r</script></li>
<li><p>单个脉冲回波信号：其功率为$A^2$，噪声功率为$\sigma^2$</p>
<script type="math/tex; mode=display">
Acos(2\pi f_0+\phi_0)</script></li>
<li><p>$M$个脉冲相参积累（$\phi$相同）后：其功率为$M^2A^2$，噪声功率为$M\sigma^2$</p>
<script type="math/tex; mode=display">
MAcos(2\pi f_0t+\phi_0)</script></li>
<li><p>故相参后信号噪声比为：</p>
<script type="math/tex; mode=display">
\frac{M^2A^2}{M\sigma^2}=M\frac{A^2}{\sigma^2}</script></li>
<li><p><strong>则相参积累后，信噪比扩大了M倍</strong></p>
</li>
<li><p><strong>定义$D_0(M)$：M个脉冲积累之后，每一个脉冲所需的信噪比</strong></p>
<script type="math/tex; mode=display">
D_0(M)=\frac{D_0(1)}{M}</script><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117135803233.png" alt="image-20221117135803233" style="zoom: 33%;"></p>
</li>
<li><p><strong>相参积累后，最大作用距离变为</strong>：</p>
<script type="math/tex; mode=display">
R_{max}'=R_{max}\sqrt[4]M</script></li>
</ul>
<h2 id="2-非相参积累"><a href="#2-非相参积累" class="headerlink" title="2.非相参积累"></a>2.非相参积累</h2><ul>
<li>每个回波脉冲的初始相位$\phi$是有变化的。所以，积累之后幅度不能增加 M 倍</li>
<li>通过查表得方式查找$D_0(M)$</li>
</ul>
<h2 id="3-脉冲积累数的确定"><a href="#3-脉冲积累数的确定" class="headerlink" title="3.脉冲积累数的确定"></a>3.脉冲积累数的确定</h2><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117140919695.png" alt="image-20221117140919695" style="zoom: 33%;"></p>
<hr>
<h1 id="目标截面积及其起伏特性"><a href="#目标截面积及其起伏特性" class="headerlink" title="目标截面积及其起伏特性"></a>目标截面积及其起伏特性</h1><h2 id="1-点目标"><a href="#1-点目标" class="headerlink" title="1.点目标"></a>1.点目标</h2><h3 id="1-1-距离分辨率"><a href="#1-1-距离分辨率" class="headerlink" title="1.1 距离分辨率"></a>1.1 距离分辨率</h3><ul>
<li>距离分辨率用于描述雷达分别探测出相邻目标的能力</li>
<li>如果两个目标的间距至少为$\frac{C\tau}{2}$，那么当脉冲后沿撞上第一个目标时，这个脉冲的前沿才开始从第二个目标返回将产生两个分开的返回脉冲。当两个目标的间距小于$\frac{C\tau}{2}$时，返回的脉冲将包括两个目标的回波（即未分辨的回波)。</li>
<li>则$距离分辨率=\frac{C\tau}{2}$</li>
</ul>
<h3 id="1-2-角度分辨率"><a href="#1-2-角度分辨率" class="headerlink" title="1.2 角度分辨率"></a>1.2 角度分辨率</h3><ul>
<li>角度分辨率是由天线的波束宽度决定的</li>
<li>即使两个散射体位于同一距离的不同方位，只要它们都在天线的主瓣内，它们都会被同时照射到，它们的回波也会同时被雷达接收</li>
<li>采用天线的3dB波束宽度作为主瓣宽度，这样位于波束3dB边缘的两个点散射体就定义了雷达的角度分辨率</li>
</ul>
<h3 id="1-3-雷达三维分辨单元"><a href="#1-3-雷达三维分辨单元" class="headerlink" title="1.3 雷达三维分辨单元"></a>1.3 雷达三维分辨单元</h3><ul>
<li>如果两个目标同时落在同一个距离单元，也在同一个角度单元，雷达就无法区分这两个目标，我们就把距离单元和角度单元构成的一个三维单元称为雷达三维分辨单元$\Delta V$</li>
</ul>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117142137024.png" alt="image-20221117142137024" style="zoom:33%;"></p>
<ul>
<li>如果目标体积满足：$V&lt;ΔV$，就称之为<strong>点目标</strong>。</li>
</ul>
<h3 id="1-4-点目标横截面积与波长的关系"><a href="#1-4-点目标横截面积与波长的关系" class="headerlink" title="1.4 点目标横截面积与波长的关系"></a>1.4 点目标横截面积与波长的关系</h3><ul>
<li><p>最理想的点目标是一个各向同性的球体。设$r$为各向同性球体的半径。</p>
</li>
<li><p>当雷达照射球体时，分为三种情况：</p>
<ul>
<li>瑞利区：$λ&gt;&gt;2πr，σ∝λ−4$</li>
<li>振荡区：$λ≈2πr，σ在πr^2附近振荡$</li>
<li>光学区：$λ≤2πr，σ≈πr^2$</li>
</ul>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117143230577.png" alt="image-20221117143230577" style="zoom: 33%;"></p>
</li>
<li><p>我们希望点目标处于光学区。实际上大多数目标都处在光学区</p>
</li>
</ul>
<h2 id="2-简单形状目标的雷达截面积"><a href="#2-简单形状目标的雷达截面积" class="headerlink" title="2.简单形状目标的雷达截面积"></a>2.简单形状目标的雷达截面积</h2><ul>
<li>几何形状比较简单的目标，如球体、圆板、锥体等，它们的雷达截面积可以计算出来</li>
</ul>
<h2 id="3-复杂目标的雷达截面积"><a href="#3-复杂目标的雷达截面积" class="headerlink" title="3.复杂目标的雷达截面积"></a>3.复杂目标的雷达截面积</h2><ul>
<li>复杂目标是指雷达实际要探测的各种目标，如飞机、舰船、地物等</li>
<li>复杂目标的雷达截面积是不仅是视角的函数（也就是说雷达从不同方向照射目标，目标的雷达截面积会发生变化），同时也随频率、波长、极化等变化。通常雷达工作时，精确的目标姿态及视角是不知道的，因为目标运动时视角随时间变化。因此，最好是用统计的概念来描述雷达截面积。</li>
</ul>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117144032083.png" alt="image-20221117144032083" style="zoom: 33%;"></p>
<h2 id="4-目标反射特性与极化"><a href="#4-目标反射特性与极化" class="headerlink" title="4.目标反射特性与极化"></a>4.目标反射特性与极化</h2><ul>
<li><strong>极化</strong>：用来描述电场的方向。当电场的方向是垂直时，该电磁波被说成是垂直极化；当电场的方向是水平时，该电磁波被说成是水平极化。</li>
<li>当波被<strong>反射</strong>时，被反射波的极化不仅取决于入射波的极化，还取决于反射体的结构。事实上，雷达回波的极化可被用于辅助辨别目标的类型。</li>
</ul>
<h3 id="4-1-线极化（水平极化、垂直极化）"><a href="#4-1-线极化（水平极化、垂直极化）" class="headerlink" title="4.1 线极化（水平极化、垂直极化）"></a>4.1 线极化（水平极化、垂直极化）</h3><ul>
<li><p>将照射电场分解为$E_H^T,E_V^T$，接收电场分解为$E_H^R,E_V^R$，有：</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117145159096.png" alt="image-20221117145159096" style="zoom:33%;"></p>
<ul>
<li><strong>散射矩阵</strong>：反映目标本身的散射特性。即目标对于照射它的电场变为接收电场，目标对于极化的影响。</li>
<li>$α_{HH}$表示水平极化入射场产生水平极化散射场的散射系数</li>
<li>$α_{HV}$表示水平极化入射场产生垂直极化散射场的散射系数</li>
<li>$α_{VH}$表示垂直极化入射场产生水平极化散射场的散射系数</li>
<li>$α_{VV}$表示垂直极化入射场产生垂直极化散射场的散射系数</li>
</ul>
</li>
<li><p>特殊形体目标的散射矩阵</p>
<ul>
<li><p>各项同性的球体</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117145636457.png" alt="image-20221117145636457" style="zoom: 50%;"></p>
</li>
<li><p>相对于入射方向对称的物体</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117145706008.png" alt="image-20221117145706008" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-圆极化（左旋、右旋）"><a href="#4-2-圆极化（左旋、右旋）" class="headerlink" title="4.2 圆极化（左旋、右旋）"></a>4.2 圆极化（左旋、右旋）</h3><ul>
<li>$E_R^T，E_L^T$分别表示发射场中的右旋和左旋圆极化成分， $E_R^S，E_L^S$分别表示散射场中右旋和左旋圆极化成分。</li>
</ul>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117145803515.png" alt="image-20221117145803515" style="zoom:50%;"></p>
<ul>
<li><p>相对于入射方向对称的物体</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117150113658.png" alt="image-20221117150113658" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="5-目标起伏对检测性能的影响"><a href="#5-目标起伏对检测性能的影响" class="headerlink" title="5.目标起伏对检测性能的影响"></a>5.目标起伏对检测性能的影响</h2><ul>
<li><p>目标雷达截面积的大小对雷达检测性能有直接的关系，在工程计算中常把截面积视为常量。实际上，处于运动状态的目标，视角一直在变化，截面积随之产生起伏。</p>
</li>
<li><p>目标起伏模型</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117150319069.png" alt="image-20221117150319069" style="zoom:33%;"></p>
<ul>
<li><p>扫描间：指的是同一个周期内的M个回波间是有相关性的，不同周期扫描间的回波是没有相关性的。说明目标本身起伏特性的变化比较慢</p>
</li>
<li><p>脉冲间：指的是同一个扫描周期内的M个回波间不具有相关性，说明目标本身起伏特性的变化很快</p>
</li>
<li><p><strong>由于目标起伏引起检测困难，$D_0$增加</strong></p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117152651762.png" alt="image-20221117152651762" style="zoom:33%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="雷达方程的几种形式"><a href="#雷达方程的几种形式" class="headerlink" title="雷达方程的几种形式"></a>雷达方程的几种形式</h1><h2 id="1-二次雷达方程"><a href="#1-二次雷达方程" class="headerlink" title="1.二次雷达方程"></a>1.二次雷达方程</h2><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117155108154.png" alt="image-20221117155108154" style="zoom: 33%;"></p>
<ul>
<li><p>雷达发射信号，应答器接收</p>
<script type="math/tex; mode=display">
P_r'=\frac{P_tG_t}{4\pi R_1^2}A_r'=\frac{P_tG_t\lambda^2G_r'}{(4\pi)^2R_1^2}</script><p>则：</p>
<script type="math/tex; mode=display">
R_{1max}=[\frac{P_tG_tG_r'\lambda^2}{(4\pi)^2S_{imin}'}]^{1/2}</script></li>
<li><p>应答器发射信号，雷达接收</p>
<script type="math/tex; mode=display">
R_{2max}=[\frac{P_t'G_t'G_r\lambda^2}{(4\pi)^2S_{imin}}]^{1/2}</script></li>
<li><p>则$R_{max}$：</p>
<script type="math/tex; mode=display">
R_{max}=\lbrace R_{1max},R_{2max}\rbrace</script></li>
</ul>
<h2 id="2-双基地雷达方程"><a href="#2-双基地雷达方程" class="headerlink" title="2.双基地雷达方程"></a>2.双基地雷达方程</h2><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117160249854.png" alt="image-20221117160249854" style="zoom: 50%;"></p>
<ul>
<li>根据基本雷达方程有：<script type="math/tex; mode=display">
P_r=\frac{P_tG_t}{4\pi R_t^2}\cdot\sigma\cdot\frac{A_r}{4\pi R_r^2}=\frac{P_tG_tG_r\lambda^2\sigma}{(4\pi)^3R_t^2R_r^2}</script></li>
</ul>
<script type="math/tex; mode=display">
则:R_{max}=R_tR_r=[\frac{P_tG_tG_r\lambda^2\sigma}{(4\pi)^3S_{imin}}]^{1/2}</script><ul>
<li><p>限制条件：</p>
<script type="math/tex; mode=display">
R_t+Rr\ge R_b</script><script type="math/tex; mode=display">
|R_t-R_r|\le R_b</script></li>
</ul>
<h2 id="3-用信号能量表示的雷达方程"><a href="#3-用信号能量表示的雷达方程" class="headerlink" title="3.用信号能量表示的雷达方程"></a>3.用信号能量表示的雷达方程</h2><script type="math/tex; mode=display">
R_{max}=[\frac{EG_t^2\lambda^2\sigma}{(4\pi)^3kT_0FD_0C_B}]^{1/4}</script><script type="math/tex; mode=display">
其中，C_B是失配损失，E=P_t\tau</script><h2 id="4-干扰情况下的雷达方程"><a href="#4-干扰情况下的雷达方程" class="headerlink" title="4.干扰情况下的雷达方程"></a>4.干扰情况下的雷达方程</h2><h3 id="4-1-有源干扰（干扰机）"><a href="#4-1-有源干扰（干扰机）" class="headerlink" title="4.1 有源干扰（干扰机）"></a>4.1 有源干扰（干扰机）</h3><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117161856482.png" alt="image-20221117161856482" style="zoom:50%;"></p>
<ul>
<li><p>雷达要想检测到目标，必须满足：<strong>信号功率/（噪声功率+干扰功率）&gt; 某个门限</strong>，即$\frac{P_{rs}}{P_{rj}}\ge A$（忽略噪声功率）</p>
</li>
<li><p>雷达接收到的目标回波信号功率$P_{rs}$：</p>
<script type="math/tex; mode=display">
P_{rs}=\frac{P_tG_tG_r\lambda^2\sigma}{(4\pi)^3R^4L}</script></li>
<li><p>雷达接收到的干扰信号功率$P_{rj}$：</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117163047100.png" alt="image-20221117163047100" style="zoom:33%;"></p>
<script type="math/tex; mode=display">
P_{rj}=\frac{P_jG_jA_r'}{4\pi R_j^2}\times\frac{\Delta f_r}{\Delta f_j}</script><script type="math/tex; mode=display">
其中:G_r'=\frac{4\pi A_r'}{\lambda^2}=G_rF(\theta)</script></li>
<li><p>当$\frac{P_{rs}}{P_{rj}}=A$时，作用距离最大，有：</p>
<script type="math/tex; mode=display">
R_{max}=[\frac{P_tG_tG_r\sigma R_j^2\Delta f_j}{4\pi P_jG_jG_r'\Delta f_rAL}]^{1/4}</script></li>
<li><p><strong>自卫干扰：将干扰机放到目标上</strong></p>
<ul>
<li>$R_j=R,G_r’=G_r$</li>
<li>$R_{max}=[\frac{P_tG_t\sigma\Delta f_j}{4\pi P_jG_j\Delta f_rAL}]^{1/4}$</li>
</ul>
</li>
</ul>
<h3 id="4-2-无源干扰（箔条干扰）"><a href="#4-2-无源干扰（箔条干扰）" class="headerlink" title="4.2 无源干扰（箔条干扰）"></a>4.2 无源干扰（箔条干扰）</h3><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20221117164629008.png" alt="image-20221117164629008" style="zoom: 33%;"></p>
<hr>
<h1 id="雷达基本方程的Python实现"><a href="#雷达基本方程的Python实现" class="headerlink" title="雷达基本方程的Python实现"></a>雷达基本方程的Python实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radar_basic_eq</span>(<span class="params">pt, freq, G, sigma, b, NF, L, snr</span>):</span><br><span class="line">    c = <span class="number">3.0e8</span> <span class="comment">#光速</span></span><br><span class="line">    t0 = <span class="number">290</span></span><br><span class="line">    lambda1 = c/freq</span><br><span class="line"></span><br><span class="line">    num1 = <span class="number">10</span> * np.log10(pt * <span class="number">1.0e3</span> * lambda1 ** <span class="number">2</span>) + <span class="number">2</span> * G +sigma</span><br><span class="line">    num2 = <span class="number">10</span> * np.log10((<span class="number">4.0</span> * np.pi) ** <span class="number">3</span> * (<span class="number">1.38e-23</span>) * t0 * b) + NF + L</span><br><span class="line">    range_db = num1 * np.ones((<span class="number">1</span>, <span class="built_in">len</span>(snr))) - num2 - snr <span class="comment">#shape = (3, 1)*(1, 100) - (100, )</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> range_db</span><br><span class="line"></span><br><span class="line">pt = <span class="number">1500</span> <span class="comment">#峰值功率</span></span><br><span class="line">freq = <span class="number">5.6e9</span> <span class="comment">#频率</span></span><br><span class="line">G = <span class="number">45</span> <span class="comment">#天线增益</span></span><br><span class="line">sigma = np.array([-<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>]) <span class="comment">#目标截面积</span></span><br><span class="line">sigma = sigma.reshape(<span class="built_in">len</span>(sigma), <span class="number">1</span>)</span><br><span class="line">b = <span class="number">5.0e+6</span> <span class="comment">#宽带</span></span><br><span class="line">NF = <span class="number">3</span> <span class="comment">#噪声系数</span></span><br><span class="line">L = <span class="number">4</span> <span class="comment">#雷达损耗</span></span><br><span class="line">snr = np.linspace(<span class="number">10</span>, <span class="number">60</span>, <span class="number">100</span>) <span class="comment">#信噪比</span></span><br><span class="line"></span><br><span class="line">range_db = radar_basic_eq(pt, freq, G, sigma, b, NF, L, snr)</span><br><span class="line">range_km = <span class="number">10</span> ** (range_db / <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sigma.size):</span><br><span class="line">    plt.scatter(snr, range_km[i] / <span class="number">1000</span>, label=<span class="string">f&quot;sigma = <span class="subst">&#123;sigma[i][<span class="number">0</span>]&#125;</span>&quot;</span>) <span class="comment">#range用km表示</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;SNR in dB&quot;</span>,fontsize=<span class="number">12</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Range in km&quot;</span>,fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># plt.xlim(10, 60)</span></span><br><span class="line"><span class="comment"># plt.ylim(20, 100)</span></span><br><span class="line">plt.title(<span class="string">&quot;Radar Equation&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下（最小输出信噪比与雷达作用距离之间的关系）：</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E4%BD%9C%E7%94%A8%E8%B7%9D%E7%A6%BB/image-20230914181346262.png" alt="image-20230914181346262" style="zoom: 33%;"></p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/174829860">五，雷达作用距离 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>雷达原理之雷达终端显示器</title>
    <url>/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/</url>
    <content><![CDATA[<p>本节主要介绍了雷达终端显示器中A显、PPI显以及计算机图像显示的原理。</p>
<span id="more"></span>
<h1 id="雷达终端显示器的基本概念"><a href="#雷达终端显示器的基本概念" class="headerlink" title="雷达终端显示器的基本概念"></a>雷达终端显示器的基本概念</h1><h2 id="1-显示器的主要类型"><a href="#1-显示器的主要类型" class="headerlink" title="1.显示器的主要类型"></a>1.显示器的主要类型</h2><ul>
<li><p>距离显示器</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117103021484.png" alt="image-20221117103021484" style="zoom:50%;"></p>
<ul>
<li>显示斜距坐标</li>
<li>振幅表示目标回波强弱</li>
<li>一维显示器</li>
</ul>
</li>
<li><p>平面位置显示器（PPI）</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117103133435.png" alt="image-20221117103133435" style="zoom:50%;"></p>
<ul>
<li>二维显示器$(R,\alpha)$</li>
<li>通过亮度判断回波的强弱</li>
</ul>
</li>
<li><p>高度显示器</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117103406583.png" alt="image-20221117103406583" style="zoom:50%;"></p>
</li>
<li><p>情况显示器</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117103419090.png" alt="image-20221117103419090" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-对显示器的要求"><a href="#2-对显示器的要求" class="headerlink" title="2.对显示器的要求"></a>2.对显示器的要求</h2><ul>
<li>根据任务选择类型</li>
<li>参数选择</li>
<li><p>对比度：$对比度=\frac{图像亮度-背景亮度}{背景亮度}\times100%$</p>
</li>
<li><p>重显频率</p>
</li>
</ul>
<hr>
<h1 id="A显的原理"><a href="#A显的原理" class="headerlink" title="A显的原理"></a>A显的原理</h1><h2 id="1-静电偏转示波管"><a href="#1-静电偏转示波管" class="headerlink" title="1.静电偏转示波管"></a>1.静电偏转示波管</h2><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117103655799.png" alt="image-20221117103655799" style="zoom:50%;"></p>
<h2 id="2-相关参数"><a href="#2-相关参数" class="headerlink" title="2.相关参数"></a>2.相关参数</h2><ul>
<li>偏转灵敏度$S_x(cm/V)$</li>
<li>锯齿电压幅度$V_x(V)$</li>
<li>扫描线长$l(cm)$</li>
<li>量程$R_m(km)$</li>
<li>标尺系数$m(km/cm)$</li>
<li>正程时间$T(ms)$</li>
<li>锯齿波斜率$k(V/ms)$</li>
<li>单位刻度距离$\Delta R(km)$</li>
<li>刻度周期$T’(ms)$</li>
<li>刻度频率$f(kHz)$</li>
</ul>
<h2 id="3-参数关系"><a href="#3-参数关系" class="headerlink" title="3.参数关系"></a>3.参数关系</h2><ul>
<li>$S_x(cm/V)$的大小取决于静电偏转示波管</li>
<li>$l=S_xV_x$</li>
<li>$l=\frac{R_m}{m}$</li>
<li>$R_m=\frac{CT}{2}=150T$</li>
<li>$k=\frac{V_x}{T}$</li>
<li>$\Delta R=\frac{CT’}{2}=150T’$</li>
<li>$f=\frac{1}{T’}$</li>
</ul>
<hr>
<h1 id="PPI显示器"><a href="#PPI显示器" class="headerlink" title="PPI显示器"></a>PPI显示器</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h2><ul>
<li>距离扫掠：光点从中心沿半径向外扫掠</li>
<li>方位扫掠：距离扫掠于天线同步旋转</li>
</ul>
<h2 id="2-动圈式P显"><a href="#2-动圈式P显" class="headerlink" title="2.动圈式P显"></a>2.动圈式P显</h2><ul>
<li><p><strong>距离扫掠：磁偏转</strong></p>
<ul>
<li>偏转灵敏度$S_r(cm/V)$</li>
<li>锯齿电流幅度$I_r(V)$</li>
<li>扫描线长$l(cm)$</li>
<li>量程$R_m(km)$</li>
<li>标尺系数$m(km/cm)$</li>
<li>正程时间$T(ms)$</li>
</ul>
</li>
<li><p><strong>方位扫掠：偏转线圈（流动着锯齿电流的线圈）随天线同步旋转</strong></p>
</li>
</ul>
<h2 id="3-定圈式P显"><a href="#3-定圈式P显" class="headerlink" title="3.定圈式P显"></a>3.定圈式P显</h2><ul>
<li><p>距离扫掠与动圈式相同</p>
</li>
<li><p>方位扫掠</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117110855932.png" alt="image-20221117110855932"></p>
</li>
</ul>
<hr>
<h1 id="计算机图像显示"><a href="#计算机图像显示" class="headerlink" title="计算机图像显示"></a>计算机图像显示</h1><h2 id="1-计算机图形显示系统"><a href="#1-计算机图形显示系统" class="headerlink" title="1.计算机图形显示系统"></a>1.计算机图形显示系统</h2><ul>
<li>系统组成：<ul>
<li>计算机</li>
<li>显示内容</li>
<li>信号处理、检测</li>
</ul>
</li>
<li>分类：<ul>
<li>随机扫描：一个字符一个字符的产生</li>
<li>光栅扫描：一行一行（或列）扫描像素</li>
</ul>
</li>
</ul>
<h2 id="2-字符产生器"><a href="#2-字符产生器" class="headerlink" title="2.字符产生器"></a>2.字符产生器</h2><ul>
<li><p><strong>随机扫描字符产生器</strong></p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117111312167.png" alt="image-20221117111312167" style="zoom:50%;"></p>
<ul>
<li><p>点阵法</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117111527719.png" alt="image-20221117111527719" style="zoom:33%;"></p>
</li>
<li><p>线段法</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117111605427.png" alt="image-20221117111605427" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p><strong>光栅扫描字符产生器：按一定规律扫描全部，字符产生无先后顺序</strong></p>
</li>
</ul>
<h2 id="3-矢量产生器"><a href="#3-矢量产生器" class="headerlink" title="3.矢量产生器"></a>3.矢量产生器</h2><ul>
<li><p>矢量要素</p>
<ul>
<li>起始值$(x_m,y_m)$</li>
<li>终点值$(x_{m+1},y_{m+1})$</li>
</ul>
</li>
<li><p>规则</p>
<ul>
<li>$x_m,y_m,\Delta x_m=x_{m+1}-x_m,\Delta y_m=y_{m+1}-y_m$均为整数</li>
<li>限定画完一个矢量的总时间T</li>
<li>尽可能均匀增加$(\Delta x_m,\Delta y_m)$个增值脉冲</li>
</ul>
</li>
<li><p>系统组成</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%99%A8/image-20221117112507728.png" alt="image-20221117112507728" style="zoom:50%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>雷达原理之雷达接收机</title>
    <url>/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/</url>
    <content><![CDATA[<p>本节主要介绍了雷达接收机的任务与组成、重点描述了雷达接收机的高频部分与中频部分。</p>
<span id="more"></span>
<h1 id="雷达接收机的任务"><a href="#雷达接收机的任务" class="headerlink" title="雷达接收机的任务"></a>雷达接收机的任务</h1><ul>
<li>不失真地放大所需的微弱信号，抑制不需要的其他信号</li>
<li>其他信号包括：<ul>
<li>噪声（noise）：无意的；</li>
<li>干扰（jamming）：一般认为是有意的；</li>
<li>杂波（clutter）：近地物，如山川、海浪的回波。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="超外差雷达接收机组成"><a href="#超外差雷达接收机组成" class="headerlink" title="超外差雷达接收机组成"></a>超外差雷达接收机组成</h1><ul>
<li><strong>高频部分</strong>：<ul>
<li><strong>T/R</strong>：收发转换开关，存在于收发天线共用的系统中</li>
<li><strong>接收机保护器</strong>：超过接收机最大功率，进行强制限流，以免对接收机造成损坏</li>
<li><strong>低噪声高频高增益放大器</strong></li>
<li><strong>混频器及本振</strong>：实现下变频，将信号频率变为中频</li>
</ul>
</li>
<li><strong>中频部分</strong>：<ul>
<li><strong>中频放大器</strong>：主要通过匹配滤波器实现，提高输出SNR</li>
<li><strong>AGC</strong>：Automatc Gain Control， 自动增益控制</li>
</ul>
</li>
<li><strong>视频部分</strong>：<ul>
<li><strong>包络检波</strong></li>
<li><strong>放大</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="接收机的噪声系数和灵敏度"><a href="#接收机的噪声系数和灵敏度" class="headerlink" title="接收机的噪声系数和灵敏度"></a>接收机的噪声系数和灵敏度</h1><h2 id="1-接收机中的噪声"><a href="#1-接收机中的噪声" class="headerlink" title="1.接收机中的噪声"></a>1.接收机中的噪声</h2><ul>
<li><p><strong>噪声来源</strong>：</p>
<p>|                                | 电阻热噪声                            | 天线噪声                                     |<br>| ——————————————— | ——————————————————- | —————————————————————— |<br>| 谱性质                         | 高斯白噪声：（-∞~+∞内功率谱密度恒定） | 高斯色噪声（在某一较大频带内功率谱密度恒定） |<br>| 噪声电压均方值（反映的是功率） | $\bar{U_n^2}=4kTB_nR$                 | $\bar{U_n^2}=4kT_BB_nR_A$                    |</p>
<ul>
<li>k为玻尔兹曼常数，$k = 1.38\times 10^{-23}$</li>
<li>T为电阻的热力学温度，以绝对温度（K）计量，对于$17^oC$的室温，$T = T_0 = 290K$，称为标准噪声温度</li>
<li>R为电阻的阻值</li>
<li>$B_n$为测试设备的通带，在这里就是接收机的带宽</li>
<li>$R_A$为天线等效电阻</li>
</ul>
</li>
<li><p><strong>定量描述噪声信号</strong>：</p>
<ul>
<li><p>等效噪声功率谱宽度或噪声带宽</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116215619044.png" alt="image-20221116215619044" style="zoom:50%;"></p>
</li>
<li><p>功率谱均匀的白噪声，通过具有频率选择性的接收线性系统后，接收机输出的白噪声功率谱密度如下：</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116215715140.png" alt="image-20221116215715140" style="zoom:50%;"></p>
</li>
<li><p>则为了分析和计算方便，通常把这个不均匀的噪声功率谱等效为在一定带宽B内是均匀的功率谱。这个带宽B称为<strong>等效噪声功率谱宽度</strong>，一般简称<strong>噪声带宽</strong>。</p>
</li>
<li><p>功率谱在频率轴上进行积分就得到噪声功率，假设其与噪声带宽内的功率相等，即可求得$B=\frac{\int_{0}^{\infty}{p(f)}df}{p(f_0)}=\frac{\int_{0}^{\infty}{|H(f)|^2}df}{H(f_0)}$</p>
</li>
<li><p>从上述公式可知，噪声带宽是受|H(f)|限制的，<strong>|H(f)|反映的是雷达接收机中频滤波器的传递响应函数</strong>。接收机中频滤波器又是根据 $h(t)=KS^<em>(t_0−t)$ 来设计的，$S(t)$表示雷达信号。也就是说<strong>信号本身的带宽就决定了中频滤波器怎么设计</strong>。因此，我们可以认为<em>*信号带宽、接收机带宽、噪声带宽是近似相等的</em></em>。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-噪声系数"><a href="#2-噪声系数" class="headerlink" title="2.噪声系数"></a>2.噪声系数</h2><ul>
<li><p>噪声系数是指接收机输入端信噪比$SNR_i$与输出端信噪比$SNR_o$的比值</p>
</li>
<li><p>它的物理意义是指<strong>由于接收机内部噪声的影响</strong>，使接收机输出端的信噪比相对于其输入端的<strong>信噪比变坏的倍数</strong>，<strong>噪声系数可表示为</strong>：</p>
<script type="math/tex; mode=display">
F = \frac{(SNR)_i}{(SNR)_o}=\frac{\frac{S_i}{N_i}}{\frac{S_o}{N_o}}=\frac{N_o}{N_iG_a}</script><ul>
<li>其中：$N_i = kT_0B$为输入噪声功率，$G_a$为接收机的额定功率增益，$G_a = \frac{S_o}{S_i}$</li>
</ul>
</li>
<li><p>假设接收机内部噪声的额定功率为$\Delta N$，输出噪声功率为：</p>
<script type="math/tex; mode=display">
  N_o = N_iG_a+\Delta N = kT_0B_nG_a+\Delta N</script></li>
<li><p><strong>合并上述两式可得到噪声系数F为</strong>：</p>
<script type="math/tex; mode=display">
F = 1+\frac{\Delta N}{kT_0B_nG_a}\ge 1</script></li>
<li><p>若有n级电路级联，则n级电路级联时的<strong>总噪声系数</strong>为：</p>
<script type="math/tex; mode=display">
F_o = F_1 + \frac{F_2 - 1}{G_1}+\frac{F_3 - 1}{G_1G_2}+...+\frac{F_n-1}{G_1G_2...G_{n-1}}</script></li>
</ul>
<h2 id="3-灵敏度"><a href="#3-灵敏度" class="headerlink" title="3.灵敏度"></a>3.灵敏度</h2><ul>
<li><p>接收机灵敏度表示接收机接收微弱信号的能力</p>
</li>
<li><p><strong>能接收的信号越微弱，则接收机的灵敏度越高，因而雷达的作用距离就越远</strong></p>
</li>
<li><p>灵敏度用<strong>接收机输入端</strong>的<strong>最小可检测信号功率$S_{imin}$</strong>来表示，其表达式为：</p>
<script type="math/tex; mode=display">
S_{imin}=N_iF(\frac{S_o}{N_o}) = kT_0BF(\frac{S_o}{N_o})</script></li>
<li><p>为了保证检测系统发现目标的性能，要求$(\frac{S_o}{N_o})\ge(\frac{S_i}{N_i})_{min}$，接收机实际灵敏度为：</p>
<script type="math/tex; mode=display">
  S_{imin}= kT_0BF(\frac{S_o}{N_o})_{min} = kT_0BFM</script><ul>
<li><p>其中，$F$为噪声系数，其定义为接收机输入端信号噪声比与输出端信号噪声比的比值，即$F=\frac{S_i/N_i}{S_o/N_o}$</p>
</li>
<li><p>M为识别系数，定义接收机输出端信噪比的最小值$M=(\frac{S_o}{N_o})_{min}$，<strong>即达到一定检测性能所要求的接收机输出信号的最小信噪比</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="雷达接收机的高频部分"><a href="#雷达接收机的高频部分" class="headerlink" title="雷达接收机的高频部分"></a>雷达接收机的高频部分</h1><h2 id="1-高频组成部分"><a href="#1-高频组成部分" class="headerlink" title="1.高频组成部分"></a>1.高频组成部分</h2><ul>
<li>收发转换开关、接收机保护器、低噪声高频高增益放大器、混频器、本机振荡器</li>
</ul>
<h2 id="2-平衡收发转换开关"><a href="#2-平衡收发转换开关" class="headerlink" title="2.平衡收发转换开关"></a>2.平衡收发转换开关</h2><ul>
<li><p><strong>发射状态时</strong>：</p>
<ul>
<li>保护放电管 TR1、TR2 放电，大部分能量被反射（图中蓝色虚线），</li>
<li>只有一部分漏过放电管（图中黄线），在接收机处反向相消。</li>
</ul>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116222219708.png" alt="image-20221116222219708" style="zoom:50%;"></p>
</li>
<li><p><strong>接收状态时</strong>：</p>
<ul>
<li>保护放电管 TR1、TR2 不放电，天线接收到的信号在接收机处同相相加</li>
<li>就算有少数信号穿过，在假负载处也会相互抵消</li>
</ul>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116222432939.png" alt="image-20221116222432939" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="3-本机振荡器（LO）和自动频率控制（AFC）"><a href="#3-本机振荡器（LO）和自动频率控制（AFC）" class="headerlink" title="3.本机振荡器（LO）和自动频率控制（AFC）"></a>3.本机振荡器（LO）和自动频率控制（AFC）</h2><h3 id="3-1-混频器原理"><a href="#3-1-混频器原理" class="headerlink" title="3.1 混频器原理"></a>3.1 混频器原理</h3><ul>
<li><p>超外差式接收机利用本机振荡器和混频器把高频回波信号变换成便于滤波和处理的中频信号</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116225047186.png" alt="image-20221116225047186" style="zoom:50%;"></p>
</li>
<li><p>理想情况下，发射的高频信号$f_R$和本振频率$f_L$都是固定的，混频后二者之差也是固定不变的 “ 正确中频 ”$f_I$。但在实际工作中，常规雷达发射机磁控管振荡器和接收机本机振荡器频率稳定度不高，容易受外界条件（温度、负载、电源等）的改变而变化，使混频后的实际中频偏离 “ 正确中频 ”$f_I$。可能超出中放通带，使接收机增益大大降低甚至不能正常工作。因此，必须采用AFC，以保证混频器输出为 “ 正确中频 ” $f_I$。</p>
</li>
</ul>
<h3 id="3-2-常规雷达本振与AFC"><a href="#3-2-常规雷达本振与AFC" class="headerlink" title="3.2 常规雷达本振与AFC"></a>3.2 常规雷达本振与AFC</h3><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116225655072.png" alt="image-20221116225655072" style="zoom:50%;"></p>
<hr>
<h1 id="接收机的动态范围"><a href="#接收机的动态范围" class="headerlink" title="接收机的动态范围"></a>接收机的动态范围</h1><ul>
<li><p><strong>接收机的动态范围表示接收机能够正常工作所容许的输入信号强度变化的范围</strong></p>
</li>
<li><p><strong>信号太弱，它不能检测出来；信号太强，接收机会发生饱和而失去放大作用，这种现象称为过载</strong></p>
</li>
<li><p><strong>使接收机开始出现过载时的输入功率与最小可检测功率之比，叫做动态范围</strong>，其公式为：</p>
<script type="math/tex; mode=display">
D(dB)=10lg\frac{P_{imax}}{P_{imin}}=20lg\frac{U_{imax}}{U_{imin}}</script><ul>
<li>D表示接收机的动态范围，单位 dB</li>
<li>$P_{imax}$ 表示最大接收信号功率</li>
<li>$P_{imin}$ 表示最小接收信号功率，即灵敏度</li>
</ul>
</li>
<li><p>饱和过载：</p>
<ul>
<li>定义增量增益$K_d=\frac{du_o}{du_i}$，若$K_d\le0$，则称为饱和过载</li>
</ul>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116230738572.png" alt="image-20221116230738572" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="滤波与接收机带宽"><a href="#滤波与接收机带宽" class="headerlink" title="滤波与接收机带宽"></a>滤波与接收机带宽</h1><h2 id="1-中频放大器（匹配滤波器）"><a href="#1-中频放大器（匹配滤波器）" class="headerlink" title="1.中频放大器（匹配滤波器）"></a>1.中频放大器（匹配滤波器）</h2><p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116232729568.png" alt="image-20221116232729568" style="zoom:50%;"></p>
<ul>
<li><p>匹配滤波器是<strong>当输入端出现信号与加性白噪声时，使其输出信噪比最大的滤波器</strong>，就是一个与输入信号相匹配的最佳滤波器</p>
</li>
<li><p>冲击函数$h(t)$：</p>
<script type="math/tex; mode=display">
h(t)=KS^*(t_0-t)</script><ul>
<li>说明匹配滤波器实际上是根据雷达发射信号$S(t)$设计的。</li>
<li>输出信噪比在$t_0$时刻达到最大。</li>
</ul>
</li>
<li><p>传递响应函数$H(f)$：</p>
<script type="math/tex; mode=display">
H(f)=KS^*(f)e^{-j2\pi ft_0}=|H(f)|e^{j\phi(f)}</script></li>
<li><p>匹配滤波器的最大输出信噪比：</p>
<script type="math/tex; mode=display">
(\frac{S}{N})_{omax}=\frac{E}{N_o/2}</script><ul>
<li>其中，$N_0/2$为白噪声功率谱密度。</li>
<li>$E$为输入信号能量，根据帕塞瓦尔定理：$E=\int_{-\infty}^{+\infty}|S(t)|^2dt=\int_{-\infty}^{+\infty}|S(f)|^2df$</li>
<li>由此可知，<strong>匹配滤波器输出端的峰值瞬时信号功率与噪声的平均功率之比$SNR_o$等于两倍的输入信号能量除以输入噪声功率</strong></li>
<li>也就是说，<strong>匹配滤波器输出最大信噪比仅依赖于信号能量和输入噪声功率，而与雷达使用的波形无关</strong></li>
</ul>
</li>
</ul>
<h2 id="2-单个脉冲信号的匹配滤波"><a href="#2-单个脉冲信号的匹配滤波" class="headerlink" title="2.单个脉冲信号的匹配滤波"></a>2.单个脉冲信号的匹配滤波</h2><ul>
<li><p>假设矩形脉冲幅度为A，脉宽为$\tau$，信号波形为：</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116234631379.png" alt="image-20221116234631379" style="zoom:50%;"></p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116234539583.png" alt="image-20221116234539583" style="zoom:50%;"></p>
</li>
<li><p>经傅里叶变换，可得信号频谱：</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116234654662.png" alt="image-20221116234654662" style="zoom:50%;"></p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116234733146.png" alt="image-20221116234733146" style="zoom:50%;"></p>
</li>
<li><p>此时，<strong>匹配滤波器的带宽为$B\approx\frac{1}{\tau}$</strong></p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221116235501254.png" alt="image-20221116235501254" style="zoom: 33%;"></p>
</li>
</ul>
<h2 id="3-准匹配滤波"><a href="#3-准匹配滤波" class="headerlink" title="3.准匹配滤波"></a>3.准匹配滤波</h2><ul>
<li><p>理想匹配滤波器的特性一般比较难以实现，因此，需要考虑它的近似实现，即采用准匹配滤波器。</p>
</li>
<li><p>准匹配滤波器是指实际上容易实现的几种典型频率特性。通常可以用矩形、高斯型或其他形状的频率特性来作近似</p>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20230910215641449.png" alt="image-20230910215641449"></p>
<ul>
<li>其中实线为理想的匹配滤波器的频率特性，虚线为矩形特性滤波器的频率特性</li>
</ul>
</li>
<li><p><strong>准匹配滤波器的最大输出信噪比与理想匹配滤波器的最大输出信噪比的比值定义为失配损失</strong>ρ：</p>
<script type="math/tex; mode=display">
\rho=\frac{(\frac{S}{N})_{\approx max}}{\frac{E}{N_o/2}}\le1</script></li>
</ul>
<ul>
<li>准匹配滤波器的最大信噪比$(\frac{S}{N})_{\approx max}$</li>
<li>理想匹配滤波器输出的最大信噪比$(\frac{S}{N})_{omax} = \frac{E}{N_o/2}$ </li>
</ul>
<hr>
<h1 id="增益控制"><a href="#增益控制" class="headerlink" title="增益控制"></a>增益控制</h1><ul>
<li><p><strong>自动增益控制（AGC）</strong></p>
<ul>
<li>目的是为了使接收机的输出不要受接收机输入影响太大，引起剧烈变化</li>
<li>从<strong>视频</strong>取反馈控制信号，最终控制中频放大器的增益</li>
<li>AGC是负反馈系统</li>
</ul>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221117002147018.png" alt="image-20221117002147018" style="zoom: 33%;"></p>
</li>
<li><p><strong>瞬时自动增益控制（IAGC）</strong></p>
<ul>
<li>目的是使大功率干扰受到衰减，而维持目标信号的增益尽量不变。</li>
<li>直接从<strong>中频</strong>放大器的输出端取反馈控制信号。因此，IAGC比AGC反应更快。</li>
</ul>
<p><img src="/2022/11/17/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E6%8E%A5%E6%94%B6%E6%9C%BA/image-20221117002310909.png" alt="image-20221117002310909" style="zoom:33%;"></p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/156946799">三，雷达接收机 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>雷达原理之雷达发射机</title>
    <url>/2022/11/16/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%8F%91%E5%B0%84%E6%9C%BA/</url>
    <content><![CDATA[<p>本节主要介绍了雷达接收机，包括雷达接收机频率调制与相位调制的原理，以及单级振荡式发射机与主振放大式发射机。</p>
<span id="more"></span>
<h1 id="雷达发射机的任务"><a href="#雷达发射机的任务" class="headerlink" title="雷达发射机的任务"></a>雷达发射机的任务</h1><ul>
<li><p>产生<strong>大功率</strong>、<strong>特定调制</strong>的<strong>射频</strong>信号。</p>
</li>
<li><p>这里说的特定调制，主要包括：振幅调制、频率调制和相位调制。</p>
</li>
</ul>
<hr>
<h1 id="频率调制"><a href="#频率调制" class="headerlink" title="频率调制"></a>频率调制</h1><h2 id="1-线性调频（LFM）"><a href="#1-线性调频（LFM）" class="headerlink" title="1.线性调频（LFM）"></a>1.线性调频（LFM）</h2><ul>
<li><p>在信号脉宽内，频率随时间线性增加或减少</p>
</li>
<li><p>线性调频信号：$S_t(t)=Acos(2\pi f_0t+\pi\mu t^2+\phi)$</p>
</li>
<li><p>时域波形：</p>
<p><img src="/2022/11/16/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%8F%91%E5%B0%84%E6%9C%BA/image-20221116122426205.png" alt="image-20221116122426205" style="zoom: 50%;"></p>
</li>
<li><p>频域波形：</p>
<p><img src="/2022/11/16/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%8F%91%E5%B0%84%E6%9C%BA/image-20221116122512747.png" alt="image-20221116122512747" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-频率捷变"><a href="#2-频率捷变" class="headerlink" title="2.频率捷变"></a>2.频率捷变</h2><ul>
<li><p>每一个脉冲的频率不同，是一种有效的抗干扰手段</p>
<p><img src="/2022/11/16/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%8F%91%E5%B0%84%E6%9C%BA/image-20221116122709279.png" alt="image-20221116122709279" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="相位调制"><a href="#相位调制" class="headerlink" title="相位调制"></a>相位调制</h1><h2 id="1-随机相位"><a href="#1-随机相位" class="headerlink" title="1.随机相位"></a>1.随机相位</h2><ul>
<li>每个脉冲前沿时刻的相位是随机变化的</li>
<li>其产生对应单级振荡式发射机</li>
</ul>
<h2 id="2-相位相参"><a href="#2-相位相参" class="headerlink" title="2.相位相参"></a>2.相位相参</h2><ul>
<li>脉冲之间具有固定的相位关系，相参性是指两个信号（两个脉冲重复周期之间雷达发射的信号）的相位之间存在着确定的关系</li>
<li>其产生对应主振放大式发射机</li>
</ul>
<hr>
<h1 id="发射机的组成"><a href="#发射机的组成" class="headerlink" title="发射机的组成"></a>发射机的组成</h1><h2 id="1-单极振荡式发射机"><a href="#1-单极振荡式发射机" class="headerlink" title="1.单极振荡式发射机"></a>1.单极振荡式发射机</h2><ul>
<li><p>大功率电磁震荡产生与调制同时完成</p>
</li>
<li><p>因为脉冲调制器直接控制振荡器的工作，每个射频脉冲的起始射频相位是由振荡器的噪声决定的，相继脉冲的射频相位是随机的，不能根据一个周期内的确定时刻，确定下一周期内相同位置的幅度信息，这样的信号<strong>相位是不相参的。</strong></p>
</li>
<li><p>其组成如下：</p>
<p><img src="/2022/11/16/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%8F%91%E5%B0%84%E6%9C%BA/image-20221116123217773.png" alt="image-20221116123217773" style="zoom: 33%;"></p>
</li>
</ul>
<h2 id="2-主振放大式发射机"><a href="#2-主振放大式发射机" class="headerlink" title="2.主振放大式发射机"></a>2.主振放大式发射机</h2><ul>
<li><p>主振放大器的脉冲实际上是从连续波上“切”下来的</p>
<p><img src="/2022/11/16/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%8F%91%E5%B0%84%E6%9C%BA/image-20230910162736851.png" alt="image-20230910162736851"></p>
</li>
<li><p>先产生小功率连续波信号，再分多级进行调制放大</p>
</li>
<li><p>发射机的发射信号$f_0$，稳定本振电压$f_L$，相参振荡电压$f_c$，定时器触发脉冲$f_r$，均是由基准信号F产生的，他们之间具有<strong>相位相参性</strong></p>
</li>
<li><p>其组成如下：</p>
<p><img src="/2022/11/16/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%8F%91%E5%B0%84%E6%9C%BA/image-20221116124123261.png" alt="image-20221116124123261" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="雷达发射机的主要质量指标"><a href="#雷达发射机的主要质量指标" class="headerlink" title="雷达发射机的主要质量指标"></a>雷达发射机的主要质量指标</h1><h2 id="1-工作频率"><a href="#1-工作频率" class="headerlink" title="1.工作频率"></a>1.工作频率</h2><ul>
<li><p>频率与器件有关。</p>
</li>
<li><p>频率与功率有关，频率越高功率越低</p>
</li>
</ul>
<h2 id="2-输出功率"><a href="#2-输出功率" class="headerlink" title="2.输出功率"></a>2.输出功率</h2><ul>
<li>平均功率$P_{av}$：$T_r$内的输出平均功率</li>
<li>峰值功率$P_t$：$\tau$内的输出平均功率</li>
</ul>
<script type="math/tex; mode=display">
P_{av}=P_t\times\frac{\tau}{T_r}=P_tD
\\其中，D为工作比</script><h2 id="3-总效率"><a href="#3-总效率" class="headerlink" title="3.总效率"></a>3.总效率</h2><script type="math/tex; mode=display">
\eta=\frac{P_{av}}{P_s}
\\其中，P_s发射机发射的总功率</script><hr>
<h1 id="脉冲调制器"><a href="#脉冲调制器" class="headerlink" title="脉冲调制器"></a>脉冲调制器</h1><ul>
<li><p>脉冲调制器的任务是给发射机的射频各级提供合适的视频调制脉冲</p>
</li>
<li><p>基本组成：</p>
<p><img src="/2022/11/16/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%8F%91%E5%B0%84%E6%9C%BA/image-20221116130342927.png" alt="image-20221116130342927" style="zoom:50%;"></p>
</li>
<li><p>刚性开关脉冲调制器：产生的脉冲前后沿由预调器的脉冲控制</p>
</li>
<li><p>软性开关脉冲调制器：开关控制脉冲起始，储能元件放电完毕后，脉冲自动结束</p>
</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/151071135">二，雷达发射机 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之符号计算</title>
    <url>/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>本节主要介绍了MATLAB中符号对象的建立与相关运算，包括微积分、级数、方程求解。</p>
<span id="more"></span>
<h1 id="符号对象"><a href="#符号对象" class="headerlink" title="符号对象"></a>符号对象</h1><h2 id="1-符号对象的建立"><a href="#1-符号对象的建立" class="headerlink" title="1.符号对象的建立"></a>1.符号对象的建立</h2><ul>
<li><p><code>符合对象名=sym(A)</code></p>
<ul>
<li><p>A可以是一个数值常量、数值矩阵或数值表达式，此时符号对象是一个符号常量</p>
</li>
<li><p>A也可以是一个变量名，这时符号对象为一个符号变量</p>
</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115134631714.png" alt="image-20221115134631714" style="zoom:50%;"></p>
<ul>
<li>由结果可以看出符号计算的结果是一个精确的数学表达式，数值计算的结果是一个数值</li>
</ul>
</li>
<li><p><code>syms 符号变量名1 符号变量名2 …… 符号变量名n</code> %一次定义多个符号变量</p>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115140157221.png" alt="image-20221115140157221" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-符号对象的运算"><a href="#2-符号对象的运算" class="headerlink" title="2.符号对象的运算"></a>2.符号对象的运算</h2><ul>
<li><p><strong>四则运算</strong>：<code>+、-、*、/、^</code>，<strong>符号运算结果依然是一个符号表达式</strong></p>
</li>
<li><p><strong>关系运算符</strong>：<code>&lt;、&lt;=、&gt;、&gt;=、==、~=</code></p>
</li>
<li><p><strong>使用assume函数对符号对象设置值域</strong></p>
<ul>
<li><code>assume(condition)</code> %指定变量满足条件condition</li>
<li><code>assume(expr,set)</code> %指定表达式expr属于集合set</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115141223254.png" alt="image-20221115141223254" style="zoom:50%;"></p>
</li>
<li><p><strong>逻辑运算</strong>：<code>&amp;、|、~</code></p>
</li>
<li><p><strong>因式分解与展开运算</strong>：</p>
<ul>
<li><code>factor(s)</code>：对符号表达式s分解因式</li>
<li><code>expand(s)</code>：对符号表达式s进行展开</li>
<li><code>collect(s)</code>：对符号表达式s合并同类项</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115142555549.png" alt="image-20221115142555549" style="zoom:50%;"></p>
</li>
<li><p><strong>其他运算</strong></p>
<ul>
<li>提取有理分式的分子分母：<code>[n,d]=numden(s)</code></li>
<li>提取符号表达式的系数：<code>c=coeffs(s,x)</code></li>
<li>符号表达式化简：<code>simplify(s)</code></li>
<li>符号多项式与多项式系数向量之间的转换<ul>
<li>符号多项式转换为多项式系数向量：<code>p=sym2poly(s)</code> %<strong>其中符号表达式s只能有一个符号变量</strong></li>
<li>多项式系数向量转化为符号多项式：<code>s=poly2sym(p)</code></li>
</ul>
</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115143306302.png" alt="image-20221115143306302" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="符号微积分"><a href="#符号微积分" class="headerlink" title="符号微积分"></a>符号微积分</h1><h2 id="1-符号函数的极限"><a href="#1-符号函数的极限" class="headerlink" title="1.符号函数的极限"></a>1.符号函数的极限</h2><ul>
<li><code>limit(f,x,a)</code> %求函数f关于变量x在a点的极限</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115145834940.png" alt="image-20221115145834940" style="zoom:50%;"></p>
<h2 id="2-符号函数的导数"><a href="#2-符号函数的导数" class="headerlink" title="2.符号函数的导数"></a>2.符号函数的导数</h2><ul>
<li><code>diff(f,x,n)</code> %求函数f关于变量x的n阶导数，n的默认值是1</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115150254742.png" alt="image-20221115150254742" style="zoom:50%;"></p>
<h2 id="3-符号函数的积分"><a href="#3-符号函数的积分" class="headerlink" title="3.符号函数的积分"></a>3.符号函数的积分</h2><ul>
<li><p><strong>不定积分</strong></p>
<ul>
<li><code>int(f,x)</code> %即求函数f对变量x的不定积分</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115150645038.png" alt="image-20221115150645038" style="zoom:50%;"></p>
</li>
<li><p><strong>定积分</strong></p>
<ul>
<li><code>int(f,x,a,b)</code> </li>
<li>a,b分别表示定积分的下限和上限</li>
<li>a,b中有一个符号表达式时，函数返回一个符号函数</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115151126251.png" alt="image-20221115151126251" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h1><h2 id="1-级数求和"><a href="#1-级数求和" class="headerlink" title="1.级数求和"></a>1.级数求和</h2><ul>
<li><code>symsum(s,v,n,m)</code> </li>
<li>s表示一个级数的通项，是一个符号表达式</li>
<li>v是求和变量</li>
<li>n、m时是求和变量v的初值和末值</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115153036188.png" alt="image-20221115153036188" style="zoom:50%;"></p>
<h2 id="2-泰勒级数"><a href="#2-泰勒级数" class="headerlink" title="2.泰勒级数"></a>2.泰勒级数</h2><ul>
<li><p><code>taylor(f,v,a,Name,Value)</code></p>
</li>
<li><p>函数f按变量v在a点展开为泰勒级数</p>
</li>
<li><p>Name为选项名，Value为选项值</p>
<p>| Name             | Value                                                    |<br>| ———————— | ———————————————————————————— |<br>| ‘ExpansionPoint’ | 指定展开点，默认为0                                      |<br>| ‘Order’          | 指定截断参数，默认为6，即展开式的最高阶为5               |<br>| ‘OrderMode’      | 指定展开式采用绝对阶’Absolute’（默认）或相对阶’Relative’ |</p>
</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115154034943.png" alt="image-20221115154034943" style="zoom:50%;"></p>
<hr>
<h1 id="符号方程求解"><a href="#符号方程求解" class="headerlink" title="符号方程求解"></a>符号方程求解</h1><h2 id="1-代数方程符号求解"><a href="#1-代数方程符号求解" class="headerlink" title="1.代数方程符号求解"></a>1.代数方程符号求解</h2><ul>
<li><code>solve(s,v)</code> %求解符号表达式s的代数方程，求解变量为v</li>
</ul>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115155943524.png" alt="image-20221115155943524" style="zoom:50%;"></p>
<ul>
<li>solve函数求解方程不一定准确</li>
</ul>
<h2 id="2-常微分方程符号求解"><a href="#2-常微分方程符号求解" class="headerlink" title="2.常微分方程符号求解"></a>2.常微分方程符号求解</h2><ul>
<li><code>dsolve(e,c,v)</code> </li>
<li>e是常微分方程，导数用diff函数表示</li>
<li>v是方程中的自变量</li>
<li>若没有给出初始条件c，则求方程的通解</li>
</ul>
<p>例1：</p>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115162155578.png" alt="image-20221115162155578" style="zoom:33%;"></p>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115162301125.png" alt="image-20221115162301125"></p>
<p>例2：</p>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115162421769.png" alt="image-20221115162421769"></p>
<p><img src="/2022/11/15/MATLAB%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/image-20221115162738557.png" alt="image-20221115162738557"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>雷达原理之基本概念</title>
    <url>/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>本节主要介绍了雷达原理中的基本概念，包括雷达的基本组成，目标参数的测量等。</p>
<span id="more"></span>
<h1 id="雷达的基本组成"><a href="#雷达的基本组成" class="headerlink" title="雷达的基本组成"></a>雷达的基本组成</h1><h2 id="1-天线"><a href="#1-天线" class="headerlink" title="1.天线"></a>1.天线</h2><ul>
<li>发射信号并接收回波</li>
</ul>
<h2 id="2-发射机"><a href="#2-发射机" class="headerlink" title="2.发射机"></a>2.发射机</h2><ul>
<li>产生雷达的发射信号</li>
<li>包括连续波信号与脉冲信号</li>
</ul>
<h3 id="2-1-连续波信号"><a href="#2-1-连续波信号" class="headerlink" title="2.1 连续波信号"></a>2.1 连续波信号</h3><ul>
<li><p>$S_t(t)=A_0cos(2\pi f_0t+\phi)$</p>
<ul>
<li>$S_t(t)$下标 t 表示 transmit</li>
<li>$f_0$表示信号频率，即单位周期内波的个数，有$f_0=\frac{1}{T}$</li>
<li>$f_0$与波长$\lambda$的关系：$\lambda f_0=C（光速）$</li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221115111416164.png" alt="image-20221115111416164" style="zoom: 33%;"></p>
</li>
</ul>
<h3 id="2-2-脉冲信号"><a href="#2-2-脉冲信号" class="headerlink" title="2.2 脉冲信号"></a>2.2 脉冲信号</h3><p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221115111529539.png" alt="image-20221115111529539" style="zoom: 33%;"></p>
<ul>
<li>$\tau$是脉冲宽度</li>
<li>$T_r$是脉冲重复周期，则脉冲重复频率$f_r=\frac{1}{T_r}$</li>
</ul>
<h2 id="3-接收机"><a href="#3-接收机" class="headerlink" title="3.接收机"></a>3.接收机</h2><ul>
<li>接收回波信号，并进行处理。一般会经历<strong>射频</strong> -&gt; <strong>中频</strong> -&gt; <strong>视频</strong>的处理过程</li>
<li>一般来说，如果要测距就需要做视频处理，根据发射信号和回波信号脉冲前沿的时间差，就可以计算得到目标距雷达的距离</li>
<li>如果要测速，就需要在中频进行处理。因为测速需要利用多普勒效应，需要获取发射频率和接收频率的频率差。视频信号已经丢失了载波信息，就无法获取频率信息了</li>
</ul>
<h3 id="3-1-射频信号"><a href="#3-1-射频信号" class="headerlink" title="3.1 射频信号"></a>3.1 射频信号</h3><ul>
<li>$t_r$为时延差</li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221115112439681.png" alt="image-20221115112439681" style="zoom: 33%;"></p>
<h3 id="3-2-中频信号"><a href="#3-2-中频信号" class="headerlink" title="3.2 中频信号"></a>3.2 中频信号</h3><ul>
<li>接收机收到的是射频信号，频率本来就比较高，如果直接在射频上进行采样，根据奈奎斯特采样定理，采样频率需要大于信号频率的两倍，才能将采样后的信号无失真的还原回去。直接在射频上进行采样，成本就会很高，所以就需要对射频信号进行混频处理，变到中频，这样对采样率的要求就降低了</li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221115112905427.png" alt="image-20221115112905427" style="zoom: 33%;"></p>
<ul>
<li>从图中可知，中频信号，频率虽然变低了，但是包络还是原来的包络</li>
</ul>
<h3 id="3-3-视频信号"><a href="#3-3-视频信号" class="headerlink" title="3.3 视频信号"></a>3.3 视频信号</h3><ul>
<li>中频信号经过包络检波就能得到视频信号</li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221115113038131.png" alt="image-20221115113038131" style="zoom: 33%;"></p>
<h2 id="4-信号处理机"><a href="#4-信号处理机" class="headerlink" title="4.信号处理机"></a>4.信号处理机</h2><ul>
<li>提取目标的各种信息</li>
</ul>
<h2 id="5-终端显示设备"><a href="#5-终端显示设备" class="headerlink" title="5.终端显示设备"></a>5.终端显示设备</h2><ul>
<li>将雷达探测到的目标信息，以可视化的方式显示到屏幕上</li>
</ul>
<h2 id="6-伺服系统与同步设备"><a href="#6-伺服系统与同步设备" class="headerlink" title="6.伺服系统与同步设备"></a>6.伺服系统与同步设备</h2><ul>
<li>伺服系统：控制天线转动，使天线指向不同角度，以探测不同方位的目标</li>
<li>同步设备：雷达的频率和时间标准。产生各种频率振荡，提供统一的时钟</li>
</ul>
<hr>
<h1 id="简单的目标距离测量"><a href="#简单的目标距离测量" class="headerlink" title="简单的目标距离测量"></a>简单的目标距离测量</h1><ul>
<li>$2R=Ct_r\Rightarrow R=\frac{Ct_r}{2}$ </li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221115112757492.png" alt="image-20221115112757492" style="zoom:50%;"></p>
<hr>
<h1 id="多普勒效率与速度测量"><a href="#多普勒效率与速度测量" class="headerlink" title="多普勒效率与速度测量"></a>多普勒效率与速度测量</h1><ul>
<li>测速原理：利用多普勒效应</li>
<li>实际测量的是径向速度，目标和雷达之间必须有径向速度分量</li>
</ul>
<h2 id="1-多普勒效应"><a href="#1-多普勒效应" class="headerlink" title="1.多普勒效应"></a>1.多普勒效应</h2><ul>
<li>当目标与雷达之间存在相对速度时，接收到的回波信号的载频相对于发射信号的载频会产生一个频移$f_d$</li>
<li>$f_d=f_r-f_t=\frac{2V_r}{\lambda}$<ul>
<li>$f_r$：回波信号的频率</li>
<li>$f_t$：雷达发射信号的频率</li>
<li>$V_r$：目标相当于雷达的径向速度</li>
<li>$f_t$：信号波长</li>
</ul>
</li>
</ul>
<h2 id="2-频率与相位的关系"><a href="#2-频率与相位的关系" class="headerlink" title="2.频率与相位的关系"></a>2.频率与相位的关系</h2><ul>
<li>瞬时相位$\xrightarrow{相对于时间求导}$瞬时角频率$\xrightarrow{\div2\pi}$瞬时频率</li>
<li>对于线性调频信号有：<ul>
<li>$S_t(t)=Acos(2\pi f_0t+\pi\mu t^2+\phi)$</li>
<li>瞬时频率$f(t)=\frac{\partial(2\pi f_0t+\pi\mu t^2+\phi)}{2\pi\partial t}=f_0+\mu t$</li>
</ul>
</li>
</ul>
<h2 id="3-测速公式推导"><a href="#3-测速公式推导" class="headerlink" title="3.测速公式推导"></a>3.测速公式推导</h2><ul>
<li><p>径向速度：$V_r=Vcos\theta$</p>
</li>
<li><p>则当雷达发射信号到达目标时的距离为：$R=R_0-V_rt$</p>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221115115632640.png" alt="image-20221115115632640" style="zoom:25%;"></p>
</li>
<li><p>则回波信号为：$S_r(t)=kS_t(t-t_r)=kAcos(2\pi f_0(t-\frac{2(R_0-V_rt)}{C})+\phi)$</p>
</li>
<li><p>对$S_r(t)$求导并除以$2\pi$可以得到：$f_r=f_t+\frac{2V_r}{\lambda}$</p>
</li>
<li><p>即：$f_d=f_r-f_t=\frac{2V_r}{\lambda}$</p>
</li>
<li><p>当$f_d$为负数时，目标远离；当$f_d$为正数时，目标靠近</p>
</li>
</ul>
<h2 id="4-多普勒频率的详细解释与推导"><a href="#4-多普勒频率的详细解释与推导" class="headerlink" title="4.多普勒频率的详细解释与推导"></a>4.多普勒频率的详细解释与推导</h2><ul>
<li><p>当目标向着雷达运动时。多普勒频率为正；当目标远离雷达时，多普勒频率为负</p>
</li>
<li><p>照射到目标上的波形具有间隔为$\lambda$（波长）的等相位波前：</p>
<ul>
<li>靠近雷达的目标导致反射回波的等相位波前相互靠近（较短波长），$\lambda &gt; \lambda’$（$\lambda’$为反射波波长）</li>
<li>远离雷达运动的目标导致反射回波的等相位波前相互扩展（较长波长）$\lambda &lt; \lambda’$</li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230914093307513.png" alt="image-20230914093307513"></p>
</li>
<li><p><strong>运动目标速度对发射脉冲的影响</strong>：</p>
<ul>
<li><p>假设雷达的发射脉冲宽度为$\tau$，对应的波程为$L = c\tau$（c为光速），目标的径向速度为$v_r$</p>
</li>
<li><p>假设脉冲前沿到达目标与后沿到达目标的时间间隔为$\Delta t$，在$\Delta t$时间内目标移动脉冲内的距离为$d = v_r \Delta t$</p>
</li>
<li><p>由于脉冲以光速传播，后沿已经移动的距离是$c\tau - d$，那么：</p>
<script type="math/tex; mode=display">
c\tau = c\Delta t + v_r\Delta t</script><script type="math/tex; mode=display">
c\tau' = c\Delta t - v_r\Delta t</script></li>
<li><p>由上式可得到反射脉冲宽度$\tau’$和入射脉冲宽度$\tau$之间的关系为：</p>
<script type="math/tex; mode=display">
\tau' = \frac{c-v_r}{c+v_r}\tau</script><ul>
<li><p>式中，$\frac{c-v_r}{c+v_r}$通常称为时间扩展因子</p>
</li>
<li><p>若$v_r = 0$，则$\tau’ = \tau$</p>
</li>
<li><p>同理可计算，当目标以速度$v_r$远离雷达时，反射和入射脉冲宽度之间的关系为：</p>
<script type="math/tex; mode=display">
\tau' = \frac{c+ v_r}{c - v_r}\tau</script></li>
</ul>
</li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230914095252912.png" alt="image-20230914095252912"></p>
</li>
<li><p><strong>多普勒频率的推导</strong>：</p>
<ul>
<li><p>假设两个入射脉冲的重复频率（PRF）为$f_r$，脉冲1的前沿到达目标以后，脉冲2的前沿要花$\Delta t$时间到达目标，电波传播的距离为$(\frac{c}{f_r}-d)$，且脉冲2前沿在$\Delta t$时间的迟延距离$d = v_r\Delta t$，则</p>
<script type="math/tex; mode=display">
\frac{c}{f_r}-d = \frac{c}{f_r}-v_r\Delta t = c\Delta t</script></li>
<li><p>经化简得：</p>
<script type="math/tex; mode=display">
\Delta t = \frac{c/f_r}{c+v_r}</script><script type="math/tex; mode=display">
d = v_r\Delta t = \frac{v_rc/f_r}{c + v_r}</script><p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230914095946418.png" alt="image-20230914095946418"></p>
</li>
<li><p>反射脉冲间隔$T_r’$所对应的波程为$s-d$（下图是关于为什么反射脉冲间隔为s-d的个人见解），其中$s = c\Delta t$，则回波脉冲的重复频率$f_r’ = \frac{1}{T_r’}$，且：</p>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/287a82878c8955c70a57b081fde66d8.jpg" alt="287a82878c8955c70a57b081fde66d8" style="zoom: 33%;"></p>
<script type="math/tex; mode=display">
s-d =\frac{c}{f_r'}=\Delta t-\frac{v_rc/f_r}{c+v_r}</script></li>
<li><p>由此得到回波脉冲的PRF与入射脉冲的PRF之间的关系为：</p>
<script type="math/tex; mode=display">
f_r' = \frac{c + v_r}{c-v_r}f_r</script></li>
<li><p>由于周期的数量不变，反射信号的频率也以相同的因子上升，回波信号的载频$f_0’$与入射信号的载频$f_0$之间的关系为：</p>
<script type="math/tex; mode=display">
f_0' = \frac{c+v_r}{c-v_r}f_0</script></li>
<li><p>多普勒频率定义为回波信号的载频$f_0’$与入射信号的载频$f_0$之差，即：</p>
<script type="math/tex; mode=display">
f_d = f_0'-f_0 = \frac{c+v_r}{c-v_r}f_0-f_0 = \frac{2v_r}{c-v_r}f_0</script></li>
<li><p>由于$v_r&lt;&lt;c$，则波长$\lambda = c/f_0$，则：</p>
<script type="math/tex; mode=display">
f_d\approx \frac{2v_r}{c}f_0 = \frac{2v_r}{\lambda}</script></li>
</ul>
</li>
<li><p><strong>影响多普勒频率的因素</strong>：</p>
<ul>
<li><p>多普勒频率和<strong>雷达视线与目标运动方向之间的夹角</strong>有关</p>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230914102012510.png" alt="image-20230914102012510"></p>
</li>
<li><p>对于双基地雷达，若目标的运动方向相对于雷达视线的方位和仰角分别为$\theta_a$和$\theta_e$，则目标回波的多普勒频率为：</p>
<script type="math/tex; mode=display">
f_d = \frac{2v_t}{\lambda}cos\theta=\frac{2v_t}{\lambda}cos\theta_ecos\theta_a</script><ul>
<li>式中，$cos\theta = cos\theta_ecos\theta_a$，目标速度$v_t$投影到雷达实现的径向速度为$v_r = v_t cos\theta=v_tcos\theta_ecos\theta_a$</li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230914102628116.png" alt="image-20230914102628116"></p>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230914102657113.png" alt="image-20230914102657113"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="天线"><a href="#天线" class="headerlink" title="天线"></a>天线</h1><ul>
<li>定义：发射或接收系统中，经设计用于辐射和接收电磁波的部分</li>
</ul>
<h2 id="1-天线的基本功能"><a href="#1-天线的基本功能" class="headerlink" title="1.天线的基本功能"></a>1.天线的基本功能</h2><ul>
<li>用于发射时，将高频电流（或导波）能量转化为无线电波并按照预定的分布传送到空间</li>
<li>用于接收时，将空间传来的无线电波能量转化为高频电流（或导波）能量</li>
<li><p>因此，天线可认为是导波和辐射波的变换转置，是一个能量转换器件</p>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230914144959366.png" alt="image-20230914144959366" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-天线的主要性能指标"><a href="#2-天线的主要性能指标" class="headerlink" title="2.天线的主要性能指标"></a>2.天线的主要性能指标</h2><h3 id="2-1-天线效率"><a href="#2-1-天线效率" class="headerlink" title="2.1 天线效率"></a>2.1 天线效率</h3><ul>
<li><p>发射机输出的功率为$P_G$，进入到天线的功率为$P_{in} = (1-|\eta|^2)P_G$ ，天线辐射的功率为$P_{\sum}$，</p>
<ul>
<li>$\eta$是反射系数</li>
<li>这是由于天线和传输线之间的失配而产生的，完全匹配时，$P_{in} = P_{P_G}$</li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20230914145639644.png" alt="image-20230914145639644" style="zoom:50%;"></p>
</li>
<li><p>天线的效率定义为：</p>
<script type="math/tex; mode=display">
\eta_A = \frac{P_{\sum}}{P_{in}} = \frac{P_{\sum}}{P_{\sum}+P_{loss}}</script><ul>
<li><p>$P_{loss}$表示损耗功率，它是由天线的铜耗、介质损耗、加载元件的损耗以及接地损耗等造成的</p>
</li>
<li><p>假设这一部分功率为一电阻所吸收，称此电阻为损耗电阻，记为$R_{loss}$，则：</p>
<script type="math/tex; mode=display">
R_{loss} = \frac{2P_{loss}}{I_{A}^{2}}</script></li>
<li><p>式中$I_A$式天线上某点的电流，则$R_{loss}$是归算于此电流的损耗电阻</p>
</li>
<li><p>若天线阻抗为$R_{\sum}$，上式也可表示为：</p>
<script type="math/tex; mode=display">
\eta_A = \frac{R_{\sum}}{R_{\sum}+R_{loss}}</script></li>
</ul>
</li>
</ul>
<h3 id="2-2-天线方向图"><a href="#2-2-天线方向图" class="headerlink" title="2.2 天线方向图"></a>2.2 天线方向图</h3><ul>
<li><p><strong>天线的方向性</strong>是指天线向一定方向辐射电磁波的能力。对于接收天线而言，方向性表示天线对不同方向传来的电磁波具有不同的接收能力。天线的方向性通常用方向图来表示</p>
<ul>
<li><p>如果把天<strong>线在各方向辐射的强度</strong>用从原点出发的矢量来表示，则连接全部矢量端点所形成的曲面就是<strong>天线的方向图</strong></p>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221115121354695.png" alt="image-20221115121354695" style="zoom:33%;"></p>
<ul>
<li><p>$P_t$：发射机功率</p>
</li>
<li><p>$G_t$：最大增益（天线在最大辐射方向上辐射的功率$P_{max}$或$|E_{max}|^2$和无方向性天线（电源）的辐射功率$P_0$或$|E_0|^2$之比称为此天线的方向系数）</p>
</li>
<li><p>$G_tF(\theta)$：与最大增益方向夹角为$\theta$的方向对应的增益</p>
</li>
</ul>
</li>
<li><p>天线方向图实际在360°方向都有值，与最大增益方向夹角越大，增益越小（只在主瓣范围内有效）</p>
</li>
<li><p>主瓣获得的功率增益，是以牺牲副瓣增益得到的</p>
</li>
<li><p>在方向图（又称波瓣图）中，<strong>包含所需最大辐射方向的辐射波瓣叫天线主波瓣</strong>，也称天线波束。主瓣之外的波瓣叫副瓣或旁瓣、边瓣，主瓣相反方向上的旁瓣叫后瓣、尾瓣</p>
<ul>
<li>直角坐标系表示的方向图</li>
</ul>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/v2-a77998f30d31deaf70b623b4286e5da2_r.jpg" alt="img" style="zoom:50%;"></p>
<ul>
<li><p>极坐标系表示的方向图</p>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/v2-279a4d9436e14aec4a071e4a8bbf36a4_r.jpg" alt="img" style="zoom:50%;"></p>
</li>
<li><p>球坐标系表示的3D方向图</p>
<p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/v2-4b96d474dc1b06970c0911ce5732b54d_r.jpg" alt="img" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-波束宽度"><a href="#2-3-波束宽度" class="headerlink" title="2.3 波束宽度"></a>2.3 波束宽度</h2><ul>
<li><p>主瓣的宽度称为波束宽度，是衡量天线方向图胖瘦的指标</p>
</li>
<li><p>定义为主瓣功率下降到波束中央 1/2 功率处的宽度</p>
</li>
<li><p>波束宽度用$\theta_{3dB}$或者$\theta_{0.5}$表示</p>
<script type="math/tex; mode=display">
\begin{cases}
\begin{aligned}
20log_{10}^\frac{\sqrt 2}{2} &= -3dB\\
10log_{10}^\frac{1}{2} &= -3dB
\end{aligned}
\end{cases}</script><p><img src="/2022/11/15/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20221115123347246.png" alt="image-20221115123347246" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h1 id="雷达的工作频率"><a href="#雷达的工作频率" class="headerlink" title="雷达的工作频率"></a>雷达的工作频率</h1><ul>
<li><p>常用的工作频率：220MHz~35GHz</p>
</li>
<li><p>又分为若干个波段：</p>
<p>| 波段名称  | 频率          |<br>| ————- | ——————- |<br>| L         | 1000~2000MHz  |<br>| S         | 2000~4000MHz  |<br>| C         | 4000~8000MHz  |<br>| X         | 8000~12000MHz |<br>| K$\mu$    | 1.2~18GHz     |<br>| K         | 18~27GHZ      |<br>| K$\alpha$ | 27~40GHz      |</p>
</li>
</ul>
<hr>
<h1 id="相关单位换算"><a href="#相关单位换算" class="headerlink" title="相关单位换算"></a>相关单位换算</h1><ul>
<li>1000yd=3000ft=0.914km≈0.6mile</li>
<li>1海里=1.853km</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>$K$</th>
<th>$M$</th>
<th>$G$</th>
<th>$m$</th>
<th>$\mu$</th>
<th>$n$</th>
<th>$p$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$10^3$</td>
<td>$10^6$</td>
<td>$10^9$</td>
<td>$10^{-3}$</td>
<td>$10^{-6}$</td>
<td>$10^{-9}$</td>
<td>$10^{-12}$</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/149757466">一，雷达原理-基础知识1 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/150601023">一，雷达原理-基础知识2 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/550161645">方向图与天线增益 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>雷达原理</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之数值微积分与方程求解</title>
    <url>/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<p>本节主要介绍了MATLAB中微积分的计算、线性方程与非线性方程的求解方法、以及常微分方程的求解。</p>
<span id="more"></span>
<h1 id="数值微分与数值积分"><a href="#数值微分与数值积分" class="headerlink" title="数值微分与数值积分"></a>数值微分与数值积分</h1><h2 id="1-数值微分的定义"><a href="#1-数值微分的定义" class="headerlink" title="1.数值微分的定义"></a>1.数值微分的定义</h2><ul>
<li><p>函数在x0点处以h（h&gt;0）为步长的差分公式：</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114114047436.png" alt="image-20221114114047436" style="zoom: 33%;"></p>
</li>
<li><p>当步长h充分小时，得到 <a href="MATLAB之图像绘制.md">MATLAB之图像绘制.md</a> 函数在x0点处以h（h&gt;0)为步长的差商公式：</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114114223056.png" alt="image-20221114114223056" style="zoom:33%;"></p>
</li>
<li><p>函数f(x)在点x0的微分接近于函数在该点的差分，而f在点x的导数接近于函数在该点的差商</p>
</li>
</ul>
<h2 id="2-数值微分的实现"><a href="#2-数值微分的实现" class="headerlink" title="2.数值微分的实现"></a>2.数值微分的实现</h2><ul>
<li><p><code>dx=diff(x)</code> %计算向量x的向前差分，dx(i)=x(i+1)-x(i)</p>
<ul>
<li>如果x是长度为 m 的向量，则 dx = diff(x) 返回长度为 <strong>m-1</strong> 的向量。dx的元素是x相邻元素之间的差分。</li>
<li>dx = [X(2)-X(1) X(3)-X(2) … X(m)-X(m-1)]</li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114115313838.png" alt="image-20221114115313838" style="zoom:50%;"></p>
</li>
<li><p><code>dx=diff(x,n)</code> %计算向量x的n阶向前差分，相当于将diff(x)重复调用了n次                                                                                                                               </p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114115656613.png" alt="image-20221114115656613" style="zoom: 50%;"></p>
</li>
<li><p><code>dx=diff(A,n,dim)</code> %计算矩阵A的n阶差分</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114131530593.png" alt="image-20221114131530593" style="zoom:50%;"></p>
</li>
</ul>
<p>​                                 </p>
<h2 id="3-数值积分的定义"><a href="#3-数值积分的定义" class="headerlink" title="3.数值积分的定义"></a>3.数值积分的定义</h2><ul>
<li><p>将积分区间[a,b]分成n个子区间[$x_i$,$x_{i+1}$],i=1,2,……,n，其中$x_1$=a；$x_{n+1}$=b，这样求定积分问题就分解为：</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114132437831.png" alt="image-20221114132437831" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="4-数值积分的实现"><a href="#4-数值积分的实现" class="headerlink" title="4.数值积分的实现"></a>4.数值积分的实现</h2><ul>
<li><p>基于自适应辛普森方法</p>
<ul>
<li><code>[I,n]=quad(filename,a,b,tol,trace)</code></li>
<li>tol用来控制绝对误差容限，默认取$10^{-6}$</li>
<li>trace控制是否展现积分过程，取0则不展示（默认）</li>
<li>返回参数I即定积分的值，n为被积函数的调用次数</li>
</ul>
</li>
<li><p>基于自适应Gauss-Lobatto方法</p>
<ul>
<li><code>[I,n]=quadl(filename,a,b,tol,trace)</code></li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114133957614.png" alt="image-20221114133957614" style="zoom:50%;"></p>
</li>
<li><p><strong>基于全局自适应积分方法（MATLAB推荐使用</strong>）</p>
<ul>
<li><code>I=integral(filename,a,b)</code></li>
<li>I是计算得到的积分，filename是被积函数</li>
<li>a和b分别是定积分的下限和上限</li>
<li>积分限可以为无穷大，<code>Inf</code>表示无穷大</li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114134705448.png" alt="image-20221114134705448" style="zoom:50%;"></p>
</li>
<li><p><strong>多重积分的数值求解</strong></p>
<ul>
<li><p>二重积分</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114135057453.png" alt="image-20221114135057453" style="zoom: 50%;"></p>
<ul>
<li><p><code>I=integral2(filename,a,b,c,d)</code></p>
</li>
<li><p><code>I=quad2d(filename,a,b,c,d)</code></p>
</li>
<li><p><code>I=dblquad(filename,a,b,c,d,tol)</code></p>
</li>
</ul>
</li>
<li><p>三重积分</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114135314582.png" alt="image-20221114135314582" style="zoom:50%;"></p>
<ul>
<li><code>I=integral3(filename,a,b,c,d,e,f)</code></li>
<li><code>I=triplequad(filename,a,b,c,d,e,f,tol)</code></li>
</ul>
</li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114135711548.png" alt="image-20221114135711548" style="zoom:50%;"></p>
</li>
</ul>
<p>​    </p>
<hr>
<h1 id="线性方程组求解"><a href="#线性方程组求解" class="headerlink" title="线性方程组求解"></a>线性方程组求解</h1><h2 id="1-直接法"><a href="#1-直接法" class="headerlink" title="1.直接法"></a>1.直接法</h2><ul>
<li><p>利用左除运算符的直接解法</p>
<ul>
<li>Ax=b ———&gt; <code>x=A\b</code></li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114141202880.png" alt="image-20221114141202880" style="zoom:50%;"></p>
</li>
<li><p>利用矩阵分解求解——LU解法</p>
<ul>
<li><p>LU分解的基本思想：将一个n阶矩阵表示为一个下三角矩阵和一个上三角矩阵的乘积。可以首先求解向量y使Ly=b，再求解Ux=y</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114141707389.png" alt="image-20221114141707389" style="zoom:50%;"></p>
</li>
<li><p>求解函数：</p>
<ul>
<li><code>[L,U]=lu(A)</code> %产生一个上三角阵U和一个变换形式的下三角阵L，使之满足A=LU，A必须是方阵</li>
<li><code>[L,U,P]=lu(A)</code> %PA=LU，A必须是方阵</li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114142555139.png" alt="image-20221114142555139"></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2.迭代法"></a>2.迭代法</h2><ul>
<li><p>雅可比（Jacobi）迭代法</p>
<ul>
<li><p>基本思想：</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114142857874.png" alt="image-20221114142857874" style="zoom:50%;"></p>
</li>
<li><p>函数编写</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%雅可比迭代法的函数文件jacobi.m：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[y,n]</span>=<span class="title">jacobi</span><span class="params">(A,b,x0,ep)</span> %<span class="title">x0</span>是初值，<span class="title">ep</span>是误差</span></span><br><span class="line">D=<span class="built_in">diag</span>(<span class="built_in">diag</span>(A));</span><br><span class="line">L=-<span class="built_in">tril</span>(A,<span class="number">-1</span>);</span><br><span class="line">U=-<span class="built_in">triu</span>(A,<span class="number">1</span>);</span><br><span class="line">B=D\(L+U);</span><br><span class="line">f=D\b;</span><br><span class="line">y=B*x0+f;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> norm(y-x0)&gt;=ep</span><br><span class="line">    x0=y;</span><br><span class="line">    y=B*x0+f;</span><br><span class="line">    n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>高斯-赛德尔（Gauss-Serdel）迭代法</p>
<ul>
<li><p>基本思想：</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114143825105.png" alt="image-20221114143825105" style="zoom:50%;"></p>
</li>
<li><p>函数编写</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%Gauss-Serdel迭代法的函数文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[y,n]</span>=<span class="title">gauseidel</span><span class="params">(A,b,x0,ep)</span></span></span><br><span class="line">D=<span class="built_in">diag</span>(<span class="built_in">diag</span>(A));</span><br><span class="line">L=-<span class="built_in">tril</span>(A,<span class="number">-1</span>); </span><br><span class="line">U=-<span class="built_in">triu</span>(A,<span class="number">1</span>);</span><br><span class="line">B=(D-L)\U;</span><br><span class="line">f=(D-L)\b;</span><br><span class="line">y=B*x0+f;</span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> norm(y-x0)&gt;=ep</span><br><span class="line">    x0=y;</span><br><span class="line">    y=B*x0+f;</span><br><span class="line">    n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>调用：</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114144237853.png" alt="image-20221114144237853" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="非线性方程求解与函数极值计算"><a href="#非线性方程求解与函数极值计算" class="headerlink" title="非线性方程求解与函数极值计算"></a>非线性方程求解与函数极值计算</h1><h2 id="1-非线性方程数值求解"><a href="#1-非线性方程数值求解" class="headerlink" title="1.非线性方程数值求解"></a>1.非线性方程数值求解</h2><ul>
<li><p>单变量非线性方程求解</p>
<ul>
<li><code>x=fzero(filename,x0)</code> %x0是初值</li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114150314743.png" alt="image-20221114150314743" style="zoom:50%;"></p>
</li>
<li><p>非线性方程组的求解</p>
<ul>
<li><code>x=fsolve(filename,x0,option)</code></li>
<li>x为返回的解的近似解，x0是初值</li>
<li>opton用于设置优化工具箱的优化参数，可以调用optimset函数来完成</li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114152425293.png" alt="image-20221114152425293" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-函数极值的计算"><a href="#2-函数极值的计算" class="headerlink" title="2.函数极值的计算"></a>2.函数极值的计算</h2><ul>
<li><p>无约束最优化问题</p>
<ul>
<li><code>[xmin,fmin]=fminbnd(filename,x1,x2,option)</code></li>
<li><code>[xmin,fmin]=fminsearch(filename,x0,option)</code></li>
<li><code>[xmin,fmin]=fminunc(filename,x0,option)</code></li>
<li>x1、x2分别表示被研究区间的左、右边界；后两个函数的输入变量x0是一个向量，表示极值点的初值</li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114153148161.png" alt="image-20221114153148161" style="zoom:50%;"></p>
</li>
<li><p>有约束最优化问题</p>
<ul>
<li><p><code>[xmin,fmin]=fmincon(filename,x0,A,b,Aeq,beq,Lb,ub,nonlcon,options)</code></p>
</li>
<li><p>其中的限制条件为：nonlcon为函数句柄，接受向量或数组 x，并返回两个数组 c(x) 和 ceq(x)。</p>
<ul>
<li><p>c(x) 是由 x 处的非线性不等式约束组成的数组。<code>fmincon</code> 尝试满足</p>
<p>对于 c 的所有项，有 c(x) &lt;= 0。</p>
</li>
<li><p>ceq(x) 是 x 处的非线性等式约束的数组。fmincon 尝试满足</p>
<p>对于 ceq 的所有项，有 ceq(x) = 0。</p>
</li>
<li><p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114154903952.png" alt="image-20221114154903952" style="zoom: 67%;"></p>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114155228510.png" alt="image-20221114155228510" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="常微分方程数值求解"><a href="#常微分方程数值求解" class="headerlink" title="常微分方程数值求解"></a>常微分方程数值求解</h1><h2 id="1-常微分方程数值求解的一般概念"><a href="#1-常微分方程数值求解的一般概念" class="headerlink" title="1.常微分方程数值求解的一般概念"></a>1.常微分方程数值求解的一般概念</h2><ul>
<li>求解常微分方程初值问题就是寻找函数y(t)使之满足如下方程</li>
</ul>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114160541636.png" alt="image-20221114160541636" style="zoom:50%;"></p>
<h2 id="2-一般调用格式"><a href="#2-一般调用格式" class="headerlink" title="2.一般调用格式"></a>2.一般调用格式</h2><ul>
<li><p><code>[t,y]=solver(filename,tspan,y0,option)</code></p>
</li>
<li><p>tspan为[t0,tf]，表示求t在某一范围内的解</p>
</li>
<li><p>y0是初始状态向量</p>
</li>
<li><p>t,y分别给出时间向量和相应的数值解</p>
</li>
<li><p>solver的统一命名格式：</p>
<ul>
<li><p>ode是常微分方程的英文缩写</p>
</li>
<li><p>nn代表所用方法的阶数</p>
</li>
<li><p>xx是字母，用于标注方法的专门特征</p>
</li>
<li><p>常用的求解函数：</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114161327744.png" alt="image-20221114161327744" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<h2 id="3-相关实例"><a href="#3-相关实例" class="headerlink" title="3.相关实例"></a>3.相关实例</h2><ul>
<li><p>例1：</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114162355202.png" alt="image-20221114162355202" style="zoom:33%;"></p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114162502800.png" alt="image-20221114162502800"></p>
</li>
<li><p>例2：</p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114162715389.png" alt="image-20221114162715389" style="zoom:33%;"></p>
<p><img src="/2022/11/14/MATLAB%E4%B9%8B%E6%95%B0%E5%80%BC%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/image-20221114162925269.png" alt="image-20221114162925269"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之数据分析与多项式计算</title>
    <url>/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>本节主要介绍了MATLAB中常用的统计分析函数、多项式相关计算以及数据插值与曲线拟合函数。</p>
<span id="more"></span>
<h1 id="数据统计分析"><a href="#数据统计分析" class="headerlink" title="数据统计分析"></a>数据统计分析</h1><h2 id="1-最大值与最小值"><a href="#1-最大值与最小值" class="headerlink" title="1.最大值与最小值"></a>1.最大值与最小值</h2><ul>
<li>max() 与 min()</li>
<li><code>[y,k]=max(A,[],dim)</code> %dim=1（默认值）时，求每列的最大值，并返回一个每列最大值下标的行向量；当dim=2时，求每行的最大值，并返回一个每行最大值小标的列向量；dim=‘all’即求全局最大值</li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113114555506.png" alt="image-20221113114555506" style="zoom:50%;"></p>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113114642652.png" alt="image-20221113114642652" style="zoom: 50%;"></p>
<h2 id="2-平均值和中值"><a href="#2-平均值和中值" class="headerlink" title="2.平均值和中值"></a>2.平均值和中值</h2><ul>
<li><code>mean(A,dim)</code> %求算术平均值</li>
<li><code>median(A,dim)</code> %求中值</li>
</ul>
<h2 id="3-和与求积"><a href="#3-和与求积" class="headerlink" title="3.和与求积"></a>3.和与求积</h2><ul>
<li><code>sum(A,dim)</code> %求和函数</li>
<li><code>prod(A,dim)</code> %求积函数</li>
</ul>
<h2 id="4-累加和与累乘积"><a href="#4-累加和与累乘积" class="headerlink" title="4.累加和与累乘积"></a>4.累加和与累乘积</h2><ul>
<li><code>cumsum(A,dim)</code> %累加和函数</li>
<li><code>cumprod(A,dim)</code> %累乘积函数</li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113120149153.png" alt="image-20221113120149153" style="zoom:50%;"></p>
<h2 id="5-标准差与相关系数"><a href="#5-标准差与相关系数" class="headerlink" title="5.标准差与相关系数"></a>5.标准差与相关系数</h2><ul>
<li><p><code>std(A,flag,dim)</code>  %flag=0时，按S1所列公式计算样本标准方差；当flag=1时，按S2所列公式计算样本标准方差，在默认情况下，flag=0，dim=1</p>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113120601466.png" alt="image-20221113120601466" style="zoom:50%;"></p>
</li>
<li><p><code>corrcoef(X,Y)</code> %X,Y是向量，用于求X,Y向量之间的相关系数</p>
</li>
</ul>
<h2 id="6-排序"><a href="#6-排序" class="headerlink" title="6.排序"></a>6.排序</h2><ul>
<li><code>[Y,I]=sort(A,dim,mode)</code> </li>
<li>mode取’ascend’ or ‘descend’，默认升序</li>
<li>Y是排序后的矩阵，而I记录Y中的元素在A中位置</li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113124637863.png" alt="image-20221113124637863" style="zoom:50%;"></p>
<hr>
<h1 id="多项式计算"><a href="#多项式计算" class="headerlink" title="多项式计算"></a>多项式计算</h1><h2 id="1-多项式的四则运算"><a href="#1-多项式的四则运算" class="headerlink" title="1.多项式的四则运算"></a>1.多项式的四则运算</h2><ul>
<li>多项式的加减运算：直接对向量使用<code>+、-</code>（<strong>两个向量长度必须一致</strong>）</li>
<li>多项式乘法：<code>conv(P1,P2)</code> %P1、P2是两个多项式系数向量</li>
<li>多项式相除：<code>[Q,r]=deconv(P1,P2)</code> %Q返回多项式P1除以P2的商，r返回P1除以P2的余式</li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113165112668.png" alt="image-20221113165112668" style="zoom:50%;"></p>
<h2 id="2-多项式求导"><a href="#2-多项式求导" class="headerlink" title="2.多项式求导"></a>2.多项式求导</h2><ul>
<li><code>p=polyder(P)</code> %求多项式P的导函数</li>
<li><code>p=plolyder(P,Q)</code> %求P×Q的导函数</li>
<li><code>[p,q]=polyder(P,Q)</code> %求P/Q的导函数，导函数的分子存入p，分母存入q</li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113171132817.png" alt="image-20221113171132817" style="zoom:50%;"></p>
<h2 id="3-多项式求值"><a href="#3-多项式求值" class="headerlink" title="3.多项式求值"></a>3.多项式求值</h2><ul>
<li><code>polyval(p,x)</code> %对x中的每个数求值</li>
<li><code>polyvalm(p,x)</code> %<strong>要求x为方阵（n*n)</strong>，将这个方阵作为整体带入多项式求值</li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113172620114.png" alt="image-20221113172620114" style="zoom:50%;"></p>
<h2 id="4-多项式求根"><a href="#4-多项式求根" class="headerlink" title="4.多项式求根"></a>4.多项式求根</h2><ul>
<li><code>root(P)</code> %p为多项式的系数向量</li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113173142863.png" alt="image-20221113173142863" style="zoom:50%;"></p>
<hr>
<h1 id="数据插值"><a href="#数据插值" class="headerlink" title="数据插值"></a>数据插值</h1><h2 id="1-一维插值函数interp1-X-Y-X1-method"><a href="#1-一维插值函数interp1-X-Y-X1-method" class="headerlink" title="1.一维插值函数interp1(X,Y,X1,method)"></a>1.一维插值函数<code>interp1(X,Y,X1,method)</code></h2><ul>
<li>将根据X、Y的值，计算函数在X1处的值</li>
<li>其中，X、Y是两个等长已知向量，X1是一个向量或标量，表示要插值的点</li>
<li>method：插值方法<ul>
<li>linear：线性插值（默认方法），将与插值点靠近的两个数据点用直线连接，并在直线上选取对应插值点的数据</li>
<li>nearest：最近点插值，选择最近样本点的值作为插值数据</li>
<li>pchip、spline：是曲线更光滑</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113181729673.png" alt="image-20221113181729673" style="zoom:50%;"></p>
<h2 id="2-二维插值函数interp2-X-Y-Z-X1-Y1-method"><a href="#2-二维插值函数interp2-X-Y-Z-X1-Y1-method" class="headerlink" title="2.二维插值函数interp2(X,Y,Z,X1,Y1,method)"></a>2.二维插值函数<code>interp2(X,Y,Z,X1,Y1,method)</code></h2><ul>
<li>使用方法与一维相同，但<strong>不支持pchip方法</strong></li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113182341919.png" alt="image-20221113182341919"></p>
<hr>
<h1 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h1><ul>
<li>多项式拟合函数polyfit()</li>
<li><code>P=polyfit(X,Y,m)</code> %X、Y是样本数据，m是拟合的阶数，P是返回的多项式的系数</li>
<li><code>[P,S]=polyfit(X,Y,m)</code> %X、Y是样本数据，m是拟合的阶数，P是返回的多项式的系数。S是结构体，包括R（系数矩阵的QR分解的上三角阵），df（自由度），normr（拟合误差平方和的算术平方根）</li>
</ul>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113232716904.png" alt="image-20221113232716904"></p>
<p><img src="/2022/11/13/MATLAB%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/image-20221113232856369.png" alt="image-20221113232856369" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>小沈同学的本科实验报告</title>
    <url>/2022/11/12/%E6%9C%AC%E7%A7%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://kdocs.cn/l/cfc3MCeBzJFF?f=201">点击此处获取 电力电子之可控半波整流电路实验报告</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/coYDAIsCQgZt?f=201">点击此处获取 电力电子之可控全波整流电路实55验报告</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/canUVMWWHNYs?f=201">点击此处获取 电力电子之三相可控桥式整流电路实验报告</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/crRV9In1fgbG?f=201">点击此处获取 电力电子之Buck电路仿真分析实验报告</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/cgceUbXP7i1c?f=201">点击此处获取 电力电子之单相PWM逆变电路实验报告</a></p>
</li>
</ul>
<span id="more"></span>
<hr>
<ul>
<li><h2 id="整理不易，请取之有道，转载务必注明出处！"><a href="#整理不易，请取之有道，转载务必注明出处！" class="headerlink" title="整理不易，请取之有道，转载务必注明出处！"></a>整理不易，请取之有道，转载务必注明出处！</h2></li>
<li><h2 id="文件较大，加载可能比较费时，请耐心等待！"><a href="#文件较大，加载可能比较费时，请耐心等待！" class="headerlink" title="文件较大，加载可能比较费时，请耐心等待！"></a>文件较大，加载可能比较费时，请耐心等待！</h2></li>
<li><h2 id="若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！"><a href="#若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！" class="headerlink" title="若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！"></a>若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！</h2></li>
</ul>
]]></content>
      <categories>
        <category>知识共享</category>
      </categories>
      <tags>
        <tag>实验报告</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之图形绘制</title>
    <url>/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<p>本节主要介绍了MATLAB中基本的绘图方法，包括二维图形与三维图形的绘制。</p>
<span id="more"></span>
<h1 id="二维曲线"><a href="#二维曲线" class="headerlink" title="二维曲线"></a>二维曲线</h1><h2 id="1-plot-x-y"><a href="#1-plot-x-y" class="headerlink" title="1.plot(x,y)"></a>1.<code>plot(x,y)</code></h2><ul>
<li><p>当x是向量，y是矩阵时，如果矩阵y的列数等于x的长度，则以向量x为横坐标，以y的每个行向量为纵坐标绘制曲线，曲线的条数等于y的行数</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112142210160.png" alt="image-20221112142210160" style="zoom:33%;"></p>
</li>
<li><p>当x、y是同形矩阵时，以x、y对应列元素为横、纵坐标分别绘制曲线，曲线条数等于矩阵的列数</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112142014031.png" alt="image-20221112142014031" style="zoom: 33%;"></p>
</li>
<li><p>含多个输入参数的plot函数</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112142643652.png" alt="image-20221112142643652" style="zoom: 33%;"></p>
</li>
<li><p><code>plot(x,y,选项)</code> %选型用于指定曲线的<strong>颜色、线型、数据点标记</strong></p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112142928903.png" alt="image-20221112142928903" style="zoom: 33%;"></p>
<p>例：</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112143153993.png" alt="image-20221112143153993" style="zoom:33%;"></p>
</li>
</ul>
<h2 id="2-fplot-f-lims-选项"><a href="#2-fplot-f-lims-选项" class="headerlink" title="2.fplot(f,lims,选项)"></a>2.<code>fplot(f,lims,选项)</code></h2><ul>
<li>f代表一个函数，<strong>通常采用函数句柄的形式</strong></li>
<li>lims为x轴的取值范围，用二元向量[xmin,xmax]描述，默认值为[-5,5]</li>
<li>此绘制函数会使得自变量的采样间隔设置更加合理</li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112144322203.png" alt="image-20221112144322203" style="zoom:50%;"></p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112144738596.png" alt="image-20221112144738596" style="zoom:50%;"></p>
<hr>
<h1 id="绘制图形的辅助操作"><a href="#绘制图形的辅助操作" class="headerlink" title="绘制图形的辅助操作"></a>绘制图形的辅助操作</h1><h2 id="1-图形标注"><a href="#1-图形标注" class="headerlink" title="1. 图形标注"></a>1. 图形标注</h2><ul>
<li><p><code>title(图形标题，属性名，属性值)</code></p>
<ul>
<li>‘Color’属性：用于设置图形标题文本的颜色</li>
<li>‘Fontsize’属性：用于设置标题文字的字号</li>
<li>对于需要换行的图形标题，使用字符串、逗号、大括号的形式</li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112150916513.png" alt="image-20221112150916513" style="zoom:50%;"></p>
</li>
<li><p><code>xlabel(x轴说明)与ylabel(y轴说明)</code></p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112151343614.png" alt="image-20221112151343614" style="zoom:50%;"></p>
</li>
<li><p><code>text(x,y,说明)</code>与<code>gtext(说明)</code> %添加文字说明</p>
<ul>
<li>其中text的x，y是说明的位置</li>
<li>gtext中说明的位置是程序执行后手动点击添加的</li>
</ul>
</li>
<li><p><code>legend(图例1,图例2,……)</code></p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112152220170.png" alt="image-20221112152220170" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-坐标控制"><a href="#2-坐标控制" class="headerlink" title="2.坐标控制"></a>2.坐标控制</h2><ul>
<li><p><code>axis([xmin,xmax,ymin,ymax,zmin,zmax])</code></p>
</li>
<li><p><code>axis equal</code>：横纵坐标轴采用等长刻度</p>
</li>
<li><p><code>axis square</code>：产生正方形坐标系（默认为矩形）</p>
</li>
<li><p><code>axis auto</code>：使用默认设置</p>
</li>
<li><p><code>axis off</code>：取消坐标轴</p>
</li>
<li><p><code>axis on</code>：显示坐标轴</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)<span class="comment">%测试axis的使用</span></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line"><span class="built_in">plot</span>(x,y,LineWidth=<span class="number">3</span>)</span><br><span class="line">axis([<span class="number">-0.1</span>, <span class="number">1.1</span>, <span class="number">-0.1</span>, <span class="number">1.1</span>])</span><br><span class="line">axis equal</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>)<span class="comment">%测试axis的使用</span></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line"><span class="built_in">plot</span>(x,y,LineWidth=<span class="number">3</span>)</span><br><span class="line">axis([<span class="number">-0.1</span>, <span class="number">1.1</span>, <span class="number">-0.1</span>, <span class="number">1.1</span>])</span><br><span class="line">axis square</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112153251248.png" alt="image-20221112153251248"></p>
</li>
<li><p>给坐标系加网格、边框</p>
<ul>
<li>grid on</li>
<li>grid off</li>
<li>box on </li>
<li>box off</li>
</ul>
</li>
<li><p>图形保持</p>
<ul>
<li>hold on</li>
<li>hold off</li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112153851222.png" alt="image-20221112153851222" style="zoom:50%;"></p>
</li>
<li><p>图形窗口的分割：<code>subplot(m,n,p)</code></p>
</li>
<li><p>添加总标题：<code>sgtitle(&#39;总标题&#39;)</code></p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112154137465.png" alt="image-20221112154137465" style="zoom:50%;"></p>
</li>
</ul>
<h1 id="其他坐标系下的二维曲面图"><a href="#其他坐标系下的二维曲面图" class="headerlink" title="其他坐标系下的二维曲面图"></a>其他坐标系下的二维曲面图</h1><h2 id="1-对数坐标图"><a href="#1-对数坐标图" class="headerlink" title="1.对数坐标图"></a>1.对数坐标图</h2><ul>
<li><code>semilogx(x1,y1,选型1,x2,y2,选项2,……)</code></li>
<li><code>semilogy(x1,y1,选型1,x2,y2,选项2,……)</code></li>
<li><code>loglog(x1,y1,选型1,x2,y2,选项2,……)</code></li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112155957937.png" alt="image-20221112155957937" style="zoom:50%;"></p>
<h2 id="2-极坐标图"><a href="#2-极坐标图" class="headerlink" title="2.极坐标图"></a>2.极坐标图</h2><ul>
<li><code>polarplot(theta,rho,选项)</code> %theta为极角，rho为极经</li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112160425248.png" alt="image-20221112160425248"></p>
<h2 id="3-统计图"><a href="#3-统计图" class="headerlink" title="3.统计图"></a>3.统计图</h2><ul>
<li><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a><strong>条形图</strong></h3><ul>
<li><code>bar(x,y,style)</code> %绘制垂直条形图</li>
<li><code>barh(x,y,style)</code> %绘制水平条形图</li>
<li>x为存储横坐标，y存储数据，y的行数必须与向量x的长度相同</li>
<li>style用于指定分组排列模式，’grouped’表示簇状分组，’stacked’表示堆积分组</li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112161456011.png" alt="image-20221112161456011"></p>
</li>
<li><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a><strong>直方图</strong></h3><ul>
<li><code>histogram(y,x)</code></li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112162131529.png" alt="image-20221112162131529"></p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112162515866.png" alt="image-20221112162515866"></p>
</li>
<li><h3 id="扇形图"><a href="#扇形图" class="headerlink" title="扇形图"></a><strong>扇形图</strong></h3><ul>
<li><code>pie(x,explode)</code></li>
<li>其中x为统计的数据</li>
<li>explode将扇区从饼图偏移一定位置，其由与 x对应的零值和非零值组成的向量或矩阵。pie 函数仅将对应于 explode 中的非零元素的扇区偏移一定的位置。</li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112162955255.png" alt="image-20221112162955255" style="zoom:50%;"></p>
</li>
<li><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a><strong>散点图</strong></h3><ul>
<li><code>scatter(x,y,选项，&#39;filled&#39;)</code></li>
<li>filled指定填充数据点标记，其省略时数据点是空心的</li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112163815738.png" alt="image-20221112163815738"></p>
</li>
<li><h3 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a><strong>矢量图</strong></h3><ul>
<li><code>quiver(x,y,u,v)</code></li>
<li>其中(x,y)指定矢量起点，(u,v)指定矢量终点</li>
</ul>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112164930503.png" alt="image-20221112164930503" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="三维曲线"><a href="#三维曲线" class="headerlink" title="三维曲线"></a>三维曲线</h1><h2 id="1-plot3-x-y-z"><a href="#1-plot3-x-y-z" class="headerlink" title="1.plot3(x,y,z)"></a>1.<code>plot3(x,y,z)</code></h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%在空间不同位置绘制5条正弦曲线。</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">t=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">t=t&#x27;;</span><br><span class="line">x=[t, t, t, t, t];</span><br><span class="line">y=[<span class="built_in">sin</span>(t), <span class="built_in">sin</span>(t)+<span class="number">1</span>, <span class="built_in">sin</span>(t)+<span class="number">2</span>, <span class="built_in">sin</span>(t)+<span class="number">3</span>, <span class="built_in">sin</span>(t)+<span class="number">4</span>];</span><br><span class="line">z=x;</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,LineWidth=<span class="number">2</span>)</span><br><span class="line"><span class="comment">%这个例子也可以采用以下代码实现。</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">t=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">x=t;</span><br><span class="line">y=[<span class="built_in">sin</span>(t); <span class="built_in">sin</span>(t)+<span class="number">1</span>; <span class="built_in">sin</span>(t)+<span class="number">2</span>; <span class="built_in">sin</span>(t)+<span class="number">3</span>; <span class="built_in">sin</span>(t)+<span class="number">4</span>];</span><br><span class="line">z=x;</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,LineWidth=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112170835553.png" alt="image-20221112170835553"></p>
<ul>
<li><p>含多组输入参数的plot3函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%含多组输入的plot3函数</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">t1=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">1.5</span>*<span class="built_in">pi</span>;</span><br><span class="line">t2=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">t3=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">3</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="built_in">plot3</span>(t1,<span class="built_in">sin</span>(t1),t1,<span class="string">&#x27;r&#x27;</span>, t2,<span class="built_in">sin</span>(t2)+<span class="number">1</span>,t2,<span class="string">&#x27;b&#x27;</span>,t3,<span class="built_in">sin</span>(t3)+<span class="number">2</span>,t3,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112171510412.png" alt="image-20221112171510412" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-fplot3-funx-funy-funz-tlims"><a href="#2-fplot3-funx-funy-funz-tlims" class="headerlink" title="2.fplot3(funx,funy,funz,tlims)"></a>2.<code>fplot3(funx,funy,funz,tlims)</code></h2><ul>
<li>funx、funy、funz代表定义曲线x、y、z坐标的函数，通常使用函数句柄的形式</li>
<li>tlims为参数函数自变量的取值范围，用二元向量[tmin,tmax]描述</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%绘制墨西哥帽顶曲线</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">xt = @(t) <span class="built_in">exp</span>(-t/<span class="number">10</span>).*<span class="built_in">sin</span>(<span class="number">5</span>*t);</span><br><span class="line">yt = @(t) <span class="built_in">exp</span>(-t/<span class="number">10</span>).*<span class="built_in">cos</span>(<span class="number">5</span>*t);</span><br><span class="line">zt = @(t) t;</span><br><span class="line">fplot3(xt, yt, zt, [<span class="number">-12</span>, <span class="number">12</span>], <span class="string">&#x27;r-.&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112171957475.png" alt="image-20221112171957475" style="zoom:50%;"></p>
<hr>
<h1 id="三维曲面"><a href="#三维曲面" class="headerlink" title="三维曲面"></a>三维曲面</h1><h2 id="1-平面网格数据的生成"><a href="#1-平面网格数据的生成" class="headerlink" title="1.平面网格数据的生成"></a>1.平面网格数据的生成</h2><ul>
<li><p><code>[X,Y]=meshgrid(x,y)</code></p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112173452121.png" alt="image-20221112173452121" style="zoom:50%;"></p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112173746105.png" alt="image-20221112173746105" style="zoom:50%;"></p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112173804182.png" alt="image-20221112173804182" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="2-绘制三维曲面的函数"><a href="#2-绘制三维曲面的函数" class="headerlink" title="2.绘制三维曲面的函数"></a>2.绘制三维曲面的函数</h2><ul>
<li><code>mesh(x,y,z,c)</code> %绘制线框</li>
<li><code>surf(x,y,z,c)</code> %填充线框</li>
<li>其中，x、y是网格坐标矩阵，z是网格点上的高度矩阵，c用于指定在不同高度下的曲面颜色。c省略时，颜色的设定正比于图形高度</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%绘制三维曲面图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">5</span>)</span><br><span class="line">t = <span class="number">-2</span>:<span class="number">0.2</span>:<span class="number">2</span>; </span><br><span class="line">[X, Y] = <span class="built_in">meshgrid</span>(t);</span><br><span class="line">Z = X .* <span class="built_in">exp</span>(-X.^<span class="number">2</span> - Y.^<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">mesh(X,Y,Z); </span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">surf(X,Y,Z); </span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot3</span>(X,Y,Z); </span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112174752702.png" alt="image-20221112174752702"></p>
<h2 id="3-色彩处理"><a href="#3-色彩处理" class="headerlink" title="3.色彩处理"></a>3.色彩处理</h2><ul>
<li><p><code>colormap cmapname</code></p>
</li>
<li><p>matlab中预定义的颜色图</p>
<p><img src="/2022/11/12/MATLAB%E4%B9%8B%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/image-20221112181451498.png" alt="image-20221112181451498"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>小沈同学的日常分享2022</title>
    <url>/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/</url>
    <content><![CDATA[<p>Hello！这里是生活中的小沈同学……</p>
<span id="more"></span>
<h3 id="2022-11-12有感"><a href="#2022-11-12有感" class="headerlink" title="2022.11.12有感"></a>2022.11.12有感</h3><ul>
<li><p>所谓手控被自己迷住系列，哈哈</p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/image-20221112004525610.png" alt="image-20221112004525610" style="zoom: 67%;"></p>
</li>
</ul>
<ul>
<li><p>突然想起之前去听一个音乐节看到的一句话，很不错</p>
<ul>
<li><strong>“也许有天没音乐，我只见见你也行”</strong></li>
</ul>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/image-20221112010316665.png" alt="image-20221112010316665" style="zoom: 50%;"></p>
</li>
</ul>
<hr>
<h3 id="2022-11-13有感"><a href="#2022-11-13有感" class="headerlink" title="2022.11.13有感"></a>2022.11.13有感</h3><ul>
<li><p>又听到了很有棒很有力量的话，分享给那些永远可爱的人！</p>
</li>
<li><p>“是我们选择了这个时代，又或是这个时代选择了我们，让我们除了最好的自己别无选择”</p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/image-20221113233531872.png" alt="image-20221113233531872" style="zoom:50%;"></p>
</li>
<li><p>“不要讨好冷漠，不要辜负热情”</p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/image-20221113234953231.png" alt="image-20221113234953231" style="zoom:50%;"></p>
</li>
<li><p>明天又是崭新的一周了，大家都加油，小沈也要更加努力，晚安！</p>
</li>
</ul>
<hr>
<h3 id="2022-11-17记录"><a href="#2022-11-17记录" class="headerlink" title="2022.11.17记录"></a>2022.11.17记录</h3><ul>
<li><p>今日份快乐</p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/202b3881f84181687a790a376e58927.jpg" alt="202b3881f84181687a790a376e58927" style="zoom: 67%;"></p>
</li>
<li><p>今日份感动</p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/image-20221119000614773.png" alt="image-20221119000614773" style="zoom:50%;"></p>
</li>
<li><p>今日份励志</p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/image-20221119000726632.png" alt="image-20221119000726632" style="zoom: 50%;"></p>
</li>
</ul>
<hr>
<h3 id="2022-11-19分享"><a href="#2022-11-19分享" class="headerlink" title="2022.11.19分享"></a>2022.11.19分享</h3><ul>
<li>单曲循环一天了，太燃了！</li>
</ul>
<p><a href="https://c.y.qq.com/base/fcgi-bin/u?__=0K8ODbr4nZt5">点击此处享受听觉盛宴   思念是一种病（0713）</a></p>
<hr>
<h3 id="2022-11-22记录"><a href="#2022-11-22记录" class="headerlink" title="2022.11.22记录"></a>2022.11.22记录</h3><ul>
<li>猪喵说：这不会就是人类高质量友谊吧</li>
</ul>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221122212816.jpg" alt="微信图片_20221122212816" style="zoom:50%;"></p>
<hr>
<h3 id="2022-11-26有感"><a href="#2022-11-26有感" class="headerlink" title="2022.11.26有感"></a>2022.11.26有感</h3><ul>
<li><p>”任世界冬去春来，任人群南来北往，我会站在你们中央，你会站在我们中央“</p>
</li>
<li><p>这段话简直是我本人啦</p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/image-20221128190625338.png" alt="image-20221128190625338" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h3 id="2022-11-28有感"><a href="#2022-11-28有感" class="headerlink" title="2022.11.28有感"></a>2022.11.28有感</h3><ul>
<li>总有些再见没有期限</li>
</ul>
<hr>
<h3 id="2022-12-08记录"><a href="#2022-12-08记录" class="headerlink" title="2022.12.08记录"></a>2022.12.08记录</h3><ul>
<li><p>最近是不励志的小沈：睡觉十小时+学习两小时+各种摆烂十二小时</p>
</li>
<li><p>好不容易出来溜达了：</p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221209203243.jpg" alt="微信图片_20221209203243" style="zoom:50%;"></p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221209203354.jpg" alt="微信图片_20221209203354" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h3 id="2022-12-10记录"><a href="#2022-12-10记录" class="headerlink" title="2022.12.10记录"></a>2022.12.10记录</h3><ul>
<li><p>今天熬夜看了梅老板的比赛，赢得太艰难了</p>
</li>
<li><p>解说激动的说：“<strong>这个世界总有一些美好值得我们全力以赴，哪怕粉身碎骨</strong>”</p>
<p><img src="/2022/11/12/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB2022/image-20221210183049330.png" alt="image-20221210183049330"></p>
</li>
</ul>
<hr>
<h3 id="2022-12-14有感"><a href="#2022-12-14有感" class="headerlink" title="2022.12.14有感"></a>2022.12.14有感</h3><ul>
<li><strong>我要在有限的时间里无限地爱着那些超爱我的人</strong></li>
</ul>
<hr>
<h3 id="2022-12-18分享"><a href="#2022-12-18分享" class="headerlink" title="2022.12.18分享"></a>2022.12.18分享</h3><ul>
<li>分享一段今天看到的之前很喜欢的一位b站up主说的一段话：</li>
<li>“大家都很难，不过你要知道，你想考上说明你想变的更好，更优秀，更匹配的上未来憧憬的生活，只要你还有欲望，求知的欲望，赚钱的欲望，爱和被爱的欲望，即便再难日子都能过的津津有味。抑郁的反义词从来都不是快乐，而是活力。如果一个人对什么都不在乎，失去信心，失去兴趣，失去和他拼到死的那股鲜衣怒马的少年心性，其实才是最可怕的。万紫千红安排尽，只差春雷第一声，这个冬天迟早会过去，加油。”</li>
<li><strong>强推他讲自控的视频</strong>：<a href="https://space.bilibili.com/276472163/video">Edgar埃得加的个人空间_哔哩哔哩_bilibili</a></li>
</ul>
<hr>
<h3 id="2022-12-24分享"><a href="#2022-12-24分享" class="headerlink" title="2022.12.24分享"></a>2022.12.24分享</h3><ul>
<li><p>好久不见，过了几天痛不欲生的小”阳“人生活，我终于又回来了</p>
</li>
<li><p>先分享一段前几天看到同哥（刘同）公众号写的一段话：</p>
<p>”小时候，关系是因为害怕越来越糟糕而断掉了。现在，关系是害怕自己越来越无法自控而断掉了。“</p>
</li>
<li><p>今天平安夜，那就祝大家永远平安健康</p>
</li>
<li><p>今天还是考研的开始，在这里借助好朋友一如朋友圈的一段话祝福大家：</p>
<p>”人生海海，祝大家都能有帆有岸！“</p>
</li>
<li><p>在这里特别想祝：惠清、寝室长成功上岸！！！</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>生活碎片</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之程序流程控制与函数</title>
    <url>/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>本节主要介绍了MATLAB中函数的定义调用以及三种基本的程序运行结构，以及函数相关的定义与调用。</p>
<span id="more"></span>
<h1 id="顺序结构程序"><a href="#顺序结构程序" class="headerlink" title="顺序结构程序"></a>顺序结构程序</h1><h2 id="1-文件的建立"><a href="#1-文件的建立" class="headerlink" title="1.文件的建立"></a>1.文件的建立</h2><ul>
<li>用命令按钮创建文件<br><img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111124011062.png" alt="image-20221111124011062" style="zoom: 50%;"> </li>
<li>用edit命令创建文件：<code>edit 文件名</code></li>
</ul>
<h2 id="2-脚本文件与函数文件"><a href="#2-脚本文件与函数文件" class="headerlink" title="2.脚本文件与函数文件"></a>2.脚本文件与函数文件</h2><ul>
<li><p>脚本文件<br><img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111125023125.png" alt="image-20221111125023125" style="zoom:50%;"></p>
</li>
<li><p>函数文件<br><img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111125529258.png" alt="image-20221111125529258" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="3-数据的输入"><a href="#3-数据的输入" class="headerlink" title="3.数据的输入"></a>3.数据的输入</h2><ul>
<li><p><code>A=input(提示信息)</code> %此时只能输入数值，不能输入字符串</p>
</li>
<li><p><code>A=input(提示信息,&#39;s&#39;)</code> %输入的东西将当成字符串存储起来</p>
<p> <img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111141909298.png" alt="image-20221111141909298" style="zoom:50%;">、</p>
</li>
</ul>
<h2 id="4-数据的输出"><a href="#4-数据的输出" class="headerlink" title="4.数据的输出"></a>4.数据的输出</h2><ul>
<li><p><code>disp(输出项)</code></p>
<p> <img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111142213387.png" alt="image-20221111142213387" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="5-程序的暂停"><a href="#5-程序的暂停" class="headerlink" title="5.程序的暂停"></a>5.程序的暂停</h2><ul>
<li><code>pause(暂停的秒数)</code></li>
</ul>
<hr>
<h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><ul>
<li><p><strong>if语句</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%输入一个字符，若为大写字母，则输出其对应的小写字母；若为小写字母，则输出其对应</span></span><br><span class="line"><span class="comment">%的大写字母；若为数字字符则输出对应的数的平方，若为其他字符则原样输出</span></span><br><span class="line">c=input(<span class="string">&#x27;Please enter a char:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;大写字母转小写字母:&#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(lower(c))</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&quot;小写字母转大写字母:&quot;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(upper(c))</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&quot;数字字符输出对应的数的平方:&quot;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(str2double(c)^<span class="number">2</span>) <span class="comment">%将字符串转化为浮点型</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(c)</span><br><span class="line"><span class="keyword">end</span> <span class="comment">%结束需加end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>switch语句</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%PM2.5数值在[0，35）空气质量为优，</span></span><br><span class="line"><span class="comment">%[35，75）为良，[75，115）为轻度污染，</span></span><br><span class="line"><span class="comment">% [115，150）为中度污染，</span></span><br><span class="line"><span class="comment">% [150，250）为重度污染，</span></span><br><span class="line"><span class="comment">% 大于等于250为严重污染。</span></span><br><span class="line"><span class="comment">% 编写程序，输入PM2.5数值，输出空气质量等级。</span></span><br><span class="line">g=input(<span class="string">&#x27;请输入PM2.5值：&#x27;</span>);</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">fix</span>(g) </span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">0</span>:<span class="number">34</span>) <span class="comment">%将0~34的一个数组整体，变成单个的个体</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;空气质量优&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">35</span>:<span class="number">74</span>) </span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;空气质量良好&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">75</span>:<span class="number">114</span>) </span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;空气质量轻度污染&#x27;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">115</span>:<span class="number">149</span>) </span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;空气质量中度污染&#x27;</span>); </span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">150</span>:<span class="number">249</span>) </span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;空气质量重度污染&#x27;</span>);  </span><br><span class="line">    <span class="keyword">otherwise</span> <span class="comment">%注意matlab中使用otherwise表示其他</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;空气质量严重污染&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span> <span class="comment">%也需添加结束符end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="1-for语句"><a href="#1-for语句" class="headerlink" title="1.for语句"></a>1.for语句</h2><ul>
<li><p>格式：</p>
<p><code>for 循环变量=初值：步长：终值</code></p>
<p>​    <code>循环体语句</code></p>
<p><code>end</code></p>
</li>
<li><p>例：用蒙特卡洛法求$\pi$</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%利用蒙特卡洛法求π的近似值</span></span><br><span class="line">s=<span class="number">0</span>;</span><br><span class="line">n=input(<span class="string">&#x27;输入随机投掷的次数:(次数越多越准确)n=&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n <span class="comment">%有点像python中的遍历了</span></span><br><span class="line">    x=<span class="built_in">rand</span>(<span class="number">1</span>);</span><br><span class="line">    y=<span class="built_in">rand</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> x*x+y*y&lt;=<span class="number">1</span></span><br><span class="line">        s=s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">pai=s/n*<span class="number">4</span>;</span><br><span class="line"><span class="built_in">disp</span>(pai)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-while语句"><a href="#2-while语句" class="headerlink" title="2.while语句"></a>2.while语句</h2><ul>
<li><p>格式：</p>
<p><code>while 条件</code></p>
<p>​    <code>循环体语句</code></p>
<p><code>end</code></p>
</li>
<li><p>例：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%从键盘输入若干个数，当输入0时结束输入，求这些数的平均值和它们之和。</span></span><br><span class="line">msum=<span class="number">0</span>;</span><br><span class="line">n=<span class="number">0</span>;</span><br><span class="line">x=input(<span class="string">&#x27;Enter a number (end in 0):&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> x~=<span class="number">0</span> <span class="comment">%x不等于0时</span></span><br><span class="line">    msum=msum+x;</span><br><span class="line">    n=n+<span class="number">1</span>;</span><br><span class="line">    x=input(<span class="string">&#x27;Enter a number (end in 0):&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span> <span class="comment">%结束符end别忘了</span></span><br><span class="line"><span class="keyword">if</span> n&gt;<span class="number">0</span></span><br><span class="line">    <span class="built_in">mean</span>=msum/n;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(msum);</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">mean</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="函数文件的定义与调用"><a href="#函数文件的定义与调用" class="headerlink" title="函数文件的定义与调用"></a>函数文件的定义与调用</h1><h2 id="1-函数文件的基本结构"><a href="#1-函数文件的基本结构" class="headerlink" title="1.函数文件的基本结构"></a>1.函数文件的基本结构</h2><ul>
<li><p><code>function 输出形参表=函数名（输入形参表）</code></p>
</li>
<li><p>return语句表示结束函数的执行。通常在函数文件中也可以不使用return语句，那么被调用函数执行完成后会自动返回</p>
</li>
<li><p>例：</p>
<p> <img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111155246922.png" alt="image-20221111155246922" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2.匿名函数"></a>2.匿名函数</h2><ul>
<li><p>格式：</p>
<p><code>函数句柄变量=@（匿名函数输入参数）匿名函数表达式</code></p>
<p><code>函数句柄变量=@函数名 %这里的函数名可以是内部函数或自定义函数</code></p>
</li>
<li><p>例：</p>
<p> <img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111160019289.png" alt="image-20221111160019289" style="zoom:50%;"></p>
<p> <img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111160115764.png" alt="image-20221111160115764" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h1><p><img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111162644607.png" alt="image-20221111162644607" style="zoom: 50%;"></p>
<hr>
<h1 id="函数参数的可调性"><a href="#函数参数的可调性" class="headerlink" title="函数参数的可调性"></a>函数参数的可调性</h1><ul>
<li><strong>nargin</strong>：输入实参的个数</li>
<li><strong>nargout</strong>：输出实参的个数</li>
</ul>
<p><img src="/2022/11/11/MATLAB%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/image-20221111163746681.png" alt="image-20221111163746681" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之矩阵处理</title>
    <url>/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>本节介绍了MATLAB学习的一些矩阵处理相关的知识，包括通用与专用的特殊矩阵、矩阵变换、矩阵特征值与特征向量的求解、稀疏矩阵等。</p>
<span id="more"></span>
<h1 id="通用的特殊矩阵"><a href="#通用的特殊矩阵" class="headerlink" title="通用的特殊矩阵"></a>通用的特殊矩阵</h1><ul>
<li>zeros函数：产生全0矩阵</li>
<li>ones函数：产生全1矩阵</li>
<li>eye函数：产生对角线为1的矩阵</li>
<li><strong>rand函数</strong>：产生(0,1)【不包括0和1】区间均匀分布的随机矩阵</li>
<li><strong>randn函数</strong>：产生均值为0，方差为1的标准正态分布随机矩阵</li>
<li>调用方式：以zeros函数的为例：<ul>
<li><code>zeros(m)</code>：产生m×m零矩阵</li>
<li><code>zeros(m,n)</code>：产生m×n零矩阵</li>
<li><code>zeros(size(A))</code>：产生与矩阵A同样大小的零矩阵</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110112204278.png" alt="image-20221110112204278" style="zoom:50%;"></p>
<hr>
<h1 id="用于专门学科的特殊矩阵"><a href="#用于专门学科的特殊矩阵" class="headerlink" title="用于专门学科的特殊矩阵"></a>用于专门学科的特殊矩阵</h1><h2 id="1-魔方矩阵（Magic-Square）："><a href="#1-魔方矩阵（Magic-Square）：" class="headerlink" title="1.魔方矩阵（Magic Square）："></a>1.魔方矩阵（Magic Square）：</h2><ul>
<li><code>magic(n)</code>产生一个特定的魔方阵</li>
<li>n阶魔方阵由1，2，3，……n2共n2个整数组成，且每行、每列以及主、副对角线上各n各元素之和都相等</li>
<li>n节魔方阵每行每列元素的和为(1+2+3+……+n2)/n=(n+n3)/2</li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110113057250.png" alt="image-20221110113057250" style="zoom:50%;"></p>
<h2 id="2-范德蒙矩阵：vander"><a href="#2-范德蒙矩阵：vander" class="headerlink" title="2.范德蒙矩阵：vander()"></a>2.范德蒙矩阵：<code>vander()</code></h2><p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110113551524.png" alt="image-20221110113551524" style="zoom:50%;"></p>
<h2 id="3-希尔伯特矩阵：hilb-n"><a href="#3-希尔伯特矩阵：hilb-n" class="headerlink" title="3.希尔伯特矩阵：hilb(n)"></a>3.希尔伯特矩阵：<code>hilb(n)</code></h2><p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110113814471.png" alt="image-20221110113814471" style="zoom:50%;"></p>
<h2 id="4-帕斯克矩阵：pascal-n"><a href="#4-帕斯克矩阵：pascal-n" class="headerlink" title="4.帕斯克矩阵：pascal(n)"></a>4.帕斯克矩阵：<code>pascal(n)</code></h2><p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110114348920.png" alt="image-20221110114348920" style="zoom:50%;"></p>
<hr>
<h1 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h1><h2 id="1-对角阵"><a href="#1-对角阵" class="headerlink" title="1.对角阵"></a>1.<strong>对角阵</strong></h2><ul>
<li><p><code>diag(V)</code>：以向量V为主对角线元素，产生对角矩阵</p>
</li>
<li><p><code>diag(V,k)</code>：以向量V为第k条对角线元素，产生对角矩阵</p>
</li>
<li><code>diag(A,k)</code>：提取A中的第k条对角线元素，返回一个列向量</li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110122114206.png" alt="image-20221110122114206" style="zoom:50%;"></p>
<ul>
<li><p>例：将A的各列元素分别乘以对角阵的对角线元素</p>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110124600894.png" alt="image-20221110124600894" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-三角阵：下三角矩阵（triu）和上三角矩阵（tril）"><a href="#2-三角阵：下三角矩阵（triu）和上三角矩阵（tril）" class="headerlink" title="2.三角阵：下三角矩阵（triu）和上三角矩阵（tril）"></a>2.<strong>三角阵</strong>：下三角矩阵（triu）和上三角矩阵（tril）</h2><ul>
<li><code>triu(A)</code>：提取矩阵A的主对角线及以上的元素</li>
<li><code>triu(A,k)</code>：提取矩阵A的第k条对角线及以上的元素</li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110123111461.png" alt="image-20221110123111461" style="zoom:50%;"></p>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110123310690.png" alt="image-20221110123310690" style="zoom:50%;"></p>
<h2 id="3-矩阵转置"><a href="#3-矩阵转置" class="headerlink" title="3.矩阵转置"></a>3.<strong>矩阵转置</strong></h2><ul>
<li>转置运算符：<code>.&#39;</code></li>
<li>共轭转置：<code>&#39;</code> %它在转置的基础上还要取每个数的复共轭</li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110123832562.png" alt="image-20221110123832562" style="zoom:50%;"></p>
<h2 id="4-矩阵的旋转"><a href="#4-矩阵的旋转" class="headerlink" title="4.矩阵的旋转"></a>4.<strong>矩阵的旋转</strong></h2><ul>
<li><code>rot90(A,k)</code></li>
<li>将矩阵A逆时针方向旋转90°的k倍，当k为1时可省略</li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110124224929.png" alt="image-20221110124224929" style="zoom:50%;"></p>
<h2 id="5-矩阵的翻转"><a href="#5-矩阵的翻转" class="headerlink" title="5.矩阵的翻转"></a>5.<strong>矩阵的翻转</strong></h2><ul>
<li><code>fliplr(A)</code>：左右翻转</li>
<li><code>flipud(A)</code>：上下翻转</li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110124830166.png" alt="image-20221110124830166" style="zoom:50%;"></p>
<h2 id="6-矩阵的求逆"><a href="#6-矩阵的求逆" class="headerlink" title="6.矩阵的求逆"></a>6.<strong>矩阵的求逆</strong></h2><ul>
<li><p><code>inv(A)</code></p>
</li>
<li><p>可以通过矩阵求逆的方法求解线性方程组</p>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110125422429.png" alt="image-20221110125422429" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="矩阵行列式求解"><a href="#矩阵行列式求解" class="headerlink" title="矩阵行列式求解"></a>矩阵行列式求解</h1><ul>
<li><code>det(A)</code></li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221122161052638.png" alt="image-20221122161052638" style="zoom:50%;"></p>
<hr>
<h1 id="矩阵的特征值与特征向量"><a href="#矩阵的特征值与特征向量" class="headerlink" title="矩阵的特征值与特征向量"></a>矩阵的特征值与特征向量</h1><ul>
<li>设A时n阶方阵，如果存在常数$\lambda$和n维非零列向量x，使得等式Ax=$\lambda$x成立，则称$\lambda$为A的特征值，x是对应特征值$\lambda$的特征向量</li>
<li><code>E=eig(A)</code>：求矩阵A的全部特征值，构成向量E</li>
<li><code>[X,D]=eig(A)</code>：求矩阵A的全部特征值，构成对角阵D，并产生矩阵X，X各列是相应的特性向量</li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110143923535.png" alt="image-20221110143923535" style="zoom:50%;"></p>
<hr>
<h1 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h1><h2 id="1-无规则结构稀疏矩阵的产生"><a href="#1-无规则结构稀疏矩阵的产生" class="headerlink" title="1.无规则结构稀疏矩阵的产生"></a>1.无规则结构稀疏矩阵的产生</h2><ul>
<li><code>A=sparse(S)</code>：将矩阵S转化为稀疏存储方式的矩阵A</li>
<li><code>S=full(A)</code>：将矩阵A转化为完全存储方式的矩阵S</li>
</ul>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110145416770.png" alt="image-20221110145416770" style="zoom:50%;"></p>
<ul>
<li><p><code>sparse(m,n)</code>：生成一个m×n的所有元素都是零的稀疏矩阵</p>
</li>
<li><p><code>sparse(i,j,S)</code>：i,j是存储元素的下标，S表示要存储的非零元素</p>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110145955079.png" alt="image-20221110145955079" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-带状稀疏矩阵的产生"><a href="#2-带状稀疏矩阵的产生" class="headerlink" title="2.带状稀疏矩阵的产生"></a>2.带状稀疏矩阵的产生</h2><ul>
<li><p>其是指所有非零元素集中在对角线上的矩阵</p>
</li>
<li><p><code>[B,d]=spdiags(A)</code>：从带状稀疏矩阵A中提取全部非零对角线元素赋给矩阵B及其这些非零对角线的位置向量d</p>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110152245868.png" alt="image-20221110152245868" style="zoom:50%;"></p>
</li>
<li><p><code>A=spdiags(B,d,m,n)</code></p>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110153444565.png" alt="image-20221110153444565" style="zoom:50%;"></p>
</li>
<li><p><code>speye(m,n)</code>：返回m×n的稀疏存储的单位矩阵</p>
<p><img src="/2022/11/10/MATLAB%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/image-20221110153724671.png" alt="image-20221110153724671" style="zoom:50%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>小沈同学的本科课程设计</title>
    <url>/2022/11/10/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://kdocs.cn/l/crHuJo2z6NHB?f=201">点击此处获取 STM32课程设计之自平衡小车</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/ccI81EsAP318?f=201">点击此处获取 CAD课程设计之模拟PID控制器</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/cqYTXGPqJwNn?f=201">点击此处获取 结构化数字设计之课程设计</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/cp9HsaoE6AN8?f=201">点击此处获取 单片机课程设计之音乐盒</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/cnDZF0qPIKDa?f=201">点击此处获取 CAD实验讲解PPT</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/cnUrWdYHIMV4?f=301">点击此处获取 数学建模校赛论文</a></p>
</li>
<li><p><a href="https://kdocs.cn/l/ciCMhlvK7uQT?f=301">点击此处获取 数学建模国赛论文</a></p>
</li>
</ul>
<span id="more"></span>
<hr>
<ul>
<li><h2 id="整理不易，请取之有道，转载务必注明出处！"><a href="#整理不易，请取之有道，转载务必注明出处！" class="headerlink" title="整理不易，请取之有道，转载务必注明出处！"></a>整理不易，请取之有道，转载务必注明出处！</h2></li>
<li><h2 id="文件较大，加载可能比较费时，请耐心等待！"><a href="#文件较大，加载可能比较费时，请耐心等待！" class="headerlink" title="文件较大，加载可能比较费时，请耐心等待！"></a>文件较大，加载可能比较费时，请耐心等待！</h2></li>
<li><h2 id="若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！"><a href="#若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！" class="headerlink" title="若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！"></a>若多次刷新后点击链接仍不能查看，请通过关于处的邮箱联系我！</h2></li>
</ul>
]]></content>
      <categories>
        <category>知识共享</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之基础知识</title>
    <url>/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>本节介绍了MATLAB学习的一些基础知识，包括数值类型、矩阵的创建以及相关运算、字符串处理等。</p>
<span id="more"></span>
<h1 id="MATLAB数据类型"><a href="#MATLAB数据类型" class="headerlink" title="MATLAB数据类型"></a>MATLAB数据类型</h1><ul>
<li><p>MATLAB中数值数据默认double类型</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109122902166.png" alt="image-20221109122902166" style="zoom: 67%;"></p>
</li>
<li><p>single()函数：将其他类型的数据转化为单精度型</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109123220743.png" alt="image-20221109123220743" style="zoom: 67%;"></p>
</li>
<li><p>double()函数：将其他类型的数据转化为双精度型</p>
</li>
<li><p>复数类型：</p>
<ul>
<li><p>实部和虚部默认为双精度型</p>
</li>
<li><p>虚数单位用i或j来表示</p>
</li>
<li><p>real函数：求复数的实部</p>
</li>
<li><p>imag函数：求复数的虚部</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h1><ul>
<li><p>三角函数：有以弧度为单位的函数和以角度为单位的函数，如果是以角度为单位的函数就在函数名后面加“d”</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109141448904.png" alt="image-20221109141448904" style="zoom:50%;"></p>
</li>
<li><p>abs函数可以求实数的绝对值、复数的模、字符串的ASCII码值</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109141745974.png" alt="image-20221109141745974" style="zoom:50%;"></p>
</li>
<li><p><strong>用于取整的函数有fix、floor、ceil、round</strong></p>
<ul>
<li>round函数按照四舍五入的规则取整</li>
<li>ceil函数是向上取整，取大于等于这个数的第一个整数</li>
<li>floor函数是向下取整，取小于等于这个数的第一个整数</li>
<li>fix函数是舍去小数取整</li>
</ul>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109142322591.png" alt="image-20221109142322591" style="zoom:50%;"></p>
</li>
<li><p>isprime()函数判断是否为素数：若是则返回1，否则返回0</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109142852414.png" alt="image-20221109142852414" style="zoom:50%;"></p>
</li>
<li><p>perms()函数可以用来计算全排列</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221120125607598.png" alt="image-20221120125607598" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="内存变量文件"><a href="#内存变量文件" class="headerlink" title="内存变量文件"></a>内存变量文件</h1><ul>
<li><p>save命令：创建内存变量文件</p>
</li>
<li><p>load命令：装入内存变量文件</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">save mydata a x</span><br><span class="line">load mydata</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="MATLAB矩阵的表示"><a href="#MATLAB矩阵的表示" class="headerlink" title="MATLAB矩阵的表示"></a>MATLAB矩阵的表示</h1><h2 id="1-基本矩阵的建立"><a href="#1-基本矩阵的建立" class="headerlink" title="1.基本矩阵的建立"></a>1.基本矩阵的建立</h2><ul>
<li><p><strong>利用直接输入法建立矩阵</strong>：将矩阵的元素用<strong>中括号</strong>括起来，按矩阵行的顺序输入各元素，同一行的各元素之间<strong>用逗号或空格</strong>分隔，不同行的元素之间用<strong>分号</strong>分隔</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109144556051.png" alt="image-20221109144556051" style="zoom:50%;"></p>
</li>
<li><p><strong>利用已建好的矩阵建立更大的矩阵</strong>：一个大矩阵可以由已经建立好的小矩阵拼接而成</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109144914092.png" alt="image-20221109144914092" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-行向量的建立"><a href="#2-行向量的建立" class="headerlink" title="2.行向量的建立"></a>2.行向量的建立</h2><ul>
<li><p>使用冒号表达式</p>
<ul>
<li>格式：e1:e2:e3</li>
<li>其中，<strong>e1为初始值，e2为步长，e3为终止值</strong></li>
<li>如果省略步长e2，则步长为1</li>
</ul>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109145523588.png" alt="image-20221109145523588" style="zoom:50%;"></p>
</li>
<li><p>使用linspace()函数</p>
<ul>
<li><code>linspace(a,b,n)</code></li>
<li>其中，a为第一个元素，b为最后一个元素，n为元素总个数</li>
</ul>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109145746394.png" alt="image-20221109145746394" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="3-结构矩阵的建立"><a href="#3-结构矩阵的建立" class="headerlink" title="3.结构矩阵的建立"></a>3.结构矩阵的建立</h2><ul>
<li><p>结构矩阵.成员名=表达式</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109150859310.png" alt="image-20221109150859310"></p>
<p>结果如下：</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109150953705.png" alt="image-20221109150953705" style="zoom: 67%;"></p>
</li>
</ul>
<h2 id="4-单元矩阵的建立"><a href="#4-单元矩阵的建立" class="headerlink" title="4.单元矩阵的建立"></a>4.单元矩阵的建立</h2><ul>
<li><p>建立单元矩阵和基本矩阵相似，只是单元矩阵元素用<strong>大括号</strong>括起来</p>
</li>
<li><p>其允许输入不同数据类型的数据</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109151403981.png" alt="image-20221109151403981" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="矩阵元素的引用"><a href="#矩阵元素的引用" class="headerlink" title="矩阵元素的引用"></a>矩阵元素的引用</h1><ul>
<li><p>通过下标来引用矩阵的元素，若下标超过矩阵大小，将用0填充</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109152801772.png" alt="image-20221109152801772" style="zoom:50%;"></p>
</li>
<li><p>通过序号来引用：矩阵中的元素按列存储</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109153206104.png" alt="image-20221109153206104" style="zoom:50%;"></p>
</li>
<li><p><strong>矩阵元素的删除</strong>：通过对元素赋予[]从而删除元素</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109154021265.png" alt="image-20221109154021265" style="zoom:50%;"></p>
</li>
<li><p><strong>改变矩阵的形状</strong>：<code>reshape(A,m,n)</code>，在矩阵总元素保持不变得前提下，将矩阵A重新排成m×n的二维矩阵</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109155627818.png" alt="image-20221109155627818" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="MATLAB基本运算"><a href="#MATLAB基本运算" class="headerlink" title="MATLAB基本运算"></a>MATLAB基本运算</h1><ul>
<li><p>除法运算</p>
<ul>
<li>B/A等效于B*inv(A)</li>
<li>A\B等效于inv(A)*B</li>
</ul>
</li>
<li><p>乘法运算与点乘运算</p>
<ul>
<li><p>*表示矩阵相乘</p>
</li>
<li><p>.*表示两个矩阵中对应元素相乘</p>
</li>
</ul>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109162421397.png" alt="image-20221109162421397" style="zoom:50%;"></p>
</li>
<li><p>逻辑运算符：&amp;、|、~</p>
</li>
<li><p>实例：水仙花数是指各位数字的立方之和等于该数本身的三位正整数，求全部水仙花数</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109163246893.png" alt="image-20221109163246893" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><h2 id="1-字符串的表示"><a href="#1-字符串的表示" class="headerlink" title="1.字符串的表示"></a>1.字符串的表示</h2><ul>
<li><p>在MATLAB中，字符串是用单引号括起来的字符序列</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109164858570.png" alt="image-20221109164858570" style="zoom:50%;"></p>
</li>
<li><p>若字符串中的字符含有单引号，则该单引号字符要用两个单引号来表示</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109165035761.png" alt="image-20221109165035761" style="zoom:50%;"></p>
</li>
<li><p>建立多行字符串，形成字符串矩阵</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109165516169.png" alt="image-20221109165516169" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-字符串的操作"><a href="#2-字符串的操作" class="headerlink" title="2.字符串的操作"></a>2.字符串的操作</h2><ul>
<li><p><code>eval(s)</code> %表示执行字符串中的内容</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109165804919.png" alt="image-20221109165804919" style="zoom:50%;"></p>
</li>
<li><p>字符串与数值之间的转换</p>
<ul>
<li><code>abs</code>与<code>double</code>函数都可以用来获取字符串矩阵所对应的ASCII码数值矩阵</li>
<li><code>char</code>函数可以把ASCII码矩阵转化为字符串矩阵</li>
</ul>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109170131759.png" alt="image-20221109170131759" style="zoom:50%;"></p>
</li>
<li><p>字符串的比较</p>
<ul>
<li><p>关系运算符比较：两个字符串中的元素分别比较</p>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109170323450.png" alt="image-20221109170323450" style="zoom:50%;"></p>
</li>
<li><p>字符串比较函数</p>
<ul>
<li><code>strcmp(s1,s2)</code>：用来比较字符串s1和s2是否相等，如果相等，返回结果1，否则返回0</li>
<li><code>strcmpn(s1,s2,n)</code>：用来比较字符串s1和s2中前n个字符串是否相等，如果相等，返回结果1，否则返回0</li>
<li><code>strcmpi(s1,s2)</code>：在忽略字母大小写前提下，比较字符串s1和s2是否相等，如果相等，返回结果1，否则返回0</li>
<li><code>strcmpi(s1,s2)</code>：在忽略字母大小写前提下，比较字符串s1和s2中前n个字符串是否相等，如果相等，返回结果1，否则返回0     </li>
</ul>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109172205320.png" alt="image-20221109172205320" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>字符串的查找与替换</p>
<ul>
<li><code>findstr(s1,s2)</code>：返回短字符串在长字符串中的开始位置</li>
<li><code>strrep(s1,s2,s3)</code>：将字符串s1中的所有子字符串s2替换为字符串s3</li>
</ul>
<p><img src="/2022/11/09/MATLAB%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221109172940944.png" alt="image-20221109172940944" style="zoom:50%;"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow实践之人工神经网路</title>
    <url>/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本节从单层神经网络到多层神经网络，一步步介绍了神经网络的基本结构与简单实现，并借助TensorFlow框架中提供的Sequential模型，快速进行神经网络的搭建与训练。</p>
<span id="more"></span>
<h1 id="单层神经网络的实现"><a href="#单层神经网络的实现" class="headerlink" title="单层神经网络的实现"></a>单层神经网络的实现</h1><h2 id="1-单层神经网络的设计"><a href="#1-单层神经网络的设计" class="headerlink" title="1.单层神经网络的设计"></a>1.单层神经网络的设计</h2><ul>
<li>神经网络的结构：单层前馈型神经网络</li>
<li>激活函数：softmax函数</li>
<li>损失函数：交叉熵损失函数</li>
</ul>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107100009490.png" alt="image-20221107100009490"></p>
<h2 id="2-单层神经网络实现的相关函数"><a href="#2-单层神经网络实现的相关函数" class="headerlink" title="2.单层神经网络实现的相关函数"></a>2.单层神经网络实现的相关函数</h2><ul>
<li><h3 id="softmax函数：tf-nn-softmax"><a href="#softmax函数：tf-nn-softmax" class="headerlink" title="softmax函数：tf.nn.softmax()"></a>softmax函数：<code>tf.nn.softmax()</code></h3><ul>
<li>tf.nn.softmax(tf.matmul(X_train,W)+B)</li>
</ul>
</li>
<li><h3 id="独热编码：tf-one-hot-indices-depth"><a href="#独热编码：tf-one-hot-indices-depth" class="headerlink" title="独热编码：tf.one_hot(indices,depth)"></a>独热编码：<code>tf.one_hot(indices,depth)</code></h3><ul>
<li>tf.one_hot(tf.constant(y_test,dtype=tf.int32),3)</li>
</ul>
</li>
<li><h3 id="交叉熵损失函数：tf-keras-losses-categorical-crossentropy-y-true-y-pred"><a href="#交叉熵损失函数：tf-keras-losses-categorical-crossentropy-y-true-y-pred" class="headerlink" title="交叉熵损失函数：tf.keras.losses.categorical_crossentropy(y_true,y_pred)"></a>交叉熵损失函数：<code>tf.keras.losses.categorical_crossentropy(y_true,y_pred)</code></h3><ul>
<li>y_true表示为独热编码的标签值</li>
<li>y_pred为softmax函数的输出</li>
<li>其返回的是每个样本的交叉熵损失</li>
<li>则平均交叉熵损失为：tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true=Y_train,y_pred=PRED_train))</li>
</ul>
</li>
</ul>
<h2 id="3-单层神经网络的代码实现"><a href="#3-单层神经网络的代码实现" class="headerlink" title="3.单层神经网络的代码实现"></a>3.单层神经网络的代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.导入库，加载数据</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#2.下载鸢尾花数据集iris</span></span><br><span class="line"><span class="comment">#训练集</span></span><br><span class="line">TRAIN_URL = <span class="string">&quot;http://download.tensorflow.org/data/iris_training.csv&quot;</span></span><br><span class="line">train_path = tf.keras.utils.get_file(<span class="string">&quot;iris_train.csv&quot;</span>,TRAIN_URL,cache_dir=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\TensorFlow&quot;</span>)</span><br><span class="line"><span class="comment">#测试集</span></span><br><span class="line">TRAIN_URL = <span class="string">&quot;http://download.tensorflow.org/data/iris_test.csv&quot;</span></span><br><span class="line">test_path = tf.keras.utils.get_file(<span class="string">&quot;iris_test.csv&quot;</span>,TRAIN_URL,cache_dir=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\TensorFlow&quot;</span>)</span><br><span class="line">df_iris_train=pd.read_csv(train_path,header=<span class="number">0</span>)</span><br><span class="line">df_iris_test=pd.read_csv(test_path,header=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#3.处理数据</span></span><br><span class="line"><span class="comment">#转化为numpy数组</span></span><br><span class="line">iris_train=np.array(df_iris_train)</span><br><span class="line">iris_test=np.array(df_iris_test)</span><br><span class="line"><span class="comment">#取出属性</span></span><br><span class="line">x_train=iris_train[:,<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">x_test=iris_test[:,<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="comment">#取出标签</span></span><br><span class="line">y_train=iris_train[:,<span class="number">4</span>]</span><br><span class="line">y_test=iris_test[:,<span class="number">4</span>]</span><br><span class="line"><span class="comment">#对属性值进行标准化处理</span></span><br><span class="line">x_train=x_train-np.mean(x_train,axis=<span class="number">0</span>)<span class="comment">#x_train为120*4</span></span><br><span class="line">x_test=x_test-np.mean(x_test,axis=<span class="number">0</span>)<span class="comment">#x_test为30*4</span></span><br><span class="line"><span class="comment">#生成标签的独热编码</span></span><br><span class="line">X_train=tf.cast(x_train,tf.float32)</span><br><span class="line">Y_train=tf.one_hot(tf.constant(y_train,dtype=tf.int32),<span class="number">3</span>)<span class="comment">#Y_train为120*3</span></span><br><span class="line">X_test=tf.cast(x_test,tf.float32)</span><br><span class="line">Y_test=tf.one_hot(tf.constant(y_test,dtype=tf.int32),<span class="number">3</span>)<span class="comment">#Y_test为30*3</span></span><br><span class="line"><span class="comment">#3.设置超参数学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.5</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">50</span></span><br><span class="line">display_step=<span class="number">10</span> <span class="comment">#设置每十次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#4.设置模型参数初值W、B</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">W=tf.Variable(np.random.randn(<span class="number">4</span>,<span class="number">3</span>),dtype=tf.float32)</span><br><span class="line">B=tf.Variable(np.zeros([<span class="number">3</span>]),dtype=tf.float32)</span><br><span class="line"><span class="comment">#5.训练模型</span></span><br><span class="line">ce_train=[]<span class="comment">#用来存放训练集的交叉熵损失</span></span><br><span class="line">acc_train=[]<span class="comment">#用来存放训练集的准确率</span></span><br><span class="line">ce_test=[]<span class="comment">#用来存放测试集的交叉熵损失</span></span><br><span class="line">acc_test=[]<span class="comment">#用来存放测试集的准确率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        PRED_train=tf.nn.softmax(tf.matmul(X_train,W)+B)<span class="comment">#PRED_train是120*3的矩阵</span></span><br><span class="line">        Loss_train=tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true=Y_train,y_pred=PRED_train))</span><br><span class="line">    PRED_test=tf.nn.softmax(tf.matmul(X_test,W)+B)</span><br><span class="line">    Loss_test=tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true=Y_test,y_pred=PRED_test))</span><br><span class="line">    Accuracy_train=tf.reduce_mean(tf.cast(tf.equal(tf.argmax(PRED_train.numpy(),axis=<span class="number">1</span>),y_train),tf.float32))</span><br><span class="line">    Accuracy_test=tf.reduce_mean(tf.cast(tf.equal(tf.argmax(PRED_test.numpy(),axis=<span class="number">1</span>),y_test),tf.float32))</span><br><span class="line">    ce_train.append(Loss_train)</span><br><span class="line">    acc_train.append(Accuracy_train)</span><br><span class="line">    ce_test.append(Loss_test)</span><br><span class="line">    acc_test.append(Accuracy_test)</span><br><span class="line">    dL_dW,dL_dB=tape.gradient(Loss_train,[W,B])</span><br><span class="line">    W.assign_sub(learn_rate*dL_dW)</span><br><span class="line">    B.assign_sub(learn_rate*dL_dB)</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i:%i\tTrain Acc:%f\tTrain Loss:%f,\tTest Acc:%f\tTest Loss:%f&quot;</span>%(i,Accuracy_train,Loss_train,Accuracy_test,Loss_test))</span><br><span class="line"><span class="comment">#6.结果可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.plot(ce_train,color=<span class="string">&quot;blue&quot;</span>,label=<span class="string">&quot;Train Loss&quot;</span>)</span><br><span class="line">plt.plot(ce_test,color=<span class="string">&quot;green&quot;</span>,label=<span class="string">&quot;test Loss&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.plot(acc_train,color=<span class="string">&quot;blue&quot;</span>,label=<span class="string">&quot;Train acc&quot;</span>)</span><br><span class="line">plt.plot(acc_test,color=<span class="string">&quot;green&quot;</span>,label=<span class="string">&quot;test acc&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Accuracy&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i:0    Train Acc:0.333333    Train Loss:2.066978,    Test Acc:0.266667    Test Loss:1.880856
i:10    Train Acc:0.875000    Train Loss:0.339410,    Test Acc:0.866667    Test Loss:0.461705
i:20    Train Acc:0.875000    Train Loss:0.279647,    Test Acc:0.866667    Test Loss:0.368414
i:30    Train Acc:0.916667    Train Loss:0.245924,    Test Acc:0.933333    Test Loss:0.314814
i:40    Train Acc:0.933333    Train Loss:0.222922,    Test Acc:0.933333    Test Loss:0.278643
i:50    Train Acc:0.933333    Train Loss:0.205636,    Test Acc:0.966667    Test Loss:0.251937
</code></pre><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_7_1.png" alt="output_7_1"></p>
<hr>
<h1 id="多层神经网络"><a href="#多层神经网络" class="headerlink" title="多层神经网络"></a>多层神经网络</h1><ul>
<li>具有隐含层的神经网络称为多层神经网络</li>
</ul>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107101251196.png" alt="image-20221107101251196" style="zoom: 25%;"></p>
<h2 id="1-线性分类器"><a href="#1-线性分类器" class="headerlink" title="1.线性分类器"></a>1.线性分类器</h2><ul>
<li>与运算</li>
<li>或运算</li>
<li>非运算</li>
<li>对感知机（二分类的线性分类模型）给定一个合适的权值向量即可实现运算</li>
</ul>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107101405138.png" alt="image-20221107101405138" style="zoom:33%;"></p>
<h2 id="2-通过实现异或运算进而理解多层神经网络"><a href="#2-通过实现异或运算进而理解多层神经网络" class="headerlink" title="2.通过实现异或运算进而理解多层神经网络"></a>2.通过实现异或运算进而理解多层神经网络</h2><ul>
<li>隐藏层由与运算与或非运算两个感知机组成</li>
<li>这两个感知机的输出作为下一层神经元的输入</li>
<li>增加的这一层权值（W）和阈值（B）与前一层的第二个感知机一样，则也是实现了或非运算</li>
<li>红圈为有计算能力的神经元</li>
<li>一个感知机对应一根直线</li>
</ul>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107101503565.png" alt="image-20221107101503565" style="zoom: 50%;"></p>
<h2 id="3-线性不可分数据集的分类思路"><a href="#3-线性不可分数据集的分类思路" class="headerlink" title="3.线性不可分数据集的分类思路"></a>3.线性不可分数据集的分类思路</h2><ul>
<li>弯曲的直线可以看成是多条直线的线性组合</li>
<li>其中的每一条直线可以用一个感知机来实现<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107101620753.png" alt="image-20221107101620753" style="zoom: 33%;"></li>
<li>如果神经网络中有足够的隐藏层，每个隐藏层中有足够多的神经元，神经网络就可以表示任意复杂的函数或空间分布<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107101758824.png" alt="image-20221107101758824" style="zoom:33%;"><br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107101832691.png" alt="image-20221107101832691" style="zoom:33%;"></li>
<li><strong>多隐含层神经网络：能够表示非连续的函数或空间区域，减小泛化误差，减小每层神经元的数量</strong></li>
</ul>
<h2 id="4-前馈神经网络（Feedforward-Neural-Network）"><a href="#4-前馈神经网络（Feedforward-Neural-Network）" class="headerlink" title="4.前馈神经网络（Feedforward Neural Network）"></a>4.前馈神经网络（Feedforward Neural Network）</h2><ul>
<li>每层神经元只与前一层的神经元相连</li>
<li>处于同一层的神经元之间没有连接</li>
<li>各层间没有反馈，不存在跨层连接<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102034190.png" alt="image-20221107102034190" style="zoom: 50%;"></li>
<li><strong>万能近似定理：在前馈型神经网络中，只要有一个隐含层，并且这个隐含层中有足够多的神经元，就可以逼近任意一个连续的函数或空间分布</strong></li>
</ul>
<h2 id="5-全连接网络（Full-Connected-Network）"><a href="#5-全连接网络（Full-Connected-Network）" class="headerlink" title="5.全连接网络（Full Connected Network）"></a>5.全连接网络（Full Connected Network）</h2><ul>
<li>每一层中的任何一个节点都与其后面一层的所有节点连接<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102143789.png" alt="image-20221107102143789" style="zoom:50%;"></li>
<li>第n层中的每个节点接收来自第n-1层中所有节点的输入<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102222409.png" alt="image-20221107102222409" style="zoom:50%;"></li>
</ul>
<h2 id="6-超参数与验证集"><a href="#6-超参数与验证集" class="headerlink" title="6.超参数与验证集"></a>6.超参数与验证集</h2><ul>
<li>训练集：训练模型，确定模型参数</li>
<li>验证集：确定超参数</li>
<li>测试集：评估模型的泛化能力</li>
</ul>
<hr>
<h1 id="误差反向传播算法"><a href="#误差反向传播算法" class="headerlink" title="误差反向传播算法"></a>误差反向传播算法</h1><ul>
<li>通过误差反向传播法计算梯度<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102259737.png" alt="image-20221107102259737" style="zoom: 50%;"></li>
<li>先计算输出层对误差的梯度，进而更新输出层的权值<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102350316.png" alt="image-20221107102350316" style="zoom: 33%;"></li>
<li>再计算隐藏层对误差的梯度，进而更新隐藏层的权值<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102420550.png" alt="image-20221107102420550" style="zoom: 25%;"></li>
<li>输出端有多个神经元的误差反向传播<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102503633.png" alt="image-20221107102503633" style="zoom:33%;"></li>
</ul>
<hr>
<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><h2 id="1-激活函数的性质"><a href="#1-激活函数的性质" class="headerlink" title="1.激活函数的性质"></a>1.激活函数的性质</h2><ul>
<li>简单的非线性函数</li>
<li>连续并可导</li>
<li>单调函数<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102618782.png" alt="image-20221107102618782" style="zoom:25%;"></li>
</ul>
<h2 id="2-常用的激活函数"><a href="#2-常用的激活函数" class="headerlink" title="2.常用的激活函数"></a>2.常用的激活函数</h2><ul>
<li>logistic函数与Tanh函数<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102808313.png" alt="image-20221107102808313" style="zoom: 33%;"></li>
<li>ReLU函数（Rectified Linear Unit，修正线性单元）<ul>
<li>z&gt;0时，导数等于1，缓解了梯度消失问题</li>
<li>不存在幂运算，计算速度快</li>
<li>导数恒等于1，训练模型收敛速度快</li>
<li>输出不是以0为均值的</li>
<li>z<0时，梯度为0，神经元死亡 <img src="TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102905651.png" alt="image-20221107102905651" style="zoom:33%;"></0时，梯度为0，神经元死亡></li>
</ul>
</li>
<li>Leaky-ReLU函数<ul>
<li>避免了ReLU神经元死亡</li>
<li>神经网络的计算和训练速度快</li>
<li>超参数a需要人工调整<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107102942585.png" alt="image-20221107102942585" style="zoom: 25%;"></li>
</ul>
</li>
</ul>
<hr>
<h1 id="实例：多层神经网络实现鸢尾花分类"><a href="#实例：多层神经网络实现鸢尾花分类" class="headerlink" title="实例：多层神经网络实现鸢尾花分类"></a>实例：多层神经网络实现鸢尾花分类</h1><ul>
<li><p>思路：</p>
<ul>
<li>隐藏层激活函数：relu函数</li>
<li>输出层激活函数：softmax函数</li>
<li>损失函数：交叉熵损失函数</li>
<li>W是属性个数（前一层的输入神经元数）×分类数（本层的个数），B是关于分类数的一维向量</li>
</ul>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107103055953.png" alt="image-20221107103055953" style="zoom: 33%;"></p>
</li>
<li><p>具体代码实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.导入库，加载数据</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#2.下载鸢尾花数据集iris</span></span><br><span class="line"><span class="comment">#训练集</span></span><br><span class="line">TRAIN_URL = <span class="string">&quot;http://download.tensorflow.org/data/iris_training.csv&quot;</span></span><br><span class="line">train_path = tf.keras.utils.get_file(<span class="string">&quot;iris_train.csv&quot;</span>,TRAIN_URL,cache_dir=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\TensorFlow&quot;</span>)</span><br><span class="line"><span class="comment">#测试集</span></span><br><span class="line">TRAIN_URL = <span class="string">&quot;http://download.tensorflow.org/data/iris_test.csv&quot;</span></span><br><span class="line">test_path = tf.keras.utils.get_file(<span class="string">&quot;iris_test.csv&quot;</span>,TRAIN_URL,cache_dir=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\TensorFlow&quot;</span>)</span><br><span class="line">df_iris_train=pd.read_csv(train_path,header=<span class="number">0</span>)</span><br><span class="line">df_iris_test=pd.read_csv(test_path,header=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#3.处理数据</span></span><br><span class="line"><span class="comment">#转化为numpy数组</span></span><br><span class="line">iris_train=np.array(df_iris_train)</span><br><span class="line">iris_test=np.array(df_iris_test)</span><br><span class="line"><span class="comment">#取出属性</span></span><br><span class="line">x_train=iris_train[:,<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">x_test=iris_test[:,<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="comment">#取出标签</span></span><br><span class="line">y_train=iris_train[:,<span class="number">4</span>]</span><br><span class="line">y_test=iris_test[:,<span class="number">4</span>]</span><br><span class="line"><span class="comment">#对属性值进行标准化处理</span></span><br><span class="line">x_train=x_train-np.mean(x_train,axis=<span class="number">0</span>)<span class="comment">#x_train为120*4</span></span><br><span class="line">x_test=x_test-np.mean(x_test,axis=<span class="number">0</span>)<span class="comment">#x_test为30*4</span></span><br><span class="line"><span class="comment">#生成标签的独热编码</span></span><br><span class="line">X_train=tf.cast(x_train,tf.float32)</span><br><span class="line">Y_train=tf.one_hot(tf.constant(y_train,dtype=tf.int32),<span class="number">3</span>)<span class="comment">#Y_train为120*3</span></span><br><span class="line">X_test=tf.cast(x_test,tf.float32)</span><br><span class="line">Y_test=tf.one_hot(tf.constant(y_test,dtype=tf.int32),<span class="number">3</span>)<span class="comment">#Y_test为130*3</span></span><br><span class="line"><span class="comment">#4.设置超参数学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.5</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">50</span></span><br><span class="line">display_step=<span class="number">10</span> <span class="comment">#设置每十次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#5.设置模型参数初值W1、B1,W2、B2（重点在此）</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">W1=tf.Variable(np.random.randn(<span class="number">4</span>,<span class="number">16</span>),dtype=tf.float32)</span><br><span class="line">B1=tf.Variable(np.zeros([<span class="number">16</span>]),dtype=tf.float32)</span><br><span class="line">W2=tf.Variable(np.random.randn(<span class="number">16</span>,<span class="number">3</span>),dtype=tf.float32)</span><br><span class="line">B2=tf.Variable(np.zeros([<span class="number">3</span>]),dtype=tf.float32)</span><br><span class="line"><span class="comment">#6.定义梯度带并构造神经网络模型</span></span><br><span class="line">ce_train=[]<span class="comment">#用来存放训练集的交叉熵损失</span></span><br><span class="line">acc_train=[]<span class="comment">#用来存放训练集的准确率</span></span><br><span class="line">ce_test=[]<span class="comment">#用来存放测试集的交叉熵损失</span></span><br><span class="line">acc_test=[]<span class="comment">#用来存放测试集的准确率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:<span class="comment">#（重点在此）</span></span><br><span class="line">        Hidden_train=tf.nn.relu(tf.matmul(X_train,W1)+B1)</span><br><span class="line">        PRED_train=tf.nn.softmax(tf.matmul(Hidden_train,W2)+B2)<span class="comment">#PRED_train是120*3的矩阵</span></span><br><span class="line">        Loss_train=tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true=Y_train,y_pred=PRED_train))</span><br><span class="line">    Hidden_test=tf.nn.relu(tf.matmul(X_test,W1)+B1)</span><br><span class="line">    PRED_test=tf.nn.softmax(tf.matmul(Hidden_test,W2)+B2)</span><br><span class="line">    Loss_test=tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true=Y_test,y_pred=PRED_test))</span><br><span class="line">    </span><br><span class="line">    Accuracy_train=tf.reduce_mean(tf.cast(tf.equal(tf.argmax(PRED_train.numpy(),axis=<span class="number">1</span>),y_train),tf.float32))</span><br><span class="line">    Accuracy_test=tf.reduce_mean(tf.cast(tf.equal(tf.argmax(PRED_test.numpy(),axis=<span class="number">1</span>),y_test),tf.float32))</span><br><span class="line">    </span><br><span class="line">    ce_train.append(Loss_train)</span><br><span class="line">    acc_train.append(Accuracy_train)</span><br><span class="line">    ce_test.append(Loss_test)</span><br><span class="line">    acc_test.append(Accuracy_test)</span><br><span class="line">    </span><br><span class="line">    grads=tape.gradient(Loss_train,[W1,B1,W2,B2])</span><br><span class="line">    W1.assign_sub(learn_rate*grads[<span class="number">0</span>])</span><br><span class="line">    B1.assign_sub(learn_rate*grads[<span class="number">1</span>])</span><br><span class="line">    W2.assign_sub(learn_rate*grads[<span class="number">2</span>])</span><br><span class="line">    B2.assign_sub(learn_rate*grads[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i:%i\tTrain Acc:%f\tTrain Loss:%f,\tTest Acc:%f\tTest Loss:%f&quot;</span>%(i,Accuracy_train,Loss_train,Accuracy_test,Loss_test))</span><br><span class="line"><span class="comment">#7.结果可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.plot(ce_train,color=<span class="string">&quot;blue&quot;</span>,label=<span class="string">&quot;Train Loss&quot;</span>)</span><br><span class="line">plt.plot(ce_test,color=<span class="string">&quot;green&quot;</span>,label=<span class="string">&quot;test Loss&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.plot(acc_train,color=<span class="string">&quot;blue&quot;</span>,label=<span class="string">&quot;Train acc&quot;</span>)</span><br><span class="line">plt.plot(acc_test,color=<span class="string">&quot;green&quot;</span>,label=<span class="string">&quot;test acc&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Accuracy&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i:0    Train Acc:0.433333    Train Loss:2.205641,    Test Acc:0.400000    Test Loss:1.721138
i:10    Train Acc:0.941667    Train Loss:0.205314,    Test Acc:0.966667    Test Loss:0.249661
i:20    Train Acc:0.950000    Train Loss:0.149540,    Test Acc:1.000000    Test Loss:0.167103
i:30    Train Acc:0.958333    Train Loss:0.122346,    Test Acc:1.000000    Test Loss:0.124693
i:40    Train Acc:0.958333    Train Loss:0.105099,    Test Acc:1.000000    Test Loss:0.099869
i:50    Train Acc:0.958333    Train Loss:0.092934,    Test Acc:1.000000    Test Loss:0.084885
</code></pre><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_20_1.png" alt="output_20_1"></p>
<hr>
<h1 id="小批量梯度下降法"><a href="#小批量梯度下降法" class="headerlink" title="小批量梯度下降法"></a>小批量梯度下降法</h1><ul>
<li>对于多层神经网络，使用梯度下降法，从理论上无法保证一定可以达到最小值</li>
<li>使用小批量梯度下降法对其进行改进</li>
<li>影响小批量梯度下降法的主要因素：<ul>
<li>小批量样本的选择：打乱样本</li>
<li>批量大小：选择2的幂数，如32、64、128、……</li>
<li>学习率</li>
<li>梯度</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Sequential模型"><a href="#Sequential模型" class="headerlink" title="Sequential模型"></a>Sequential模型</h1><ul>
<li>其是一个神经网络框架</li>
<li>只有一组输入和一组输出</li>
<li>各层按照先后顺序堆叠</li>
</ul>
<h2 id="1-建立Sequential模型"><a href="#1-建立Sequential模型" class="headerlink" title="1.建立Sequential模型"></a>1.建立Sequential模型</h2><ul>
<li><code>model=tf.keras.Sequential()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">model=tf.keras.Sequential()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>&lt;tensorflow.python.keras.engine.sequential.Sequential object at 0x0000014AC0B9FD90&gt;
</code></pre><h3 id="1-1-添加全连接层"><a href="#1-1-添加全连接层" class="headerlink" title="1.1 添加全连接层"></a>1.1 添加全连接层</h3><ul>
<li><code>model.add(tf.keras.layers)</code></li>
<li><code>tf.keras.layers.Dense(inputs,activation,input_shape)</code><ul>
<li>inputs: 本层神经元的个数</li>
<li>activation: 激活函数(“relu”、”softmax”、”sigmoid”、”tanh”</li>
<li>input_shape: 输入数据的形状</li>
</ul>
</li>
<li>示例：<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107103755860.png" alt="image-20221107103755860" style="zoom:33%;"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">model=tf.keras.Sequential()</span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">8</span>,activation=<span class="string">&quot;relu&quot;</span>,input_shape=(<span class="number">4</span>,)))</span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">4</span>,activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">3</span>,activation=<span class="string">&quot;softmax&quot;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="1-2-查看摘要"><a href="#1-2-查看摘要" class="headerlink" title="1.2 查看摘要"></a>1.2 查看摘要</h3><ul>
<li><code>model.summary()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>Model: &quot;sequential_8&quot;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
dense_15 (Dense)             (None, 8)                 40        
_________________________________________________________________
dense_16 (Dense)             (None, 4)                 36        
_________________________________________________________________
dense_17 (Dense)             (None, 3)                 15        
=================================================================
Total params: 91
Trainable params: 91
Non-trainable params: 0
_________________________________________________________________
</code></pre><h2 id="2-配置训练方法"><a href="#2-配置训练方法" class="headerlink" title="2.配置训练方法"></a>2.配置训练方法</h2><ul>
<li><code>model.compile(loss,optimizer,metrics)</code></li>
</ul>
<h3 id="2-1-常用的损失函数loss"><a href="#2-1-常用的损失函数loss" class="headerlink" title="2.1 常用的损失函数loss"></a>2.1 常用的损失函数loss</h3><ul>
<li>对于多分类交叉熵损失函数<ul>
<li>当标签的编码为独热编码时，采用”categorical_crossentropy”</li>
<li>当标签的编码为自然顺序码时，采用”sparse_categorical_crossentropy”</li>
<li>from_logits=False表示神经网络在输出前，已经使用softmax函数将预测结果变成了概率分布，否则设置为True<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107104412770.png" alt="image-20221107104412770" style="zoom: 33%;"></li>
</ul>
</li>
</ul>
<h3 id="2-2-优化器optimizer"><a href="#2-2-优化器optimizer" class="headerlink" title="2.2 优化器optimizer"></a>2.2 优化器optimizer</h3><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107104453525.png" alt="image-20221107104453525" style="zoom: 25%;"></p>
<h3 id="2-3-评估函数metrics"><a href="#2-3-评估函数metrics" class="headerlink" title="2.3 评估函数metrics"></a>2.3 评估函数metrics</h3><ul>
<li>keras模型性能评估函数<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107104601631.png" alt="image-20221107104601631" style="zoom:50%;"></li>
<li>可以使用model.metrics_names查看评估函数</li>
</ul>
<h2 id="3-训练模型"><a href="#3-训练模型" class="headerlink" title="3.训练模型"></a>3.训练模型</h2><ul>
<li><code>model.fit()</code><ul>
<li>validation_data与validation_split二选一</li>
<li>validation_freq：每隔多少次训练，使用测试集计算并输出一次评测指标</li>
<li>verbose:<ul>
<li>=0：不在标准输出流输出</li>
<li>=1：输出进度条记录</li>
<li>=2：每个epoch输出一行记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107104731779.png" alt="image-20221107104731779" style="zoom:33%;"></p>
<ul>
<li><p>model.fit()初始值</p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107104829486.png" alt="image-20221107104829486" style="zoom:33%;"></p>
</li>
<li><p><code>history=model.fit();history.history</code></p>
<ul>
<li>其以字典的形式分别返回训练集和测试集的损失和准确率</li>
</ul>
</li>
</ul>
<h2 id="4-评估模型"><a href="#4-评估模型" class="headerlink" title="4.评估模型"></a>4.评估模型</h2><ul>
<li><code>model.evaluate(test_set_x,test_set_y,batch_size,verbose)</code></li>
</ul>
<h2 id="5-使用模型"><a href="#5-使用模型" class="headerlink" title="5.使用模型"></a>5.使用模型</h2><ul>
<li><code>model.predict(x,batch_size,verbose) #x为数据的属性值</code></li>
</ul>
<h2 id="6-模型的保存与加载"><a href="#6-模型的保存与加载" class="headerlink" title="6.模型的保存与加载"></a>6.模型的保存与加载</h2><h3 id="仅保存神经网络的模型参数"><a href="#仅保存神经网络的模型参数" class="headerlink" title="仅保存神经网络的模型参数"></a>仅保存神经网络的模型参数</h3><ul>
<li>保存：<code>model.save_weights()</code>#相当于替代了model.fit()<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107104943429.png" alt="image-20221107104943429" style="zoom:33%;"></li>
<li>加载：<code>model.load_weights()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model2.save_weights(<span class="string">&quot;mnist_save_weights.h5&quot;</span>)</span><br><span class="line">model2.load_weights(<span class="string">&quot;mnist_save_weights.h5&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="保存整个模型"><a href="#保存整个模型" class="headerlink" title="保存整个模型"></a>保存整个模型</h3><ul>
<li><code>model.save()</code><br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107105022947.png" alt="image-20221107105022947" style="zoom:33%;"></li>
<li><code>tf.keras.models.load_model()</code></li>
</ul>
<hr>
<h1 id="实例：Sequential实现手写数字识别"><a href="#实例：Sequential实现手写数字识别" class="headerlink" title="实例：Sequential实现手写数字识别"></a>实例：Sequential实现手写数字识别</h1><h2 id="1-设计神经网络结构"><a href="#1-设计神经网络结构" class="headerlink" title="1.设计神经网络结构"></a>1.设计神经网络结构</h2><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107105108812.png" alt="image-20221107105108812"></p>
<h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.导入库</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#2.加载数据</span></span><br><span class="line">mnist=tf.keras.datasets.mnist</span><br><span class="line">(train_x,train_y),(test_x,test_y)=mnist.load_data(path=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\image\mnist.npz&quot;</span>)</span><br><span class="line"><span class="comment">#3.数据预处理:对属性进行归一化并转化为Tensor张量</span></span><br><span class="line">X_train,X_test=tf.cast(train_x/<span class="number">255.0</span>,tf.float32),tf.cast(test_x/<span class="number">255.0</span>,tf.float32)</span><br><span class="line">y_train,y_test = tf.cast(train_y,tf.int16),tf.cast(test_y,tf.int16)</span><br><span class="line"><span class="comment">#4.建立模型</span></span><br><span class="line">model2=tf.keras.Sequential()</span><br><span class="line">model2.add(tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)))<span class="comment">#将输入的数据形状拉直</span></span><br><span class="line">model2.add(tf.keras.layers.Dense(<span class="number">128</span>,activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model2.add(tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&quot;softmax&quot;</span>))</span><br><span class="line">model2.summary()</span><br><span class="line"><span class="built_in">print</span>(<span class="number">80</span>*<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="comment">#5.配置训练方法</span></span><br><span class="line">model2.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;adam&quot;</span>,loss=<span class="string">&quot;sparse_categorical_crossentropy&quot;</span>,metrics=[<span class="string">&quot;sparse_categorical_accuracy&quot;</span>])</span><br><span class="line"><span class="comment">#6.训练模型</span></span><br><span class="line">model2.fit(X_train,y_train,batch_size=<span class="number">64</span>,epochs=<span class="number">5</span>,validation_split=<span class="number">0.2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">80</span>*<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="comment">#7.评估模型</span></span><br><span class="line">model2.evaluate(X_test,y_test,verbose=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">80</span>*<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="comment">#8.使用模型</span></span><br><span class="line"><span class="built_in">print</span>(model2.predict(tf.reshape(X_test[<span class="number">0</span>], (<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>))))</span><br><span class="line"><span class="built_in">print</span>(np.argmax(model2.predict(tf.reshape(X_test[<span class="number">0</span>], (<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)))))  </span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line"><span class="comment"># 下面取出测试集中的前4个数据进行识别</span></span><br><span class="line">y_pred = np.argmax(model2.predict(X_test[<span class="number">0</span>:<span class="number">4</span>]), axis=<span class="number">1</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.suptitle(<span class="string">&quot;取出测试集中的前4个数据进行识别&quot;</span>, fontsize=<span class="number">20</span>, color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(test_x[i], cmap=<span class="string">&quot;gray&quot;</span>)  <span class="comment"># cmap=&quot;gray&quot;表示绘制的是灰度图</span></span><br><span class="line">    plt.title(<span class="string">&quot;y= &quot;</span>+<span class="built_in">str</span>(test_y[i]) + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;y_pred=&quot;</span> + <span class="built_in">str</span>(y_pred[i]))</span><br><span class="line">plt.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.98</span>])</span><br><span class="line"><span class="comment"># 下面再随机取出测试集中的任意4个数据进行识别</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.suptitle(<span class="string">&quot;随机取出测试集中的任意4个数据进行识别&quot;</span>, fontsize=<span class="number">20</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    num = np.random.randint(<span class="number">1</span>, <span class="number">10000</span>)</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(test_x[num], cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    y_pred = np.argmax(model2.predict(tf.reshape(X_test[num],(<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>))))</span><br><span class="line">    plt.title(<span class="string">&quot;y= &quot;</span>+<span class="built_in">str</span>(test_y[num]) + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;y_pred=&quot;</span> + <span class="built_in">str</span>(y_pred))</span><br><span class="line">plt.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.98</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>Model: &quot;sequential_3&quot;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
flatten_3 (Flatten)          (None, 784)               0         
_________________________________________________________________
dense_6 (Dense)              (None, 128)               100480    
_________________________________________________________________
dense_7 (Dense)              (None, 10)                1290      
=================================================================
Total params: 101,770
Trainable params: 101,770
Non-trainable params: 0
_________________________________________________________________
********************************************************************************
Epoch 1/5
750/750 [==============================] - 4s 4ms/step - loss: 0.3279 - sparse_categorical_accuracy: 0.9079 - val_loss: 0.1745 - val_sparse_categorical_accuracy: 0.9503
Epoch 2/5
750/750 [==============================] - 3s 4ms/step - loss: 0.1517 - sparse_categorical_accuracy: 0.9566 - val_loss: 0.1307 - val_sparse_categorical_accuracy: 0.9626
Epoch 3/5
750/750 [==============================] - 2s 2ms/step - loss: 0.1087 - sparse_categorical_accuracy: 0.9691 - val_loss: 0.1137 - val_sparse_categorical_accuracy: 0.9668
Epoch 4/5
750/750 [==============================] - 1s 1ms/step - loss: 0.0830 - sparse_categorical_accuracy: 0.9752 - val_loss: 0.1081 - val_sparse_categorical_accuracy: 0.9678
Epoch 5/5
750/750 [==============================] - 1s 2ms/step - loss: 0.0649 - sparse_categorical_accuracy: 0.9801 - val_loss: 0.1021 - val_sparse_categorical_accuracy: 0.9694
********************************************************************************
313/313 - 0s - loss: 0.0890 - sparse_categorical_accuracy: 0.9732
********************************************************************************
[[4.3734741e-07 4.9217494e-08 1.3537046e-04 1.3679784e-03 1.0147285e-09
  6.0127795e-06 8.5093779e-11 9.9846399e-01 5.7829629e-06 2.0411160e-05]]
7
</code></pre><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_43_1.png" alt="output_43_1"></p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_43_2.png" alt="output_43_2"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>TensorFlow</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow实践之典型的卷积神经网路</title>
    <url>/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本节主要介绍了LeNet、VGGNet、GoogLeNet神经网络。其中，对LeNet模型进行了函数封装，对VGGNet进行了基本介绍，并着重介绍了GoogLeNet神经网络中1×1卷积核的作用。</p>
<span id="more"></span>
<h1 id="LeNet神经网络"><a href="#LeNet神经网络" class="headerlink" title="LeNet神经网络"></a>LeNet神经网络</h1><h2 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h2><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107140234908.png" alt="image-20221107140234908"></p>
<h2 id="2-封装LeNet模型"><a href="#2-封装LeNet模型" class="headerlink" title="2.封装LeNet模型"></a>2.封装LeNet模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">LeNet</span>(<span class="params">input_shape,padding</span>):</span><br><span class="line">    model=tf.keras.Sequential()</span><br><span class="line">    <span class="comment">#添加卷积层1、池化层1</span></span><br><span class="line">    model.add(tf.keras.layers.Conv2D(<span class="number">6</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),padding=padding,activation=<span class="string">&quot;sigmoid&quot;</span>,input_shape=input_shape))</span><br><span class="line">    model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">    <span class="comment">#添加卷积层2、池化层2</span></span><br><span class="line">    model.add(tf.keras.layers.Conv2D(<span class="number">16</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),padding=<span class="string">&quot;valid&quot;</span>,activation=<span class="string">&quot;sigmoid&quot;</span>))</span><br><span class="line">    model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">    <span class="comment">#添加卷积层3</span></span><br><span class="line">    model.add(tf.keras.layers.Conv2D(<span class="number">120</span>,kernel_size=(<span class="number">5</span>,<span class="number">5</span>),padding=<span class="string">&quot;valid&quot;</span>,activation=<span class="string">&quot;sigmoid&quot;</span>))<span class="comment">#本层输出为形状为（1，1，120）</span></span><br><span class="line">    <span class="comment">#添加Flatten层，将数据拉直</span></span><br><span class="line">    model.add(tf.keras.layers.Flatten())</span><br><span class="line">    <span class="comment">#添加隐含层和输出层</span></span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">84</span>,activation=<span class="string">&quot;sigmoid&quot;</span>))</span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&quot;softmax&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"><span class="comment">#调用方法</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;model=LeNet((28,28,1),&quot;same&quot;)</span></span><br><span class="line"><span class="string">model=LeNet((32,32,1),&quot;valid&quot;)&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-实例：LeNet实现手写数字识别"><a href="#3-实例：LeNet实现手写数字识别" class="headerlink" title="3.实例：LeNet实现手写数字识别"></a>3.实例：LeNet实现手写数字识别</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.导入库</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#2.加载数据</span></span><br><span class="line">mnist=tf.keras.datasets.mnist</span><br><span class="line">(train_x,train_y),(test_x,test_y)=mnist.load_data(path=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\image\mnist.npz&quot;</span>)</span><br><span class="line"><span class="comment">#3.数据预处理:对属性进行归一化并转化为Tensor张量</span></span><br><span class="line">X_train,X_test=tf.cast(train_x/<span class="number">255.0</span>,tf.float32),tf.cast(test_x/<span class="number">255.0</span>,tf.float32)</span><br><span class="line">Y_train,Y_test=tf.cast(train_y,tf.int16),tf.cast(test_y,tf.int16)</span><br><span class="line">X_train=tf.reshape(X_train,[<span class="number">60000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br><span class="line">X_test=tf.reshape(X_test,[<span class="number">10000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">#4.建立LeNet模型</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;model=tf.keras.Sequential()</span></span><br><span class="line"><span class="string">#添加卷积层1、池化层1</span></span><br><span class="line"><span class="string">model.add(tf.keras.layers.Conv2D(6,kernel_size=(5,5),padding=&quot;same&quot;,activation=&quot;sigmoid&quot;,input_shape=(28,28,1)))</span></span><br><span class="line"><span class="string">model.add(tf.keras.layers.MaxPool2D(pool_size=(2,2)))</span></span><br><span class="line"><span class="string">#添加卷积层2、池化层2</span></span><br><span class="line"><span class="string">model.add(tf.keras.layers.Conv2D(16,kernel_size=(5,5),padding=&quot;valid&quot;,activation=&quot;sigmoid&quot;))</span></span><br><span class="line"><span class="string">model.add(tf.keras.layers.MaxPool2D(pool_size=(2,2)))</span></span><br><span class="line"><span class="string">#添加卷积层3</span></span><br><span class="line"><span class="string">model.add(tf.keras.layers.Conv2D(120,kernel_size=(5,5),padding=&quot;valid&quot;,activation=&quot;sigmoid&quot;))</span></span><br><span class="line"><span class="string">#添加Flatten层，将数据拉直</span></span><br><span class="line"><span class="string">model.add(tf.keras.layers.Flatten())</span></span><br><span class="line"><span class="string">#添加隐含层和输出层</span></span><br><span class="line"><span class="string">model.add(tf.keras.layers.Dense(84,activation=&quot;sigmoid&quot;))</span></span><br><span class="line"><span class="string">model.add(tf.keras.layers.Dense(10,activation=&quot;softmax&quot;))&#x27;&#x27;&#x27;</span></span><br><span class="line">model=LeNet((<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>),<span class="string">&quot;same&quot;</span>)</span><br><span class="line">model.summary()</span><br><span class="line"><span class="comment">#5.配置训练方法</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;adam&quot;</span>,loss=<span class="string">&quot;sparse_categorical_crossentropy&quot;</span>,metrics=[<span class="string">&quot;accuracy&quot;</span>])</span><br><span class="line"><span class="comment">#6.训练模型</span></span><br><span class="line">history=model.fit(X_train,Y_train,batch_size=<span class="number">64</span>,epochs=<span class="number">5</span>,validation_split=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment">#7.评估模型</span></span><br><span class="line">model.evaluate(X_test,Y_test,verbose=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#8.使用模型</span></span><br><span class="line"><span class="comment"># 下面再随机取出测试集中的任意10个数据进行识别</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.suptitle(<span class="string">&quot;随机取出测试集中的任意10个数据进行识别&quot;</span>, fontsize=<span class="number">20</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    num = np.random.randint(<span class="number">1</span>, <span class="number">10000</span>)</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">5</span>, i+<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(test_x[num], cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    y_pred = np.argmax(model.predict(tf.reshape(X_test[num],(<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>))))</span><br><span class="line">    plt.title(<span class="string">&quot;y= &quot;</span>+<span class="built_in">str</span>(test_y[num]) + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;y_pred=&quot;</span> + <span class="built_in">str</span>(y_pred))</span><br><span class="line">plt.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.98</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>Model: &quot;sequential_9&quot;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d_27 (Conv2D)           (None, 28, 28, 6)         156       
_________________________________________________________________
max_pooling2d_18 (MaxPooling (None, 14, 14, 6)         0         
_________________________________________________________________
conv2d_28 (Conv2D)           (None, 10, 10, 16)        2416      
_________________________________________________________________
max_pooling2d_19 (MaxPooling (None, 5, 5, 16)          0         
_________________________________________________________________
conv2d_29 (Conv2D)           (None, 1, 1, 120)         48120     
_________________________________________________________________
flatten_9 (Flatten)          (None, 120)               0         
_________________________________________________________________
dense_18 (Dense)             (None, 84)                10164     
_________________________________________________________________
dense_19 (Dense)             (None, 10)                850       
=================================================================
Total params: 61,706
Trainable params: 61,706
Non-trainable params: 0
_________________________________________________________________
Epoch 1/5
750/750 [==============================] - 23s 29ms/step - loss: 1.1872 - accuracy: 0.6143 - val_loss: 0.3047 - val_accuracy: 0.9153
Epoch 2/5
750/750 [==============================] - 22s 29ms/step - loss: 0.2160 - accuracy: 0.9393 - val_loss: 0.1392 - val_accuracy: 0.9581
Epoch 3/5
750/750 [==============================] - 22s 29ms/step - loss: 0.1238 - accuracy: 0.9627 - val_loss: 0.0956 - val_accuracy: 0.9721
Epoch 4/5
750/750 [==============================] - 21s 28ms/step - loss: 0.0919 - accuracy: 0.9717 - val_loss: 0.0836 - val_accuracy: 0.9755
Epoch 5/5
750/750 [==============================] - 21s 28ms/step - loss: 0.0759 - accuracy: 0.9766 - val_loss: 0.0788 - val_accuracy: 0.9761
313/313 - 3s - loss: 0.0719 - accuracy: 0.9774
</code></pre><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_4_1.png" alt="output_4_1"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存训练的模型参数</span></span><br><span class="line">model.save_weights(<span class="string">&quot;mnist_save_weights_LeNet.h5&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="AlexNet神经网络"><a href="#AlexNet神经网络" class="headerlink" title="AlexNet神经网络"></a>AlexNet神经网络</h1><ul>
<li><p><strong>AlexNet网络结构</strong></p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221111181303375.png" alt="image-20221111181303375"></p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221111181352031.png" alt="image-20221111181352031" style="zoom:50%;"></p>
</li>
<li><p><strong>AlexNet创新点</strong></p>
<ul>
<li>使用ReLU激活函数：使网络训练收敛更快</li>
<li>使用Dropout训练模型</li>
<li>数据增强：增加了2048倍的数据量<ul>
<li>原始图像256×256，随机截取224×224区域</li>
<li>水平翻转的镜像</li>
</ul>
</li>
<li>使用重叠最大池化：能够很好克服过拟合问题</li>
<li>使用GPU加速训练过程</li>
</ul>
</li>
</ul>
<hr>
<h1 id="VGGNet神经网络"><a href="#VGGNet神经网络" class="headerlink" title="VGGNet神经网络"></a>VGGNet神经网络</h1><ul>
<li>多个小卷积核级联加深网络结构<ul>
<li>减少网络计算量</li>
<li>增加网络的泛化能力和表达能力</li>
</ul>
</li>
<li>先训练级别A的简单网络，再复用A网络的权重初始化复杂模型<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107140620259.png" alt="image-20221107140620259" style="zoom: 33%;"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#VGG16模型的建立</span></span><br><span class="line">model=tf.keras.Sequential()</span><br><span class="line"><span class="comment">#添加卷积层1-2、池化层</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">64</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu,input_shape=(<span class="number">224</span>,<span class="number">244</span>,<span class="number">3</span>)))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">64</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment">#添加卷积层3-4、池化层</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">128</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">128</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment">#添加卷积层5-7、池化层</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">256</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">256</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">256</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment">#添加卷积层8-10、池化层</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">512</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">512</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">512</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment">#添加卷积层11-13、池化层</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">512</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">512</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">512</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment">#添加Flatten层，将数据拉直</span></span><br><span class="line">model.add(tf.keras.layers.Flatten())</span><br><span class="line"><span class="comment">#全连接层1，Dropout层</span></span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">4096</span>,activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(tf.keras.layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">#全连接层2，Dropout层</span></span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">4096</span>,activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(tf.keras.layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">#全连接层3（输出层）</span></span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">1000</span>,activation=<span class="string">&quot;softmax&quot;</span>))</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>Model: &quot;sequential_14&quot;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d_56 (Conv2D)           (None, 224, 244, 64)      1792      
_________________________________________________________________
conv2d_57 (Conv2D)           (None, 224, 244, 64)      36928     
_________________________________________________________________
max_pooling2d_32 (MaxPooling (None, 112, 122, 64)      0         
_________________________________________________________________
conv2d_58 (Conv2D)           (None, 112, 122, 128)     73856     
_________________________________________________________________
conv2d_59 (Conv2D)           (None, 112, 122, 128)     147584    
_________________________________________________________________
max_pooling2d_33 (MaxPooling (None, 56, 61, 128)       0         
_________________________________________________________________
conv2d_60 (Conv2D)           (None, 56, 61, 256)       295168    
_________________________________________________________________
conv2d_61 (Conv2D)           (None, 56, 61, 256)       590080    
_________________________________________________________________
conv2d_62 (Conv2D)           (None, 56, 61, 256)       590080    
_________________________________________________________________
max_pooling2d_34 (MaxPooling (None, 28, 30, 256)       0         
_________________________________________________________________
conv2d_63 (Conv2D)           (None, 28, 30, 512)       1180160   
_________________________________________________________________
conv2d_64 (Conv2D)           (None, 28, 30, 512)       2359808   
_________________________________________________________________
conv2d_65 (Conv2D)           (None, 28, 30, 512)       2359808   
_________________________________________________________________
max_pooling2d_35 (MaxPooling (None, 14, 15, 512)       0         
_________________________________________________________________
conv2d_66 (Conv2D)           (None, 14, 15, 512)       2359808   
_________________________________________________________________
conv2d_67 (Conv2D)           (None, 14, 15, 512)       2359808   
_________________________________________________________________
conv2d_68 (Conv2D)           (None, 14, 15, 512)       2359808   
_________________________________________________________________
max_pooling2d_36 (MaxPooling (None, 7, 7, 512)         0         
_________________________________________________________________
flatten_14 (Flatten)         (None, 25088)             0         
_________________________________________________________________
dense_30 (Dense)             (None, 4096)              102764544 
_________________________________________________________________
dropout_4 (Dropout)          (None, 4096)              0         
_________________________________________________________________
dense_31 (Dense)             (None, 4096)              16781312  
_________________________________________________________________
dropout_5 (Dropout)          (None, 4096)              0         
_________________________________________________________________
dense_32 (Dense)             (None, 1000)              4097000   
=================================================================
Total params: 138,357,544
Trainable params: 138,357,544
Non-trainable params: 0
_________________________________________________________________
</code></pre><hr>
<h1 id="GoogLeNet神经网络"><a href="#GoogLeNet神经网络" class="headerlink" title="GoogLeNet神经网络"></a>GoogLeNet神经网络</h1><h2 id="1-Inception-Module的初代"><a href="#1-Inception-Module的初代" class="headerlink" title="1.Inception Module的初代"></a>1.Inception Module的初代</h2><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107140740258.png" alt="image-20221107140740258" style="zoom:50%;"></p>
<h2 id="2-1×1卷积核"><a href="#2-1×1卷积核" class="headerlink" title="2.1×1卷积核"></a>2.1×1卷积核</h2><ul>
<li><p><strong>能够降维/升维，跨通道信息交流</strong><br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107140820217.png" alt="image-20221107140820217" style="zoom:50%;"></p>
</li>
<li><p>个人对1×1，7与1×1×7，1的理解：前者表示有七个1×1的卷积核，其中每个卷积核都与图像去卷一卷，那么每个卷积核都会输出一个特征图，则一个会输出七个特征图；后者表示一个卷积核，这个卷积核的大小是1×1×7，可以理解为有七个通道，每个通道里都有1×1的一个小卷积核（也就是这7个所谓的小卷积核从不同维度共同组成一个整体的大卷积核，实际上还是只有一个卷积核），这7个小卷积核与前一层中7个对应通道的图像分别卷积，将其结果相加后，最终还是只会得到一个特征图。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>TensorFlow</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow实践之分类问题</title>
    <url>/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本节从二分类问题到多分类问题均进行了简单的介绍以及相应示例的实现，同时对Pandas处理二维数据进行了基本介绍。</p>
<span id="more"></span>
<h1 id="一元逻辑回归的实现（二分类问题）"><a href="#一元逻辑回归的实现（二分类问题）" class="headerlink" title="一元逻辑回归的实现（二分类问题）"></a>一元逻辑回归的实现（二分类问题）</h1><ul>
<li>问题：根据房屋面积这一属性对房屋进行普通房和高档房的分类</li>
<li>思路：线性回归+sigmoid函数，即将线性回归的结果映射到0~1，通过设置阈值从而实现二分类问题（0/1）。个人理解是：将映射的结果看成概率，即若是通过线性回归得到的房屋价格越高，那么其属于高档房的概率就越高</li>
<li>步骤：<ul>
<li>加载数据</li>
<li>数据处理</li>
<li>设置超参数：学习率和迭代次数</li>
<li>设置模型参数的初值</li>
<li>训练模型</li>
<li>预测：设置阈值进行二分类</li>
<li>可视化输出</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#1.加载数据</span></span><br><span class="line">x=np.array([<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">126.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">140.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>])</span><br><span class="line">y=np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment">#2.数据处理：中心化（每个样本点都减去他们的平均值）</span></span><br><span class="line">x_train=x-np.mean(x)</span><br><span class="line">y_train=y</span><br><span class="line"><span class="comment">#3.设置超参数学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.005</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">5</span></span><br><span class="line">display_step=<span class="number">1</span> <span class="comment">#设置每一次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#4.设置模型参数初值w0,b0</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">w=tf.Variable(np.random.randn())</span><br><span class="line">b=tf.Variable(np.random.randn())</span><br><span class="line">x_=<span class="built_in">range</span>(-<span class="number">80</span>,<span class="number">80</span>)</span><br><span class="line">y_=<span class="number">1</span>/(<span class="number">1</span>+tf.exp(-(w*x_+b)))</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.scatter(x_train,y_train)</span><br><span class="line">plt.plot(x_,y_,color=<span class="string">&quot;red&quot;</span>,linewidth=<span class="number">3</span>)<span class="comment">#绘制模型初始参数时对应的sigmoid曲线</span></span><br><span class="line"><span class="comment">#5.训练模型</span></span><br><span class="line">cross_train=[]<span class="comment">#用来存放训练集的交叉熵损失</span></span><br><span class="line">acc_train=[]<span class="comment">#用来存放训练集的准确率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        pred_train=<span class="number">1</span>/(<span class="number">1</span>+tf.exp(-(w*x_train+b)))</span><br><span class="line">        Loss_train=-tf.reduce_mean(y_train*tf.math.log(pred_train)+(<span class="number">1</span>-y_train)*tf.math.log(<span class="number">1</span>-pred_train))</span><br><span class="line">    Accuracy_train=tf.reduce_mean(tf.cast(tf.equal(tf.where(pred_train&lt;<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">1</span>),y_train),tf.float32))<span class="comment">#因为tf.equal返回的是bool类型，故需要将其转化为float32</span></span><br><span class="line">    cross_train.append(Loss_train)</span><br><span class="line">    acc_train.append(Accuracy_train)</span><br><span class="line">    dL_dw,dL_db=tape.gradient(Loss_train,[w,b])</span><br><span class="line">    w.assign_sub(learn_rate*dL_dw)</span><br><span class="line">    b.assign_sub(learn_rate*dL_db)</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i:%i\tTrain Loss:%f\tAccuracy Train:%f&quot;</span> % (i,Loss_train,Accuracy_train))   </span><br><span class="line">        y_=<span class="number">1</span>/(<span class="number">1</span>+tf.exp(-(w*x_+b)))</span><br><span class="line">        plt.plot(x_,y_)<span class="comment">#绘制随着迭代次数sigmoid曲线的变化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">80</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#6.预测</span></span><br><span class="line">x_test=[<span class="number">128.15</span>,<span class="number">45.00</span>,<span class="number">141.43</span>,<span class="number">106.27</span>,<span class="number">99.00</span>,<span class="number">53.84</span>,<span class="number">85.36</span>,<span class="number">70.00</span>,<span class="number">162.00</span>,<span class="number">114.60</span>]</span><br><span class="line">pred_test=<span class="number">1</span>/(<span class="number">1</span>+tf.exp(-(w*(x_test-np.mean(x))+b)))</span><br><span class="line">y_test=tf.where(pred_test&lt;<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">1</span>)<span class="comment">#设置阈值进行二分类</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_test)):</span><br><span class="line">    <span class="built_in">print</span>(x_test[i],<span class="string">&#x27;\t&#x27;</span>,pred_test[i].numpy(),<span class="string">&#x27;\t&#x27;</span>,y_test[i].numpy(),<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"><span class="comment">#将分类后的数据可视化输出</span></span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.scatter(x_test,y_test)</span><br><span class="line">x_=np.array(<span class="built_in">range</span>(-<span class="number">80</span>,<span class="number">80</span>))</span><br><span class="line">y_=<span class="number">1</span>/(<span class="number">1</span>+tf.exp(-(w*x_+b)))</span><br><span class="line">plt.plot(x_+np.mean(x),y_)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i:0    Train Loss:0.852807    Accuracy Train:0.625000
i:1    Train Loss:0.400259    Accuracy Train:0.875000
i:2    Train Loss:0.341504    Accuracy Train:0.812500
i:3    Train Loss:0.322571    Accuracy Train:0.812500
i:4    Train Loss:0.313972    Accuracy Train:0.812500
i:5    Train Loss:0.309411    Accuracy Train:0.812500
--------------------------------------------------------------------------------
128.15      0.8610252      1     
45.0      0.0029561974      0     
141.43      0.9545566      1     
106.27      0.45318928      0     
99.0      0.29813623      0     
53.84      0.00663888      0     
85.36      0.108105935      0     
70.0      0.028681064      0     
162.0      0.9928677      1     
114.6      0.6406205      1     
</code></pre><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/output_1_1.png" alt="output_1_1"></p>
<hr>
<h1 id="多元逻辑回归的实现（二分类问题）"><a href="#多元逻辑回归的实现（二分类问题）" class="headerlink" title="多元逻辑回归的实现（二分类问题）"></a>多元逻辑回归的实现（二分类问题）</h1><ul>
<li>问题：通过花萼的长度和宽度这两个属性对山鸢尾和变色鸢尾进行分类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="comment">#1.下载鸢尾花数据集iris</span></span><br><span class="line"><span class="comment">#训练集</span></span><br><span class="line">TRAIN_URL = <span class="string">&quot;http://download.tensorflow.org/data/iris_training.csv&quot;</span></span><br><span class="line">train_path = tf.keras.utils.get_file(<span class="string">&quot;iris_train.csv&quot;</span>,TRAIN_URL,cache_dir=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\TensorFlow&quot;</span>)</span><br><span class="line"><span class="comment">#测试集</span></span><br><span class="line">TRAIN_URL = <span class="string">&quot;http://download.tensorflow.org/data/iris_test.csv&quot;</span></span><br><span class="line">test_path = tf.keras.utils.get_file(<span class="string">&quot;iris_test.csv&quot;</span>,TRAIN_URL,cache_dir=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\TensorFlow&quot;</span>)</span><br><span class="line">df_iris_train=pd.read_csv(train_path,header=<span class="number">0</span>)</span><br><span class="line">df_iris_test=pd.read_csv(test_path,header=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#2.处理数据</span></span><br><span class="line"><span class="comment">#转化为numpy数组</span></span><br><span class="line">iris_train=np.array(df_iris_train)</span><br><span class="line">iris_test=np.array(df_iris_test)</span><br><span class="line"><span class="comment">#取出前两个属性</span></span><br><span class="line">train_x=iris_train[:,<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">test_x=iris_test[:,<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment">#取出标签</span></span><br><span class="line">train_y=iris_train[:,<span class="number">4</span>]</span><br><span class="line">test_y=iris_test[:,<span class="number">4</span>]</span><br><span class="line"><span class="comment">#取出山鸢尾和变色鸢尾</span></span><br><span class="line">x_train=train_x[train_y&lt;<span class="number">2</span>]</span><br><span class="line">y_train=train_y[train_y&lt;<span class="number">2</span>]</span><br><span class="line">x_test=test_x[test_y&lt;<span class="number">2</span>]</span><br><span class="line">y_test=test_y[test_y&lt;<span class="number">2</span>]</span><br><span class="line"><span class="comment">#记录此时的样本数</span></span><br><span class="line">num_train=<span class="built_in">len</span>(x_train)</span><br><span class="line">num_test=<span class="built_in">len</span>(x_test)</span><br><span class="line"><span class="comment">#可视化样本数据</span></span><br><span class="line">cm_pt=mpl.colors.ListedColormap([<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;red&quot;</span>])</span><br><span class="line"><span class="comment">#plt.scatter(x_train[:,0],x_train[:,1],c=y_train,cmap=cm_pt)#使用花萼长度和宽度分别作为横纵坐标</span></span><br><span class="line"><span class="comment">#属性中心化</span></span><br><span class="line">x_train=x_train-np.mean(x_train,axis=<span class="number">0</span>)</span><br><span class="line">x_test=x_test-np.mean(x_test,axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#生成多元模型的属性矩阵和标签列向量</span></span><br><span class="line">x0_train=np.ones(num_train).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">X_train=tf.cast(tf.concat((x0_train,x_train),axis=<span class="number">1</span>),tf.float32)</span><br><span class="line">Y_train=y_train.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">x0_test=np.ones(num_test).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">X_test=tf.cast(tf.concat((x0_test,x_test),axis=<span class="number">1</span>),tf.float32)</span><br><span class="line">Y_test=y_test.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#4.设置超参数学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.2</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">120</span></span><br><span class="line">display_step=<span class="number">30</span> <span class="comment">#设置每三十次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#5.设置模型参数初值W</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">W=tf.Variable(np.random.randn(<span class="number">3</span>,<span class="number">1</span>),dtype=tf.float32)</span><br><span class="line">x_=[-<span class="number">1.5</span>,<span class="number">1.5</span>]</span><br><span class="line">y_=-(W[<span class="number">0</span>]+W[<span class="number">1</span>]*x_)/W[<span class="number">2</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.scatter(x_train[:,<span class="number">0</span>],x_train[:,<span class="number">1</span>],c=y_train,cmap=cm_pt)</span><br><span class="line">plt.plot(x_,y_,color=<span class="string">&quot;red&quot;</span>,linewidth=<span class="number">3</span>)</span><br><span class="line">plt.xlim(-<span class="number">1.5</span>,<span class="number">1.5</span>)</span><br><span class="line">plt.ylim(-<span class="number">1.5</span>,<span class="number">1.5</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.scatter(x_test[:,<span class="number">0</span>],x_test[:,<span class="number">1</span>],c=y_test,cmap=cm_pt)</span><br><span class="line">plt.plot(x_,y_,color=<span class="string">&quot;red&quot;</span>,linewidth=<span class="number">3</span>)</span><br><span class="line">plt.xlim(-<span class="number">1.5</span>,<span class="number">1.5</span>)</span><br><span class="line">plt.ylim(-<span class="number">1.5</span>,<span class="number">1.5</span>)</span><br><span class="line"><span class="comment">#6.训练模型</span></span><br><span class="line">ce_train=[]<span class="comment">#用来存放训练集的交叉熵损失</span></span><br><span class="line">acc_train=[]<span class="comment">#用来存放训练集的准确率</span></span><br><span class="line">ce_test=[]<span class="comment">#用来存放测试集的交叉熵损失</span></span><br><span class="line">acc_test=[]<span class="comment">#用来存放测试集的准确率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        PRED_train=<span class="number">1</span>/(<span class="number">1</span>+tf.exp(-tf.matmul(X_train,W)))</span><br><span class="line">        Loss_train=-tf.reduce_mean(Y_train*tf.math.log(PRED_train)+(<span class="number">1</span>-Y_train)*tf.math.log(<span class="number">1</span>-PRED_train))</span><br><span class="line">        PRED_test=<span class="number">1</span>/(<span class="number">1</span>+tf.exp(-tf.matmul(X_test,W)))</span><br><span class="line">        Loss_test=-tf.reduce_mean(Y_test*tf.math.log(PRED_test)+(<span class="number">1</span>-Y_test)*tf.math.log(<span class="number">1</span>-PRED_test))</span><br><span class="line">    Accuracy_train=tf.reduce_mean(tf.cast(tf.equal(tf.where(PRED_train&lt;<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">1</span>),Y_train),tf.float32))</span><br><span class="line">    Accuracy_test=tf.reduce_mean(tf.cast(tf.equal(tf.where(PRED_test&lt;<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">1</span>),Y_test),tf.float32))</span><br><span class="line">    ce_train.append(Loss_train)</span><br><span class="line">    acc_train.append(Accuracy_train)</span><br><span class="line">    ce_test.append(Loss_test)</span><br><span class="line">    acc_test.append(Accuracy_test)</span><br><span class="line">    dL_dW=tape.gradient(Loss_train,W)</span><br><span class="line">    W.assign_sub(learn_rate*dL_dW)</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i:%i\tTrain Loss:%f\tAccuracy Train:%f\t\tTest Loss:%f\tAccuracy Test:%f&quot;</span> % (i,Loss_train,Accuracy_train,Loss_test,Accuracy_test)) </span><br><span class="line">        y_=-(W[<span class="number">0</span>]+W[<span class="number">1</span>]*x_)/W[<span class="number">2</span>]</span><br><span class="line">        plt.subplot(<span class="number">121</span>)</span><br><span class="line">        plt.plot(x_,y_)</span><br><span class="line">        plt.subplot(<span class="number">122</span>)</span><br><span class="line">        plt.plot(x_,y_)</span><br><span class="line"><span class="comment">#7.结果可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.plot(ce_train,color=<span class="string">&quot;blue&quot;</span>,label=<span class="string">&quot;Loss_train&quot;</span>)</span><br><span class="line">plt.plot(ce_test,color=<span class="string">&quot;red&quot;</span>,label=<span class="string">&quot;Loss_test&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.plot(acc_train,color=<span class="string">&quot;blue&quot;</span>,label=<span class="string">&quot;Accuracy_train&quot;</span>)</span><br><span class="line">plt.plot(acc_test,color=<span class="string">&quot;red&quot;</span>,label=<span class="string">&quot;Accuracy_test&quot;</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i:0    Train Loss:0.994269    Accuracy Train:0.230769        Test Loss:0.939684    Accuracy Test:0.272727
i:30    Train Loss:0.481892    Accuracy Train:0.961538        Test Loss:0.505456    Accuracy Test:0.863636
i:60    Train Loss:0.319128    Accuracy Train:0.987179        Test Loss:0.362112    Accuracy Test:0.863636
i:90    Train Loss:0.246626    Accuracy Train:0.987179        Test Loss:0.295611    Accuracy Test:0.863636
i:120    Train Loss:0.204982    Accuracy Train:1.000000        Test Loss:0.256212    Accuracy Test:0.863636
</code></pre><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/output_3_2.png" alt="output_3_2"></p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/output_3_3-1667791998015-13.png" alt="output_3_3"></p>
<ul>
<li><strong>绘制决策边界原理</strong><br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/image-20221107113341906.png" alt="image-20221107113341906" style="zoom: 25%;"></li>
</ul>
<hr>
<h1 id="绘制分类图"><a href="#绘制分类图" class="headerlink" title="绘制分类图"></a>绘制分类图</h1><h2 id="1-绘制填充块"><a href="#1-绘制填充块" class="headerlink" title="1.绘制填充块"></a>1.绘制填充块</h2><ul>
<li>生成网格坐标矩阵：<code>np.meshgrid()</code></li>
<li>填充网格：<code>plt.pcolomesh()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">n=<span class="number">200</span></span><br><span class="line">x=np.linspace(-<span class="number">10</span>,<span class="number">10</span>,n)</span><br><span class="line">y=np.linspace(-<span class="number">10</span>,<span class="number">10</span>,n)</span><br><span class="line">X,Y=np.meshgrid(x,y)</span><br><span class="line">Z=X+Y</span><br><span class="line">plt.pcolormesh(X,Y,Z,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/output_7_0-1667792314109-15.png" alt="output_7_0" style="zoom: 80%;">    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义色彩区域</span></span><br><span class="line">cm_bg=mpl.colors.ListedColormap([<span class="string">&quot;#FFA0A0&quot;</span>,<span class="string">&quot;#A0FFA0&quot;</span>])</span><br><span class="line">plt.pcolormesh(X,Y,Z,cmap=cm_bg)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/output_8_0-1667792375363-17.png" alt="output_8_0" style="zoom:80%;"></p>
<h2 id="2-绘制轮廓线"><a href="#2-绘制轮廓线" class="headerlink" title="2.绘制轮廓线"></a>2.绘制轮廓线</h2><ul>
<li><code>plt.contour()</code>#绘制轮廓线</li>
<li><code>plt.contourf()</code>#填充</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n=<span class="number">200</span></span><br><span class="line">x=np.linspace(-<span class="number">10</span>,<span class="number">10</span>,n)</span><br><span class="line">y=np.linspace(-<span class="number">10</span>,<span class="number">10</span>,n)</span><br><span class="line">X,Y=np.meshgrid(x,y)</span><br><span class="line">Z=X**<span class="number">2</span>+Y**<span class="number">2</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.contour(X,Y,Z,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.contourf(X,Y,Z,<span class="number">20</span>,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/output_10_0-1667792407570-19.png" alt="output_10_0" style="zoom:80%;"></p>
<h2 id="3-根据鸢尾花分类模型，绘制分类图"><a href="#3-根据鸢尾花分类模型，绘制分类图" class="headerlink" title="3.根据鸢尾花分类模型，绘制分类图"></a>3.根据鸢尾花分类模型，绘制分类图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M=<span class="number">300</span></span><br><span class="line">x1_min,x2_min=x_train.<span class="built_in">min</span>(axis=<span class="number">0</span>)</span><br><span class="line">x1_max,x2_max=x_train.<span class="built_in">max</span>(axis=<span class="number">0</span>)</span><br><span class="line">t1=np.linspace(x1_min,x1_max,M)</span><br><span class="line">t2=np.linspace(x2_min,x2_max,M)</span><br><span class="line">m1,m2=np.meshgrid(t1,t2)</span><br><span class="line">m0=np.ones(M*M)</span><br><span class="line">X_mesh=tf.cast(np.stack((m0,m1.reshape(-<span class="number">1</span>),m2.reshape(-<span class="number">1</span>)),axis=<span class="number">1</span>),dtype=tf.float32)</span><br><span class="line">Y_mesh=tf.cast(<span class="number">1</span>/(<span class="number">1</span>+tf.exp(-tf.matmul(X_mesh,W))),dtype=tf.float32)</span><br><span class="line">Y_mesh=tf.where(Y_mesh&lt;<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">n=tf.reshape(Y_mesh,m1.shape)</span><br><span class="line">cm_pt=mpl.colors.ListedColormap([<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;red&quot;</span>])</span><br><span class="line">cm_bg=mpl.colors.ListedColormap([<span class="string">&quot;#FFA0A0&quot;</span>,<span class="string">&quot;#A0FFA0&quot;</span>])</span><br><span class="line">plt.pcolormesh(m1,m2,n,cmap=cm_bg)</span><br><span class="line">plt.scatter(x_train[:,<span class="number">0</span>],x_train[:,<span class="number">1</span>],c=y_train,cmap=cm_pt)</span><br><span class="line">plt.xlim(-<span class="number">1.2</span>,<span class="number">1.7</span>)</span><br><span class="line">plt.ylim(-<span class="number">1.2</span>,<span class="number">1.4</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/output_12_0-1667792473557-21.png" alt="output_12_0" style="zoom:80%;">    </p>
<hr>
<h1 id="Pandas二维数据基本操作"><a href="#Pandas二维数据基本操作" class="headerlink" title="Pandas二维数据基本操作"></a>Pandas二维数据基本操作</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h2 id="1-读取数据并设置列标题"><a href="#1-读取数据并设置列标题" class="headerlink" title="1.读取数据并设置列标题"></a>1.读取数据并设置列标题</h2><ul>
<li><code>pd.read_csv(filepath_or_buffer,header,names)</code></li>
<li>通过header设置列标题，默认header=0，表示第一行作为列标题；header=None,表示没有标题</li>
<li>names参数：自定义列标题，代替header参数指定的列标题</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pd.read_csv(filepath_or_buffer,header,names)</span></span><br><span class="line">df_iris=pd.read_csv(train_path,header=<span class="number">0</span>)</span><br><span class="line">df_iris.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>120</th>
      <th>4</th>
      <th>setosa</th>
      <th>versicolor</th>
      <th>virginica</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>6.4</td>
      <td>2.8</td>
      <td>5.6</td>
      <td>2.2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5.0</td>
      <td>2.3</td>
      <td>3.3</td>
      <td>1.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.9</td>
      <td>2.5</td>
      <td>4.5</td>
      <td>1.7</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.9</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.7</td>
      <td>3.8</td>
      <td>1.7</td>
      <td>0.3</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义列标题</span></span><br><span class="line">COLUMN_NAMES=[<span class="string">&quot;SepalLength&quot;</span>,<span class="string">&quot;SepalWidth&quot;</span>,<span class="string">&quot;PetalLength&quot;</span>,<span class="string">&quot;PetalWidth&quot;</span>,<span class="string">&quot;Species&quot;</span>]</span><br><span class="line">df_iris=pd.read_csv(train_path,header=<span class="number">0</span>,names=COLUMN_NAMES)</span><br><span class="line">df_iris.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SepalLength</th>
      <th>SepalWidth</th>
      <th>PetalLength</th>
      <th>PetalWidth</th>
      <th>Species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>6.4</td>
      <td>2.8</td>
      <td>5.6</td>
      <td>2.2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5.0</td>
      <td>2.3</td>
      <td>3.3</td>
      <td>1.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.9</td>
      <td>2.5</td>
      <td>4.5</td>
      <td>1.7</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.9</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.7</td>
      <td>3.8</td>
      <td>1.7</td>
      <td>0.3</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="2-访问数据"><a href="#2-访问数据" class="headerlink" title="2.访问数据"></a>2.访问数据</h2><ul>
<li><code>head(n)</code>#默认读取前5行数据，也可以通过n指定读取前n行</li>
<li><code>tail(n)</code>#默认读取后5行数据，也可以通过n指定读取后n行</li>
<li>使用索引和切片读取数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_iris.head(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SepalLength</th>
      <th>SepalWidth</th>
      <th>PetalLength</th>
      <th>PetalWidth</th>
      <th>Species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>6.4</td>
      <td>2.8</td>
      <td>5.6</td>
      <td>2.2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5.0</td>
      <td>2.3</td>
      <td>3.3</td>
      <td>1.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.9</td>
      <td>2.5</td>
      <td>4.5</td>
      <td>1.7</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.9</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.7</td>
      <td>3.8</td>
      <td>1.7</td>
      <td>0.3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>4.4</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>5.4</td>
      <td>3.4</td>
      <td>1.5</td>
      <td>0.4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>6.9</td>
      <td>3.1</td>
      <td>5.1</td>
      <td>2.3</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_iris.tail(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SepalLength</th>
      <th>SepalWidth</th>
      <th>PetalLength</th>
      <th>PetalWidth</th>
      <th>Species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>112</th>
      <td>5.0</td>
      <td>3.0</td>
      <td>1.6</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>113</th>
      <td>6.3</td>
      <td>3.3</td>
      <td>6.0</td>
      <td>2.5</td>
      <td>2</td>
    </tr>
    <tr>
      <th>114</th>
      <td>5.0</td>
      <td>3.5</td>
      <td>1.6</td>
      <td>0.6</td>
      <td>0</td>
    </tr>
    <tr>
      <th>115</th>
      <td>5.5</td>
      <td>2.6</td>
      <td>4.4</td>
      <td>1.2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>116</th>
      <td>5.7</td>
      <td>3.0</td>
      <td>4.2</td>
      <td>1.2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>117</th>
      <td>4.4</td>
      <td>2.9</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>118</th>
      <td>4.8</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>119</th>
      <td>5.5</td>
      <td>2.4</td>
      <td>3.7</td>
      <td>1.0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用索引和切片读取数据</span></span><br><span class="line">df_iris[<span class="number">10</span>:<span class="number">20</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SepalLength</th>
      <th>SepalWidth</th>
      <th>PetalLength</th>
      <th>PetalWidth</th>
      <th>Species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>10</th>
      <td>5.2</td>
      <td>2.7</td>
      <td>3.9</td>
      <td>1.4</td>
      <td>1</td>
    </tr>
    <tr>
      <th>12</th>
      <td>5.8</td>
      <td>4.0</td>
      <td>1.2</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>14</th>
      <td>7.7</td>
      <td>3.8</td>
      <td>6.7</td>
      <td>2.2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>16</th>
      <td>6.8</td>
      <td>3.2</td>
      <td>5.9</td>
      <td>2.3</td>
      <td>2</td>
    </tr>
    <tr>
      <th>18</th>
      <td>6.4</td>
      <td>3.2</td>
      <td>5.3</td>
      <td>2.3</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

</div>



<h2 id="3-显示统计信息"><a href="#3-显示统计信息" class="headerlink" title="3.显示统计信息"></a>3.显示统计信息</h2><ul>
<li>describe()#对每列数据进行统计</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_iris.describe()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>SepalLength</th>
      <th>SepalWidth</th>
      <th>PetalLength</th>
      <th>PetalWidth</th>
      <th>Species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>120.000000</td>
      <td>120.000000</td>
      <td>120.000000</td>
      <td>120.000000</td>
      <td>120.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>5.845000</td>
      <td>3.065000</td>
      <td>3.739167</td>
      <td>1.196667</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.868578</td>
      <td>0.427156</td>
      <td>1.822100</td>
      <td>0.782039</td>
      <td>0.840168</td>
    </tr>
    <tr>
      <th>min</th>
      <td>4.400000</td>
      <td>2.000000</td>
      <td>1.000000</td>
      <td>0.100000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>5.075000</td>
      <td>2.800000</td>
      <td>1.500000</td>
      <td>0.300000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>5.800000</td>
      <td>3.000000</td>
      <td>4.400000</td>
      <td>1.300000</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>6.425000</td>
      <td>3.300000</td>
      <td>5.100000</td>
      <td>1.800000</td>
      <td>2.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>7.900000</td>
      <td>4.400000</td>
      <td>6.900000</td>
      <td>2.500000</td>
      <td>2.000000</td>
    </tr>
  </tbody>
</table>

</div>



<h2 id="4-DataFrame的常用属性"><a href="#4-DataFrame的常用属性" class="headerlink" title="4.DataFrame的常用属性"></a>4.DataFrame的常用属性</h2><ul>
<li>.ndim #数据表的维数</li>
<li>.shape #数据表的形状</li>
<li>.size #数据表元素的总个数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df_iris.ndim)</span><br><span class="line"><span class="built_in">print</span>(df_iris.shape)</span><br><span class="line"><span class="built_in">print</span>(df_iris.size)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>2
(120, 5)
600
</code></pre><hr>
<h1 id="实现多分类任务"><a href="#实现多分类任务" class="headerlink" title="实现多分类任务"></a>实现多分类任务</h1><h2 id="1-独热编码的实现"><a href="#1-独热编码的实现" class="headerlink" title="1.独热编码的实现"></a>1.独热编码的实现</h2><ul>
<li><code>tf.one_hot(indices,depth)</code></li>
<li>indices是一维整数数组或整数张量</li>
<li>depth是编码深度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">b=tf.one_hot(a,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[1. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 1.]
 [0. 0. 1. 0. 0. 0.]], shape=(5, 6), dtype=float32)
</code></pre><h2 id="2-softmax函数的实现"><a href="#2-softmax函数的实现" class="headerlink" title="2.softmax函数的实现"></a>2.softmax函数的实现</h2><ul>
<li><code>tf.nn.softmax()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">tf.nn.softmax([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">5.0</span>])</span><br><span class="line">np.<span class="built_in">round</span>(tf.nn.softmax([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">5.0</span>]),<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>array([0.02, 0.05, 0.94], dtype=float32)
</code></pre><h2 id="3-准确率的实现"><a href="#3-准确率的实现" class="headerlink" title="3.准确率的实现"></a>3.准确率的实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">y=np.array([<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">y_onehot=np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]])</span><br><span class="line">pred=np.array([[<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.7</span>],[<span class="number">0.1</span>,<span class="number">0.7</span>,<span class="number">0.2</span>],[<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.3</span>]])</span><br><span class="line">answer_tof=tf.equal(tf.argmax(pred,axis=<span class="number">1</span>),y)</span><br><span class="line">answer=tf.cast(answer_tof,tf.float32)</span><br><span class="line">acc=tf.reduce_mean(answer)</span><br><span class="line"><span class="built_in">print</span>(acc)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(0.6666667, shape=(), dtype=float32)
</code></pre><h2 id="4-实例：使用花瓣长度、花瓣宽度将三种鸢尾花区分开"><a href="#4-实例：使用花瓣长度、花瓣宽度将三种鸢尾花区分开" class="headerlink" title="4.实例：使用花瓣长度、花瓣宽度将三种鸢尾花区分开"></a>4.实例：使用花瓣长度、花瓣宽度将三种鸢尾花区分开</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.导入库，加载数据</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="comment">#训练集</span></span><br><span class="line">TRAIN_URL = <span class="string">&quot;http://download.tensorflow.org/data/iris_training.csv&quot;</span></span><br><span class="line">train_path = tf.keras.utils.get_file(<span class="string">&quot;iris_train.csv&quot;</span>,TRAIN_URL,cache_dir=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\TensorFlow&quot;</span>)</span><br><span class="line">df_iris_train=pd.read_csv(train_path,header=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#2.处理数据</span></span><br><span class="line"><span class="comment">#转化为numpy数组</span></span><br><span class="line">iris_train=np.array(df_iris_train)</span><br><span class="line"><span class="comment">#取出前两个属性</span></span><br><span class="line">x_train=iris_train[:,<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="comment">#取出标签</span></span><br><span class="line">y_train=iris_train[:,<span class="number">4</span>]</span><br><span class="line"><span class="comment">#记录此时的样本数</span></span><br><span class="line">num_train=<span class="built_in">len</span>(x_train)</span><br><span class="line"><span class="comment">#生成多元模型的属性矩阵和标签独热码</span></span><br><span class="line">x0_train=np.ones(num_train).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">X_train=tf.cast(tf.concat((x0_train,x_train),axis=<span class="number">1</span>),tf.float32)</span><br><span class="line">Y_train=tf.one_hot(tf.constant(y_train,dtype=tf.int32),<span class="number">3</span>)<span class="comment">#Y_train为120*3</span></span><br><span class="line"><span class="comment">#3.设置超参数学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.2</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">500</span></span><br><span class="line">display_step=<span class="number">100</span> <span class="comment">#设置每三十次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#4.设置模型参数初值W</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">W=tf.Variable(np.random.randn(<span class="number">3</span>,<span class="number">3</span>),dtype=tf.float32)<span class="comment">#W为3*3，其中第一个3为（属性+1）对应的权重，第二个3为三类</span></span><br><span class="line"><span class="comment">#5.训练模型</span></span><br><span class="line">ce_train=[]<span class="comment">#用来存放训练集的交叉熵损失</span></span><br><span class="line">acc_train=[]<span class="comment">#用来存放训练集的准确率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        PRED_train=tf.nn.softmax(tf.matmul(X_train,W))<span class="comment">#PRED_train是120*3的矩阵</span></span><br><span class="line">        Loss_train=-tf.reduce_sum(Y_train*tf.math.log(PRED_train))/num_train</span><br><span class="line">    Accuracy_train=tf.reduce_mean(tf.cast(tf.equal(tf.argmax(PRED_train.numpy(),axis=<span class="number">1</span>),y_train),tf.float32))</span><br><span class="line">    ce_train.append(Loss_train)</span><br><span class="line">    acc_train.append(Accuracy_train)</span><br><span class="line">    dL_dW=tape.gradient(Loss_train,W)</span><br><span class="line">    W.assign_sub(learn_rate*dL_dW)</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i:%i\tAcc:%f\tLoss:%f&quot;</span>%(i,Accuracy_train,Loss_train))</span><br><span class="line"><span class="built_in">print</span>(tf.argmax(PRED_train.numpy(),axis=<span class="number">1</span>)) <span class="comment">#分类结果</span></span><br><span class="line"><span class="built_in">print</span>(Loss_train)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i:0    Acc:0.350000    Loss:4.510763
i:100    Acc:0.808333    Loss:0.503537
i:200    Acc:0.883333    Loss:0.402912
i:300    Acc:0.891667    Loss:0.352650
i:400    Acc:0.941667    Loss:0.319779
i:500    Acc:0.941667    Loss:0.295599
tf.Tensor(
[2 1 2 0 0 0 0 2 1 0 1 1 0 0 2 2 2 2 2 0 2 2 0 1 1 0 1 2 1 2 1 1 1 2 2 2 2
 2 0 0 2 2 2 0 0 1 0 2 0 2 0 1 1 0 1 2 2 2 2 1 1 2 2 2 1 2 0 2 2 0 0 1 0 2
 2 0 1 1 1 2 0 1 1 1 2 0 1 1 2 0 2 1 0 0 2 0 0 2 2 0 0 1 0 1 0 0 0 0 1 0 2
 1 0 2 0 1 1 0 0 1], shape=(120,), dtype=int64)
tf.Tensor(0.295599, shape=(), dtype=float32)
</code></pre>]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow实践之卷积神经网路</title>
    <url>/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本节主要介绍了卷积神经网络的基本结构，并通过Sequential模型对卷积神经网络进行了搭建。</p>
<span id="more"></span>
<h1 id="深度学习基础"><a href="#深度学习基础" class="headerlink" title="深度学习基础"></a>深度学习基础</h1><ul>
<li><strong>深度神经网络</strong>：有多层隐含层的神经网络</li>
<li><strong>端到端学习</strong>：自动的从数据中学习特征</li>
<li><strong>具有多层隐含层的深度神经网络就是深度学习（Deep Learning）</strong></li>
<li>深度学习能够自动从数据中学习到与任务相关的特征，提取出的特征缺乏可解释性</li>
</ul>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107120929581.png" alt="image-20221107120929581" style="zoom: 33%;"></p>
<hr>
<h1 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h1><h2 id="1-图像卷积运算"><a href="#1-图像卷积运算" class="headerlink" title="1.图像卷积运算"></a>1.图像卷积运算</h2><ul>
<li>首先，把卷积核和图像中的像素点一一对应</li>
<li>加权求和，把得到的结果作为中心像素点新的灰度值</li>
<li>用卷积核从左至右，从上至下滑动，就可以计算出每个像素点的取值<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107121513161.png" alt="image-20221107121513161" style="zoom: 33%;"></li>
<li>使用卷积核计算后的结果会比原图稍微小一点，因为对于图像边界上的点，无法进行卷积运算<br>  <img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107121617059.png" alt="image-20221107121617059" style="zoom: 25%;">            <img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107121658899.png" alt="image-20221107121658899" style="zoom:25%;"></li>
<li>可以通过填充外层使得卷积后图像大小和原图一样<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107121827880.png" alt="image-20221107121827880" style="zoom: 50%;"></li>
<li>步长(stride)：卷积核一次移动的像素数</li>
<li>步长等于卷积核的边长，相当于将图像缩小了n倍<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107121906994.png" alt="image-20221107121906994" style="zoom: 50%;"></li>
</ul>
<h2 id="2-卷积核的作用效果"><a href="#2-卷积核的作用效果" class="headerlink" title="2.卷积核的作用效果"></a>2.卷积核的作用效果</h2><ul>
<li><p><strong>卷积核的尺寸，决定了周围像素的范围，卷积核的数值，表明了其权值，采用不同的卷积核，能够产生不同的效果</strong></p>
</li>
<li><p>输出原图：<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107122049776.png" alt="image-20221107122049776" style="zoom:50%;"></p>
</li>
<li><p><strong>均值模糊</strong>：可以将图像中的高频噪声过滤掉，故对图像的卷积运算，也称为平滑或者滤波，卷积核也称为滤波器<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107122126981.png" alt="image-20221107122126981" style="zoom:50%;"></p>
<ul>
<li><strong>卷积核尺寸越大，图像越模糊</strong></li>
</ul>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107122232759.png" alt="image-20221107122232759" style="zoom: 50%;"></p>
</li>
<li><p><strong>高斯模糊</strong>：根据高斯分布的取值来确定权值</p>
<ul>
<li>为了尽可能保留图像中的边缘信息，给不同位置的像素点赋予不同的权值，离中心点越近的像素，权值越大，远离中心点的像素，权值也逐渐减小<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107122501280.png" alt="image-20221107122501280" style="zoom:50%;"></li>
</ul>
</li>
<li><p>均值模糊与高斯模糊的对比：高斯模糊能够更好的保留图像的边缘和轮廓<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107123237685.png" alt="image-20221107123237685" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="3-边缘检测"><a href="#3-边缘检测" class="headerlink" title="3.边缘检测"></a>3.边缘检测</h2><ul>
<li>计算当前点和周围点颜色值或灰度值的差别</li>
<li><strong>Prewitt算子</strong>：<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107123416992.png" alt="image-20221107123416992" style="zoom:33%;"></li>
<li><strong>Roberts算子</strong>：能够比较好的检测45°角方向的边缘</li>
<li><strong>Sobel算子</strong>：在Prewitt算子的基础上增加的权重的概念，认为上下左右直线方向的距离大于斜线方向的距离</li>
<li><strong>Laplacian算子</strong>：判断中心像素的灰度与邻域内其他像素灰度的关系</li>
<li><strong>Log算子</strong>：综合考虑了噪声的抑制和边缘检测,其抗干扰能力强，边界定位精度高，边缘连续性好，而且能有效提取对比度弱的边界<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107123553479.png" alt="image-20221107123553479" style="zoom:33%;"></li>
</ul>
<hr>
<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul>
<li>卷积神经网络中的每一个神经元相当于使用同一个卷积核（卷积核中的数值就是权重）在整个图像上滑动</li>
<li>一个卷积核只能提取一种特征，使用不同的卷积核提取不同的特征</li>
<li>卷积神经网络具有局部连接和权值共享的特点</li>
<li>卷积核中的权值是从数据中学习得到的</li>
</ul>
<h2 id="2-卷积神经网络的构成"><a href="#2-卷积神经网络的构成" class="headerlink" title="2.卷积神经网络的构成"></a>2.卷积神经网络的构成</h2><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107123809535.png" alt="image-20221107123809535" style="zoom: 33%;"></p>
<ul>
<li><strong>特征提取阶段</strong><ul>
<li>卷积层：特征提取层<ul>
<li><strong>每个卷积层中包含多个卷积核提取不同的特征</strong></li>
<li><strong>每个卷积核（每个卷积核又可能包含多通道）都输出一张特征图</strong></li>
<li>激励函数：如ReLU<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107123910625.png" alt="image-20221107123910625" style="zoom:33%;"></li>
</ul>
</li>
<li>池化层：特征映射层<ul>
<li><strong>下采样：使用n×n的池化模板，且步长为n，将其尺寸减小到1/n</strong></li>
<li>在减小数据的处理量的同时，保留有用的信息<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107124037477.png" alt="image-20221107124037477" style="zoom:33%;"></li>
</ul>
</li>
</ul>
</li>
<li><strong>分类识别阶段</strong>：由全连接层或支持向量机组成</li>
</ul>
<hr>
<h1 id="实例：卷积神经网络实现手写数字识别"><a href="#实例：卷积神经网络实现手写数字识别" class="headerlink" title="实例：卷积神经网络实现手写数字识别"></a>实例：卷积神经网络实现手写数字识别</h1><h2 id="1-创建卷积层"><a href="#1-创建卷积层" class="headerlink" title="1.创建卷积层"></a>1.创建卷积层</h2><ul>
<li><code>tf.keras.layers.Conv2D(filters,kernel_size,padding,activation,input_shape)</code></li>
<li>filters表示卷积核的数量</li>
<li>kernel_size表示卷积核大小</li>
<li>padding表示扩充图像的方式<ul>
<li>padding=”same”：以0扩充</li>
<li>padding=”valid”：不扩充图像边界</li>
</ul>
</li>
<li>activation用来设置激活函数</li>
<li>input_shape表示输入卷积层的数据形状，分别是samples（由batch_size自动指定）,rows,cols,channels</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.Conv2D(filters=<span class="number">16</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu,input_shape=(<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>))<span class="comment">#因为MNIST数据集是灰度图像，所以通道数为1</span></span><br></pre></td></tr></table></figure>
<h2 id="2-创建池化层"><a href="#2-创建池化层" class="headerlink" title="2.创建池化层"></a>2.创建池化层</h2><ul>
<li><code>tf.keras.layers.MaxPool2D(pool_size)</code></li>
<li>pool_size指定池化窗口的大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h2 id="3-模型设计"><a href="#3-模型设计" class="headerlink" title="3.模型设计"></a>3.模型设计</h2><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107124332422.png" alt="image-20221107124332422" style="zoom: 50%;"></p>
<h2 id="4-具体代码实现"><a href="#4-具体代码实现" class="headerlink" title="4.具体代码实现"></a>4.具体代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.导入库</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#2.加载数据</span></span><br><span class="line">mnist=tf.keras.datasets.mnist</span><br><span class="line">(train_x,train_y),(test_x,test_y)=mnist.load_data(path=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\image\mnist.npz&quot;</span>)</span><br><span class="line"><span class="comment">#3.数据预处理:对属性进行归一化并转化为Tensor张量</span></span><br><span class="line">X_train,X_test=tf.cast(train_x/<span class="number">255.0</span>,tf.float32),tf.cast(test_x/<span class="number">255.0</span>,tf.float32)</span><br><span class="line">y_train,y_test=tf.cast(train_y,tf.int16),tf.cast(test_y,tf.int16)</span><br><span class="line">X_train=tf.reshape(X_train,[<span class="number">60000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br><span class="line">X_test=tf.reshape(X_test,[<span class="number">10000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">#4.建立模型</span></span><br><span class="line">model=tf.keras.Sequential()</span><br><span class="line"><span class="comment">#添加卷积层1</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">16</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu,input_shape=(<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))</span><br><span class="line"><span class="comment">#添加池化层1</span></span><br><span class="line">model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment">#添加卷积层2</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">32</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line"><span class="comment">#添加池化层2</span></span><br><span class="line">model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment">#添加Flatten层，将数据拉直</span></span><br><span class="line">model.add(tf.keras.layers.Flatten())</span><br><span class="line"><span class="comment">#添加隐含层和输出层</span></span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">128</span>,activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&quot;softmax&quot;</span>))</span><br><span class="line">model.summary()</span><br><span class="line"><span class="comment">#5.配置训练方法</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;adam&quot;</span>,loss=<span class="string">&quot;sparse_categorical_crossentropy&quot;</span>,metrics=[<span class="string">&quot;sparse_categorical_accuracy&quot;</span>])</span><br><span class="line"><span class="comment">#6.训练模型</span></span><br><span class="line"><span class="comment">#model.load_weights(&quot;mnist_save_weights_CNN.h5&quot;)</span></span><br><span class="line">history=model.fit(X_train,y_train,batch_size=<span class="number">64</span>,epochs=<span class="number">5</span>,validation_split=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment">#7.评估模型</span></span><br><span class="line">model.evaluate(X_test,y_test,verbose=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#8.保存训练日志并绘制训练曲线</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span></span><br><span class="line">pd.DataFrame(history.history).to_csv(<span class="string">&quot;trainning_log.csv&quot;</span>,index=<span class="literal">False</span>)</span><br><span class="line">graph=pd.read_csv(<span class="string">&quot;trainning_log.csv&quot;</span>)</span><br><span class="line">graph.plot(figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">plt.grid(<span class="number">1</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#9.使用模型</span></span><br><span class="line"><span class="comment"># 下面再随机取出测试集中的任意10个数据进行识别</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.suptitle(<span class="string">&quot;随机取出测试集中的任意10个数据进行识别&quot;</span>, fontsize=<span class="number">20</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    num = np.random.randint(<span class="number">1</span>, <span class="number">10000</span>)</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">5</span>, i+<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(test_x[num], cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    y_pred = np.argmax(model.predict(tf.reshape(X_test[num],(<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>))))</span><br><span class="line">    plt.title(<span class="string">&quot;y= &quot;</span>+<span class="built_in">str</span>(test_y[num]) + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;y_pred=&quot;</span> + <span class="built_in">str</span>(y_pred))</span><br><span class="line">plt.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.98</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>Model: &quot;sequential_2&quot;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d_4 (Conv2D)            (None, 28, 28, 16)        160       
_________________________________________________________________
max_pooling2d_4 (MaxPooling2 (None, 14, 14, 16)        0         
_________________________________________________________________
conv2d_5 (Conv2D)            (None, 14, 14, 32)        4640      
_________________________________________________________________
max_pooling2d_5 (MaxPooling2 (None, 7, 7, 32)          0         
_________________________________________________________________
flatten_2 (Flatten)          (None, 1568)              0         
_________________________________________________________________
dense_4 (Dense)              (None, 128)               200832    
_________________________________________________________________
dense_5 (Dense)              (None, 10)                1290      
=================================================================
Total params: 206,922
Trainable params: 206,922
Non-trainable params: 0
_________________________________________________________________
Epoch 1/5
750/750 [==============================] - 25s 32ms/step - loss: 0.2131 - sparse_categorical_accuracy: 0.9379 - val_loss: 0.0909 - val_sparse_categorical_accuracy: 0.9721
Epoch 2/5
750/750 [==============================] - 25s 33ms/step - loss: 0.0646 - sparse_categorical_accuracy: 0.9796 - val_loss: 0.0538 - val_sparse_categorical_accuracy: 0.9843
Epoch 3/5
750/750 [==============================] - 25s 34ms/step - loss: 0.0429 - sparse_categorical_accuracy: 0.9872 - val_loss: 0.0508 - val_sparse_categorical_accuracy: 0.9859
Epoch 4/5
750/750 [==============================] - 25s 34ms/step - loss: 0.0332 - sparse_categorical_accuracy: 0.9892 - val_loss: 0.0412 - val_sparse_categorical_accuracy: 0.9892
Epoch 5/5
750/750 [==============================] - 25s 33ms/step - loss: 0.0246 - sparse_categorical_accuracy: 0.9920 - val_loss: 0.0450 - val_sparse_categorical_accuracy: 0.9855
313/313 - 2s - loss: 0.0345 - sparse_categorical_accuracy: 0.9884
</code></pre><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_14_1.png" alt="output_14_1"></p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_14_2.png" alt="output_14_2"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存训练的模型参数</span></span><br><span class="line">model.save_weights(<span class="string">&quot;mnist_save_weights_CNN.h5&quot;</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="卷积神经网络的优化"><a href="#卷积神经网络的优化" class="headerlink" title="卷积神经网络的优化"></a>卷积神经网络的优化</h1><h2 id="1-Dropout-：减少过拟合"><a href="#1-Dropout-：减少过拟合" class="headerlink" title="1.Dropout()：减少过拟合"></a>1.Dropout()：减少过拟合</h2><ul>
<li>随机让神经网络的某些隐含层节点停止工作，也就是让他们的权值为0</li>
<li><strong>tf.layers.Dropout(inputs,rate,seed=None,training=False,name=None)</strong></li>
<li>inputs为输入的张量</li>
<li>rate指定神经元每一次随机被丢弃的比例</li>
<li>seed丢弃固定位置的神经元</li>
<li>trainning=True处于训练阶段时，才会进行dropout操作</li>
<li>name表示dropout层的名称</li>
</ul>
<h2 id="2-级联卷积核"><a href="#2-级联卷积核" class="headerlink" title="2.级联卷积核"></a>2.级联卷积核</h2><ul>
<li>使用两个3×3的卷积核级联与使用一个5×5的卷积核得到的感受野是一样的，但参数个数却少了<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107124918062.png" alt="image-20221107124918062" style="zoom:33%;"></li>
<li>多通道的级联卷积核<br><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107124939129.png" alt="image-20221107124939129" style="zoom:33%;"></li>
</ul>
<hr>
<h1 id="实例：卷积神经网络识别cifar10图片"><a href="#实例：卷积神经网络识别cifar10图片" class="headerlink" title="实例：卷积神经网络识别cifar10图片"></a>实例：卷积神经网络识别cifar10图片</h1><h2 id="1-设计卷积神经网络的结构"><a href="#1-设计卷积神经网络的结构" class="headerlink" title="1.设计卷积神经网络的结构"></a>1.设计卷积神经网络的结构</h2><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20221107125056907.png" alt="image-20221107125056907"></p>
<h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.导入库</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#2.加载数据</span></span><br><span class="line">cifar10=tf.keras.datasets.cifar10</span><br><span class="line">(train_x,train_y),(test_x,test_y)=cifar10.load_data()</span><br><span class="line"><span class="comment">#3.数据预处理:对属性进行归一化并转化为Tensor张量</span></span><br><span class="line">X_train,X_test=tf.cast(train_x/<span class="number">255.0</span>,tf.float32),tf.cast(test_x/<span class="number">255.0</span>,tf.float32)</span><br><span class="line">Y_train,Y_test=tf.cast(train_y,tf.int16),tf.cast(test_y,tf.int16)</span><br><span class="line"><span class="comment">#4.建立模型</span></span><br><span class="line">model=tf.keras.Sequential()</span><br><span class="line"><span class="comment">#添加卷积层1-1、1-2、池化层1</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">16</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu,input_shape=(<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>)))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">16</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(tf.keras.layers.Dropout(<span class="number">0.2</span>))</span><br><span class="line"><span class="comment">#添加卷积层2-1、2-2、池化层2</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">32</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">32</span>,kernel_size=(<span class="number">3</span>,<span class="number">3</span>),padding=<span class="string">&quot;same&quot;</span>,activation=tf.nn.relu))</span><br><span class="line">model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(tf.keras.layers.Dropout(<span class="number">0.2</span>))</span><br><span class="line"><span class="comment">#添加Flatten层，将数据拉直</span></span><br><span class="line">model.add(tf.keras.layers.Flatten())</span><br><span class="line">model.add(tf.keras.layers.Dropout(<span class="number">0.2</span>))</span><br><span class="line"><span class="comment">#添加隐含层和输出层</span></span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">128</span>,activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(tf.keras.layers.Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">&quot;softmax&quot;</span>))</span><br><span class="line">model.summary()</span><br><span class="line"><span class="comment">#5.配置训练方法</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;adam&quot;</span>,loss=<span class="string">&quot;sparse_categorical_crossentropy&quot;</span>,metrics=[<span class="string">&quot;sparse_categorical_accuracy&quot;</span>])</span><br><span class="line"><span class="comment">#6.训练模型</span></span><br><span class="line">history=model.fit(X_train,Y_train,batch_size=<span class="number">64</span>,epochs=<span class="number">10</span>,validation_split=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment">#7.评估模型</span></span><br><span class="line">model.evaluate(X_test,Y_test,verbose=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#8.保存训练日志并绘制训练曲线</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span></span><br><span class="line">pd.DataFrame(history.history).to_csv(<span class="string">&quot;cifar10_trainning_log.csv&quot;</span>,index=<span class="literal">False</span>)</span><br><span class="line">graph=pd.read_csv(<span class="string">&quot;cifar10_trainning_log.csv&quot;</span>)</span><br><span class="line">graph.plot(figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">plt.grid(<span class="number">1</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#9.使用模型</span></span><br><span class="line"><span class="comment"># 下面再随机取出测试集中的任意10个数据进行识别</span></span><br><span class="line">plt.figure()                                       </span><br><span class="line">plt.suptitle(<span class="string">&quot;随机取出测试集中的任意10个数据进行识别&quot;</span>, fontsize=<span class="number">20</span>, color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    num = np.random.randint(<span class="number">1</span>, <span class="number">10000</span>)</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">5</span>, i+<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(test_x[num], cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    y_pred = np.argmax(model.predict(tf.reshape(X_test[num],(<span class="number">1</span>,<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>))))</span><br><span class="line">    plt.title(<span class="string">&quot;标签值：&quot;</span>+<span class="built_in">str</span>(test_y[num,<span class="number">0</span>]) + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;预测值：&quot;</span> + <span class="built_in">str</span>(y_pred))</span><br><span class="line">plt.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.98</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>Model: &quot;sequential_3&quot;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d_6 (Conv2D)            (None, 32, 32, 16)        448       
_________________________________________________________________
conv2d_7 (Conv2D)            (None, 32, 32, 16)        2320      
_________________________________________________________________
max_pooling2d_6 (MaxPooling2 (None, 16, 16, 16)        0         
_________________________________________________________________
dropout (Dropout)            (None, 16, 16, 16)        0         
_________________________________________________________________
conv2d_8 (Conv2D)            (None, 16, 16, 32)        4640      
_________________________________________________________________
conv2d_9 (Conv2D)            (None, 16, 16, 32)        9248      
_________________________________________________________________
max_pooling2d_7 (MaxPooling2 (None, 8, 8, 32)          0         
_________________________________________________________________
dropout_1 (Dropout)          (None, 8, 8, 32)          0         
_________________________________________________________________
flatten_3 (Flatten)          (None, 2048)              0         
_________________________________________________________________
dropout_2 (Dropout)          (None, 2048)              0         
_________________________________________________________________
dense_6 (Dense)              (None, 128)               262272    
_________________________________________________________________
dropout_3 (Dropout)          (None, 128)               0         
_________________________________________________________________
dense_7 (Dense)              (None, 10)                1290      
=================================================================
Total params: 280,218
Trainable params: 280,218
Non-trainable params: 0
_________________________________________________________________
Epoch 1/10
625/625 [==============================] - 76s 120ms/step - loss: 1.6868 - sparse_categorical_accuracy: 0.3793 - val_loss: 1.3407 - val_sparse_categorical_accuracy: 0.5164
Epoch 2/10
625/625 [==============================] - 76s 122ms/step - loss: 1.3250 - sparse_categorical_accuracy: 0.5247 - val_loss: 1.1971 - val_sparse_categorical_accuracy: 0.5724
Epoch 3/10
625/625 [==============================] - 76s 122ms/step - loss: 1.1885 - sparse_categorical_accuracy: 0.5766 - val_loss: 1.0775 - val_sparse_categorical_accuracy: 0.6217
Epoch 4/10
625/625 [==============================] - 75s 121ms/step - loss: 1.1078 - sparse_categorical_accuracy: 0.6027 - val_loss: 1.0216 - val_sparse_categorical_accuracy: 0.6404
Epoch 5/10
625/625 [==============================] - 75s 121ms/step - loss: 1.0438 - sparse_categorical_accuracy: 0.6285 - val_loss: 0.9560 - val_sparse_categorical_accuracy: 0.6635
Epoch 6/10
625/625 [==============================] - 76s 122ms/step - loss: 0.9973 - sparse_categorical_accuracy: 0.6466 - val_loss: 0.9293 - val_sparse_categorical_accuracy: 0.6713
Epoch 7/10
625/625 [==============================] - 76s 121ms/step - loss: 0.9587 - sparse_categorical_accuracy: 0.6584 - val_loss: 0.9301 - val_sparse_categorical_accuracy: 0.6723
Epoch 8/10
625/625 [==============================] - 75s 121ms/step - loss: 0.9225 - sparse_categorical_accuracy: 0.6694 - val_loss: 0.8832 - val_sparse_categorical_accuracy: 0.6938
Epoch 9/10
625/625 [==============================] - 76s 121ms/step - loss: 0.8886 - sparse_categorical_accuracy: 0.6809 - val_loss: 0.8450 - val_sparse_categorical_accuracy: 0.6965
Epoch 10/10
625/625 [==============================] - 76s 121ms/step - loss: 0.8632 - sparse_categorical_accuracy: 0.6917 - val_loss: 0.8446 - val_sparse_categorical_accuracy: 0.7016
313/313 - 7s - loss: 0.8541 - sparse_categorical_accuracy: 0.7033
</code></pre><p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_22_1.png" alt="output_22_1"></p>
<p><img src="/2022/11/07/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/output_22_2.png" alt="output_22_2"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存所有模型与数据</span></span><br><span class="line">model.save(<span class="string">&quot;cifar10_save_all.h5&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>TensorFlow</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之数据类型</title>
    <url>/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>C++之数据类型……</p>
<span id="more"></span>
<h1 id="信息在计算机中的表示"><a href="#信息在计算机中的表示" class="headerlink" title="信息在计算机中的表示"></a>信息在计算机中的表示</h1><ul>
<li>二进制数：0、1，称为一个bit（b）</li>
<li>八个二进制位称为一个byte（B）</li>
</ul>
<script type="math/tex; mode=display">
2^{10}B=1KB,\,2^{10}KB=1MB,\,2^{10}MB=1GB,\,2^{10}GB=1TB</script><hr>
<h1 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h1><ul>
<li><p>short至少16位</p>
</li>
<li><p>int至少与short一样长</p>
</li>
<li><p>long至少32位，且至少与int一样长</p>
</li>
<li><p>long long至少64位，且至少与long一样长</p>
</li>
<li><p>若不加usigned，默认为有符号整数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用sizeof查看变量所占字节数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;int is &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>)&lt;&lt;<span class="string">&quot; bytes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;short is &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">short</span>)&lt;&lt;<span class="string">&quot; bytes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;long is &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">long</span>)&lt;&lt;<span class="string">&quot; bytes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;long long is &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)&lt;&lt;<span class="string">&quot; bytes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过climits库中的变量查看数据类型的最值</span></span><br><span class="line">    <span class="type">int</span> n_int=INT_MAX;</span><br><span class="line">    <span class="type">short</span> n_short=SHRT_MAX;</span><br><span class="line">    <span class="type">long</span> n_long=LONG_MAX;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n_llong=LLONG_MAX;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;int max is:&quot;</span>&lt;&lt;n_int&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;short max is:&quot;</span>&lt;&lt;n_short&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;long max is:&quot;</span>&lt;&lt;n_long&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;long long max is:&quot;</span>&lt;&lt;n_llong&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221104202738975.png" alt="image-20221104202738975"></p>
</li>
<li><p>char与cout.put()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//char字符的使用</span></span><br><span class="line">    <span class="type">char</span> ch=<span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> i=ch;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The char is:&quot;</span>&lt;&lt;ch&lt;&lt;endl;<span class="comment">//cin和cout的行为都是由变量类型引导的</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The ASCII code is:&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用cout对象中的.put()方法显示单个字符</span></span><br><span class="line">    cout.<span class="built_in">put</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221106155936150.png" alt="image-20221106155936150"></p>
</li>
<li><p>溢出问题：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221104200504476.png" alt="image-20221104200504476" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h1 id="进制的表示与显示"><a href="#进制的表示与显示" class="headerlink" title="进制的表示与显示"></a>进制的表示与显示</h1><ul>
<li>十六进制：0x开头</li>
<li>八进制：0开头</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//进制表示</span></span><br><span class="line">    <span class="type">int</span> D10=<span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> D16=<span class="number">0x42</span>;</span><br><span class="line">    <span class="type">int</span> D8=<span class="number">042</span>;</span><br><span class="line">    <span class="comment">//进制显示</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;D10 is:&quot;</span>&lt;&lt;D10&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;hex;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;D16 is:&quot;</span>&lt;&lt;D16&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;oct;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;D8 is:&quot;</span>&lt;&lt;D8&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221104202636559.png" alt="image-20221104202636559" style="zoom: 67%;"></p>
<hr>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221106155734492.png" alt="image-20221106155734492"></p>
<hr>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h2 id="1-书写浮点数"><a href="#1-书写浮点数" class="headerlink" title="1.书写浮点数"></a>1.书写浮点数</h2><ul>
<li><p>使用常用的标准小数点表示</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221106182523410.png" alt="image-20221106182523410" style="zoom:80%;"></p>
</li>
<li><p>使用E/e表示法</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221106182623534.png" alt="image-20221106182623534" style="zoom:80%;"></p>
</li>
</ul>
<h2 id="2-浮点数的有效位数"><a href="#2-浮点数的有效位数" class="headerlink" title="2.浮点数的有效位数"></a>2.浮点数的有效位数</h2><ul>
<li><p>C++有3种浮点类型：float、double、long double</p>
</li>
<li><p>float至少32位，double至少48位，且不少于float、long double至少和double一样多</p>
</li>
<li><p>float的精度（6~7位，其中6位一定是准的）比double低，<strong>尽量用double类型表示浮点数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//浮点数的精度问题</span></span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::fixed,ios_base::floatfield);<span class="comment">//强制cout显示小数点后6位</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> tub=<span class="number">10.0</span>/<span class="number">3.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> million=<span class="number">1.0E6</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;tub= &quot;</span>&lt;&lt;tub&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A million tubs= &quot;</span>&lt;&lt;million*tub&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Ten million tubs= &quot;</span>&lt;&lt;<span class="number">10</span>*million*tub&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> mints=<span class="number">10.0</span>/<span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;tub= &quot;</span>&lt;&lt;mints&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A million mints= &quot;</span>&lt;&lt;million*mints&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Ten million mints= &quot;</span>&lt;&lt;<span class="number">10</span>*million*mints&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221106184428062.png" alt="image-20221106184428062"></p>
</li>
</ul>
<h2 id="3-浮点数的优缺点"><a href="#3-浮点数的优缺点" class="headerlink" title="3.浮点数的优缺点"></a>3.浮点数的优缺点</h2><ul>
<li><p>优点：首先，它可以表示整数之间的值，其次，由于有缩放因子，它可以表示的范围大很多</p>
</li>
<li><p>缺点：浮点运算的速度通常比整数运算慢，且精度将降低</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//浮点数的缺点</span></span><br><span class="line">    <span class="type">float</span> a=<span class="number">2.34E22</span>;</span><br><span class="line">    <span class="type">float</span> b=a+<span class="number">1.0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;b-a&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221106185926389.png" alt="image-20221106185926389"></p>
</li>
</ul>
<hr>
<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><ul>
<li><code>(typeName) value</code></li>
<li><code>typeName (value)</code></li>
</ul>
<hr>
<h1 id="实例1：对输入的整数，求其对应的天数小时分钟秒数"><a href="#实例1：对输入的整数，求其对应的天数小时分钟秒数" class="headerlink" title="实例1：对输入的整数，求其对应的天数小时分钟秒数"></a>实例1：对输入的整数，求其对应的天数小时分钟秒数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//问题：输出一个整数，计算其对应多少天多少小时多少分钟多少秒</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Day_to_hour=<span class="number">24</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Hour_to_minute=<span class="number">60</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Minute_to_second=<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> seconds=<span class="number">31600000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter the number of seconds: &quot;</span>;</span><br><span class="line">    cin&gt;&gt;seconds;</span><br><span class="line">    cout&lt;&lt;seconds;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> days,hours,minutes;</span><br><span class="line">    days=seconds/(Day_to_hour*Hour_to_minute*Minute_to_second);</span><br><span class="line">    seconds=seconds%(Day_to_hour*Hour_to_minute*Minute_to_second);</span><br><span class="line">    hours=seconds/(Hour_to_minute*Minute_to_second);</span><br><span class="line">    seconds=seconds%(Hour_to_minute*Minute_to_second);</span><br><span class="line">    minutes=seconds/Minute_to_second;</span><br><span class="line">    seconds=seconds%Minute_to_second;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; seconds= &quot;</span>&lt;&lt;days&lt;&lt;<span class="string">&quot;days, &quot;</span>&lt;&lt;hours&lt;&lt;<span class="string">&quot; hours, &quot;</span>&lt;&lt;minutes&lt;&lt;<span class="string">&quot; minutes, &quot;</span>&lt;&lt;seconds&lt;&lt;<span class="string">&quot; seconds&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221108181917206.png" alt="image-20221108181917206"></p>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>数组中每个元素必须是相同的数据类型</li>
<li>计算机在内存中依次存储数组的各个元素</li>
</ul>
<h2 id="1-数组的声明"><a href="#1-数组的声明" class="headerlink" title="1.数组的声明"></a>1.数组的声明</h2><ul>
<li><code>typeName arrayName[arraySize]</code>;</li>
<li>arraySize必须是整数常量或const值或常量表达式</li>
</ul>
<h2 id="2-数组的初始化"><a href="#2-数组的初始化" class="headerlink" title="2.数组的初始化"></a>2.数组的初始化</h2><ul>
<li><code>int cards[4]=&#123;3,6,8,10&#125;</code></li>
<li>如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0</li>
<li><code>short things[]=&#123;1,5,3,8&#125;</code>//编译器将使things数组包含4个元素</li>
<li><code>unsigned int couts[10]=&#123;&#125;</code>//若不在大括号内包含任何东西，编译器将把所有元素都设置为零</li>
</ul>
<h2 id="3-矩阵乘法的实现"><a href="#3-矩阵乘法的实现" class="headerlink" title="3.矩阵乘法的实现"></a>3.矩阵乘法的实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ROWS=<span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> COLS=<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[ROWS][COLS];</span><br><span class="line"><span class="type">int</span> b[ROWS][COLS];</span><br><span class="line"><span class="type">int</span> c[ROWS][COLS];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读入a、b矩阵</span></span><br><span class="line">    <span class="type">int</span> m,n,p,q;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;p&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;q;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算矩阵乘积</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;q;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印计算结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;q;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;c[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">2 3</span><br><span class="line">2 4 5</span><br><span class="line">2 1 3</span><br><span class="line">3 3</span><br><span class="line">1 1 1 </span><br><span class="line">2 3 2</span><br><span class="line">0 1 4</span><br><span class="line">输出：</span><br><span class="line">10 19 30</span><br><span class="line">4 8 16</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="1-字符串的创建"><a href="#1-字符串的创建" class="headerlink" title="1.字符串的创建"></a>1.字符串的创建</h2><ul>
<li><p>C-风格字符串：以‘\0作为字符数组的结尾</p>
<ul>
<li><code>char dog[8]=&#123;&#39;f&#39;, &#39;a&#39;, &#39;t&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, &#39;a&#39;, &#39;\0&#39;&#125;</code></li>
<li><code>char fish[]=&quot;Bubbles&quot;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size =<span class="number">15</span>;</span><br><span class="line">    <span class="type">char</span> name1[size];</span><br><span class="line">    <span class="type">char</span> name2[size]=<span class="string">&quot;C++owBoy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Howdy! I am &quot;</span>&lt;&lt;name2&lt;&lt;<span class="string">&quot;. What your name?&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;name1;</span><br><span class="line">    <span class="comment">//strlen()只计算字符串的长度，不包括空字符</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Your name has &quot;</span>&lt;&lt;<span class="built_in">strlen</span>(name1)&lt;&lt;<span class="string">&quot; letters&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//sizeof()计算的是字符串数组所占据的字节数，共有15个char类型，每个char占一个byte</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Your name take up &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(name1)&lt;&lt;<span class="string">&quot; bytes&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221108194822412.png" alt="image-20221108194822412"></p>
</li>
<li><p>使用string类创建字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string name=<span class="string">&quot;ssyttmsl&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-字符串的输入"><a href="#2-字符串的输入" class="headerlink" title="2.字符串的输入"></a>2.字符串的输入</h2><ul>
<li><p><code>cin.getline(variable,size)</code></p>
<ul>
<li><p>读取一行输入，直到到达换行符，然后将换行符丢弃</p>
</li>
<li><p>相比于直接cin，可以读取空格，否则cin遇到空格则会停止读取</p>
</li>
<li><strong>其中的第二个参数为size，最多存放size-1个字符</strong></li>
<li><strong>对于string类型的字符串</strong>，输入为<code>getline(cin,str)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*使用getline()读取一行数据*/</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size =<span class="number">15</span>;</span><br><span class="line">    <span class="type">char</span> name1[size];</span><br><span class="line">    <span class="type">char</span> name2[size]=<span class="string">&quot;C++owBoy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Howdy! I am &quot;</span>&lt;&lt;name2&lt;&lt;<span class="string">&quot;. What your name?&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>(name1,size);</span><br><span class="line">    <span class="comment">//strlen()只计算字符串的长度，不包括空字符</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Your name has &quot;</span>&lt;&lt;<span class="built_in">strlen</span>(name1)&lt;&lt;<span class="string">&quot; letters&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//sizeof()计算的是字符串数组所占据的字节数，共有15个char类型，每个char占一个byte</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Your name take up &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(name1)&lt;&lt;<span class="string">&quot; bytes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221109205139096.png" alt="image-20221109205139096"></p>
</li>
<li><p><code>cin.get(variable,size)</code></p>
<ul>
<li>读取一行输入，将换行符保留在输入序列中</li>
<li>直接使用cin也会读取换行符</li>
<li>使用不带任何参数的<code>cin.get()</code>，可读取下一行的字符(即使是换行符)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*使用get()读取一行数据*/</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size =<span class="number">15</span>;</span><br><span class="line">    <span class="type">char</span> name[size];</span><br><span class="line">    <span class="type">char</span> play[size];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter your name:&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(name,size);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter the sport you love:&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>();<span class="comment">//读取换行符</span></span><br><span class="line">    cin.<span class="built_in">get</span>(play,size);</span><br><span class="line">    cout&lt;&lt;name&lt;&lt;<span class="string">&quot; loves &quot;</span>&lt;&lt;play&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221109211059425.png" alt="image-20221109211059425"></p>
</li>
</ul>
<h2 id="3-字符串的赋值、拼接和附加"><a href="#3-字符串的赋值、拼接和附加" class="headerlink" title="3.字符串的赋值、拼接和附加"></a>3.字符串的赋值、拼接和附加</h2><ul>
<li><p>对于<strong>string类</strong>型的字符串：</p>
<ul>
<li><strong>赋值</strong>：一个string对象可以赋给另一个string对象，但char数组却不行</li>
<li><strong>拼接</strong>：使用运算符<code>+</code>将两个string对象合并起来</li>
<li><strong>附加</strong>：使用运算符<code>+=</code>将字符串附加到string对象的末尾</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*string的赋值、拼接、附加*/</span></span><br><span class="line">    string str1=<span class="string">&quot;ssy&quot;</span>;</span><br><span class="line">    string str2;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    str2=str1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The str2 is:&quot;</span>&lt;&lt;str2&lt;&lt;<span class="string">&quot;,which is equal to str1:&quot;</span>&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    str2=<span class="string">&quot; tql&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The str1+str2 is:&quot;</span>&lt;&lt;str1+str2&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//附加</span></span><br><span class="line">    str1+=<span class="string">&quot; is a excellent person.&quot;</span>;</span><br><span class="line">    cout&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221109235315552.png" alt="image-20221109235315552"></p>
</li>
<li><p>对于<strong>C风格</strong>的字符串</p>
<ul>
<li>赋值：<code>strcpy(charr1,charr2)</code>//将字符串数组charr2赋给charr1</li>
<li>附加：<code>strcat(charr1,charr2)</code>//将字符串数组charr2添加到charr1的末尾</li>
</ul>
</li>
</ul>
<h2 id="4-计算字符串的大小"><a href="#4-计算字符串的大小" class="headerlink" title="4.计算字符串的大小"></a>4.计算字符串的大小</h2><ul>
<li>对于<strong>C风格</strong>的字符串，使用<code>strlen()</code></li>
<li>对于<strong>string类</strong>型的字符串，使用<code>str.size()</code></li>
</ul>
<hr>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="1-结构体的创建及其初始化"><a href="#1-结构体的创建及其初始化" class="headerlink" title="1.结构体的创建及其初始化"></a>1.结构体的创建及其初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> grates;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义结构体对象及初始化</span></span><br><span class="line">    student ssy=&#123;<span class="string">&quot;ssy&quot;</span>,<span class="number">21</span>,<span class="number">99.98</span>&#125;;</span><br><span class="line">    ssy.age=<span class="number">22</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The age of student1 is:&quot;</span>&lt;&lt;ssy.age&lt;&lt;endl;</span><br><span class="line">    student wcf=&#123;<span class="string">&quot;wcf&quot;</span>,<span class="number">21</span>,<span class="number">98.99</span>&#125;;</span><br><span class="line">    <span class="comment">//结构体的调用</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The student1 is:&quot;</span>&lt;&lt;ssy.name&lt;&lt;<span class="string">&quot; and grates is:&quot;</span>&lt;&lt;ssy.grates&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The student2 is:&quot;</span>&lt;&lt;wcf.name&lt;&lt;<span class="string">&quot; and grates is:&quot;</span>&lt;&lt;wcf.grates&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//结构体可以直接赋值给另一个结构体</span></span><br><span class="line">    student cyr;</span><br><span class="line">    cyr=wcf;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The cyr is:&quot;</span>&lt;&lt;cyr.name&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221120223038507.png" alt="image-20221120223038507"></p>
<h2 id="2-结构体数组"><a href="#2-结构体数组" class="headerlink" title="2.结构体数组"></a>2.结构体数组</h2><ul>
<li>数组中的每一个元素都是结构体</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> grates;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结构数组的定义与初始化</span></span><br><span class="line">    student Stu_array[<span class="number">2</span>]=</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;ssy&quot;</span>,<span class="number">21</span>,<span class="number">99.98</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;wcf&quot;</span>,<span class="number">21</span>,<span class="number">98.99</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//结构数组的调用</span></span><br><span class="line">    cout&lt;&lt;Stu_array[<span class="number">0</span>].name&lt;&lt;<span class="string">&quot; and &quot;</span>&lt;&lt;Stu_array[<span class="number">1</span>].name&lt;&lt;<span class="string">&quot; are good frends&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221120223703994.png" alt="image-20221120223703994"></p>
<hr>
<h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><ul>
<li>共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，故共用体的长度为其最大成员的长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共用体的定义</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">one2all</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> ch;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义共用体对象</span></span><br><span class="line">    one2all demo;</span><br><span class="line">    <span class="comment">//因为int占四个字节，故取int所占的大小作为union所在存储的空间</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The size of union is:&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(demo)&lt;&lt;endl;</span><br><span class="line">    demo.ch=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="comment">//以char类型去访问存储的变量</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The char of demo is:&quot;</span>&lt;&lt;demo.ch&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//以int类型去访问存储的变量</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The int of demo is:&quot;</span>&lt;&lt;demo.n&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221120225842812.png" alt="image-20221120225842812"></p>
<hr>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul>
<li>枚举类型只有赋值运算，没有其他算数运算</li>
<li>只能对枚举类型赋予枚举中的值</li>
<li>枚举量是整形</li>
<li>默认枚举中的第一个数为0，后面的数依次＋1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型的定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">week</span>&#123;one=<span class="number">1</span>,two,three,four,five,six,seven&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义枚举对象</span></span><br><span class="line">    week demo;</span><br><span class="line">    <span class="comment">//对枚举对象赋值</span></span><br><span class="line">    demo=seven;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Today is week:&quot;</span>&lt;&lt;demo;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221120231905948.png" alt="image-20221120231905948"></p>
<hr>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="1-指针的定义与使用"><a href="#1-指针的定义与使用" class="headerlink" title="1.指针的定义与使用"></a>1.指针的定义与使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data=<span class="number">100</span>;</span><br><span class="line">    <span class="comment">//指针的定义</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="comment">//指针的初始化</span></span><br><span class="line">    p=&amp;data;<span class="comment">//或者在定义时直接初始化int *p=&amp;data;</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The address of data is:&quot;</span>&lt;&lt;&amp;data&lt;&lt;<span class="string">&quot; ,which is same as p:&quot;</span>&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//*p是指针的解引用，表示指针指向的那个变量</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The number of data is:&quot;</span>&lt;&lt;data&lt;&lt;<span class="string">&quot; ,which is same as *p:&quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    *p=*p+<span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Now the number of data is:&quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221121220631570.png" alt="image-20221121220631570"></p>
<p>形象解释取地址&amp;与*p：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221121221749902.png" alt="image-20221121221749902" style="zoom:50%;"></p>
<h2 id="2-内存分配：new与delete"><a href="#2-内存分配：new与delete" class="headerlink" title="2.内存分配：new与delete"></a>2.内存分配：new与delete</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//动态内存的分配</span></span><br><span class="line">    <span class="type">double</span> *p=<span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">    *p=<span class="number">100.11</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The content of P is:&quot;</span>&lt;&lt;p&lt;&lt;<span class="string">&quot;,and the data of *p is:&quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//可以看出p中地址每+1，是+了指向的数据类型所占的字节数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The P+1 is:&quot;</span>&lt;&lt;p+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The P+2 is:&quot;</span>&lt;&lt;p+<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The P+3 is:&quot;</span>&lt;&lt;p+<span class="number">3</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The address of P is:&quot;</span>&lt;&lt;&amp;p&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//使用delete释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221121223750515.png" alt="image-20221121223750515"></p>
<h2 id="3-使用new来创建动态数组"><a href="#3-使用new来创建动态数组" class="headerlink" title="3.使用new来创建动态数组"></a>3.使用new来创建动态数组</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用new来创建动态数组</span></span><br><span class="line">    <span class="type">double</span> *p=<span class="keyword">new</span> <span class="type">double</span> [<span class="number">3</span>];<span class="comment">//p最初会指向分配地址的首地址</span></span><br><span class="line">    <span class="comment">//可以对指针使用数组的方式对其赋值</span></span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">0.1</span>;</span><br><span class="line">    p[<span class="number">1</span>]=<span class="number">0.2</span>;</span><br><span class="line">    p[<span class="number">2</span>]=<span class="number">0.3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Array &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; is:&quot;</span>&lt;&lt;p[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    p=p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Array &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; is:&quot;</span>&lt;&lt;p[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    p=p<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//释放动态数组</span></span><br><span class="line">    <span class="keyword">delete</span> [] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221121225638392.png" alt="image-20221121225638392"></p>
<p>形象解释：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221121230342656.png" alt="image-20221121230342656" style="zoom: 50%;"></p>
<ul>
<li><strong>动态获取输入字符串</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getname</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用getname从而分配动态数组</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        name=<span class="built_in">getname</span>();</span><br><span class="line">        cout&lt;&lt;name&lt;&lt;<span class="string">&quot; at address &quot;</span>&lt;&lt;(<span class="type">int</span> *)name&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] name;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getname</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> array_name[<span class="number">80</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter your name:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;array_name;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p=<span class="keyword">new</span> <span class="type">char</span> [<span class="built_in">strlen</span>(array_name)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p,array_name);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221123150810181.png" alt="image-20221123150810181"></p>
<h2 id="4-指针与数组"><a href="#4-指针与数组" class="headerlink" title="4.指针与数组"></a>4.指针与数组</h2><ul>
<li><code>数组名</code>通常代表数组中第一个元素的起始地址</li>
<li><code>&amp;数组名</code>代表整个数组的起始地址</li>
<li><strong>其二者的区别在于它们+1时，前者加的是元素所占的字节数，后者加的是整个数组所占的字节数</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array1[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=array1;<span class="comment">//数组名代表数组第一个元素的起始地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The address of array &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; is:&quot;</span>&lt;&lt;(p+i)&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Array &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; is:&quot;</span>&lt;&lt;*(p+i)&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-----------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;array1 is:&quot;</span>&lt;&lt;array1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;array1[0] is:&quot;</span>&lt;&lt;&amp;array1[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//注意对存地址的变量加1，加的都是那个变量所代表的整个地址</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;array1 + 1 is:&quot;</span>&lt;&lt;array1+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;array1 is:&quot;</span>&lt;&lt;&amp;array1&lt;&lt;endl;<span class="comment">//&amp;array1代表整个数组的起始地址</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;array1 + 1 is:&quot;</span>&lt;&lt;&amp;array1+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(array1) is:&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(array1)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(*p) is:&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(*p)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221122215306985.png" alt="image-20221122215306985"></p>
<h2 id="5-指针与字符串"><a href="#5-指针与字符串" class="headerlink" title="5.指针与字符串"></a>5.指针与字符串</h2><ul>
<li>C-type类型的字符串的数组名虽代表第一个字符的首地址，但打印时却会打印出地址对应的整个字符串</li>
<li>可通过<code>（int *）</code>将数组名强制转化成整数指针输出，从而打印地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//指针与字符串</span></span><br><span class="line">    <span class="type">char</span> charray[<span class="number">4</span>]=<span class="string">&quot;ssy&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p=charray;</span><br><span class="line">    <span class="comment">//打印字符串的首地址，出来的会是对应的字符串</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The charray is:&quot;</span>&lt;&lt;charray&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The p is:&quot;</span>&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The &amp;p is:&quot;</span>&lt;&lt;&amp;p&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//将地址强制转化为整数指针，因为指针里面存储的就是地址</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The address of charray is:&quot;</span>&lt;&lt;(<span class="type">int</span> *)charray&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The address of charray is:&quot;</span>&lt;&lt;(<span class="type">int</span> *)p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The address of p+1 is:&quot;</span>&lt;&lt;(<span class="type">int</span> *)(p+<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The p+1 is:&quot;</span>&lt;&lt;(p+<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221122224702963.png" alt="image-20221122224702963"></p>
<h2 id="6-使用new创建动态结构"><a href="#6-使用new创建动态结构" class="headerlink" title="6.使用new创建动态结构"></a>6.使用new创建动态结构</h2><ul>
<li>使用<code>p-&gt;变量</code>访问结构体中的变量</li>
<li>或者使用<code>(*p).变量</code>访问结构体中的变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> grates;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建动态结构</span></span><br><span class="line">    student *p=<span class="keyword">new</span> student;</span><br><span class="line">    <span class="comment">//通过p-&gt;访问结构中的变量</span></span><br><span class="line">    p-&gt;name=<span class="string">&quot;ssy&quot;</span>;</span><br><span class="line">    p-&gt;age=<span class="number">21</span>;</span><br><span class="line">    p-&gt;grates=<span class="number">99.99</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The p-&gt;name is:&quot;</span>&lt;&lt;p-&gt;name&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The p-&gt;age is:&quot;</span>&lt;&lt;p-&gt;age&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The p-&gt;grates is&quot;</span>&lt;&lt;p-&gt;grates&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Also can use (*p).,like (*p).name is:&quot;</span>&lt;&lt;(*p).name&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221123144807095.png" alt="image-20221123144807095"></p>
<h2 id="7-结构体数组与结构体类型的指针数组"><a href="#7-结构体数组与结构体类型的指针数组" class="headerlink" title="7.结构体数组与结构体类型的指针数组"></a>7.结构体数组与结构体类型的指针数组</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">simple</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结构体数组</span></span><br><span class="line">    simple struct_array[<span class="number">3</span>];</span><br><span class="line">    simple *p=struct_array;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (p+i)-&gt;data=<span class="number">100</span>+i;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;struct_array data &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; is:&quot;</span>&lt;&lt;struct_array[i].data&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    simple s1,s2,s3;</span><br><span class="line">    s1.data=<span class="number">1</span>;</span><br><span class="line">    s2.data=<span class="number">2</span>;</span><br><span class="line">    s3.data=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构体类型的指针数组</span></span><br><span class="line">    simple *pointer_array[<span class="number">3</span>]=&#123;&amp;s1,&amp;s2,&amp;s3&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The data of pointer_array &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; is:&quot;</span>&lt;&lt;pointer_array[i]-&gt;data&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向指针的指针</span></span><br><span class="line">    simple **ptr=pointer_array;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(*(ptr+&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;))-&gt;data &quot;</span>&lt;&lt;<span class="string">&quot;is:&quot;</span>&lt;&lt;(*(ptr+i))-&gt;data&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221123162248897.png" alt="image-20221123162248897"></p>
<p>形象解释：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221123163611564.png" alt="image-20221123163611564"></p>
<h2 id="8-指针与const"><a href="#8-指针与const" class="headerlink" title="8.指针与const"></a>8.指针与const</h2><ul>
<li><p><code>const int *pt;</code>//不能通过指针去改变指针所指向变量的值，但能指针所指向的地址可以改变，即指针自身所存储的内容可以被改变</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221216220850065.png" alt="image-20221216220850065" style="zoom:50%;"></p>
</li>
<li><p><code>int *const pt;</code>//能通过指针去改变指针所指向变量的值，但不能改变指针中存储的内容，也就是指针一旦指定，就不能被改变去指向别的地址</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221216221039467.png" alt="image-20221216221039467" style="zoom:50%;"></p>
</li>
<li><p><code>const int *const pt;</code>//结合上述二者，即不能通过指针去改变指针所指向变量的值，也不能改变指针里的内容</p>
</li>
</ul>
<hr>
<h1 id="模板类vector与array"><a href="#模板类vector与array" class="headerlink" title="模板类vector与array"></a>模板类vector与array</h1><ul>
<li>模板类vector的调用格式：<code>vector&lt;typeName&gt; vt(n_elem);</code></li>
<li>模板类array的调用格式：<code>array&lt;typeName,n_elem&gt; arr;</code></li>
<li>需要包含的头文件有<code>&lt;vector&gt;</code>与<code>&lt;array&gt;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用vector类定义数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vector_array</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    vector_array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    vector_array[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    vector_array[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vector_array2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">//vector类可以将一个数组赋值给另一个数组</span></span><br><span class="line">    vector_array2=vector_array;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用array类定义数组</span></span><br><span class="line">    array&lt;<span class="type">double</span>,3&gt; array1=&#123;<span class="number">1.1</span>,<span class="number">2.1</span>,<span class="number">3.1</span>&#125;;</span><br><span class="line">    array&lt;<span class="type">double</span>,3&gt; array2;</span><br><span class="line">    <span class="comment">//array类可以将一个数组赋值给另一个数组</span></span><br><span class="line">    array2=array1;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;vector_array[0] is:&quot;</span>&lt;&lt;vector_array[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; at &quot;</span>&lt;&lt;&amp;vector_array[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;vector_array2[1] is:&quot;</span>&lt;&lt;vector_array2[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; at &quot;</span>&lt;&lt;&amp;vector_array2[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;array1[1] is:&quot;</span>&lt;&lt;array1[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; at &quot;</span>&lt;&lt;&amp;array1[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;array2[2] is:&quot;</span>&lt;&lt;array2[<span class="number">2</span>]&lt;&lt;<span class="string">&quot; at &quot;</span>&lt;&lt;&amp;array2[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/04/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221124182904615.png" alt="image-20221124182904615"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI基础之易错易忘知识点</title>
    <url>/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>小沈同学在回顾VLSI这门课程中，发现了许多容易遗忘的知识点以及之前一直没弄明白的知识点。下面是一些记录……</p>
<span id="more"></span>
<h1 id="MOS场效应晶体管"><a href="#MOS场效应晶体管" class="headerlink" title="MOS场效应晶体管"></a>MOS场效应晶体管</h1><h2 id="1-MOS管的工作原理"><a href="#1-MOS管的工作原理" class="headerlink" title="1.MOS管的工作原理"></a>1.MOS管的工作原理</h2><p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221103221528739.png" alt="image-20221103221528739"></p>
<h2 id="2-阈值电压"><a href="#2-阈值电压" class="headerlink" title="2.阈值电压"></a>2.阈值电压</h2><ul>
<li>Φms：与材料的功函数差有关</li>
<li>ΦF：费米电势，与温度和材料有关</li>
<li>QB：与衬底的掺杂浓度以及偏置条件有关</li>
<li>Cox：氧化层的厚度以及介电常数有关</li>
</ul>
<p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221103221921462.png" alt="image-20221103221921462" style="zoom: 25%;"></p>
<h2 id="3-MOS管的基本电流方程"><a href="#3-MOS管的基本电流方程" class="headerlink" title="3.MOS管的基本电流方程"></a>3.MOS管的基本电流方程</h2><p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221103222319446.png" alt="image-20221103222319446" style="zoom: 50%;"></p>
<h2 id="4-沟道长度调制效应产生原因"><a href="#4-沟道长度调制效应产生原因" class="headerlink" title="4.沟道长度调制效应产生原因"></a>4.沟道长度调制效应产生原因</h2><p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221103222543370.png" alt="image-20221103222543370" style="zoom: 50%;"></p>
<h2 id="5-MOS管的电容"><a href="#5-MOS管的电容" class="headerlink" title="5.MOS管的电容"></a>5.MOS管的电容</h2><h3 id="栅电容：覆盖电容-沟道电容"><a href="#栅电容：覆盖电容-沟道电容" class="headerlink" title="栅电容：覆盖电容+沟道电容"></a>栅电容：覆盖电容+沟道电容</h3><ul>
<li><p>覆盖电容：CGSO、CGDO</p>
<p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221103222956743.png" alt="image-20221103222956743" style="zoom: 50%;"></p>
</li>
<li><p>沟道电容：CGC=CGCD+CGCS+CGCB</p>
<p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221103223105683.png" alt="image-20221103223105683" style="zoom:50%;"></p>
</li>
</ul>
<h3 id="结电容：底板pn结电容-侧壁pn结电容"><a href="#结电容：底板pn结电容-侧壁pn结电容" class="headerlink" title="结电容：底板pn结电容+侧壁pn结电容"></a>结电容：底板pn结电容+侧壁pn结电容</h3><ul>
<li><p>底板pn结形成的电容：Cbottom</p>
<p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221103223643127.png" alt="image-20221103223643127" style="zoom: 50%;"></p>
</li>
<li><p>侧壁pn结形成的电容：Csw</p>
<p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221103223733404.png" alt="image-20221103223733404" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="6-体效应"><a href="#6-体效应" class="headerlink" title="6.体效应"></a>6.体效应</h2><p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221104205118895.png" alt="image-20221104205118895" style="zoom:33%;"></p>
<h2 id="7-阈值变化"><a href="#7-阈值变化" class="headerlink" title="7.阈值变化"></a>7.阈值变化</h2><ul>
<li>短沟效应</li>
<li>DIBL</li>
</ul>
<p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221104205539722.png" alt="image-20221104205539722" style="zoom: 50%;"></p>
<h2 id="8-影响MOS管阈值的效应总结"><a href="#8-影响MOS管阈值的效应总结" class="headerlink" title="8.影响MOS管阈值的效应总结"></a>8.影响MOS管阈值的效应总结</h2><ul>
<li>VBS：体效应</li>
<li>VDS：DIBL</li>
<li>L：短沟效应</li>
<li>温度：功函数和费米电势都和温度有关（阈值电压随温度升高而降低）</li>
<li>工艺参数：衬底掺杂浓度、表面电荷、注入电荷量……</li>
</ul>
<h2 id="9-温度对器件的影响"><a href="#9-温度对器件的影响" class="headerlink" title="9.温度对器件的影响"></a>9.温度对器件的影响</h2><ul>
<li>温度升高导通电流减小、漏电流增大</li>
<li>高温条件下电路的性能会下降</li>
</ul>
<hr>
<h1 id="复杂逻辑门的静态特性"><a href="#复杂逻辑门的静态特性" class="headerlink" title="复杂逻辑门的静态特性"></a>复杂逻辑门的静态特性</h1><ul>
<li>复杂逻辑门的静态特性与输入图形有关</li>
<li>复杂逻辑门的静态特性分析时要根据输入图像考虑上拉网络的等效晶体管尺寸和下拉网络的等效晶体管尺寸</li>
<li>同时要考虑到体效应</li>
</ul>
<p><img src="/2022/11/03/VLSI%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%98%93%E9%94%99%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221110005939095.png" alt="image-20221110005939095"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>VLSI</tag>
        <tag>易错易忘知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow基础之张量相关</title>
    <url>/2022/11/01/TensorFlow%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%A0%E9%87%8F%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>本节主要介绍了TensorFlow基础知识中与张量（Tensor）相关的部分，包括创建张量、张量运算、维度变换等</p>
<span id="more"></span>
<h1 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h1><ul>
<li>TensorFlow的定义：An end-to-end open source machine learning platform</li>
<li>TensorFlow中的”Tensor”表示张量，其实就是多维数组</li>
</ul>
<h2 id="1-张量的基本创建"><a href="#1-张量的基本创建" class="headerlink" title="1.张量的基本创建"></a>1.张量的基本创建</h2><ul>
<li><p><code>tf.constant(value,dtype,shape)</code></p>
</li>
<li><p>value可以是数字、python列表、numpy数组、bool类型、字符串</p>
</li>
<li><p>dtype:（可省略）</p>
<p>| 数据类型     | 描述                              |<br>| —————— | ————————————————- |<br>| tf.int8      | 8位有符号整数                     |<br>| tf.int16     | 16位有符号整数                    |<br>| tf.int32     | 32位有符号整数                    |<br>| tf.int64     | 64位有符号整数                    |<br>| tf.uint8     | 8位无符号整数                     |<br>| tf.float32   | 32位浮点数                        |<br>| tf.float64   | 64位浮点数                        |<br>| tf.string    | 字符串（非Unicode编码的字节数组） |<br>| tf.bool      | 布尔型                            |<br>| tf.complex64 | 复数，实数和虚数分别为32位浮点数  |</p>
</li>
<li><p>shape：张量的形状（可省略）</p>
</li>
</ul>
<h3 id="创建Tensor对象"><a href="#创建Tensor对象" class="headerlink" title="创建Tensor对象"></a>创建Tensor对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建张量</span></span><br><span class="line">tf.constant([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>&lt;tf.Tensor: shape=(2, 2), dtype=int32, numpy=
array([[1, 2],
       [3, 4]])&gt;
</code></pre><h3 id="使用张量-numpy-方法"><a href="#使用张量-numpy-方法" class="headerlink" title="使用张量.numpy()方法"></a>使用张量.numpy()方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用张量.numpy()方法</span></span><br><span class="line">a=tf.constant([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(a.numpy())</span><br><span class="line"><span class="built_in">print</span>(<span class="number">30</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">30</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>[[1 2]
 [3 4]]
------------------------------
tf.Tensor(
[[1 2]
 [3 4]], shape=(2, 2), dtype=int32)
------------------------------
&lt;class &#39;tensorflow.python.framework.ops.EagerTensor&#39;&gt;
</code></pre><h3 id="参数为数字时，shape"><a href="#参数为数字时，shape" class="headerlink" title="参数为数字时，shape=()"></a>参数为数字时，shape=()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参数为数字时，shape=()</span></span><br><span class="line"><span class="built_in">print</span>(tf.constant(<span class="number">1.0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">30</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line">tf.constant(<span class="number">1.</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tf.Tensor(1.0, shape=(), dtype=float32)</span><br><span class="line">------------------------------</span><br><span class="line">&lt;tf.Tensor: shape=(), dtype=float32, numpy=1.0&gt;</span><br></pre></td></tr></table></figure>
<h3 id="参数为NumPy数组"><a href="#参数为NumPy数组" class="headerlink" title="参数为NumPy数组"></a>参数为NumPy数组</h3><ul>
<li>numpy创建浮点数数组时，默认的浮点型是64位浮点数</li>
<li>当使用numpy数组创建张量时，TensorFlow会接受数组元素的数据类型，使用64位浮点数保存数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参数为Numpy数组</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">b=tf.constant(np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">c=tf.constant(np.array([[<span class="number">1.0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]))</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[1 2]
 [3 4]], shape=(2, 2), dtype=int32)
tf.Tensor(
[[1. 2.]
 [3. 4.]], shape=(2, 2), dtype=float64)
</code></pre><h3 id="参数为字符串"><a href="#参数为字符串" class="headerlink" title="参数为字符串"></a>参数为字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参数为字符串</span></span><br><span class="line">tf.constant(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>&lt;tf.Tensor: shape=(), dtype=string, numpy=b&#39;hello&#39;&gt;
</code></pre><h2 id="2-改变张量中元素的数据类型"><a href="#2-改变张量中元素的数据类型" class="headerlink" title="2.改变张量中元素的数据类型"></a>2.改变张量中元素的数据类型</h2><ul>
<li><code>tf.cast(x,dtype)</code>#将返回一个张量对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#改变张量中元素的数据类型</span></span><br><span class="line">tf.cast(b,dtype=tf.float32)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>&lt;tf.Tensor: shape=(2, 2), dtype=float32, numpy=
array([[1., 2.],
       [3., 4.]], dtype=float32)&gt;
</code></pre><h2 id="3-创建张量的其他函数"><a href="#3-创建张量的其他函数" class="headerlink" title="3.创建张量的其他函数"></a>3.创建张量的其他函数</h2><ul>
<li><code>tf.convert_to_tensor(数组/列表/数字/布尔型/字符串）</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#其他创建张量的函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tf.convert_to_tensor([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">8</span>]])))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>&lt;class &#39;tensorflow.python.framework.ops.EagerTensor&#39;&gt;
</code></pre><h2 id="4-判断是否为张量"><a href="#4-判断是否为张量" class="headerlink" title="4.判断是否为张量"></a>4.判断是否为张量</h2><ul>
<li><code>tf.is_tensor(a)</code></li>
<li><code>isinstance(a,tf.Tensor)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#判断是否为张量</span></span><br><span class="line"><span class="built_in">print</span>(tf.is_tensor(a))</span><br><span class="line"><span class="built_in">print</span>(tf.is_tensor([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">6</span>]]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a,tf.Tensor)) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(np.array([<span class="number">1</span>,<span class="number">2</span>]),np.ndarray))<span class="comment">#isinstance()还能判断是否为其他的类型</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>True
False
True
True
</code></pre><h2 id="5-创建全0张量和全1张量"><a href="#5-创建全0张量和全1张量" class="headerlink" title="5.创建全0张量和全1张量"></a>5.创建全0张量和全1张量</h2><ul>
<li>全0张量：<code>tf.zero(shape,dtype=tf.float32)</code></li>
<li>全1张量：<code>tf.ones(shape,dtype=tf.float32)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建全0张量和全1张量</span></span><br><span class="line"><span class="built_in">print</span>(tf.zeros((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(tf.zeros([<span class="number">1</span>,<span class="number">2</span>],dtype=tf.int32))<span class="comment">#shape也能用[]表示</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]], shape=(3, 4), dtype=float32)
tf.Tensor([[0 0]], shape=(1, 2), dtype=int32)
</code></pre><h2 id="6-创建元素值都相同的张量"><a href="#6-创建元素值都相同的张量" class="headerlink" title="6.创建元素值都相同的张量"></a>6.创建元素值都相同的张量</h2><ul>
<li><code>tf.fill(dims,value)</code></li>
<li>dims：形状</li>
<li>value：为要填充的值，根据此值确定数据类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常见元素值都相同的张量</span></span><br><span class="line"><span class="built_in">print</span>(tf.fill([<span class="number">2</span>,<span class="number">3</span>],<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tf.fill((<span class="number">2</span>,<span class="number">3</span>),<span class="number">6.0</span>))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[6 6 6]
 [6 6 6]], shape=(2, 3), dtype=int32)
----------------------------------------
tf.Tensor(
[[6. 6. 6.]
 [6. 6. 6.]], shape=(2, 3), dtype=float32)
</code></pre><h2 id="7-创建随机数张量"><a href="#7-创建随机数张量" class="headerlink" title="7.创建随机数张量"></a>7.创建随机数张量</h2><ul>
<li>正态分布：<code>tf.random.normal(shape,mean,stddev,dtype)</code><ul>
<li>mean：均值，默认为0</li>
<li>stddev：标准差，默认为1</li>
<li>dtype：数据类型，默认为float32</li>
</ul>
</li>
<li>截断正态分布：<code>tf.random.truncated_normal(shape,mean,stddev,dtype)</code><ul>
<li>返回一个截断的正态分布</li>
<li>截断的标准是2倍的标准差</li>
</ul>
</li>
<li>设置随机种子：<code>tf.random.set_seed()</code>#seed相同，产生的张量相同</li>
<li>均匀分布：<code>tf.random.uniform(shape,minval,maxval,dtype)</code>#maxval为开区间</li>
<li>随机打乱：<code>tf.random.shuffle()</code>#只打乱第一个维度的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建随机数张量</span></span><br><span class="line"><span class="comment">#1.正态分布</span></span><br><span class="line"><span class="built_in">print</span>(tf.random.normal([<span class="number">6</span>,<span class="number">6</span>]))</span><br><span class="line"><span class="built_in">print</span>(tf.random.truncated_normal([<span class="number">6</span>,<span class="number">6</span>]))<span class="comment">#截断正态分布：不可能出现区间[-2,2]以外的点</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">105</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#2.均匀分布</span></span><br><span class="line"><span class="built_in">print</span>(tf.random.uniform([<span class="number">3</span>,<span class="number">3</span>],<span class="number">0</span>,<span class="number">10</span>,dtype=tf.int32))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#3.随机打乱</span></span><br><span class="line"><span class="built_in">print</span>(tf.random.shuffle([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[ 0.8266079   0.7237875   0.3424334   0.49157178 -0.37519592  1.1376799 ]
 [-0.5669446  -0.3625808   1.5405077   0.6373274  -1.9455124  -0.7011395 ]
 [ 1.2457833  -0.39937112  0.57883924  1.0344775  -0.6350136  -1.3593744 ]
 [-0.74130106  1.8143122   0.5292364  -0.10480234 -1.7358512  -0.3791651 ]
 [ 0.5712524   0.9349497  -0.22174385 -0.59780544  0.78962743  0.5501346 ]
 [ 0.9522022   0.14572807 -0.21552448  1.7505981  -0.76506436 -2.3946    ]], shape=(6, 6), dtype=float32)
tf.Tensor(
[[ 0.36231953 -0.12280609 -1.0638309  -0.37071744 -0.73713136  1.2813414 ]
 [ 0.87333363 -1.4310946  -0.47064283  0.12014091 -0.92487514  1.3596456 ]
 [ 1.2385474   0.07997006 -0.07874179  0.13667127  0.44561246 -1.7509358 ]
 [-0.24318981 -0.09602328  1.65389     1.7249115  -0.5238166   0.24563125]
 [ 1.4265472  -0.01189587  0.2186302  -0.42843634  0.5324539   0.24380386]
 [-1.2853507  -1.6559658   0.54867435 -0.6609358   0.7402121   1.3007758 ]], shape=(6, 6), dtype=float32)
--------------------------------------------------------------------------------------------------------
tf.Tensor(
[[1 8 1]
 [0 8 4]
 [3 1 6]], shape=(3, 3), dtype=int32)
----------------------------------------
tf.Tensor(
[[1 2]
 [5 6]
 [3 4]], shape=(3, 2), dtype=int32)
----------------------------------------
</code></pre><h2 id="8-创建整数序列"><a href="#8-创建整数序列" class="headerlink" title="8.创建整数序列"></a>8.创建整数序列</h2><ul>
<li><code>tf.range(start,limit,delta=1,dtype)</code><ul>
<li>start可省略，默认为0</li>
<li>limit不可省略，为开区间</li>
<li>delta为步长，默认为1，可省略</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建整数序列</span></span><br><span class="line"><span class="built_in">print</span>(tf.<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor([1 3 5 7 9], shape=(5,), dtype=int32)
</code></pre><h2 id="9-Tensor对象的属性"><a href="#9-Tensor对象的属性" class="headerlink" title="9.Tensor对象的属性"></a>9.Tensor对象的属性</h2><ul>
<li><code>.ndim</code>：维度</li>
<li><code>.shape</code>：形状</li>
<li><code>.dtype</code>：类型</li>
<li><code>tf.shape(a)</code>：形状</li>
<li><code>tf.size(a)</code>：总数</li>
<li><code>tf.rank(a)</code>：维度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Tensor对象的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The nidm:&quot;</span>,a.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The shape:&quot;</span>,a.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The dtype:&quot;</span>,a.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">45</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The tf.size:&quot;</span>,tf.size(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The tf.shape:&quot;</span>,tf.shape(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The tf.rank:&quot;</span>,tf.rank(a))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>The nidm: 2
The shape: (2, 2)
The dtype: &lt;dtype: &#39;int32&#39;&gt;
---------------------------------------------
The tf.size: tf.Tensor(4, shape=(), dtype=int32)
The tf.shape: tf.Tensor([2 2], shape=(2,), dtype=int32)
The tf.rank: tf.Tensor(2, shape=(), dtype=int32)
</code></pre><hr>
<h1 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h1><h2 id="1-改变张量形状"><a href="#1-改变张量形状" class="headerlink" title="1.改变张量形状"></a>1.改变张量形状</h2><ul>
<li><code>tf.reshape(tensor,shape)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#改变张量形状</span></span><br><span class="line"><span class="built_in">print</span>(tf.reshape(a,[<span class="number">1</span>,<span class="number">4</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">48</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor([[1 2 3 4]], shape=(1, 4), dtype=int32)
------------------------------------------------
tf.Tensor(
[[1 2]
 [3 4]], shape=(2, 2), dtype=int32)
</code></pre><h2 id="2-增加和删除维度"><a href="#2-增加和删除维度" class="headerlink" title="2.增加和删除维度"></a>2.增加和删除维度</h2><ul>
<li>增加：<code>tf.expand_dims(input,axis)</code>#增加的维度长度为1</li>
<li>删除：<code>tf.squeeze(input,axis)</code>#只能删除长度为1的维度，若不指定axis，则删除所有长度为1的轴</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#增强和删除维度</span></span><br><span class="line">d=tf.<span class="built_in">range</span>(<span class="number">24</span>)</span><br><span class="line">d1=tf.reshape(d,[<span class="number">4</span>,<span class="number">6</span>])</span><br><span class="line"><span class="comment">#1.增加</span></span><br><span class="line">d2=tf.expand_dims(d1,axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(d2)</span><br><span class="line"><span class="comment">#2.删除</span></span><br><span class="line"><span class="built_in">print</span>(tf.squeeze(d2,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[[ 0  1  2  3  4  5]]

 [[ 6  7  8  9 10 11]]

 [[12 13 14 15 16 17]]

 [[18 19 20 21 22 23]]], shape=(4, 1, 6), dtype=int32)
tf.Tensor(
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]], shape=(4, 6), dtype=int32)
</code></pre><h2 id="3-交换维度"><a href="#3-交换维度" class="headerlink" title="3.交换维度"></a>3.交换维度</h2><ul>
<li><code>tf.transpose(a,perm)</code>#perm根据axis指定交换的顺序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#交换维度</span></span><br><span class="line">e=tf.<span class="built_in">range</span>(<span class="number">24</span>)</span><br><span class="line">e1=tf.reshape(e,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(tf.transpose(e1,[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[[ 0  1  2  3]
  [12 13 14 15]]

 [[ 4  5  6  7]
  [16 17 18 19]]

 [[ 8  9 10 11]
  [20 21 22 23]]], shape=(3, 2, 4), dtype=int32)
</code></pre><h2 id="4-拼接与分割"><a href="#4-拼接与分割" class="headerlink" title="4.拼接与分割"></a>4.拼接与分割</h2><ul>
<li>拼接：<code>tf.concat(tensors,axis)</code><ul>
<li>tensors：为所有需要拼接的张量列表</li>
<li>axis：指定在哪个轴上拼接</li>
</ul>
</li>
<li>分割：<code>tf.split(value,num_or_size_split,axis=0)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拼接与分割</span></span><br><span class="line"><span class="comment">#1.拼接</span></span><br><span class="line"><span class="built_in">print</span>(tf.concat([d1,d1],axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tf.concat([d1,d1],axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">60</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#2.分割</span></span><br><span class="line">x1,x2,x3=tf.split(d1,[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(x1,<span class="string">&#x27;\n&#x27;</span>,x2,<span class="string">&#x27;\n&#x27;</span>,x3)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]
 [ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]], shape=(8, 6), dtype=int32)
--------------------------------------------------
tf.Tensor(
[[ 0  1  2  3  4  5  0  1  2  3  4  5]
 [ 6  7  8  9 10 11  6  7  8  9 10 11]
 [12 13 14 15 16 17 12 13 14 15 16 17]
 [18 19 20 21 22 23 18 19 20 21 22 23]], shape=(4, 12), dtype=int32)
------------------------------------------------------------
tf.Tensor(
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]], shape=(2, 6), dtype=int32) 
 tf.Tensor([[12 13 14 15 16 17]], shape=(1, 6), dtype=int32) 
 tf.Tensor([[18 19 20 21 22 23]], shape=(1, 6), dtype=int32)
</code></pre><h2 id="5-堆叠与分解"><a href="#5-堆叠与分解" class="headerlink" title="5.堆叠与分解"></a>5.堆叠与分解</h2><ul>
<li>堆叠：<code>tf.stack(values,axis)</code></li>
<li>分解：<code>tf.unstack(values,axis)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#堆叠与分解</span></span><br><span class="line"><span class="comment">#1.堆叠</span></span><br><span class="line">x=tf.constant([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">y=tf.constant([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(tf.stack([x,y],axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(tf.stack([x,y],axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">80</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#2.分解</span></span><br><span class="line"><span class="built_in">print</span>(tf.unstack(d1,axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[1 2 3]
 [4 5 6]], shape=(2, 3), dtype=int32)
tf.Tensor(
[[1 4]
 [2 5]
 [3 6]], shape=(3, 2), dtype=int32)
--------------------------------------------------------------------------------
[&lt;tf.Tensor: shape=(6,), dtype=int32, numpy=array([0, 1, 2, 3, 4, 5])&gt;, &lt;tf.Tensor: shape=(6,), dtype=int32, numpy=array([ 6,  7,  8,  9, 10, 11])&gt;, &lt;tf.Tensor: shape=(6,), dtype=int32, numpy=array([12, 13, 14, 15, 16, 17])&gt;, &lt;tf.Tensor: shape=(6,), dtype=int32, numpy=array([18, 19, 20, 21, 22, 23])&gt;]
</code></pre><hr>
<h1 id="部分采样"><a href="#部分采样" class="headerlink" title="部分采样"></a>部分采样</h1><ul>
<li><code>tf.gather(params,axis,indices)</code>#用一个索引列表，将给定张量中，对应索引值的元素提取出来，但一次只能索引一个维度</li>
<li><code>tf.gather_nd(params,indices)</code>#可同时采样多个点</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#部分采样</span></span><br><span class="line"><span class="built_in">print</span>(d1)</span><br><span class="line"><span class="comment">#gather()：一次只能对一个维度索引</span></span><br><span class="line"><span class="built_in">print</span>(tf.gather(d1,axis=<span class="number">0</span>,indices=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span>(tf.gather(d1,axis=<span class="number">1</span>,indices=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#同时采样多个点/采样维度</span></span><br><span class="line"><span class="built_in">print</span>(tf.gather_nd(d1,[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>]]))</span><br><span class="line"><span class="built_in">print</span>(tf.gather_nd(d1,[[<span class="number">0</span>],[<span class="number">1</span>],[<span class="number">2</span>]]))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]], shape=(4, 6), dtype=int32)
tf.Tensor(
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [18 19 20 21 22 23]], shape=(3, 6), dtype=int32)
tf.Tensor(
[[ 0  1  3]
 [ 6  7  9]
 [12 13 15]
 [18 19 21]], shape=(4, 3), dtype=int32)
----------------------------------------
tf.Tensor([ 0  7 14 21], shape=(4,), dtype=int32)
tf.Tensor(
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]], shape=(3, 6), dtype=int32)
</code></pre><hr>
<h1 id="张量运算"><a href="#张量运算" class="headerlink" title="张量运算"></a>张量运算</h1><h2 id="1-基本数学运算"><a href="#1-基本数学运算" class="headerlink" title="1.基本数学运算"></a>1.基本数学运算</h2><ul>
<li><h3 id="加减乘法运算"><a href="#加减乘法运算" class="headerlink" title="加减乘法运算"></a>加减乘法运算</h3><p>| 算数操作          | 描述             |<br>| ————————- | ———————— |<br>| tf.add(x,y)       | 将x和y逐元素相加 |<br>| tf.substract(x,y) | 将x和y逐元素相减 |<br>| tf.multiply(x,y)  | 将x和y逐元素相乘 |<br>| tf.divide(x,y)    | 将x和y逐元素相除 |<br>| tf.math.mode(x,y) | 对x逐元素        |</p>
</li>
<li><h3 id="幂指对数运算"><a href="#幂指对数运算" class="headerlink" title="幂指对数运算"></a>幂指对数运算</h3><p>| 算数操作       | 描述                                               |<br>| ——————— | ————————————————————————— |<br>| tf.pow(x,y)    | 对x求y的幂次方<strong>（当y为小数时，x需为浮点数）</strong>     |<br>| tf.square(x)   | 对x逐元素求平方                                    |<br>| tf.sqrt(x)     | 对x逐元素开平方根                                  |<br>| tf.exp(x)      | 计算e的x次方<strong>（要求x为浮点数，且必须是float64）</strong> |<br>| tf.math.log(x) | 计算自然对数，底数为e<strong>（要求x为浮点数）</strong>         |</p>
</li>
<li><h3 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h3><p><img src="/2022/11/01/TensorFlow%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%A0%E9%87%8F%E7%9B%B8%E5%85%B3/image-20221101160451959.png" alt="image-20221101160451959" style="zoom:50%;"></p>
</li>
<li><h3 id="三角函数和反三角函数运算"><a href="#三角函数和反三角函数运算" class="headerlink" title="三角函数和反三角函数运算"></a>三角函数和反三角函数运算</h3><p><img src="/2022/11/01/TensorFlow%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%A0%E9%87%8F%E7%9B%B8%E5%85%B3/image-20221101160646689.png" alt="image-20221101160646689" style="zoom: 33%;"></p>
</li>
<li><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p><img src="/2022/11/01/TensorFlow%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%A0%E9%87%8F%E7%9B%B8%E5%85%B3/image-20221101160721869.png" alt="image-20221101160721869" style="zoom: 50%;"></p>
</li>
</ul>
<h2 id="2-向量乘法"><a href="#2-向量乘法" class="headerlink" title="2.向量乘法"></a>2.向量乘法</h2><ul>
<li><code>tf.matmul(a,b)</code></li>
<li><code>a @ b</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多维向量乘法</span></span><br><span class="line"><span class="comment">#三维向量×二维向量</span></span><br><span class="line">a1=tf.random.normal([<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line">b1=tf.random.normal([<span class="number">5</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(a1@b1)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">90</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#三维向量×三维向量</span></span><br><span class="line">a2=tf.constant(np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">b2=tf.constant(np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(a2)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">45</span>*<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b2)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">45</span>*<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a2@b2)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(
[[[ 2.203142    0.09738441  1.9606446  -1.1057658 ]
  [-0.27357578  0.14026386  0.94474745  2.1895509 ]
  [ 1.7446913  -0.9555952  -0.04033652  1.8337672 ]]

 [[-1.0159464   0.11673293 -0.04575142  0.06979337]
  [-1.342845    1.4855313   1.4126754  -0.32664305]
  [ 3.1746514  -1.7697542  -1.3596829   2.2296028 ]]], shape=(2, 3, 4), dtype=float32)
------------------------------------------------------------------------------------------
tf.Tensor(
[[[ 0  1  2]
  [ 3  4  5]]

 [[ 6  7  8]
  [ 9 10 11]]], shape=(2, 2, 3), dtype=int32)
*********************************************
tf.Tensor(
[[[ 0  1]
  [ 2  3]
  [ 4  5]]

 [[ 6  7]
  [ 8  9]
  [10 11]]], shape=(2, 3, 2), dtype=int32)
*********************************************
tf.Tensor(
[[[ 10  13]
  [ 28  40]]

 [[172 193]
  [244 274]]], shape=(2, 2, 2), dtype=int32)
</code></pre><h2 id="3-数据统计"><a href="#3-数据统计" class="headerlink" title="3.数据统计"></a>3.数据统计</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>tf.reduce_sum(input_tensor,axis)</td>
<td>求和，<strong>axis未指定时默认求全局</strong></td>
</tr>
<tr>
<td>tf.reduce_mean(input_tensor,axis)</td>
<td>求平均值，<strong>axis未指定时默认求全局</strong></td>
</tr>
<tr>
<td>tf.reduce_max(input_tensor,axis)</td>
<td>求最大值，<strong>axis未指定时默认求全局</strong></td>
</tr>
<tr>
<td>tf.reduce_min(input_tensor,axis)</td>
<td>求最小值，<strong>axis未指定时默认求全局</strong></td>
</tr>
<tr>
<td>tf.argmax(input_tensor,axis)</td>
<td>求最大值索引，<strong>axis默认为0</strong></td>
</tr>
<tr>
<td>tf.argmin(input_tensor,axis)</td>
<td>求最小值索引，<strong>axis默认为0</strong></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow实践之线性回归问题</title>
    <url>/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本节主要介绍了如何通过解析法与梯度下降法求解线性回归问题。</p>
<span id="more"></span>
<h1 id="解析法实现一元线性回归"><a href="#解析法实现一元线性回归" class="headerlink" title="解析法实现一元线性回归"></a>解析法实现一元线性回归</h1><ul>
<li><p>加载样本数据：x、y</p>
</li>
<li><p>学习模型：计算w、b</p>
<p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/image-20221101173858009.png" alt="image-20221101173858009" style="zoom:33%;"></p>
</li>
<li><p>预测：y_pred=w*x_test+b</p>
</li>
</ul>
<h2 id="1-纯Python实现"><a href="#1-纯Python实现" class="headerlink" title="1.纯Python实现"></a>1.纯Python实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加载样本数据：x、y</span></span><br><span class="line">x=[<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">124.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">138.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>]</span><br><span class="line">y=[<span class="number">145.00</span>,<span class="number">110.00</span>,<span class="number">93.00</span>,<span class="number">116.00</span>,<span class="number">65.32</span>,<span class="number">104.00</span>,<span class="number">118.00</span>,<span class="number">91.00</span>,<span class="number">62.00</span>,<span class="number">133.00</span>,<span class="number">51.00</span>,<span class="number">45.00</span>,<span class="number">78.50</span>,<span class="number">69.65</span>,<span class="number">75.69</span>,<span class="number">95.30</span>]</span><br><span class="line"><span class="comment">#学习模型：计算w、b</span></span><br><span class="line">x_mean=<span class="built_in">sum</span>(x)/<span class="built_in">len</span>(x)</span><br><span class="line">y_mean=<span class="built_in">sum</span>(y)/<span class="built_in">len</span>(y)</span><br><span class="line">sumXY=<span class="number">0.0</span></span><br><span class="line">sumX=<span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    sumXY+=(x[i]-x_mean)*(y[i]-y_mean)</span><br><span class="line">    sumX+=<span class="built_in">pow</span>((x[i]-x_mean),<span class="number">2</span>)</span><br><span class="line">w=sumXY/sumX</span><br><span class="line">b=y_mean-w*x_mean</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w:&quot;</span>,w)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>,b)</span><br><span class="line"><span class="comment">#预测房价</span></span><br><span class="line">x_test=[<span class="number">128.15</span>,<span class="number">45.00</span>,<span class="number">141.43</span>,<span class="number">106.27</span>,<span class="number">99.00</span>,<span class="number">53.84</span>,<span class="number">85.36</span>,<span class="number">70.00</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_test)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The Y of&quot;</span>,x_test[i],<span class="string">&#x27;is:&#x27;</span>,w*x_test[i]+b)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>w: 0.8945605120044221
b: 5.410840339418002
The Y of 128.15 is: 120.0487699527847
The Y of 45.0 is: 45.66606337961699
The Y of 141.43 is: 131.92853355220342
The Y of 106.27 is: 100.47578595012793
The Y of 99.0 is: 93.97233102785579
The Y of 53.84 is: 53.57397830573609
The Y of 85.36 is: 81.77052564411547
The Y of 70.0 is: 68.03007617972756
</code></pre><h2 id="2-NumPy实现"><a href="#2-NumPy实现" class="headerlink" title="2.NumPy实现"></a>2.NumPy实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#加载样本数据：x、y</span></span><br><span class="line">x=np.array([<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">124.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">138.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>])</span><br><span class="line">y=np.array([<span class="number">145.00</span>,<span class="number">110.00</span>,<span class="number">93.00</span>,<span class="number">116.00</span>,<span class="number">65.32</span>,<span class="number">104.00</span>,<span class="number">118.00</span>,<span class="number">91.00</span>,<span class="number">62.00</span>,<span class="number">133.00</span>,<span class="number">51.00</span>,<span class="number">45.00</span>,<span class="number">78.50</span>,<span class="number">69.65</span>,<span class="number">75.69</span>,<span class="number">95.30</span>])</span><br><span class="line"><span class="comment">#学习模型</span></span><br><span class="line">x_mean=np.mean(x)</span><br><span class="line">y_mean=np.mean(y)</span><br><span class="line">sumXY=np.<span class="built_in">sum</span>((x-x_mean)*(y-y_mean))</span><br><span class="line">sumX=np.<span class="built_in">sum</span>((x-x_mean)**<span class="number">2</span>)</span><br><span class="line">w=sumXY/sumX</span><br><span class="line">b=y_mean-w*x_mean</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w:&quot;</span>,w)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>,b)</span><br><span class="line"><span class="comment">#预测房价</span></span><br><span class="line">x_test=np.array([<span class="number">128.15</span>,<span class="number">45.00</span>,<span class="number">141.43</span>,<span class="number">106.27</span>,<span class="number">99.00</span>,<span class="number">53.84</span>,<span class="number">85.36</span>,<span class="number">70.00</span>])</span><br><span class="line">Y=w*x_test+b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Y is:&quot;</span>,Y)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>w: 0.894560512004422
b: 5.410840339418002
The Y is: [120.04876995  45.66606338 131.92853355 100.47578595  93.97233103
  53.57397831  81.77052564  68.03007618]
</code></pre><h2 id="3-TensorFlow实现"><a href="#3-TensorFlow实现" class="headerlink" title="3.TensorFlow实现"></a>3.TensorFlow实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">#加载样本数据：x、y</span></span><br><span class="line">x=tf.constant([<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">124.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">138.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>])</span><br><span class="line">y=tf.constant([<span class="number">145.00</span>,<span class="number">110.00</span>,<span class="number">93.00</span>,<span class="number">116.00</span>,<span class="number">65.32</span>,<span class="number">104.00</span>,<span class="number">118.00</span>,<span class="number">91.00</span>,<span class="number">62.00</span>,<span class="number">133.00</span>,<span class="number">51.00</span>,<span class="number">45.00</span>,<span class="number">78.50</span>,<span class="number">69.65</span>,<span class="number">75.69</span>,<span class="number">95.30</span>])</span><br><span class="line"><span class="comment">#学习模型</span></span><br><span class="line">x_mean=tf.reduce_mean(x)</span><br><span class="line">y_mean=tf.reduce_mean(y)</span><br><span class="line">sumXY=tf.reduce_sum((x-x_mean)*(y-y_mean))</span><br><span class="line">sumX=tf.reduce_sum((x-x_mean)**<span class="number">2</span>)</span><br><span class="line">w=sumXY/sumX</span><br><span class="line">b=y_mean-w*x_mean</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w:&quot;</span>,w.numpy())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>,b.numpy())</span><br><span class="line"><span class="comment">#预测房价</span></span><br><span class="line">x_test=tf.constant([<span class="number">128.15</span>,<span class="number">45.00</span>,<span class="number">141.43</span>,<span class="number">106.27</span>,<span class="number">99.00</span>,<span class="number">53.84</span>,<span class="number">85.36</span>,<span class="number">70.00</span>])</span><br><span class="line">Y=w*x_test+b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Y is:&quot;</span>,Y.numpy())</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>w: 0.8945604
b: 5.4108505
The Y is: [120.04876   45.66607  131.92853  100.475784  93.97233   53.573982
  81.77052   68.030075]
</code></pre><h2 id="4-数据和模型可视化"><a href="#4-数据和模型可视化" class="headerlink" title="4.数据和模型可视化"></a>4.数据和模型可视化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#加载数据样本</span></span><br><span class="line">x=tf.constant([<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">124.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">138.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>])</span><br><span class="line">y=tf.constant([<span class="number">145.00</span>,<span class="number">110.00</span>,<span class="number">93.00</span>,<span class="number">116.00</span>,<span class="number">65.32</span>,<span class="number">104.00</span>,<span class="number">118.00</span>,<span class="number">91.00</span>,<span class="number">62.00</span>,<span class="number">133.00</span>,<span class="number">51.00</span>,<span class="number">45.00</span>,<span class="number">78.50</span>,<span class="number">69.65</span>,<span class="number">75.69</span>,<span class="number">95.30</span>])</span><br><span class="line"><span class="comment">#学习模型</span></span><br><span class="line">x_mean=tf.reduce_mean(x)</span><br><span class="line">y_mean=tf.reduce_mean(y)</span><br><span class="line">sumXY=tf.reduce_sum((x-x_mean)*(y-y_mean))</span><br><span class="line">sumX=tf.reduce_sum((x-x_mean)**<span class="number">2</span>)</span><br><span class="line">w=sumXY/sumX</span><br><span class="line">b=y_mean-w*x_mean</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;线性模型：y=&#123;&#125;*x+&#123;&#125;&quot;</span>.<span class="built_in">format</span>(w.numpy(),b.numpy()))</span><br><span class="line"><span class="comment">#预测房价</span></span><br><span class="line">x_test=np.array([<span class="number">128.15</span>,<span class="number">45.00</span>,<span class="number">141.43</span>,<span class="number">106.27</span>,<span class="number">99.00</span>,<span class="number">53.84</span>,<span class="number">85.36</span>,<span class="number">70.00</span>])</span><br><span class="line">Y=(w*x_test+b).numpy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;面积\t房价&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_test)):</span><br><span class="line">    <span class="built_in">print</span>(x_test[i],<span class="string">&quot;\t&quot;</span>,<span class="built_in">round</span>(Y[i],<span class="number">2</span>)) <span class="comment">#round()四舍五入保留小数</span></span><br><span class="line"><span class="comment">#可视化</span></span><br><span class="line">plt.figure(num=<span class="string">&quot;一维线性回归数据可视化&quot;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span></span><br><span class="line">plt.scatter(x,y,color=<span class="string">&quot;red&quot;</span>,label=<span class="string">&quot;销售记录&quot;</span>)</span><br><span class="line">plt.scatter(x_test,Y,color=<span class="string">&quot;blue&quot;</span>,label=<span class="string">&quot;预测房价&quot;</span>)</span><br><span class="line">plt.plot(x_test,Y,color=<span class="string">&quot;green&quot;</span>,label=<span class="string">&quot;拟合直线&quot;</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;面积（平方米）&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;价格（万元）&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.xlim(<span class="number">40</span>,<span class="number">150</span>)</span><br><span class="line">plt.ylim(<span class="number">40</span>,<span class="number">150</span>)</span><br><span class="line">plt.suptitle(<span class="string">&quot;商品房销售价格评估系统v1.0&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.legend(loc=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>线性模型：y=0.8945603966712952*x+5.410850524902344
面积    房价
128.15      120.05
45.0      45.67
141.43      131.93
106.27      100.48
99.0      93.97
53.84      53.57
85.36      81.77
70.0      68.03
</code></pre><p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/output_7_1.png" alt="output_7_1" style="zoom: 80%;"></p>
<p>​    </p>
<hr>
<h1 id="解析法实现多元线性回归"><a href="#解析法实现多元线性回归" class="headerlink" title="解析法实现多元线性回归"></a>解析法实现多元线性回归</h1><ul>
<li><p>加载样本数据</p>
</li>
<li><p>数据处理：将输入的数据转化为模型要求的形式</p>
</li>
<li><p>学习模型：计算W</p>
<p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/image-20221101174733205.png" alt="image-20221101174733205" style="zoom: 33%;"></p>
</li>
<li><p>预测：Y=X@W</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#加载样本数据</span></span><br><span class="line">x1=np.array([<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">124.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">138.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>])</span><br><span class="line">x2=np.array([<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">y=np.array([<span class="number">145.00</span>,<span class="number">110.00</span>,<span class="number">93.00</span>,<span class="number">116.00</span>,<span class="number">65.32</span>,<span class="number">104.00</span>,<span class="number">118.00</span>,<span class="number">91.00</span>,<span class="number">62.00</span>,<span class="number">133.00</span>,<span class="number">51.00</span>,<span class="number">45.00</span>,<span class="number">78.50</span>,<span class="number">69.65</span>,<span class="number">75.69</span>,<span class="number">95.30</span>])</span><br><span class="line"><span class="comment">#数据处理：将输入的数据转化为模型要求的形式</span></span><br><span class="line"><span class="comment">#1.X：16*3</span></span><br><span class="line">x0=np.ones(<span class="built_in">len</span>(x1))</span><br><span class="line">X=np.stack([x0,x1,x2],axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The X is:\n&quot;</span>,X)</span><br><span class="line"><span class="comment">#2.Y：16*1</span></span><br><span class="line">Y=y.reshape(-<span class="number">1</span>,<span class="number">1</span>)<span class="comment">#-1表示根据数量自动匹配行的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Y is:\n&quot;</span>,Y)</span><br><span class="line"><span class="comment">#求解模型参数W</span></span><br><span class="line"><span class="comment">#1.计算X&#x27;</span></span><br><span class="line">Xt=np.transpose(X)</span><br><span class="line"><span class="comment">#2.计算(X&#x27;X)-1</span></span><br><span class="line">XtX_1=np.linalg.inv(np.matmul(Xt,X))</span><br><span class="line"><span class="comment">#3.计算(X&#x27;X)-1X&#x27;</span></span><br><span class="line">XtX_1_Xt=np.matmul(XtX_1,Xt)</span><br><span class="line"><span class="comment">#4.计算W=(X&#x27;X)-1X&#x27;Y</span></span><br><span class="line">W=np.matmul(XtX_1_Xt,Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The W is:\n&quot;</span>,W)</span><br><span class="line"><span class="comment">#转置W方便打印显示</span></span><br><span class="line">W=W.reshape(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;多元线性回归方程：Y=&#123;&#125;*x1+&#123;&#125;*x2+&#123;&#125;&quot;</span>.<span class="built_in">format</span>(W[<span class="number">1</span>],W[<span class="number">2</span>],W[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#预测房价</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入房屋面积和房间数，预测房屋销售价格：&quot;</span>)</span><br><span class="line">x1_test=<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;商品房面积：&quot;</span>))</span><br><span class="line">x2_test=<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;房间数：&quot;</span>))</span><br><span class="line">Y_pred=W[<span class="number">1</span>]*x1_test+W[<span class="number">2</span>]*x2_test+W[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;预测价格：&quot;</span>,<span class="built_in">round</span>(Y_pred,<span class="number">2</span>),<span class="string">&quot;万元&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>The X is:
 [[  1.   137.97   3.  ]
 [  1.   104.5    2.  ]
 [  1.   100.     2.  ]
 [  1.   124.32   3.  ]
 [  1.    79.2    1.  ]
 [  1.    99.     2.  ]
 [  1.   124.     3.  ]
 [  1.   114.     2.  ]
 [  1.   106.69   2.  ]
 [  1.   138.05   3.  ]
 [  1.    53.75   1.  ]
 [  1.    46.91   1.  ]
 [  1.    68.     1.  ]
 [  1.    63.02   1.  ]
 [  1.    81.26   2.  ]
 [  1.    86.21   2.  ]]
The Y is:
 [[145.  ]
 [110.  ]
 [ 93.  ]
 [116.  ]
 [ 65.32]
 [104.  ]
 [118.  ]
 [ 91.  ]
 [ 62.  ]
 [133.  ]
 [ 51.  ]
 [ 45.  ]
 [ 78.5 ]
 [ 69.65]
 [ 75.69]
 [ 95.3 ]]
The W is:
 [[11.96729093]
 [ 0.53488599]
 [14.33150378]]
多元线性回归方程：Y=0.5348859949724512*x1+14.331503777673632*x2+11.967290930536517
请输入房屋面积和房间数，预测房屋销售价格：
商品房面积：140
房间数：3
预测价格： 129.85 万元
</code></pre><hr>
<h1 id="三维模型可视化"><a href="#三维模型可视化" class="headerlink" title="三维模型可视化"></a>三维模型可视化</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入mplot3d工具集，其内置于Matplotlib</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="comment">#%matplotlib notebook</span></span><br></pre></td></tr></table></figure>
<h2 id="1-绘制散点图"><a href="#1-绘制散点图" class="headerlink" title="1.绘制散点图"></a>1.绘制散点图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义坐标轴</span></span><br><span class="line">fig=plt.figure(num=<span class="string">&quot;Scatter&quot;</span>)</span><br><span class="line">ax1=plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">x=np.random.uniform(<span class="number">10</span>,<span class="number">40</span>,<span class="number">500</span>)</span><br><span class="line">y=np.random.uniform(<span class="number">100</span>,<span class="number">200</span>,<span class="number">500</span>)</span><br><span class="line">z=<span class="number">2</span>*x+y</span><br><span class="line">ax1.scatter(x,y,z,c=<span class="string">&quot;b&quot;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">ax1.set_zlabel(<span class="string">&quot;z=2*x+y&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/output_13_0-1667297718852-15.png" alt="output_13_0"></p>
<h2 id="2-绘制平面图"><a href="#2-绘制平面图" class="headerlink" title="2.绘制平面图"></a>2.绘制平面图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成网格点矩阵坐标</span></span><br><span class="line">x=np.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">y=np.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">X,Y=np.meshgrid(x,y)</span><br><span class="line">Z=<span class="number">2</span>*X+Y</span><br><span class="line"><span class="comment">#绘制平面</span></span><br><span class="line">fig=plt.figure(num=<span class="string">&quot;Suface&quot;</span>)</span><br><span class="line">ax2=plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">surf=ax2.plot_surface(X,Y,Z,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">ax2.set_zlabel(<span class="string">&quot;z=2*x+y&quot;</span>)</span><br><span class="line">fig.colorbar(surf,shrink=<span class="number">0.5</span>,aspect=<span class="number">10</span>)<span class="comment">#绘制颜色指示条</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/output_15_0.png" alt="output_15_0"></p>
<h2 id="3-绘制线框图"><a href="#3-绘制线框图" class="headerlink" title="3.绘制线框图"></a>3.绘制线框图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成网格点矩阵坐标</span></span><br><span class="line">x=np.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">y=np.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">X,Y=np.meshgrid(x,y)</span><br><span class="line">Z=<span class="number">2</span>*X+Y</span><br><span class="line"><span class="comment">#绘制线框图</span></span><br><span class="line">fig=plt.figure(num=<span class="string">&quot;wireframe&quot;</span>)</span><br><span class="line">ax3=plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax3.plot_wireframe(X,Y,Z,color=<span class="string">&quot;m&quot;</span>,linewidth=<span class="number">0.5</span>)</span><br><span class="line">ax3.set_xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ax3.set_ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">ax3.set_zlabel(<span class="string">&quot;z=2*x+y&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/output_17_0-1667297507362-9.png" alt="output_17_0"></p>
<h2 id="4-绘制曲面图"><a href="#4-绘制曲面图" class="headerlink" title="4.绘制曲面图"></a>4.绘制曲面图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成网格点矩阵坐标</span></span><br><span class="line">x=np.arange(-<span class="number">5</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">y=np.arange(-<span class="number">5</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">X,Y=np.meshgrid(x,y)</span><br><span class="line">Z=np.sin(np.sqrt(X**<span class="number">2</span>+Y**<span class="number">2</span>))</span><br><span class="line"><span class="comment">#绘制曲面图</span></span><br><span class="line">fig=plt.figure(num=<span class="string">&quot;曲面图&quot;</span>)</span><br><span class="line">ax4=plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax4.plot_surface(X,Y,Z,cmap=<span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">ax4.set_xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ax4.set_ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/output_19_0-1667297662738-13.png" alt="output_19_0"></p>
<hr>
<h1 id="梯度下降法实现线性回归"><a href="#梯度下降法实现线性回归" class="headerlink" title="梯度下降法实现线性回归"></a>梯度下降法实现线性回归</h1><h2 id="1-NumPy实现"><a href="#1-NumPy实现" class="headerlink" title="1.NumPy实现"></a>1.NumPy实现</h2><ul>
<li><h3 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h3><ul>
<li><p>加载样本数据x、y</p>
</li>
<li><p>设置超参数学习率、迭代次数</p>
</li>
<li><p>设置模型参数初值w0、b0</p>
</li>
<li><p>训练模型w、b</p>
<p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/image-20221101182056089.png" alt="image-20221101182056089" style="zoom:33%;"></p>
</li>
<li><p>结果可视化</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment">#加载样本数据：x、y</span></span><br><span class="line">x=np.array([<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">124.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">138.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>])</span><br><span class="line">y=np.array([<span class="number">145.00</span>,<span class="number">110.00</span>,<span class="number">93.00</span>,<span class="number">116.00</span>,<span class="number">65.32</span>,<span class="number">104.00</span>,<span class="number">118.00</span>,<span class="number">91.00</span>,<span class="number">62.00</span>,<span class="number">133.00</span>,<span class="number">51.00</span>,<span class="number">45.00</span>,<span class="number">78.50</span>,<span class="number">69.65</span>,<span class="number">75.69</span>,<span class="number">95.30</span>])</span><br><span class="line"><span class="comment">#设置超参数学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.00001</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">100</span></span><br><span class="line">display_step=<span class="number">10</span> <span class="comment">#设置每十次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#设置模型参数初值w0,b0</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">w=np.random.randn()</span><br><span class="line">b=np.random.randn()</span><br><span class="line"><span class="comment">#训练模型w,b</span></span><br><span class="line">mse=[]<span class="comment">#用于记录每次的均方误差值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    dL_dw=np.mean(x*(w*x+b-y))</span><br><span class="line">    dL_db=np.mean(w*x+b-y)</span><br><span class="line">    w=w-learn_rate*dL_dw</span><br><span class="line">    b=b-learn_rate*dL_db</span><br><span class="line">    <span class="comment">#记录模型的预测值</span></span><br><span class="line">    pred=w*x+b</span><br><span class="line">    <span class="comment">#计算并保存均方误差</span></span><br><span class="line">    Loss=np.mean(np.square(y-pred))/<span class="number">2</span></span><br><span class="line">    mse.append(Loss)</span><br><span class="line">    <span class="comment">#每十次迭代输出一次结果</span></span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i:%i, Loss:%f, w:%f, b:%f&quot;</span> %(i,mse[i],w,b))</span><br><span class="line"><span class="comment">#结果可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">5</span>))</span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">plt.scatter(x,y,color=<span class="string">&quot;red&quot;</span>,label=<span class="string">&quot;销售记录&quot;</span>)</span><br><span class="line">plt.scatter(x,pred,color=<span class="string">&quot;blue&quot;</span>,label=<span class="string">&quot;梯度下降法&quot;</span>)</span><br><span class="line">plt.plot(x,pred,color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">plt.plot(x,<span class="number">0.89</span>*x+<span class="number">5.41</span>,color=<span class="string">&quot;green&quot;</span>,label=<span class="string">&quot;解析解&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Area&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Price&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(mse)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Iteration&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot(y,color=<span class="string">&quot;red&quot;</span>,marker=<span class="string">&quot;o&quot;</span>,label=<span class="string">&quot;销售记录&quot;</span>)</span><br><span class="line">plt.plot(pred,color=<span class="string">&quot;blue&quot;</span>,marker=<span class="string">&quot;o&quot;</span>,label=<span class="string">&quot;预测房价&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Sample&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;PRICE&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i:0, Loss:3874.243711, w:0.082565, b:-1.161967
i:10, Loss:562.072704, w:0.648552, b:-1.156446
i:20, Loss:148.244254, w:0.848612, b:-1.154462
i:30, Loss:96.539782, w:0.919327, b:-1.153728
i:40, Loss:90.079712, w:0.944323, b:-1.153435
i:50, Loss:89.272557, w:0.953157, b:-1.153299
i:60, Loss:89.171687, w:0.956280, b:-1.153217
i:70, Loss:89.159061, w:0.957383, b:-1.153156
i:80, Loss:89.157460, w:0.957773, b:-1.153101
i:90, Loss:89.157238, w:0.957910, b:-1.153048
i:100, Loss:89.157187, w:0.957959, b:-1.152997
</code></pre><p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/output_21_1.png" alt="output_21_1"></p>
<ul>
<li><h3 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><ul>
<li><p>加载数据样本</p>
</li>
<li><p>数据处理：归一化、堆叠</p>
</li>
<li><p>设置超参数：学习率、迭代次数</p>
</li>
<li><p>设置模型参数的初值Wo</p>
</li>
<li><p>训练模型W：</p>
<p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/image-20221101182703479.png" alt="image-20221101182703479" style="zoom: 25%;"></p>
</li>
<li><p>结果可视化</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#加载样本数据</span></span><br><span class="line">area=np.array([<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">124.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">138.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>])</span><br><span class="line">room=np.array([<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">price=np.array([<span class="number">145.00</span>,<span class="number">110.00</span>,<span class="number">93.00</span>,<span class="number">116.00</span>,<span class="number">65.32</span>,<span class="number">104.00</span>,<span class="number">118.00</span>,<span class="number">91.00</span>,<span class="number">62.00</span>,<span class="number">133.00</span>,<span class="number">51.00</span>,<span class="number">45.00</span>,<span class="number">78.50</span>,<span class="number">69.65</span>,<span class="number">75.69</span>,<span class="number">95.30</span>])</span><br><span class="line">num=<span class="built_in">len</span>(area)<span class="comment">#样本数量</span></span><br><span class="line"><span class="comment">#数据处理：归一化、堆叠</span></span><br><span class="line">x0=np.ones(num)</span><br><span class="line">x1=(area-area.<span class="built_in">min</span>())/(area.<span class="built_in">max</span>()-area.<span class="built_in">min</span>())</span><br><span class="line">x2=(room-room.<span class="built_in">min</span>())/(room.<span class="built_in">max</span>()-room.<span class="built_in">min</span>())</span><br><span class="line">X=np.stack((x0,x1,x2),axis=<span class="number">1</span>)</span><br><span class="line">Y=price.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#设置超参数：学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.2</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">50</span></span><br><span class="line">display_step=<span class="number">10</span> <span class="comment">#设置每十次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#设置模型参数初值W</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">W=np.random.randn(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#训练模型</span></span><br><span class="line">mse=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    PRED=np.matmul(X,W)</span><br><span class="line">    Loss=np.mean(np.square(Y-PRED))/<span class="number">2</span></span><br><span class="line">    mse.append(Loss)</span><br><span class="line">    dL_dW=np.matmul(np.transpose(X),np.matmul(X,W)-Y)/num</span><br><span class="line">    W=W-learn_rate*dL_dW</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i: %i, Loss:%f&quot;</span> % (i,mse[i]))</span><br><span class="line"><span class="comment">#结果可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">5</span>))</span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(mse)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Iteration&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">PRED=PRED.reshape(-<span class="number">1</span>)</span><br><span class="line">plt.plot(price,color=<span class="string">&quot;red&quot;</span>,marker=<span class="string">&quot;o&quot;</span>,label=<span class="string">&quot;销售记录&quot;</span>)</span><br><span class="line">plt.plot(PRED,color=<span class="string">&quot;blue&quot;</span>,marker=<span class="string">&quot;o&quot;</span>,label=<span class="string">&quot;预测房价&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Sample&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;PRICE&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i: 0, Loss:4593.851656
i: 10, Loss:85.480869
i: 20, Loss:82.080953
i: 30, Loss:81.408948
i: 40, Loss:81.025841
i: 50, Loss:80.803450
</code></pre><p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/output_23_1.png" alt="output_23_1" style="zoom: 80%;"></p>
<h2 id="2-TensorFlow实现"><a href="#2-TensorFlow实现" class="headerlink" title="2.TensorFlow实现"></a>2.TensorFlow实现</h2><ul>
<li><h3 id="一元线性回归-1"><a href="#一元线性回归-1" class="headerlink" title="一元线性回归"></a>一元线性回归</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#加载样本数据：x、y</span></span><br><span class="line">x=np.array([<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">124.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">138.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>])</span><br><span class="line">y=np.array([<span class="number">145.00</span>,<span class="number">110.00</span>,<span class="number">93.00</span>,<span class="number">116.00</span>,<span class="number">65.32</span>,<span class="number">104.00</span>,<span class="number">118.00</span>,<span class="number">91.00</span>,<span class="number">62.00</span>,<span class="number">133.00</span>,<span class="number">51.00</span>,<span class="number">45.00</span>,<span class="number">78.50</span>,<span class="number">69.65</span>,<span class="number">75.69</span>,<span class="number">95.30</span>])</span><br><span class="line"><span class="comment">#设置超参数学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.0001</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">10</span></span><br><span class="line">display_step=<span class="number">1</span> <span class="comment">#设置每一次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#设置模型参数初值w0,b0</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">w=tf.Variable(np.random.randn())</span><br><span class="line">b=tf.Variable(np.random.randn())</span><br><span class="line"><span class="comment">#训练模型w,b</span></span><br><span class="line">mse=[]<span class="comment">#用于记录每次的均方误差值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        pred=w*x+b</span><br><span class="line">        Loss=<span class="number">0.5</span>*tf.reduce_mean(tf.square(y-pred))</span><br><span class="line">    mse.append(Loss)</span><br><span class="line">    dL_dw,dL_db=tape.gradient(Loss,[w,b])</span><br><span class="line">    w.assign_sub(learn_rate*dL_dw)</span><br><span class="line">    b.assign_sub(learn_rate*dL_db)</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i: %i,Loss: %f, w: %f, b: %f&quot;</span> % (i,Loss,w.numpy(),b.numpy()))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i: 0,Loss: 4749.362305, w: 0.946047, b: -1.153577
i: 1,Loss: 89.861862, w: 0.957843, b: -1.153412
i: 2,Loss: 89.157501, w: 0.957987, b: -1.153359
i: 3,Loss: 89.157379, w: 0.957988, b: -1.153308
i: 4,Loss: 89.157364, w: 0.957988, b: -1.153257
i: 5,Loss: 89.157318, w: 0.957987, b: -1.153206
i: 6,Loss: 89.157280, w: 0.957987, b: -1.153155
i: 7,Loss: 89.157265, w: 0.957986, b: -1.153104
i: 8,Loss: 89.157219, w: 0.957986, b: -1.153052
i: 9,Loss: 89.157211, w: 0.957985, b: -1.153001
i: 10,Loss: 89.157196, w: 0.957985, b: -1.152950
</code></pre><ul>
<li><h3 id="多元线性回归-1"><a href="#多元线性回归-1" class="headerlink" title="多元线性回归"></a>多元线性回归</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#加载样本数据</span></span><br><span class="line">area=np.array([<span class="number">137.97</span>,<span class="number">104.50</span>,<span class="number">100.00</span>,<span class="number">124.32</span>,<span class="number">79.20</span>,<span class="number">99.00</span>,<span class="number">124.00</span>,<span class="number">114.00</span>,<span class="number">106.69</span>,<span class="number">138.05</span>,<span class="number">53.75</span>,<span class="number">46.91</span>,<span class="number">68.00</span>,<span class="number">63.02</span>,<span class="number">81.26</span>,<span class="number">86.21</span>])</span><br><span class="line">room=np.array([<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">price=np.array([<span class="number">145.00</span>,<span class="number">110.00</span>,<span class="number">93.00</span>,<span class="number">116.00</span>,<span class="number">65.32</span>,<span class="number">104.00</span>,<span class="number">118.00</span>,<span class="number">91.00</span>,<span class="number">62.00</span>,<span class="number">133.00</span>,<span class="number">51.00</span>,<span class="number">45.00</span>,<span class="number">78.50</span>,<span class="number">69.65</span>,<span class="number">75.69</span>,<span class="number">95.30</span>])</span><br><span class="line">num=<span class="built_in">len</span>(area)<span class="comment">#样本数量</span></span><br><span class="line"><span class="comment">#数据处理：归一化、堆叠</span></span><br><span class="line">x0=np.ones(num)</span><br><span class="line">x1=(area-area.<span class="built_in">min</span>())/(area.<span class="built_in">max</span>()-area.<span class="built_in">min</span>())</span><br><span class="line">x2=(room-room.<span class="built_in">min</span>())/(room.<span class="built_in">max</span>()-room.<span class="built_in">min</span>())</span><br><span class="line">X=np.stack((x0,x1,x2),axis=<span class="number">1</span>)</span><br><span class="line">Y=price.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#设置超参数：学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.2</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">50</span></span><br><span class="line">display_step=<span class="number">10</span> <span class="comment">#设置每十次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#设置模型参数初值W</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">W=tf.Variable(np.random.randn(<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment">#训练模型</span></span><br><span class="line">mse=[]<span class="comment">#用于记录每次的均方误差值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        PRED=tf.matmul(X,W)</span><br><span class="line">        Loss=<span class="number">0.5</span>*tf.reduce_mean(tf.square(Y-PRED))</span><br><span class="line">    mse.append(Loss)</span><br><span class="line">    dL_dW=tape.gradient(Loss,W)</span><br><span class="line">    W.assign_sub(learn_rate*dL_dW)</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i: %i, Loss: %f&quot;</span> % (i,Loss))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i: 0, Loss: 4593.851656
i: 10, Loss: 85.480869
i: 20, Loss: 82.080953
i: 30, Loss: 81.408948
i: 40, Loss: 81.025841
i: 50, Loss: 80.803450
</code></pre><hr>
<h1 id="TensorFlow的可训练变量和自动求导机制"><a href="#TensorFlow的可训练变量和自动求导机制" class="headerlink" title="TensorFlow的可训练变量和自动求导机制"></a>TensorFlow的可训练变量和自动求导机制</h1><h2 id="1-Variable对象"><a href="#1-Variable对象" class="headerlink" title="1.Variable对象"></a>1.Variable对象</h2><ul>
<li><code>tf.Variable(initial_value,dtype)</code>#initial_value可以是数字、Python列表、ndarray对象、Tensor对象</li>
<li>可训练变量赋值：<ul>
<li>对象名.assign()</li>
<li>对象名.assign_add()</li>
<li>对象名.assign_sub()</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Variable对象：是可以被训练的变量，在模型训练过程中自动记录梯度信息，由算法自动优化</span></span><br><span class="line"><span class="comment">#创建</span></span><br><span class="line">x=tf.Variable([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#trainalbe属性</span></span><br><span class="line"><span class="built_in">print</span>(x.trainable)</span><br><span class="line"><span class="comment">#对可训练变量赋值</span></span><br><span class="line"><span class="built_in">print</span>(x.assign([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]))</span><br><span class="line"><span class="built_in">print</span>(x.assign_add([[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>]]))</span><br><span class="line"><span class="built_in">print</span>(x.assign_sub([[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>]]))<span class="comment">#由结果可知，此操作改变了x对象本身</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>&lt;tf.Variable &#39;Variable:0&#39; shape=(2, 4) dtype=int32, numpy=
array([[1, 2, 3, 4],
       [4, 5, 6, 7]])&gt;
True
&lt;tf.Variable &#39;UnreadVariable&#39; shape=(2, 4) dtype=int32, numpy=
array([[1, 2, 3, 4],
       [4, 5, 6, 7]])&gt;
&lt;tf.Variable &#39;UnreadVariable&#39; shape=(2, 4) dtype=int32, numpy=
array([[ 4,  4,  7,  9],
       [ 7, 12, 14,  8]])&gt;
&lt;tf.Variable &#39;UnreadVariable&#39; shape=(2, 4) dtype=int32, numpy=
array([[1, 2, 3, 4],
       [4, 5, 6, 7]])&gt;
</code></pre><h2 id="2-自动求导机制"><a href="#2-自动求导机制" class="headerlink" title="2.自动求导机制"></a>2.自动求导机制</h2><ul>
<li><h3 id="GradientTape-的基本使用"><a href="#GradientTape-的基本使用" class="headerlink" title="GradientTape()的基本使用"></a>GradientTape()的基本使用</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#GradientTape()</span></span><br><span class="line"><span class="comment">#基本使用</span></span><br><span class="line">x=tf.Variable(<span class="number">3.0</span>) <span class="comment">#必须是浮点数</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    y=tf.square(x)</span><br><span class="line">dy_dx=tape.gradient(y,x)<span class="comment">#dy_dx代表y对x的求导</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(dy_dx)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor([9.], shape=(1,), dtype=float32)
tf.Tensor([6.], shape=(1,), dtype=float32)
</code></pre><ul>
<li><h3 id="GradientTape-的persistent参数"><a href="#GradientTape-的persistent参数" class="headerlink" title="GradientTape()的persistent参数"></a>GradientTape()的persistent参数</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#当对多个函数同时求导时，需要将persistent=True,否则会报错因为其默认只计算一次求导，将其赋值为True后，需用del tape释放</span></span><br><span class="line">x=tf.Variable(<span class="number">3.0</span>) <span class="comment">#必须是浮点数</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape(persistent=<span class="literal">True</span>) <span class="keyword">as</span> tape:</span><br><span class="line">    y=tf.square(x)</span><br><span class="line">    z=tf.<span class="built_in">pow</span>(x,<span class="number">3</span>)</span><br><span class="line">dy_dx=tape.gradient(y,x)<span class="comment">#dy_dx代表y对x的求导</span></span><br><span class="line">dz_dx=tape.gradient(z,x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(dy_dx)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="built_in">print</span>(dz_dx)</span><br><span class="line"><span class="keyword">del</span> tape</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(9.0, shape=(), dtype=float32)
tf.Tensor(6.0, shape=(), dtype=float32)
----------------------------------------
tf.Tensor(27.0, shape=(), dtype=float32)
tf.Tensor(27.0, shape=(), dtype=float32)
</code></pre><ul>
<li><h3 id="GradientTape-的watch-accessed-variables参数"><a href="#GradientTape-的watch-accessed-variables参数" class="headerlink" title="GradientTape()的watch_accessed_variables参数"></a>GradientTape()的watch_accessed_variables参数</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认watch_accessed_variables为True，表示自动监视可训练变量，若设置为False，则无法自动监视变量，可以使用watch()添加监视</span></span><br><span class="line">x=tf.Variable(<span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">with</span> tf.GradientTape(watch_accessed_variables=<span class="literal">False</span>) <span class="keyword">as</span> tape:</span><br><span class="line">    tape.watch(x)<span class="comment">#添加监视</span></span><br><span class="line">    y=tf.square(x)</span><br><span class="line">dy_dx=tape.gradient(y,x)<span class="comment">#dy_dx代表y对x的求导</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(dy_dx)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(9.0, shape=(), dtype=float32)
tf.Tensor(6.0, shape=(), dtype=float32)
</code></pre><ul>
<li><h3 id="watch-添加监视"><a href="#watch-添加监视" class="headerlink" title="watch()添加监视"></a>watch()添加监视</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#watch()还可以监视非可训练变量</span></span><br><span class="line">x=tf.constant(<span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">with</span> tf.GradientTape(watch_accessed_variables=<span class="literal">False</span>) <span class="keyword">as</span> tape:</span><br><span class="line">    tape.watch(x)<span class="comment">#添加监视</span></span><br><span class="line">    y=tf.square(x)</span><br><span class="line">dy_dx=tape.gradient(y,x)<span class="comment">#dy_dx代表y对x的求导</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(dy_dx)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(9.0, shape=(), dtype=float32)
tf.Tensor(6.0, shape=(), dtype=float32)
</code></pre><ul>
<li><h3 id="多元函数求偏导tape-gradient-函数，自变量"><a href="#多元函数求偏导tape-gradient-函数，自变量" class="headerlink" title="多元函数求偏导tape.gradient(函数，自变量)"></a>多元函数求偏导tape.gradient(函数，自变量)</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tape.gradient(函数，自变量)，这里的自变量可以是一个，也可以是多个，将多个自变量放在一个列表（元组）中，则可以对多元函数求偏导</span></span><br><span class="line">x=tf.Variable(<span class="number">3.0</span>)</span><br><span class="line">y=tf.Variable(<span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    f=tf.square(x)+<span class="number">2</span>*tf.square(y)+<span class="number">1</span></span><br><span class="line">df_dx,df_dy=tape.gradient(f,[x,y])</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(df_dx)</span><br><span class="line"><span class="built_in">print</span>(df_dy)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(42.0, shape=(), dtype=float32)
tf.Tensor(6.0, shape=(), dtype=float32)
tf.Tensor(16.0, shape=(), dtype=float32)
</code></pre><ul>
<li><h3 id="求二阶导数"><a href="#求二阶导数" class="headerlink" title="求二阶导数"></a>求二阶导数</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=tf.Variable(<span class="number">3.0</span>)</span><br><span class="line">y=tf.Variable(<span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape2:</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape1:</span><br><span class="line">        f=tf.square(x)+<span class="number">2</span>*tf.square(y)+<span class="number">1</span></span><br><span class="line">    first_grads=tape1.gradient(f,[x,y])</span><br><span class="line">second_grads=tape2.gradient(first_grads,[x,y])</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(first_grads)</span><br><span class="line"><span class="built_in">print</span>(second_grads)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor(42.0, shape=(), dtype=float32)
[&lt;tf.Tensor: shape=(), dtype=float32, numpy=6.0&gt;, &lt;tf.Tensor: shape=(), dtype=float32, numpy=16.0&gt;]
[&lt;tf.Tensor: shape=(), dtype=float32, numpy=2.0&gt;, &lt;tf.Tensor: shape=(), dtype=float32, numpy=4.0&gt;]
</code></pre><ul>
<li><h3 id="对向量求偏导"><a href="#对向量求偏导" class="headerlink" title="对向量求偏导"></a>对向量求偏导</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=tf.Variable([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>])</span><br><span class="line">y=tf.Variable([<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>])</span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    f=tf.square(x)+<span class="number">2</span>*tf.square(y)+<span class="number">1</span></span><br><span class="line">df_dx,df_dy=tape.gradient(f,[x,y])</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(df_dx)</span><br><span class="line"><span class="built_in">print</span>(df_dy)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>tf.Tensor([34. 55. 82.], shape=(3,), dtype=float32)
tf.Tensor([2. 4. 6.], shape=(3,), dtype=float32)
tf.Tensor([16. 20. 24.], shape=(3,), dtype=float32)
</code></pre><hr>
<h1 id="实例分析：波士顿房价预测"><a href="#实例分析：波士顿房价预测" class="headerlink" title="实例分析：波士顿房价预测"></a>实例分析：波士顿房价预测</h1><h2 id="1-平均房间数与房价的关系"><a href="#1-平均房间数与房价的关系" class="headerlink" title="1.平均房间数与房价的关系"></a>1.平均房间数与房价的关系</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#加载数据集</span></span><br><span class="line">boston_housing = tf.keras.datasets.boston_housing</span><br><span class="line"><span class="comment">#x表示房屋的属性值，y表示房价</span></span><br><span class="line">(train_x,train_y),(test_x,test_y)=boston_housing.load_data()</span><br><span class="line">x_train=train_x[:,<span class="number">5</span>]</span><br><span class="line">y_train=train_y</span><br><span class="line">x_test=test_x[:,<span class="number">5</span>]</span><br><span class="line">y_test=test_y</span><br><span class="line"><span class="comment">#设置超参数：学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.04</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">2000</span></span><br><span class="line">display_step=<span class="number">200</span> <span class="comment">#设置每十次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#设置模型参数初值w0,b0</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">w=tf.Variable(np.random.randn())</span><br><span class="line">b=tf.Variable(np.random.randn())</span><br><span class="line"><span class="comment">#训练模型w,b</span></span><br><span class="line">mse_train=[]<span class="comment">#用来记录训练集上的损失（训练误差）</span></span><br><span class="line">mse_test=[]<span class="comment">#用来记录测试集上的损失（测试误差）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        pred_train=w*x_train+b</span><br><span class="line">        loss_train=<span class="number">0.5</span>*tf.reduce_mean(tf.square(y_train-pred_train))</span><br><span class="line">        pred_test=w*x_test+b</span><br><span class="line">        loss_test=<span class="number">0.5</span>*tf.reduce_mean(tf.square(y_test-pred_test))</span><br><span class="line">    mse_train.append(loss_train)</span><br><span class="line">    mse_test.append(loss_test)</span><br><span class="line">    dL_dw,dL_db=tape.gradient(loss_train,[w,b])</span><br><span class="line">    w.assign_sub(learn_rate*dL_dw)</span><br><span class="line">    b.assign_sub(learn_rate*dL_db)</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i:%i,\tTrain Loss:%f,\tTest Loss:%f&quot;</span> % (i,loss_train,loss_test))</span><br><span class="line"><span class="comment">#模型和数据可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">10</span>))</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.scatter(x_train,y_train,color=<span class="string">&quot;blue&quot;</span>,label=<span class="string">&quot;data&quot;</span>)</span><br><span class="line">plt.plot(x_train,pred_train,color=<span class="string">&quot;red&quot;</span>,label=<span class="string">&quot;model&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(mse_train,color=<span class="string">&quot;blue&quot;</span>,linewidth=<span class="number">3</span>,label=<span class="string">&quot;train loss&quot;</span>)</span><br><span class="line">plt.plot(mse_test,color=<span class="string">&quot;red&quot;</span>,linewidth=<span class="number">1.5</span>,label=<span class="string">&quot;test loss&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.plot(y_train,color=<span class="string">&quot;blue&quot;</span>,marker=<span class="string">&quot;o&quot;</span>,label=<span class="string">&quot;true_price&quot;</span>)</span><br><span class="line">plt.plot(pred_train,color=<span class="string">&quot;red&quot;</span>,marker=<span class="string">&quot;.&quot;</span>,label=<span class="string">&quot;predict&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.plot(y_test,color=<span class="string">&quot;blue&quot;</span>,marker=<span class="string">&quot;o&quot;</span>,label=<span class="string">&quot;true_price&quot;</span>)</span><br><span class="line">plt.plot(pred_test,color=<span class="string">&quot;red&quot;</span>,marker=<span class="string">&quot;.&quot;</span>,label=<span class="string">&quot;predict&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i:0,    Train Loss:321.837585,    Test Loss:337.568634
i:200,    Train Loss:28.122616,    Test Loss:26.237764
i:400,    Train Loss:27.144739,    Test Loss:25.099327
i:600,    Train Loss:26.341949,    Test Loss:24.141077
i:800,    Train Loss:25.682899,    Test Loss:23.332979
i:1000,    Train Loss:25.141848,    Test Loss:22.650162
i:1200,    Train Loss:24.697670,    Test Loss:22.072006
i:1400,    Train Loss:24.333027,    Test Loss:21.581432
i:1600,    Train Loss:24.033667,    Test Loss:21.164261
i:1800,    Train Loss:23.787903,    Test Loss:20.808695
i:2000,    Train Loss:23.586145,    Test Loss:20.504938
</code></pre><p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/output_47_1.png" alt="output_47_1"></p>
<h2 id="2-所有属性的多元线性回归"><a href="#2-所有属性的多元线性回归" class="headerlink" title="2.所有属性的多元线性回归"></a>2.所有属性的多元线性回归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加载数据集</span></span><br><span class="line">boston_housing = tf.keras.datasets.boston_housing</span><br><span class="line"><span class="comment">#x表示房屋的属性值，y表示房价</span></span><br><span class="line">(train_x,train_y),(test_x,test_y)=boston_housing.load_data()</span><br><span class="line">num_train=<span class="built_in">len</span>(train_x)</span><br><span class="line">num_test=<span class="built_in">len</span>(test_x)</span><br><span class="line"><span class="comment">#数据处理：归一化与拼接</span></span><br><span class="line">x_train=(train_x-train_x.<span class="built_in">min</span>(axis=<span class="number">0</span>))/(train_x.<span class="built_in">max</span>(axis=<span class="number">0</span>)-train_x.<span class="built_in">min</span>(axis=<span class="number">0</span>))</span><br><span class="line">y_train=train_y</span><br><span class="line">x_test=(test_x-test_x.<span class="built_in">min</span>(axis=<span class="number">0</span>))/(test_x.<span class="built_in">max</span>(axis=<span class="number">0</span>)-test_x.<span class="built_in">min</span>(axis=<span class="number">0</span>))</span><br><span class="line">y_test=test_y</span><br><span class="line">x0_train=np.ones(num_train).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">x0_test=np.ones(num_test).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">X_train=tf.concat([x0_train,x_train],axis=<span class="number">1</span>)</span><br><span class="line">X_test=tf.concat([x0_test,x_test],axis=<span class="number">1</span>)</span><br><span class="line">Y_train=tf.constant(y_train.reshape(-<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">Y_test=tf.constant(y_test.reshape(-<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment">#设置超参数：学习率与迭代次数</span></span><br><span class="line">learn_rate=<span class="number">0.01</span></span><br><span class="line"><span class="built_in">iter</span>=<span class="number">2000</span></span><br><span class="line">display_step=<span class="number">200</span> <span class="comment">#设置每十次迭代输出一次结果</span></span><br><span class="line"><span class="comment">#设置模型参数初值W</span></span><br><span class="line">np.random.seed(<span class="number">612</span>)</span><br><span class="line">W=tf.Variable(np.random.randn(<span class="number">14</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment">#训练模型W</span></span><br><span class="line">mse_train=[]<span class="comment">#用来记录训练集上的损失（训练误差）</span></span><br><span class="line">mse_test=[]<span class="comment">#用来记录测试集上的损失（测试误差）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">iter</span>+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        PRED_train=tf.matmul(X_train,W)</span><br><span class="line">        Loss_train=<span class="number">0.5</span>*tf.reduce_mean(tf.square(Y_train-PRED_train))</span><br><span class="line">        PRED_test=tf.matmul(X_test,W)</span><br><span class="line">        Loss_test=<span class="number">0.5</span>*tf.reduce_mean(tf.square(Y_test-PRED_test))</span><br><span class="line">    mse_train.append(Loss_train)</span><br><span class="line">    mse_test.append(Loss_test)</span><br><span class="line">    dL_dW=tape.gradient(Loss_train,W)</span><br><span class="line">    W.assign_sub(learn_rate*dL_dW)</span><br><span class="line">    <span class="keyword">if</span> i % display_step==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i:%i,\tTrain Loss:%f,\tTest Loss:%f&quot;</span> % (i,Loss_train,Loss_test))</span><br><span class="line"><span class="comment">#模型和数据可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">131</span>)</span><br><span class="line">plt.plot(mse_train,color=<span class="string">&quot;blue&quot;</span>,linewidth=<span class="number">3</span>,label=<span class="string">&quot;train loss&quot;</span>)</span><br><span class="line">plt.plot(mse_test,color=<span class="string">&quot;red&quot;</span>,linewidth=<span class="number">1.5</span>,label=<span class="string">&quot;test loss&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>)</span><br><span class="line">plt.plot(Y_train,color=<span class="string">&quot;blue&quot;</span>,marker=<span class="string">&quot;o&quot;</span>,label=<span class="string">&quot;true_price&quot;</span>)</span><br><span class="line">plt.plot(PRED_train,color=<span class="string">&quot;red&quot;</span>,marker=<span class="string">&quot;.&quot;</span>,label=<span class="string">&quot;predict&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.subplot(<span class="number">133</span>)</span><br><span class="line">plt.plot(Y_test,color=<span class="string">&quot;blue&quot;</span>,marker=<span class="string">&quot;o&quot;</span>,label=<span class="string">&quot;true_price&quot;</span>)</span><br><span class="line">plt.plot(PRED_test,color=<span class="string">&quot;red&quot;</span>,marker=<span class="string">&quot;.&quot;</span>,label=<span class="string">&quot;predict&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<pre><code>i:0,    Train Loss:263.193459,    Test Loss:276.994119
i:200,    Train Loss:36.176548,    Test Loss:37.562946
i:400,    Train Loss:28.789464,    Test Loss:28.952521
i:600,    Train Loss:25.520702,    Test Loss:25.333921
i:800,    Train Loss:23.460534,    Test Loss:23.340539
i:1000,    Train Loss:21.887280,    Test Loss:22.039745
i:1200,    Train Loss:20.596287,    Test Loss:21.124848
i:1400,    Train Loss:19.510205,    Test Loss:20.467240
i:1600,    Train Loss:18.587010,    Test Loss:19.997707
i:1800,    Train Loss:17.797461,    Test Loss:19.671583
i:2000,    Train Loss:17.118926,    Test Loss:19.456854
</code></pre><p><img src="/2022/11/01/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98/output_49_1.png" alt="output_49_1"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow实践之NumPy与Matplotlib库</title>
    <url>/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/</url>
    <content><![CDATA[<p>这里记录着小沈在学习神经网络与深度学习之TensorFlow实践课程中，遇到的两个比较重要又有意思的库：科学计算库NumPy和数据可视化库Matplotlib。</p>
<span id="more"></span>
<h1 id="NumPy科学计算库"><a href="#NumPy科学计算库" class="headerlink" title="NumPy科学计算库"></a>NumPy科学计算库</h1><ul>
<li>提供了<strong>多维数组、矩阵</strong>的常规操作和一些高效的科学计算函数</li>
<li>底层运算用过C语言实现，<strong>处理速度快，效率高</strong>，适用于<strong>大规模多维数组</strong></li>
<li>可以<strong>直接完成数组和矩阵运算</strong>，无需循环</li>
</ul>
<h2 id="1-多维数组的基本概念"><a href="#1-多维数组的基本概念" class="headerlink" title="1.多维数组的基本概念"></a>1.多维数组的基本概念</h2><ul>
<li><p>形状（shape）：是一个元组，描述数组的维度（<strong>元组中有几个数就代表几维</strong>），以及各个维度的长度</p>
</li>
<li><p>长度（length）：某个维度中的元素个数</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027163211507.png" alt="image-20221027163211507" style="zoom:33%;"></p>
</li>
</ul>
<h2 id="2-NumPy数组的创建及其属性"><a href="#2-NumPy数组的创建及其属性" class="headerlink" title="2.NumPy数组的创建及其属性"></a>2.NumPy数组的创建及其属性</h2><h3 id="2-1-创建数组：array-列表-元组"><a href="#2-1-创建数组：array-列表-元组" class="headerlink" title="2.1 创建数组：array([列表]/(元组))"></a>2.1 创建数组：<code>array([列表]/(元组))</code></h3><ul>
<li><p><strong>一维数组的创建与索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment">#一维数组的创建</span></span><br><span class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a),<span class="string">&quot; &quot;</span>,a)</span><br><span class="line"><span class="comment">#一维数组的索引，同序列</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027164257343.png" alt="image-20221027164257343" style="zoom: 67%;"></p>
</li>
<li><p><strong>二维数组的创建与索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment">#二维数组的创建</span></span><br><span class="line">b=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The array is:\n&quot;</span>,b)</span><br><span class="line"><span class="comment">#二维数组的索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The index is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">2</span>][<span class="number">1</span>])<span class="comment">#还可以用print(b[2,1])这样的索引方式</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027165415344.png" alt="image-20221027165415344" style="zoom:67%;"></p>
</li>
<li><p><strong>三维数组的创建与索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#三维数组的创建</span></span><br><span class="line">c=np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]],[[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>],[<span class="number">12</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">16</span>],[<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>]]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The array is:\n&quot;</span>,c,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#三维数组的索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The index is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027170734415.png" alt="image-20221027170734415" style="zoom: 67%;"></p>
</li>
</ul>
<h3 id="2-2-数组的属性"><a href="#2-2-数组的属性" class="headerlink" title="2.2 数组的属性"></a>2.2 数组的属性</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ndim</td>
<td>数组的维数</td>
</tr>
<tr>
<td>shape</td>
<td>数组的形状</td>
</tr>
<tr>
<td>size</td>
<td>数组元素的总个数</td>
</tr>
<tr>
<td>dtype</td>
<td>数组中元素的数据类型</td>
</tr>
<tr>
<td>itemsize</td>
<td>数组中每个元素的字节</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#三维数组的创建</span></span><br><span class="line">c=np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]],[[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>],[<span class="number">12</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">16</span>],[<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>]]])</span><br><span class="line"><span class="comment">#三维数组的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;三维数组的属性：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组维度：&quot;</span>,c.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组形状：&quot;</span>,c.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组元素总个数：&quot;</span>,c.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">20</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#二维数组的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;二维数组的属性：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组维度：&quot;</span>,c[<span class="number">0</span>].ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组形状：&quot;</span>,c[<span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组元素总个数：&quot;</span>,c[<span class="number">0</span>].size)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027172312521.png" alt="image-20221027172312521" style="zoom:67%;"></p>
<h3 id="2-3创建特殊的数组"><a href="#2-3创建特殊的数组" class="headerlink" title="2.3创建特殊的数组"></a>2.3创建特殊的数组</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>np.arange(起始数字,结束数字,步长,dtype=数据类型)</td>
<td>创建数字序列数组，默认数据类型为int32</td>
</tr>
<tr>
<td>np.ones(shape,dtye=数据类型)</td>
<td>创建全1数组，默认数据类型为float64</td>
</tr>
<tr>
<td>np.zeros(shape,dtye=数据类型)</td>
<td>创建全0数组，默认数据类型为float64</td>
</tr>
<tr>
<td>np.eye(shape)</td>
<td>创建单位矩阵，默认数据类型为float64</td>
</tr>
<tr>
<td>np.linspace(start,stop,num=50)</td>
<td>创建等差数列，默认数据类型为float64</td>
</tr>
<tr>
<td>np.logspace(start,stop,num=50,base=10)</td>
<td>创建等比数列，默认数据类型为float64，<strong>修改基数时一定要加base=</strong></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#创建数字序列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;此数字序列是：\n&quot;</span>,np.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>).dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">#创建全1数组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;此全1数组是：\n&quot;</span>,np.ones((<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>(np.ones((<span class="number">2</span>,<span class="number">3</span>)).dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">#创建单位矩阵</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;此单位矩阵是：\n&quot;</span>,np.eye(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(np.eye(<span class="number">3</span>,<span class="number">3</span>).dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">#创建等差数列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;此等差数列是：&quot;</span>,np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>).dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">50</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">#创建等比数列：开始的数为base^start,结束的数为base^stop,num表示总共生成几个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;此等比数列是：&quot;</span>,np.logspace(<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,base=<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(np.logspace(<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,base=<span class="number">2</span>).dtype)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027184800827.png" alt="image-20221027184800827" style="zoom:67%;"></p>
<h2 id="3-数组运算"><a href="#3-数组运算" class="headerlink" title="3.数组运算"></a>3.数组运算</h2><ul>
<li><h3 id="改变数组的函数"><a href="#改变数组的函数" class="headerlink" title="改变数组的函数"></a>改变数组的函数</h3><p>| 函数              | 功能描述                              |<br>| ————————- | ——————————————————- |<br>| np.reshape(shape) | 不改变当前数组，按照shape创建新的数组 |<br>| np.resize(shape)  | 改变当前数组，按照shape创建数组       |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建数组，并按照shape创建新的数组</span></span><br><span class="line">b=np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b.reshape(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">#执行reshape语句后原数组并未被改变</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#创建数组，并改变数组形状</span></span><br><span class="line">b.resize(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">#由结果，很明显数组被改变了</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027201249163.png" alt="image-20221027201249163" style="zoom: 67%;"></p>
</li>
<li><h3 id="数组与数组之间常见运算"><a href="#数组与数组之间常见运算" class="headerlink" title="数组与数组之间常见运算"></a>数组与数组之间常见运算</h3><ul>
<li><p><strong>加法运算</strong>：一维数组可以和多维数组相加，相加时会将一维数组扩展至多维</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b=np.array([[<span class="number">0</span>,<span class="number">8</span>,<span class="number">67</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">456</span>,<span class="number">7</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">68</span>,<span class="number">1</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027201731666.png" alt="image-20221027201731666" style="zoom:67%;"></p>
</li>
<li><p><strong>幂运算</strong>：<code>array**2</code>#对数组中的每个元素求n次方</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">b=np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The array b is:\n&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The b**2 is:\n&quot;</span>,b**<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027202136524.png" alt="image-20221027202136524" style="zoom:67%;"></p>
</li>
<li><p><strong>矩阵运算：转置和求逆</strong></p>
<ul>
<li>矩阵转置：<code>np.transpose()</code></li>
<li>矩阵求逆：<code>np.linalg.inv()</code></li>
<li>矩阵相乘：<code>np.matmul()</code></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="数组中元素的计算"><a href="#数组中元素的计算" class="headerlink" title="数组中元素的计算"></a>数组中元素的计算</h3><ul>
<li><p><strong>常见的数组间元素的计算函数</strong></p>
<p>| 函数      | 功能描述                   |<br>| ————- | ————————————— |<br>| np.sum()  | 计算所有元素的和           |<br>| np.prod() | 计算所有元素的乘积         |<br>| np.diff() | 计算数组相邻元素之间的差值 |<br>| np.sqrt() | 计算各元素的平方根         |<br>| np.exp()  | 计算各元素的指数值         |<br>| np.abs()  | 取各元素的绝对值           |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c=np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>],[<span class="number">48</span>,<span class="number">47</span>,<span class="number">3</span>,<span class="number">28</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The diff:\n&quot;</span>,np.diff(c))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027203826317.png" alt="image-20221027203826317" style="zoom:67%;"></p>
</li>
<li><p><code>np.linalg.norm(x, ord=None, axis=None, keepdims=False)</code></p>
<ul>
<li><p><strong>ord</strong></p>
<p>| 参数       | 说明                                                         | 计算方法                                                     |<br>| ————— | —————————————————————————————— | —————————————————————————————— |<br>| 默认       | 二范数：<img src="https://private.codecogs.com/gif.latex?l_%7B2%7D" alt="l_{2}"> | <img src="https://private.codecogs.com/gif.latex?%5Csqrt%7Bx_%7B1%7D%5E%7B2%7D%20&plus;%20x_%7B2%7D%5E%7B2%7D%20&plus;%20...%20&plus;%20x_%7Bn%7D%5E%7B2%7D%7D" alt="\sqrt{x_{1}^{2} + x_{2}^{2} + ... + x_{n}^{2}}"> |<br>| ord=2      | 二范数：<img src="https://private.codecogs.com/gif.latex?l_%7B2%7D" alt="l_{2}"> | 同上                                                         |<br>| ord=1      | 一范数：<img src="https://private.codecogs.com/gif.latex?l_%7B1%7D" alt="l_{1}"> | <img src="https://private.codecogs.com/gif.latex?%5Cleft%20%7C%20x_%7B1%7D%20%5Cright%20%7C%20&plus;%20%5Cleft%20%7C%20x_%7B2%7D%20%5Cright%20%7C%20&plus;%20...%20&plus;%20%5Cleft%20%7C%20x_%7Bn%7D%20%5Cright%20%7C" alt="\left \| x_{1} \right \| + \left \| x_{2} \right \| + ... + \left \| x_{n} \right \|"> |<br>| ord=np.inf | 无穷范数：<img src="https://private.codecogs.com/gif.latex?l_%7B%5Cinfty%7D" alt="l_{\infty}"> | <img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/right.gif" alt="MAX \left \| x_{i} \right \|"> |</p>
</li>
<li><p>axis表示在某个轴上求值</p>
</li>
<li><p><strong>keeptime=True表示结果保留x的维度特性</strong>，若keeptime=False将会减少一个维度</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>]])</span><br><span class="line">x1 = np.linalg.norm(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(x1)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">25</span>*<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">x2 = np.linalg.norm(x,axis=<span class="number">1</span>,keepdims=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(x2)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221112001803738.png" alt="image-20221112001803738" style="zoom: 67%;"></p>
</li>
<li><p><strong>关于轴（axes）与秩（rank）控制的运算</strong></p>
<ul>
<li><p>轴（axes）：数组中的每一个维度被称为一个轴</p>
</li>
<li><p>秩（rank）：轴的个数：<strong>对于二维数组rank=2；三维数组rank=3</strong></p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027204146469.png" alt="image-20221027204146469" style="zoom: 25%;"></p>
</li>
<li><p><strong>通过控制axes实现数组内的加法运算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">c=np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The array is:\n&quot;</span>,c,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(c,axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(c,axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(c,axis=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027210417266.png" alt="image-20221027210417266" style="zoom: 50%;"></p>
</li>
<li><p><strong>数组堆叠运算</strong>：<code>np.stack((数组1,数组2,……),axis)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#一维数组的堆叠</span></span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">y=np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;一维数组的堆叠：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Axis=0:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.stack((x,y),axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Axis=1:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.stack((x,y),axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">30</span>*<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="comment">#二维数组的堆叠</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;二维数组的堆叠：&quot;</span>)</span><br><span class="line">m=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]])</span><br><span class="line">    n=np.array([[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">10</span>],[<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">10</span>],[<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">10</span>]])</span><br><span class="line">    a0=np.stack((m,n),axis=<span class="number">0</span>)</span><br><span class="line">    a1=np.stack((m,n),axis=<span class="number">1</span>)</span><br><span class="line">    a2=np.stack((m,n),axis=<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The shape is:&quot;</span>,a0.shape)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The array is:\n&quot;</span>,a0)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">30</span>*<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The shape is:&quot;</span>,a1.shape)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The array is:\n&quot;</span>,a1)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">30</span>*<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The shape is:&quot;</span>,a2.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The array is:\n&quot;</span>,a2)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">30</span>*<span class="string">&quot;*&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027212847784.png" alt="image-20221027212847784" style="zoom: 50%;"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-矩阵"><a href="#4-矩阵" class="headerlink" title="4.矩阵"></a>4.矩阵</h2><ul>
<li><h3 id="矩阵生成"><a href="#矩阵生成" class="headerlink" title="矩阵生成"></a>矩阵生成</h3><ul>
<li><code>np.matrix(字符串/列表/元组/数组)</code></li>
<li><code>np.mat(字符串/列表/元组/数组)</code></li>
</ul>
</li>
<li><h3 id="矩阵对象的属性"><a href="#矩阵对象的属性" class="headerlink" title="矩阵对象的属性"></a>矩阵对象的属性</h3><p>| 属性   | 说明           |<br>| ——— | ——————— |<br>| .ndim  | 矩阵的维数     |<br>| .shape | 矩阵的形状     |<br>| .size  | 矩阵的元素个数 |<br>| .dtype | 元素的数据类型 |</p>
</li>
<li><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><ul>
<li><p><strong>矩阵相乘</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a1=np.mat([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">a2=np.mat([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(a1*a2)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转置、求逆</strong></p>
<ul>
<li><code>矩阵转置：matrix.T</code></li>
<li><code>矩阵求逆：matrix.I</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-随机数模块"><a href="#5-随机数模块" class="headerlink" title="5.随机数模块"></a>5.随机数模块</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>np.random.rand(d0,d1,……,dn)</td>
<td>元素在[0:1)区间均匀分布的数组,(d0,d1,dn)表示形状(shape)</td>
<td>浮点数</td>
</tr>
<tr>
<td>np.random.uniform(low,hige,size)</td>
<td>元素在[low,hige)区间均匀分布的数组</td>
<td>浮点数</td>
</tr>
<tr>
<td>np.random.randint(low,hige,size)</td>
<td>元素在[low,hige)区间均匀分布的数组</td>
<td>整数</td>
</tr>
<tr>
<td>np.random.randn(d0,d1,……,dn)</td>
<td>产生标准正态分布的数组</td>
<td>浮点数</td>
</tr>
<tr>
<td>np.random.normal(loc,scale,size)</td>
<td>产生正态分布的数组，loc表示均值，scale表示方差</td>
<td>浮点数</td>
</tr>
<tr>
<td>np.random.seed()</td>
<td>随机种子，设置随机种子相同时，产生的随机数相同，默认为系统时间</td>
<td></td>
</tr>
<tr>
<td>np.random.shuffle(序列)</td>
<td>打乱数组第一个维度的顺序</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h1 id="Matplotlib数据可视化"><a href="#Matplotlib数据可视化" class="headerlink" title="Matplotlib数据可视化"></a>Matplotlib数据可视化</h1><ul>
<li>绘制图表的第三方库，可以快速方便地生成高质量的图表</li>
</ul>
<h2 id="1-Matplotlib绘图基础"><a href="#1-Matplotlib绘图基础" class="headerlink" title="1.Matplotlib绘图基础"></a>1.Matplotlib绘图基础</h2><p>本文均讨论Matplotlib中二维图标的绘制，故引入：<code>import matplotlib.pyplot as plt</code></p>
<ul>
<li><p><strong>figure对象</strong>：<code>figure(num,figsize,dpi,facecolor,edgecolor,frameon)</code></p>
<p>| 特征      | 描述                              |<br>| ————- | ————————————————- |<br>| num       | 图形编号或名称，取值为数字/字符串 |<br>| figsize   | 绘制对象的宽和高，单位为英寸      |<br>| dpi       | 绘制对象的分辨率，缺省值为80      |<br>| facecolor | 背景颜色                          |<br>| edgecolor | 边框颜色                          |<br>| linewidth | 边框宽度                          |<br>| frameon   | 表示是否显示边框                  |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure(</span><br><span class="line">    num=<span class="number">10</span>,</span><br><span class="line">    figsize=(<span class="number">3</span>,<span class="number">2</span>), <span class="comment"># 指定画布大小，(宽度，高度)，单位为英寸</span></span><br><span class="line">    dpi=<span class="number">80</span>, <span class="comment"># 指定绘图对象的分辨率，即每英寸多少个像素，</span></span><br><span class="line">    facecolor=<span class="string">&#x27;yellow&#x27;</span>, <span class="comment"># 背景颜色</span></span><br><span class="line">    edgecolor=<span class="string">&#x27;blue&#x27;</span>, <span class="comment">#边框颜色</span></span><br><span class="line">    linewidth=<span class="number">4.0</span>, <span class="comment"># 边框宽度</span></span><br><span class="line">    frameon=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">plt.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027232725582.png" alt="image-20221027232725582" style="zoom:67%;"></p>
</li>
<li><p><strong>划分子图</strong>：<code>subplot(行数，列数，子图序号)</code></p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027233213784.png" alt="image-20221027233213784" style="zoom: 25%;"></p>
</li>
<li><p><strong>设置中文字体</strong>：<code>plt.rcParams[&quot;font.sans-serif&quot;]=&quot;SimHei&quot;</code></p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027233501687.png" alt="image-20221027233501687" style="zoom: 50%;"></p>
</li>
<li><p><strong>添加标题</strong>：</p>
<ul>
<li><p>添加全局标题：<code>suptitle(标题文字)</code></p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027233727329.png" alt="image-20221027233727329" style="zoom: 33%;"></p>
</li>
<li><p>添加子标题：<code>title(标题文字)</code></p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027233904919.png" alt="image-20221027233904919" style="zoom:33%;"></p>
</li>
</ul>
</li>
<li><p><strong>自动调整子图间隔</strong>：<code>tight_layout()</code></p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221027234054706.png" alt="image-20221027234054706" style="zoom:33%;"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line"><span class="comment">#画布设置</span></span><br><span class="line">fig=plt.figure(facecolor=<span class="string">&quot;lightgrey&quot;</span>)</span><br><span class="line"><span class="comment">#划分子图并设置其标题</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&quot;子标题1&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">&quot;子标题2&quot;</span>,loc=<span class="string">&quot;left&quot;</span>,color=<span class="string">&quot;b&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">myfontdict=&#123;<span class="string">&quot;fontsize&quot;</span>:<span class="number">12</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;g&quot;</span>,<span class="string">&quot;rotation&quot;</span>:<span class="number">30</span>&#125;<span class="comment">#参数字典的使用</span></span><br><span class="line">plt.title(<span class="string">&quot;子标题3&quot;</span>,fontdict=myfontdict)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">plt.title(<span class="string">&quot;子标题4&quot;</span>,color=<span class="string">&quot;white&quot;</span>,backgroundcolor=<span class="string">&quot;black&quot;</span>)</span><br><span class="line"><span class="comment">#设置全局标题</span></span><br><span class="line">plt.suptitle(<span class="string">&quot;全局标题&quot;</span>,fontsize=<span class="number">20</span>,color=<span class="string">&quot;red&quot;</span>,backgroundcolor=<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line"><span class="comment">#调整子图间隔</span></span><br><span class="line">plt.tight_layout(rect=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.98</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>  结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221028000516819.png" alt="image-20221028000516819" style="zoom: 50%;"></p>
<h2 id="2-散点图"><a href="#2-散点图" class="headerlink" title="2.散点图"></a>2.散点图</h2><ul>
<li><p><strong>绘制散点图</strong>：<code>scatter(x,y,scale,color,marker,label)</code></p>
<p>| 参数   | 说明          | 默认值    |<br>| ——— | ——————- | ————- |<br>| x      | 数据点的x坐标 | 不可省略  |<br>| y      | 数据点的y坐标 | 不可省略  |<br>| scale  | 数据点的大小  | 36        |<br>| color  | 数据点的颜色  | 浅蓝      |<br>| marker | 数据点的样式  | ‘o’(圆点) |<br>| label  | 图列文字      |           |</p>
<ul>
<li><p>marker相关参数：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221028111408749.png" alt="image-20221028111408749" style="zoom: 33%;"></p>
</li>
<li><p>使用<code>plt.legend(loc,fontsize)</code>显示图例</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221028111737941.png" alt="image-20221028111737941" style="zoom: 50%;"></p>
</li>
</ul>
</li>
<li><p><strong>在指定位置添加文字</strong>：<code>text(x,y,s,fontsize,color)</code></p>
<p>| 参数     | 说明        | 默认值   |<br>| ———— | —————- | ———— |<br>| x        | 文字的x坐标 | 不可省略 |<br>| y        | 文字的y坐标 | 不可省略 |<br>| s        | 显示的文字  | 不可省略 |<br>| fontsize | 文字的大小  | 12       |<br>| color    | 文字的颜色  | 黑色     |</p>
</li>
<li><p><strong>坐标轴设置</strong></p>
<p>| 函数                         | 说明               |<br>| —————————————— | ————————— |<br>| xlabel(x,y,s,fontszie,color) | 设置x轴标签        |<br>| ylabel(x,y,s,fontszie,color) | 设置y轴标签        |<br>| xlim(xmin,xmax)              | 设置x轴坐标的范围  |<br>| ylim(ymin,ymax)              | 设置y轴坐标的范围  |<br>| tick_params(labelsize)       | 设置刻度文字的字号 |</p>
</li>
<li><p><strong>当设置字体为中文，坐标系中有负数，则做此设置</strong>：</p>
<p><code>plt.rcParams[&quot;axes.unicode_minus&quot;]=False</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span></span><br><span class="line"><span class="comment">#随机生成散点图数据：正态分布与均匀分布</span></span><br><span class="line">n=<span class="number">1024</span></span><br><span class="line">x1=np.random.normal(<span class="number">0</span>,<span class="number">1</span>,n)</span><br><span class="line">y1=np.random.normal(<span class="number">0</span>,<span class="number">1</span>,n)</span><br><span class="line">x2=np.random.uniform(-<span class="number">4</span>,<span class="number">4</span>,n)</span><br><span class="line">y2=np.random.uniform(-<span class="number">4</span>,<span class="number">4</span>,n)</span><br><span class="line"><span class="comment">#绘制散点图</span></span><br><span class="line">plt.scatter(x1,y1,color=<span class="string">&quot;blue&quot;</span>,marker=<span class="string">&quot;*&quot;</span>,label=<span class="string">&quot;正态分布&quot;</span>)</span><br><span class="line">plt.scatter(x2,y2,color=<span class="string">&quot;yellow&quot;</span>,marker=<span class="string">&quot;o&quot;</span>,label=<span class="string">&quot;均匀分布&quot;</span>)</span><br><span class="line"><span class="comment">#设置标题</span></span><br><span class="line">plt.title(<span class="string">&quot;标准分布&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment">#设置坐标轴范围</span></span><br><span class="line">plt.xlim(-<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">plt.ylim(-<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">#设置坐标轴标签</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;横坐标x&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;纵坐标y&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment">#设置文本</span></span><br><span class="line">plt.text(-<span class="number">3.8</span>,<span class="number">3</span>,<span class="string">&quot;均 值：0 标准差：1\n均匀分布:[-4:4]&quot;</span>)</span><br><span class="line"><span class="comment">#设置图例</span></span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221028111234270.png" alt="image-20221028111234270" style="zoom:50%;"></p>
<h2 id="3-折线图"><a href="#3-折线图" class="headerlink" title="3.折线图"></a>3.折线图</h2><p><code>plt.plot(x,y,color,marker,label,linewidth,markersize)</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>数据点的x坐标</td>
<td>0,1,2,……</td>
</tr>
<tr>
<td>y</td>
<td>数据点的y坐标</td>
<td>不可缺省</td>
</tr>
<tr>
<td>color</td>
<td>数据点的颜色</td>
<td></td>
</tr>
<tr>
<td>marker</td>
<td>数据点的样式</td>
<td>‘o’（圆点）</td>
</tr>
<tr>
<td>label</td>
<td>图例文字</td>
<td></td>
</tr>
<tr>
<td>linewidth</td>
<td>折线的宽度</td>
<td></td>
</tr>
<tr>
<td>markersize</td>
<td>数据点的大小</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line"><span class="comment">#随机生成数据点</span></span><br><span class="line">n=<span class="number">24</span></span><br><span class="line">y1=np.random.randint(<span class="number">27</span>,<span class="number">37</span>,n)</span><br><span class="line">y2=np.random.randint(<span class="number">40</span>,<span class="number">60</span>,n)</span><br><span class="line"><span class="comment">#绘图</span></span><br><span class="line">plt.plot(y1,label=<span class="string">&quot;温度&quot;</span>)</span><br><span class="line">plt.plot(y2,label=<span class="string">&quot;湿度&quot;</span>)</span><br><span class="line"><span class="comment">#设置坐标轴</span></span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">23</span>)</span><br><span class="line">plt.ylim(<span class="number">20</span>,<span class="number">70</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;小时&quot;</span>,fontsize=<span class="number">12</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;测量值&quot;</span>,fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment">#设置标题</span></span><br><span class="line">plt.title(<span class="string">&quot;24小时温度湿度统计&quot;</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"><span class="comment">#设置图例</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221028113312696.png" alt="image-20221028113312696" style="zoom: 50%;"></p>
<h2 id="4-柱状图"><a href="#4-柱状图" class="headerlink" title="4.柱状图"></a>4.柱状图</h2><p><code>bar(left,height,width,facecolor,edgecolor,label)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=<span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span></span><br><span class="line"><span class="comment">#设置数据</span></span><br><span class="line">y1=[<span class="number">32</span>,<span class="number">25</span>,<span class="number">16</span>,<span class="number">30</span>,<span class="number">24</span>,<span class="number">45</span>,<span class="number">40</span>,<span class="number">33</span>,<span class="number">28</span>,<span class="number">17</span>,<span class="number">24</span>,<span class="number">20</span>]</span><br><span class="line">y2=[-<span class="number">23</span>,-<span class="number">35</span>,-<span class="number">26</span>,-<span class="number">35</span>,-<span class="number">45</span>,-<span class="number">43</span>,-<span class="number">35</span>,-<span class="number">32</span>,-<span class="number">23</span>,-<span class="number">17</span>,-<span class="number">22</span>,-<span class="number">28</span>]</span><br><span class="line"><span class="comment">#绘图</span></span><br><span class="line">plt.bar(<span class="built_in">range</span>(<span class="built_in">len</span>(y1)),y1,width=<span class="number">0.8</span>,facecolor=<span class="string">&quot;green&quot;</span>,edgecolor=<span class="string">&quot;white&quot;</span>,label=<span class="string">&quot;统计量1&quot;</span>)</span><br><span class="line">plt.bar(<span class="built_in">range</span>(<span class="built_in">len</span>(y2)),y2,width=<span class="number">0.8</span>,facecolor=<span class="string">&quot;red&quot;</span>,edgecolor=<span class="string">&quot;white&quot;</span>,label=<span class="string">&quot;统计量2&quot;</span>)</span><br><span class="line"><span class="comment">#设置标题</span></span><br><span class="line">plt.title(<span class="string">&quot;柱状图&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment">#添加图例</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221028115614661.png" alt="image-20221028115614661" style="zoom: 50%;"></p>
<hr>
<h1 id="实例分析：波士顿房价数据集可视化"><a href="#实例分析：波士顿房价数据集可视化" class="headerlink" title="实例分析：波士顿房价数据集可视化"></a>实例分析：波士顿房价数据集可视化</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">boston_housing = tf.keras.datasets.boston_housing</span><br><span class="line"><span class="comment">#x表示房屋的属性值，y表示房价</span></span><br><span class="line">(train_x,train_y),(test_x,test_y)=boston_housing.load_data(test_split=<span class="number">0</span>)<span class="comment">#其中test_split为设置测试组数据所占比例，默认为0.2</span></span><br><span class="line"><span class="comment">#打印训练与测试数据的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The train:&quot;</span>,<span class="built_in">len</span>(train_x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The test:&quot;</span>,<span class="built_in">len</span>(test_x))</span><br><span class="line"><span class="comment">#打印测试数据的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(train_x))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(train_y))</span><br><span class="line"><span class="comment">#打印测试数据的维度与形状</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Dim of train_x:&quot;</span>,train_x.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shape of train_x:&quot;</span>,train_x.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Dim of train_y:&quot;</span>,train_y.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shape of train_y:&quot;</span>,train_y.shape)</span><br><span class="line"><span class="comment">#输出train_x中的前5行数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The train_x[0:5] is:\n&quot;</span>,train_x[<span class="number">0</span>:<span class="number">5</span>])</span><br><span class="line"><span class="comment">#取出train_x中某一列的数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The train_x[:,5] is:\n&quot;</span>,train_x[:,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制各个属性与房价的关系</span></span><br><span class="line"><span class="comment">#设置运行时参数</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>]=[<span class="string">&quot;SimHei&quot;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>]=<span class="literal">False</span></span><br><span class="line"><span class="comment">#子图的标题</span></span><br><span class="line">titles=[<span class="string">&quot;CRIM&quot;</span>,<span class="string">&quot;ZN&quot;</span>,<span class="string">&quot;INDUS&quot;</span>,<span class="string">&quot;CHAS&quot;</span>,<span class="string">&quot;NOX&quot;</span>,<span class="string">&quot;RM&quot;</span>,<span class="string">&quot;AGE&quot;</span>,<span class="string">&quot;DIS&quot;</span>,<span class="string">&quot;RAD&quot;</span>,<span class="string">&quot;TAX&quot;</span>,<span class="string">&quot;PTRATIO&quot;</span>,<span class="string">&quot;B-1000&quot;</span>,<span class="string">&quot;LSTAT&quot;</span>,<span class="string">&quot;MEDV&quot;</span>]</span><br><span class="line"><span class="comment">#设置绘图尺寸</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">12</span>))</span><br><span class="line"><span class="comment">#通过循环绘制散点图</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    plt.subplot(<span class="number">4</span>,<span class="number">4</span>,(i+<span class="number">1</span>))</span><br><span class="line">    plt.scatter(train_x[:,i],train_y)</span><br><span class="line">    plt.xlabel(titles[i])</span><br><span class="line">    plt.ylabel(<span class="string">&quot;Price($1000&#x27;s)&quot;</span>)</span><br><span class="line">    plt.title(<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&quot;.&quot;</span>+titles[i]+<span class="string">&quot; - Price&quot;</span>)</span><br><span class="line"><span class="comment">#调整子图间隔</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line"><span class="comment">#设置全局标题</span></span><br><span class="line">plt.suptitle(<span class="string">&quot;各个属性与房价的关系&quot;</span>,x=<span class="number">0.5</span>,y=<span class="number">1.02</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment">#显示绘图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>部分结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221028120441204.png" alt="image-20221028120441204" style="zoom: 67%;"></p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8BNumPy%E4%B8%8EMatplotlib%E5%BA%93/image-20221028120530479.png" alt="image-20221028120530479"></p>
<hr>
<h1 id="附：相关网站"><a href="#附：相关网站" class="headerlink" title="附：相关网站"></a>附：相关网站</h1><ul>
<li>Matplotlib官网：<a href="https://matplotlib.org">https://matplotlib.org</a></li>
<li>Gallery页面：<a href="https://matplotlib.org/gallery.html">https://matplotlib.org/gallery.html</a></li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow实践之数字图像处理基础</title>
    <url>/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>计算机视觉是人工智能的大门，其已成为人工智能应用方向的领头羊。故掌握数字图像处理的基础十分必要。本文主要介绍了导入Pillow库中的Image对图像进行简单处理的方法。</p>
<span id="more"></span>
<h1 id="图像的打开与保存"><a href="#图像的打开与保存" class="headerlink" title="图像的打开与保存"></a>图像的打开与保存</h1><ul>
<li><p><strong>导入模块</strong>：<code>from PIL import Image</code></p>
</li>
<li><p><strong>打开图像</strong>：<code>Image.open()</code>#返回图像对象</p>
</li>
<li><p><strong>保存图像</strong>：<code>Image.save(文件路径)</code>#<strong>改变文件名后缀，就可以转换图像格式</strong></p>
</li>
<li><p><strong>图像对象的主要属性</strong>：</p>
<p>| 属性            | 说明     |<br>| ———————- | ———— |<br>| 图像对象.format | 图像格式 |<br>| 图像对象.size   | 图像尺寸 |<br>| 图像对象.mode   | 色彩模式 |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment">#打开图像</span></span><br><span class="line">img=Image.<span class="built_in">open</span>(<span class="string">&quot;lena.tiff&quot;</span>)</span><br><span class="line"><span class="comment">#保存图像</span></span><br><span class="line">img.save(<span class="string">&quot;test.tiff&quot;</span>)</span><br><span class="line">img.save(<span class="string">&quot;lena.jpg&quot;</span>)</span><br><span class="line">img.save(<span class="string">&quot;lena.bmp&quot;</span>)</span><br><span class="line"><span class="comment">#查看图像对象的主要属性</span></span><br><span class="line">img1=Image.<span class="built_in">open</span>(<span class="string">&quot;lena.jpg&quot;</span>)</span><br><span class="line">img2=Image.<span class="built_in">open</span>(<span class="string">&quot;lena.bmp&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The format:&quot;</span>,img2.<span class="built_in">format</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The size:&quot;</span>,img2.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The mode:&quot;</span>,img2.mode)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/image-20221028221253149.png" alt="image-20221028221253149" style="zoom: 67%;"></p>
</li>
</ul>
<hr>
<h1 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h1><ul>
<li><p><code>plt.imshow(image对象/Numpy数组)</code>#对图像进行处理并显示其格式</p>
</li>
<li><p><code>plt.show()</code>#将处理后的图像显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示图像</span></span><br><span class="line"><span class="comment">#设置画布尺寸</span></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment">#设置子图</span></span><br><span class="line">plt.subplot(<span class="number">131</span>)</span><br><span class="line"><span class="comment">#plt.axis(&quot;off&quot;)#关闭坐标轴</span></span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.title(img.<span class="built_in">format</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">132</span>)</span><br><span class="line"><span class="comment">#plt.axis(&quot;off&quot;)</span></span><br><span class="line">plt.imshow(img1)</span><br><span class="line">plt.title(img1.<span class="built_in">format</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">133</span>)</span><br><span class="line"><span class="comment">#plt.axis(&quot;off&quot;)</span></span><br><span class="line">plt.imshow(img2)</span><br><span class="line">plt.title(img2.<span class="built_in">format</span>)</span><br><span class="line"><span class="comment">#将处理后的图像显示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/image-20221028221709477.png" alt="image-20221028221709477"></p>
</li>
</ul>
<hr>
<h1 id="转换图像的色彩模式"><a href="#转换图像的色彩模式" class="headerlink" title="转换图像的色彩模式"></a>转换图像的色彩模式</h1><ul>
<li><p><code>图像对象.convert(色彩模式)</code></p>
<p>| 取值  | 色彩模式                            |<br>| ——- | —————————————————- |<br>| 1     | 二值图像（仍是8位数据，0x00与0xFF） |<br>| L     | 灰度图像                            |<br>| P     | 8位彩色图像                         |<br>| RGB   | 24位彩色图像                        |<br>| RGBA  | 32位彩色图像                        |<br>| CMYK  | CMYK彩色图像                        |<br>| YCbCr | YCbCr彩色图像                       |<br>| I     | 32位整数灰度图像                    |<br>| F     | 32位浮点灰度图像                    |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换图像的色彩模式</span></span><br><span class="line">img_convert=img.convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The convert mode:&quot;</span>,img_convert.mode)<span class="comment">#img_convert是一个新的图像对象</span></span><br><span class="line">img_convert.save(<span class="string">&quot;img_Gray.bmp&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/image-20221028222519861.png" alt="image-20221028222519861" style="zoom:67%;"></p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/image-20221028222455045.png" alt="image-20221028222455045"></p>
</li>
</ul>
<hr>
<h1 id="颜色通道的分离与合并"><a href="#颜色通道的分离与合并" class="headerlink" title="颜色通道的分离与合并"></a>颜色通道的分离与合并</h1><ul>
<li><p><strong>分离</strong>：<code>图像对象.split()</code></p>
</li>
<li><p><strong>合并</strong>：<code>Image.merge(色彩模式，图像列表)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#颜色通道的分离与合并</span></span><br><span class="line"><span class="comment">#1.分离</span></span><br><span class="line">img_r,img_g,img_b=img.split()</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示分离后的效果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(img_r,cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;R&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(img_g,cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;G&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(img_b,cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;B&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.合并</span></span><br><span class="line">img_rgb=Image.merge(<span class="string">&quot;RGB&quot;</span>,[img_r,img_g,img_b])</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(img_rgb)</span><br><span class="line">plt.title(<span class="string">&quot;RGB&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示处理后的图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/image-20221028222912075.png" alt="image-20221028222912075" style="zoom: 50%;"></p>
</li>
</ul>
<hr>
<h1 id="将图像数据转化为数组"><a href="#将图像数据转化为数组" class="headerlink" title="将图像数据转化为数组"></a>将图像数据转化为数组</h1><ul>
<li><p><code>np.array(图像对象)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将图像数据转化为数组</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img_array=np.array(img)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The shape:&quot;</span>,img_array.shape)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/image-20221028223116921.png" alt="image-20221028223116921" style="zoom: 80%;"></p>
</li>
</ul>
<hr>
<h1 id="图像的缩放、旋转和裁剪"><a href="#图像的缩放、旋转和裁剪" class="headerlink" title="图像的缩放、旋转和裁剪"></a>图像的缩放、旋转和裁剪</h1><ul>
<li><p><strong>缩放</strong>：</p>
<ul>
<li><code>图像对象.resize((width,height))</code></li>
<li><code>图像对象.thumbnail((width,height))</code><strong>#其返回值是None，也就是直接对图像对象进行了缩放</strong></li>
</ul>
</li>
<li><p><strong>旋转、镜像</strong>：</p>
<ul>
<li><p><code>图像对象.transpose(旋转方式)</code></p>
</li>
<li><p>旋转方式：</p>
<p>| 操作                            | 对应旋转方式               |<br>| ———————————————- | ————————————— |<br>| Image.Transpose.FLIP_LEFT_RIGHT | 水平翻转                   |<br>| Image.Transpose.FLIP_TOP_BOTTOM | 上下翻转                   |<br>| Image.Transpose.ROTATE_90       | 逆时针旋转90               |<br>| Image.Transpose.ROTATE_180      | 逆时针旋转180              |<br>| Image.Transpose.ROTATE_270      | 逆时针旋转270              |<br>| Image.Transpose.TRANSPOSE       | 将图像进行转置             |<br>| Image.Transpose.TRANSVERSE      | 将图像进行转置，再水平翻转 |</p>
</li>
</ul>
</li>
<li><p><strong>裁剪</strong>：在图像上指定的位置裁剪出一个矩形区域</p>
<ul>
<li><code>图像对象.crop((x0,y0,x1,y1))</code></li>
<li><strong>x0,x0对应左上角坐标；x1,y1对应右下角坐标</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对图像进行缩放和旋转和裁剪</span></span><br><span class="line"><span class="comment">#1.缩放图像</span></span><br><span class="line">img_resize=img.resize((<span class="number">64</span>,<span class="number">64</span>))</span><br><span class="line"><span class="comment">#2.旋转图像</span></span><br><span class="line">img_transpose=img.transpose(Image.Transpose.ROTATE_90)</span><br><span class="line"><span class="comment">#3.裁剪图像</span></span><br><span class="line">img_crop=img.crop((<span class="number">100</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">400</span>))</span><br><span class="line"><span class="comment">#显示图像</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.title(<span class="string">&quot;img&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(img_resize)</span><br><span class="line">plt.title(<span class="string">&quot;img_resize&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(img_transpose)</span><br><span class="line">plt.title(<span class="string">&quot;img_transpose&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(img_crop)</span><br><span class="line">plt.title(<span class="string">&quot;img_crop&quot;</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/image-20221028224240134.png" alt="image-20221028224240134" style="zoom: 50%;"></p>
<hr>
<h1 id="实例分析：手写数字数据集MNIST"><a href="#实例分析：手写数字数据集MNIST" class="headerlink" title="实例分析：手写数字数据集MNIST"></a>实例分析：手写数字数据集MNIST</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#下载MNIST数据集</span></span><br><span class="line">mnist=tf.keras.datasets.mnist</span><br><span class="line">(train_x,train_y),(test_x,test_y)=mnist.load_data(path=<span class="string">&quot;D:\App_Data_File\Anaconda_data\jupyter\image\mnist.npz&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机显示四幅手写图</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    num=np.random.randint(<span class="number">1</span>,<span class="number">50000</span>)</span><br><span class="line">    plt.subplot(<span class="number">1</span>,<span class="number">4</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(train_x[num],cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.title(train_y[num])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/28/TensorFlow%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/image-20221028224752246.png" alt="image-20221028224752246" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之数据类型</title>
    <url>/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>数据类型是Python基本语法中非常重要的一部分，本文对集合、序列、字典这三大类数据类型做了部分总结。</p>
<span id="more"></span>
<h1 id="集合类型及操作"><a href="#集合类型及操作" class="headerlink" title="集合类型及操作"></a>集合类型及操作</h1><ul>
<li>集合是多个元素的无序组合</li>
<li>集合元素之间<strong>无序</strong>，每个元素<strong>唯一，不存在相同元素</strong></li>
<li>集合元素<strong>不可更改</strong>，不能是可变数据类型</li>
</ul>
<h2 id="1-集合的创建"><a href="#1-集合的创建" class="headerlink" title="1.集合的创建"></a>1.集合的创建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用&#123;&#125;建立集合</span></span><br><span class="line">A=&#123;<span class="string">&quot;python&quot;</span>,<span class="number">123</span>,(<span class="string">&quot;python&quot;</span>,<span class="number">123</span>)&#125;</span><br><span class="line"><span class="comment">#使用set()建立集合</span></span><br><span class="line">B=<span class="built_in">set</span>(<span class="string">&quot;pypy123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出结果如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="string">&quot;python&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;python&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221026222311648.png" alt="image-20221026222311648" style="zoom:67%;"></p>
<h2 id="2-集合操作符"><a href="#2-集合操作符" class="headerlink" title="2.集合操作符"></a>2.集合操作符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作符及应用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>S\</td>
<td>T</td>
<td>并，返回一个新集合，包括在集合S和T中的所有元素</td>
</tr>
<tr>
<td>S-T</td>
<td>差，返回一个新集合，包括在集合S但不在T中的元素</td>
</tr>
<tr>
<td>S&amp;T</td>
<td>交，返回一个新集合，包括同时在集合S和T中的元素</td>
</tr>
<tr>
<td>S^T</td>
<td>补，返回一个新集合，包括集合S和T中的非相同元素</td>
</tr>
<tr>
<td>S&lt;=T 或 S&lt;T</td>
<td>返回True/False，判断S和T的子集关系</td>
</tr>
<tr>
<td>S&gt;=T 或S&gt;T</td>
<td>返回True/False，判断S和T的包含关系</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-集合处理方法"><a href="#3-集合处理方法" class="headerlink" title="3.集合处理方法"></a>3.集合处理方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作函数或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>S.add(x)</td>
<td>如何x不在集合S中，将x增加到S</td>
</tr>
<tr>
<td>S.discard(x)</td>
<td>移除S中元素x，如果x不在集合S中，不报错</td>
</tr>
<tr>
<td>S.remove(x)</td>
<td>移除S中元素x，如果x不在集合S中，产生KeyError异常</td>
</tr>
<tr>
<td>S.clear()</td>
<td>移除S中所有元素</td>
</tr>
<tr>
<td>S.pop()</td>
<td>随机返回S的一个元素，更新S，若S为空产生keyError异常</td>
</tr>
<tr>
<td>S.copy()</td>
<td>返回集合S的一个副本</td>
</tr>
<tr>
<td>len(S)</td>
<td>返回集合S的元素个数</td>
</tr>
<tr>
<td>x in S</td>
<td>判断S中元素x，x在集合S中，返回True，否则返回False</td>
</tr>
<tr>
<td>x not in S</td>
<td>判断S中元素x，x不在集合S中，返回True，否则返回False</td>
</tr>
<tr>
<td>set(x)</td>
<td>将其他类型变量x转变为集合类型</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S=&#123;<span class="string">&quot;s&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;g&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出结果如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s&quot;</span> <span class="keyword">in</span> S)</span><br><span class="line"><span class="built_in">print</span>(S.pop())</span><br><span class="line"><span class="built_in">print</span>(S)<span class="comment">#S中的元素&quot;h&quot;已经被取出</span></span><br><span class="line">S.remove(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221026224237804.png" alt="image-20221026224237804" style="zoom:67%;"></p>
<h2 id="4-集合类型应用场景：数据去重"><a href="#4-集合类型应用场景：数据去重" class="headerlink" title="4.集合类型应用场景：数据去重"></a>4.集合类型应用场景：数据去重</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls=[<span class="string">&quot;p&quot;</span>,<span class="string">&quot;p&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="number">123</span>]</span><br><span class="line"><span class="comment">#利用了集合无重复元素的特点</span></span><br><span class="line">s=<span class="built_in">set</span>(ls)</span><br><span class="line"><span class="comment">#将结合转化为列表</span></span><br><span class="line">lt=<span class="built_in">list</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出结果如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(lt)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221026224557362.png" alt="image-20221026224557362" style="zoom: 67%;"></p>
<hr>
<h1 id="序列类型及操作"><a href="#序列类型及操作" class="headerlink" title="序列类型及操作"></a>序列类型及操作</h1><ul>
<li>序列是<strong>具有先后关系</strong>的一组元素</li>
<li>序列是一维元素向量，元素类型可以不同</li>
<li>元素间由序号引导，通过下标访问序列的特定元素</li>
<li>序列是一个基类类型，主要发展为以下三类：<ul>
<li>字符串类型</li>
<li>元组类型</li>
<li>列表类型</li>
</ul>
</li>
</ul>
<h2 id="1-序列处理操作符与函数"><a href="#1-序列处理操作符与函数" class="headerlink" title="1.序列处理操作符与函数"></a>1.序列处理操作符与函数</h2><p><strong>其同样适用于字符串类型、元组类型、列表类型</strong></p>
<ul>
<li><p><strong>6个操作符</strong></p>
<p>| 操作符及应用       | 描述                                         |<br>| ————————— | —————————————————————— |<br>| x in s             | 如果x是序列s的元素，返回True，否则返回False  |<br>| x not in s         | 如果x是序列s的元素，返回False，否则返回True  |<br>| s + t              | 连接两个序列s和t                             |<br>| s*n                | 序列s复制n次                                 |<br>| s[i]               | 索引，返回s中的第i元素，i是序列的序号        |<br>| s[i:j] 或 s[i:j:k] | 切片，返回序列s中第i到j以K为步长的元素子序列 |</p>
</li>
<li><p><strong>5个函数</strong></p>
<p>| 函数                         | 描述                                          |<br>| —————————————— | ——————————————————————- |<br>| len(s)                       | 返回序列s的长度，即元素个数                   |<br>| min(s)                       | 返回序列s的最小元素，s中元素需要可比较        |<br>| max(s)                       | 返回序列s的最大元素，s中元素需要可比较        |<br>| s.index(x) 或 s.index(x,i,j) | 返回序列从i开始到j位置中第一次出现元素x的位置 |<br>| s.count(x)                   | 返回序列s中出现x的总次数                      |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=[<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出结果如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="number">9</span>,<span class="number">2</span>,<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221026230659752.png" alt="image-20221026230659752" style="zoom:67%;"></p>
</li>
</ul>
<h2 id="2-元组类型及操作"><a href="#2-元组类型及操作" class="headerlink" title="2.元组类型及操作"></a>2.元组类型及操作</h2><ul>
<li><p>元组是序列类型的一种扩展</p>
</li>
<li><p>元组是一种序列类型，一旦创建就<strong>不能被修改</strong></p>
</li>
<li><p>使用小括号<code>()</code>或<code>tuple</code>创建，元素间用逗号<code>,</code>分割</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出结果如下：&quot;</span>)</span><br><span class="line"><span class="comment">#使用tuple创建</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(s))</span><br><span class="line"><span class="comment">#使用()创建</span></span><br><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;y&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221026231303489.png" alt="image-20221026231303489" style="zoom: 67%;"></p>
</li>
</ul>
<h2 id="3-列表类型及操作"><a href="#3-列表类型及操作" class="headerlink" title="3.列表类型及操作"></a>3.列表类型及操作</h2><ul>
<li><p>列表是序列类型的一种扩展，创建后<strong>可以随意被修改</strong></p>
</li>
<li><p>使用方括号<code>[]</code>或l<code>ist</code>创建，元素间用逗号<code>,</code>分隔</p>
</li>
<li><p>列表中各元素类型可以不同，无长度限制</p>
</li>
<li><p>列表类型的操作函数</p>
<p>| 函数           | 描述                                  |<br>| ——————— | ——————————————————- |<br>| ls.append(x)   | 在列表ls最后增加一个元素              |<br>| ls.clear()     | 删除列表ls中所有的元素                |<br>| ls.copy()      | 生成一个新列表，赋值ls中所有元素      |<br>| ls.insert(i,x) | 在列表ls的第i位置增加元素x            |<br>| ls.pop(i)      | 将列表ls中第i位置元素取出并删除该元素 |<br>| ls.remove(x)   | 将列表ls中出现的第一个元素x删除       |<br>| ls.reverse()   | 将列表中ls的元素反转                  |<br>| del ls[i:j:k]  | 删除列表ls中第i到j以k为步长的元素     |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls=[<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="keyword">del</span> ls[<span class="number">0</span>:<span class="number">2</span>:<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出结果如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ls)</span><br><span class="line">ls.insert(<span class="number">3</span>,<span class="string">&quot;s&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ls)</span><br><span class="line">ls.reverse()</span><br><span class="line"><span class="built_in">print</span>(ls)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221026233245494.png" alt="image-20221026233245494" style="zoom:67%;"></p>
</li>
</ul>
<h2 id="4-字符串类型及操作"><a href="#4-字符串类型及操作" class="headerlink" title="4.字符串类型及操作"></a>4.字符串类型及操作</h2><ul>
<li><p><strong>字符串的序号</strong>：</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221027124853404.png" alt="image-20221027124853404" style="zoom: 25%;"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;python is a romantic language&quot;</span></span><br><span class="line"><span class="comment">#字符反转</span></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221027130050044.png" alt="image-20221027130050044" style="zoom: 80%;"></p>
</li>
<li><p><strong>字符串处理函数</strong></p>
<p>| 函数             | 描述                                  |<br>| ———————— | ——————————————————- |<br>| str(x)           | 任意类型所以对应的字符串形式          |<br>| hex(x) 或 oct(x) | 整数x的十六进制或八进制小写形式字符串 |<br>| chr(u)           | u为Unicode编码，返回其对应的字符      |<br>| ord(x)           | x为字符，返回其对应的Unicode编码      |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打印十二星座对应的字符</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">9800</span>+i),end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221027091451848.png" alt="image-20221027091451848" style="zoom:80%;"></p>
</li>
<li><p><strong>字符串处理方法</strong></p>
<p>| 方法                         | 描述                                                         |<br>| —————————————— | —————————————————————————————— |<br>| str.lower() 或 str.upper()   | 返回字符串的副本，全部字符小写/大写                          |<br>| <code>str.split(sep=None)</code>        | 返回一个列表，有str根据sep被分隔的部分组成                   |<br>| str.replace(old,new)         | 返回字符串str副本，所有old子串被替换成new                    |<br>| str.center(width[,fillchar]) | 字符串str根据宽度width居中，fillchar可选                     |<br>| str.strip(chars)             | 从str中去掉在其左侧和右侧chars中列出的字符                   |<br>| <code>str.join(iter)</code>             | 在iter变量除最后元素外每个元素后增加一个str，<strong>此方法也适用于列表，返回的是字符串类型</strong> |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出结果如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.upper())</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">#返回了大写的副本，原来的字符串s并没有被改变</span></span><br><span class="line">s_new=<span class="string">&quot;,&quot;</span>.join(s)</span><br><span class="line"><span class="built_in">print</span>(s_new)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s_new))<span class="comment">#说明使用str.join(iter)返回的类型是一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(s_new.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s_new.split(<span class="string">&quot;,&quot;</span>)))<span class="comment">#说明使用str.join(iter)返回的类型是列表</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">20</span>,<span class="string">&quot;=&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221027100523337.png" alt="image-20221027100523337" style="zoom:67%;"></p>
</li>
<li><p><strong>字符串类型的格式化</strong></p>
<p>| :        | &lt;填充&gt;             | &lt;对齐&gt;                                  | &lt;宽度&gt;       | &lt;,&gt;              | &lt;. 精度&gt;                             | &lt;类型&gt;                                         |<br>| ———— | ————————— | ———————————————————- | —————— | ———————— | —————————————————— | ——————————————————————— |<br>| 引导符号 | 用于填充的单个字符 | <code>&lt;</code>: 左对齐；<code>&lt;</code>: 右对齐；<code>^</code>: 居中对齐 | 设定输出位宽 | 数字的千位分隔符 | 浮点数小数精度 或 字符串最大输出长度 | 整数类型：<code>b,c,d,o,x,X</code>；浮点数类型：<code>e,E,f,%</code> |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小明的数学成绩是&#123;1:=^20.2f&#125;，英语成绩是&#123;0:*&gt;20.2f&#125;，语文成绩是&#123;2:#&lt;20.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">98.773</span>,<span class="number">97.273</span>,<span class="number">96.094</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221027102813322.png" alt="image-20221027102813322"></p>
</li>
</ul>
<hr>
<h1 id="字典类型及操作"><a href="#字典类型及操作" class="headerlink" title="字典类型及操作"></a>字典类型及操作</h1><ul>
<li>字典类型是“映射”的体现</li>
<li>键值对：键是数据索引的扩展</li>
<li>字典是键值对的集合，<strong>键值对之间无序</strong></li>
<li>采用大括号<code>&#123;&#125;</code>和<code>dict</code>创建，键值对用冒号<code>:</code>表示</li>
</ul>
<h2 id="1-字典的创建"><a href="#1-字典的创建" class="headerlink" title="1.字典的创建"></a>1.字典的创建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用&#123;&#125;创建</span></span><br><span class="line">d=&#123;<span class="string">&quot;中国&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;美国&quot;</span>:<span class="string">&quot;华盛顿&quot;</span>,<span class="string">&quot;法国&quot;</span>:<span class="string">&quot;巴黎&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment">#用dict创建</span></span><br><span class="line">lis = [(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;height&#x27;</span>, <span class="number">180</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(lis))</span><br><span class="line"><span class="comment">#创建空字典</span></span><br><span class="line">de=&#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(de))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221027110024611.png" alt="image-20221027110024611" style="zoom:67%;"></p>
<h2 id="2-字典处理函数及方法"><a href="#2-字典处理函数及方法" class="headerlink" title="2.字典处理函数及方法"></a>2.字典处理函数及方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>del d[k]</td>
<td>删除字典d中键k对应的数据值</td>
</tr>
<tr>
<td>k in d</td>
<td>判断键k是否在字典d中，如果在返回True，否则False</td>
</tr>
<tr>
<td>d.keys()</td>
<td>返回字典d中所有的键信息</td>
</tr>
<tr>
<td>d.values()</td>
<td>返回字典d中所有的值信息</td>
</tr>
<tr>
<td>d.items()</td>
<td>返回字典d中所有键值对信息</td>
</tr>
<tr>
<td>d.get(k,default)</td>
<td>键k存在，则返回相应值，不在则返回default值</td>
</tr>
<tr>
<td>d.pop(k,default)</td>
<td>键k存在，则取出相应值，不在则返回default值</td>
</tr>
<tr>
<td>d.popitem()</td>
<td>随机从字典d中取出一个键值对，以元组的形式返回</td>
</tr>
<tr>
<td>d.clear()</td>
<td>删除所有键值对</td>
</tr>
<tr>
<td>len(d)</td>
<td>返回字典d中元素的个数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个空字典d</span></span><br><span class="line">d=&#123;&#125;</span><br><span class="line"><span class="comment">#向d新增2个键值对元素</span></span><br><span class="line">d[<span class="string">&quot;a&quot;</span>]=<span class="number">1</span></span><br><span class="line">d[<span class="string">&quot;b&quot;</span>]=<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment">#修改第2个元素</span></span><br><span class="line">d[<span class="string">&quot;b&quot;</span>]=<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment">#判断”c&quot;是否是d的键值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> d)</span><br><span class="line"><span class="comment">#计算d的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(d))</span><br><span class="line"><span class="comment">#随机从字典d中取出一个键值对，并以元组形式返回</span></span><br><span class="line"><span class="built_in">print</span>(d.popitem())</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment">#通过键返回相应值，但字典d并没有被改变</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20221027111632810.png" alt="image-20221027111632810" style="zoom: 67%;"></p>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>浪漫的Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之文件的读写</title>
    <url>/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<p>数据处理可谓是Python最擅长的工作之一。那对于我们需要处理的大量数据，手动输入代码中是极其不科学的，故我们需要学会对文件进行读写操作，下面跟着小沈一起来探索吧！</p>
<span id="more"></span>
<h1 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h1><ul>
<li><p><code>&lt;变量名&gt; = open(&lt;文件名&gt;,&lt;打开模式&gt;)</code></p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/image-20221027123041800.png" alt="image-20221027123041800" style="zoom: 50%;"></p>
</li>
<li><p><strong>打开模式</strong></p>
<p>| 文件的打开模式 | 描述                                                    |<br>| ——————— | ———————————————————————————- |<br>| ‘r’            | 只读模式，默认值，如果文件不存在，返回FileNotFoundError |<br>| ‘w’            | 覆盖写模式，文件不存在则创建，存在则完全覆盖            |<br>| ‘x’            | 创建写模式，文件不存在则创建，存在则返回FileExistsError |<br>| ‘a’            | 追加写模式，文件不存在则创建，存在则在文件最后追加内容  |<br>| ‘b’            | 二进制文本模式                                          |<br>| ‘t’            | 文本文件模式，默认值                                    |<br>| ‘+’            | 与r/w/x/a一同使用，在原功能基础上增加同时读写功能       |</p>
</li>
</ul>
<hr>
<h1 id="文件内容的获取"><a href="#文件内容的获取" class="headerlink" title="文件内容的获取"></a>文件内容的获取</h1><div class="table-container">
<table>
<thead>
<tr>
<th>操作方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>f.read(size=-1)</code></td>
<td>读入全部内容，如果给出参数，读入前size长度</td>
</tr>
<tr>
<td><code>f.readline(size=-1)</code></td>
<td>读入一行内容，如果给出参数，读入该行前size长度</td>
</tr>
<tr>
<td><code>f.readlines(hint=-1)</code></td>
<td>读入文件所有行，以每行为元素形成列表，如果给出参数，读入前hint行</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#逐行遍历文件</span></span><br><span class="line"><span class="comment">#方法一：</span></span><br><span class="line">fname=<span class="built_in">input</span>(<span class="string">&quot;请输入要打开的文件名称：&quot;</span>)</span><br><span class="line">fo=<span class="built_in">open</span>(fname,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo.readlines():</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">fo.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line">fname=<span class="built_in">input</span>(<span class="string">&quot;请输入要打开的文件名称：&quot;</span>)</span><br><span class="line">fo=<span class="built_in">open</span>(fname,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo:</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数据的文件写入"><a href="#数据的文件写入" class="headerlink" title="数据的文件写入"></a>数据的文件写入</h1><div class="table-container">
<table>
<thead>
<tr>
<th>操作方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>f.write(s)</td>
<td>向文件写入一个字符串或字节流</td>
</tr>
<tr>
<td>f.writelines(lines)</td>
<td>将一个元素全为字符串的列表写入文件</td>
</tr>
<tr>
<td><code>f.seek(offset)</code></td>
<td>改变当前文件操作指针的位置，offset=0(代表回到文件开头)，offset=1（代表当前位置），offset=2（代表回到文件结尾）</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>)</span><br><span class="line">ls=[<span class="string">&quot;努力是成功的别名&quot;</span>,<span class="string">&quot;每一次成长&quot;</span>,<span class="string">&quot;都是一次经历&quot;</span>]</span><br><span class="line">fo.writelines(ls)</span><br><span class="line"><span class="comment">#fo.writelines(&#x27;\n&#x27;.join(ls)) 可以加上这一句实现分行写入</span></span><br><span class="line">fo.seek(<span class="number">0</span>)<span class="comment">#必须要改变文件操作指针的位置，不然写完元素之后指针到了文章最后，会导致写下来读不出内容</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo:</span><br><span class="line">    <span class="built_in">print</span>(line) <span class="comment">#由结果可以注意到实际上writelines不是一行行写入的，是连着写入的</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/image-20221027140238501.png" alt="image-20221027140238501" style="zoom:67%;"></p>
<hr>
<h1 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h1><ul>
<li><code>&lt;变量名&gt;.close()</code>#使用完文件后一定要记得关闭文件</li>
</ul>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>浪漫的Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之标准库与第三方库</title>
    <url>/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<p>这里记录着小沈学习在Python过程中遇到的6个重要又有趣的Python标准库与第三方库，分别是turtle库、time库、random库、PyInstaller库、jieba库、wordcloud库。</p>
<span id="more"></span>
<h1 id="Turtle库"><a href="#Turtle库" class="headerlink" title="Turtle库"></a>Turtle库</h1><p>turtle库是Python语言的标准库之一，是入门级的图形绘制函数库。</p>
<h2 id="1-Turtle的绘图窗体"><a href="#1-Turtle的绘图窗体" class="headerlink" title="1.Turtle的绘图窗体"></a>1.Turtle的绘图窗体</h2><ul>
<li><p><code>turtle.setup(width,height,startx,starty)</code></p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026233551447.png" alt="image-20221026233551447" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="2-Turtle空间坐标体系及其绘制"><a href="#2-Turtle空间坐标体系及其绘制" class="headerlink" title="2.Turtle空间坐标体系及其绘制"></a>2.Turtle空间坐标体系及其绘制</h2><ul>
<li><strong>绝对坐标</strong>：<code>turtle. goto(x,y)</code></li>
</ul>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026125555079.png" alt="image-20221026125555079" style="zoom: 33%;"></p>
<ul>
<li><p><strong>相对坐标</strong>：</p>
<ul>
<li><p><code>turtle.circle(r,angle)</code>#画圆</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026125850598.png" alt="image-20221026125850598" style="zoom:50%;"></p>
</li>
<li><p><code>turtle.bk(d)</code>#后退</p>
</li>
<li><p><code>turtle.fd(d)</code>#前进</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026130100140.png" alt="image-20221026130100140" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<h2 id="3-Turtle角度坐标体系及其角度改变"><a href="#3-Turtle角度坐标体系及其角度改变" class="headerlink" title="3.Turtle角度坐标体系及其角度改变"></a>3.Turtle角度坐标体系及其角度改变</h2><ul>
<li><p><strong>绝对角度</strong>：<code>turtle.seth(angle)</code></p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026130556081.png" alt="image-20221026130556081" style="zoom: 50%;"></p>
</li>
<li><p><strong>海龟角度</strong>：</p>
<ul>
<li><p><code>turtle.left(angle)</code></p>
</li>
<li><p><code>turtle.right(angle)</code></p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026130839885.png" alt="image-20221026130839885" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-Turtle的RGB色彩模式"><a href="#4-Turtle的RGB色彩模式" class="headerlink" title="4.Turtle的RGB色彩模式"></a>4.Turtle的RGB色彩模式</h2><ul>
<li><p><code>turtle.colormode(mode)</code></p>
</li>
<li><p>默认采用小数值，可切换为整数值:</p>
<ul>
<li>mode=1.0：RGB小数值模式</li>
<li>mode=255：RGB整数值模式</li>
</ul>
</li>
<li><p>常用RGB色彩：</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026131931664.png" alt="image-20221026131931664" style="zoom:50%;"></p>
</li>
</ul>
<h2 id="5-画笔控制函数"><a href="#5-画笔控制函数" class="headerlink" title="5.画笔控制函数"></a>5.画笔控制函数</h2><ul>
<li><code>turtle.penup()</code>#将画笔抬起</li>
<li><code>turtle.pendown()</code>#将画笔落下</li>
<li><code>turtle.pensize(width)</code></li>
<li><code>turtle.pencolor(color)</code></li>
</ul>
<h2 id="6-简单示例：爱心绘制"><a href="#6-简单示例：爱心绘制" class="headerlink" title="6.简单示例：爱心绘制"></a>6.简单示例：爱心绘制</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line"><span class="comment">#绘制准备：画布与画笔设置</span></span><br><span class="line">t.setup(<span class="number">600</span>,<span class="number">600</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">t.penup()</span><br><span class="line">t.left(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">50</span>)</span><br><span class="line">t.pendown()<span class="comment">#以上代码相当于设置绘制的起始位置</span></span><br><span class="line">t.pensize(<span class="number">10</span>)</span><br><span class="line">t.pencolor(<span class="string">&quot;pink&quot;</span>)</span><br><span class="line"><span class="comment">#正式开始绘制</span></span><br><span class="line">t.left(<span class="number">30</span>)</span><br><span class="line">t.fd(<span class="number">30</span>)</span><br><span class="line">t.circle(<span class="number">90</span>,<span class="number">200</span>)</span><br><span class="line">t.fd(<span class="number">200</span>)</span><br><span class="line">t.left(<span class="number">80</span>)</span><br><span class="line">t.fd(<span class="number">200</span>)</span><br><span class="line">t.circle(<span class="number">90</span>,<span class="number">200</span>)</span><br><span class="line">t.fd(<span class="number">30</span>)</span><br><span class="line"><span class="comment">#绘制结束</span></span><br><span class="line">t.done()</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Time库"><a href="#Time库" class="headerlink" title="Time库"></a>Time库</h1><p>time库是Python中处理时间的标准库，能够获取系统时间并格式化输出功能，并提供系统级精确计时功能，用于程序性能分析。</p>
<h2 id="1-时间获取"><a href="#1-时间获取" class="headerlink" title="1.时间获取"></a>1.时间获取</h2><ul>
<li><p><code>time()</code></p>
</li>
<li><p><code>ctime()</code></p>
</li>
<li><p><code>gmtime()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="comment">#获取当前时间戳，即计算机内部时间值，浮点数</span></span><br><span class="line">t1=time.time()</span><br><span class="line"><span class="comment">#获取当前时间并以易读的方式表示，返回字符串</span></span><br><span class="line">t2=time.ctime()</span><br><span class="line"><span class="comment">#获取当时间时间，表示为计算机可处理的时间格式</span></span><br><span class="line">t3=time.gmtime()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(t2)</span><br><span class="line"><span class="built_in">print</span>(t3)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026135304443.png" alt="image-20221026135304443"></p>
</li>
</ul>
<h2 id="2-时间格式化"><a href="#2-时间格式化" class="headerlink" title="2.时间格式化"></a>2.时间格式化</h2><ul>
<li><p><code>strftime(tpl,ts)</code></p>
</li>
<li><p>其中tpl是格式化模板字符串，用来定义输出效果，ts是计算机内部时间类型变量</p>
</li>
<li><p>格式化字符串：</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026135931077.png" alt="image-20221026135931077" style="zoom: 33%;"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">t=time.gmtime()</span><br><span class="line">s=time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,t)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行结果：&quot;</span>,s)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026140545309.png" alt="image-20221026140545309"></p>
</li>
</ul>
<h2 id="3-程序计时"><a href="#3-程序计时" class="headerlink" title="3.程序计时"></a>3.程序计时</h2><ul>
<li><p><code>perf_counter()</code>#返回一个CPU级别的精确时间计算值，单位为秒</p>
</li>
<li><p><code>sleep(s)</code>#s是休眠时间，单位是秒，可以是浮点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start=time.perf_counter()</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">end=time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行结果：&quot;</span>,end-start)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026141351592.png" alt="image-20221026141351592"></p>
</li>
</ul>
<h2 id="4-简单示例：文本进度条"><a href="#4-简单示例：文本进度条" class="headerlink" title="4.简单示例：文本进度条"></a>4.简单示例：文本进度条</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">scale = <span class="number">50</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;执行开始&quot;</span>.center(scale//<span class="number">2</span>, <span class="string">&quot;-&quot;</span>))</span><br><span class="line">start = time.perf_counter()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(scale+<span class="number">1</span>):</span><br><span class="line">    a = <span class="string">&#x27;*&#x27;</span> * i</span><br><span class="line">    b = <span class="string">&#x27;.&#x27;</span> * (scale - i)</span><br><span class="line">    c = (i/scale)*<span class="number">100</span></span><br><span class="line">    dur = time.perf_counter() - start、</span><br><span class="line">    <span class="comment">#\r表示将光标的位置回退到本行的开头位置</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;</span>.<span class="built_in">format</span>(c,a,b,dur),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;执行结束&quot;</span>.center(scale//<span class="number">2</span>,<span class="string">&#x27;-&#x27;</span>))</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Random库"><a href="#Random库" class="headerlink" title="Random库"></a>Random库</h1><p>Random库Python中用于生成随机数的标准库。</p>
<h2 id="1-基本随机函数"><a href="#1-基本随机函数" class="headerlink" title="1.基本随机函数"></a>1.基本随机函数</h2><ul>
<li><code>seed()</code>#设置随机种子，初始化给定的随机数种子，默认为当前系统时间</li>
<li><code>random()</code>#生成一个[0.0,1.0)之间的随机小数</li>
</ul>
<h2 id="2-扩展随机数函数"><a href="#2-扩展随机数函数" class="headerlink" title="2.扩展随机数函数"></a>2.扩展随机数函数</h2><ul>
<li><code>randint(a,b)</code>#生成一个[a,b]之间的整数</li>
<li><code>randrange(m,n[,k])</code>#生成一个[m,n)之间以k为步长的随机整数</li>
<li><code>getrandbits(k)</code>#生成一个k比特长的随机整数</li>
<li><code>uniform(a,b)</code>#生成一个[a,b]之间的随机小数</li>
<li><code>choice(seq)</code>#从序列seq中随机选择一个元素</li>
<li><code>shuffle(seq)</code>#将序列seq中元素随机排列，返回打乱后的序列</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> r</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行结果如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.random())</span><br><span class="line"><span class="built_in">print</span>(r.randint(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(r.randrange(<span class="number">10</span>,<span class="number">100</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(r.getrandbits(<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(r.uniform(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(r.choice([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>]))</span><br><span class="line">s=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">r.shuffle(s)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026144825189.png" alt="image-20221026144825189" style="zoom: 67%;"></p>
<h2 id="3-简单示例：蒙特卡罗方法计算圆周率"><a href="#3-简单示例：蒙特卡罗方法计算圆周率" class="headerlink" title="3.简单示例：蒙特卡罗方法计算圆周率"></a>3.简单示例：蒙特卡罗方法计算圆周率</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> perf_counter</span><br><span class="line">DARTS = <span class="number">1000</span>*<span class="number">1000</span></span><br><span class="line">hits = <span class="number">0.0</span></span><br><span class="line">start = perf_counter()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, DARTS+<span class="number">1</span>):</span><br><span class="line">    x, y = random(), random()</span><br><span class="line">    dist = <span class="built_in">pow</span>(x ** <span class="number">2</span> + y ** <span class="number">2</span>, <span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> dist &lt;= <span class="number">1.0</span>:</span><br><span class="line">        hits = hits + <span class="number">1</span></span><br><span class="line">pi = <span class="number">4</span> * (hits/DARTS)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;圆周率值是: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(pi))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行时间是: &#123;:.5f&#125;s&quot;</span>.<span class="built_in">format</span>(perf_counter() - start))</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="PyInstaller库"><a href="#PyInstaller库" class="headerlink" title="PyInstaller库"></a>PyInstaller库</h1><p>PyInstaller库是第三方库，故使用前需额外安装，其官网为：<a href="https://pyinstaller.org/en/stable/">PyInstaller Manual — PyInstaller 5.6.1 documentation</a>。其功能是将.py源代码转换成无需源代码的可执行文件。</p>
<ul>
<li><p><strong>简单使用</strong>：<code>(cmd命令行) pyinstaller -F &lt;文件名.py&gt;</code></p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026150414312.png" alt="image-20221026150414312" style="zoom: 33%;"></p>
</li>
<li><p><strong>PyInstaller库常用参数</strong>：</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026150423289.png" alt="image-20221026150423289" style="zoom: 33%;"></p>
</li>
</ul>
<hr>
<h1 id="jieba库"><a href="#jieba库" class="headerlink" title="jieba库"></a>jieba库</h1><p>jieba是优秀的中文分词第三方库，需要额外安装。jieba利用一个中文词库，确定中文字符之间的关联概率，中文字符间概率大的组成词组，形成分词结果。</p>
<ul>
<li><code>jieba.lcuts(s)</code>#精确模式，返回一个列表类型的分词结果</li>
<li><code>jieba.lcuts(s,cut_all=True)</code>#全模式，返回一个列表类型的分词结果，存在冗余</li>
<li><code>jieba.lcut_for_search(s)</code>#搜索引擎模式，返回一个列表类型的分析结果，存在冗余</li>
<li><code>jieba.add_word(w)</code>#向分词词典增加新词w</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">s=<span class="string">&quot;努力是成功的别名&quot;</span></span><br><span class="line">w=<span class="string">&quot;蟒蛇语言&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行结果如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(jieba.lcut(s))</span><br><span class="line"><span class="built_in">print</span>(jieba.lcut(s,cut_all=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(jieba.lcut_for_search(s))</span><br><span class="line">jieba.add_word(w)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/image-20221026152522008.png" alt="image-20221026152522008" style="zoom:67%;"></p>
<hr>
<h1 id="worldcloud库"><a href="#worldcloud库" class="headerlink" title="worldcloud库"></a>worldcloud库</h1><p>worldcloud库是一个生成词云的第三方库。wordcloud.WordCloud()代表一个文本对应的词云，可以根据文本中词云出现的频率等参数绘制词云，词云的绘制形状、尺寸和颜色都可以设定。</p>
<h2 id="1-常规使用方法"><a href="#1-常规使用方法" class="headerlink" title="1.常规使用方法"></a>1.常规使用方法</h2><ul>
<li><p><strong>步骤1：配置对象参数</strong></p>
<p>| 参数             | 描述                                                   |<br>| ———————— | ——————————————————————————— |<br>| width            | 指定词云对象生成图片的宽度，默认400像素                |<br>| height           | 指定词云对象生成图片的高度，默认200像素                |<br>| min_font_size    | 指定词云中字体的最小字号，默认4号                      |<br>| max_font_size    | 指定词云中字体的最大字号，根据高度自动调节             |<br>| font_step        | 指定词云中字体字号的步进间隔，默认为1                  |<br>| font_path        | 指定字体文件的路径，默认None                           |<br>| max_words        | 指定词云显示的最大单词数量，默认200                    |<br>| stop_words       | 指定词云的排除词列表，即不显示的单词列表               |<br>| mask             | 指定词云形状，默认为长方形，若更改需要引用imread()函数 |<br>| background_color | 指定词云图片的背景颜色，默认为黑色                     |</p>
</li>
<li><p><strong>步骤2：加载词云文本</strong></p>
<ul>
<li><code>w.generate(txt)</code>#向WordCloud对象w中加载文本txt</li>
</ul>
</li>
<li><p><strong>步骤3：输出词云文件</strong></p>
<ul>
<li><code>w.to_file(filename)</code>#将词云输出为图像文件，.png或.jpg格式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line"><span class="comment">#配置对象参数</span></span><br><span class="line">w=wordcloud.WordCloud(width=<span class="number">500</span>,height=<span class="number">300</span>,font_path=<span class="string">&quot;msyh.ttc&quot;</span>,min_font_size=<span class="number">2</span>,max_words=<span class="number">20</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#mask的使用示例：</span></span><br><span class="line"><span class="string">from scipy.misc import imread</span></span><br><span class="line"><span class="string">mk=imread(&quot;pic.png&quot;)</span></span><br><span class="line"><span class="string">w=wordcloud.WordCloud(mask=mk)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#加载词云文本</span></span><br><span class="line">w.generate(<span class="string">&quot;The wordcloud by Python,hello world&quot;</span>)</span><br><span class="line"><span class="comment">#输出词云文本</span></span><br><span class="line">w.to_file(<span class="string">&quot;pywordcloud.png&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
</li>
</ul>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pywordcloud-1666772052113-2.png" alt="pywordcloud" style="zoom:67%;"></p>
<h2 id="2-简单示例：生成中文词云"><a href="#2-简单示例：生成中文词云" class="headerlink" title="2.简单示例：生成中文词云"></a>2.简单示例：生成中文词云</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> wordcloud</span><br><span class="line"></span><br><span class="line"><span class="comment">#从文件中读取中文单词并转化为每个单词后面都有一个空格的字符串</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;励志.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">t = f.read()</span><br><span class="line">f.close()</span><br><span class="line">ls = jieba.lcut(t)</span><br><span class="line">txt = <span class="string">&quot; &quot;</span>.join(ls)</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置词云对象参数</span></span><br><span class="line">w = wordcloud.WordCloud(width = <span class="number">1000</span>,height = <span class="number">700</span>,background_color = <span class="string">&quot;white&quot;</span>,font_path = <span class="string">&quot;msyh.ttc&quot;</span>)</span><br><span class="line"><span class="comment">#加载词云文本</span></span><br><span class="line">w.generate(txt)</span><br><span class="line"><span class="comment">#输出词云文件按</span></span><br><span class="line">w.to_file(<span class="string">&quot;encourage.png&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/10/24/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/grwordcloud.png" alt="grwordcloud" style="zoom: 67%;"></p>
<hr>
<h1 id="Pillow库"><a href="#Pillow库" class="headerlink" title="Pillow库"></a>Pillow库</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line"></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&#x27;test.png&#x27;</span>) <span class="comment">#打开一个png图像</span></span><br><span class="line">w, h = im.size <span class="comment">#获取图像尺寸</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Original image size: %sx%s&#x27;</span> % (w, h))</span><br><span class="line">im.show() <span class="comment">#显示图片</span></span><br><span class="line"></span><br><span class="line">im.thumbnail((w//<span class="number">2</span>, h//<span class="number">2</span>)) <span class="comment">#缩放到50%</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Resize image to: %sx%s&#x27;</span> % (w//<span class="number">2</span>, h//<span class="number">2</span>))</span><br><span class="line">im.show()</span><br><span class="line">im.save(<span class="string">&#x27;thumbnail.png&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>) <span class="comment">#将缩放后的图像用jpeg格式保存</span></span><br><span class="line"></span><br><span class="line">im2 = im.<span class="built_in">filter</span>(ImageFilter.BLUR) <span class="comment">#应用模糊滤镜</span></span><br><span class="line">im2.show()</span><br><span class="line">im2.save(<span class="string">&#x27;bur.jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>浪漫的Python</tag>
      </tags>
  </entry>
  <entry>
    <title>保研分享</title>
    <url>/2022/10/23/%E4%BF%9D%E7%A0%94%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>今年，小沈同学顺利保研到了厦门大学，18岁时的梦想终于在21岁实现了！那就让小沈来谈谈这算不上经验之谈的保研经历吧！（小沈总共拿到了厦门大学、东南大学、天津大学、中南大学、南方科技大学、深圳大学6所大学的offer）</p>
<span id="more"></span>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ul>
<li>保研前期的准备包括信息收集、资料准备、联系导师三个阶段</li>
</ul>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><ul>
<li>首先，关注常见的保研公众号，如<strong>保研岛</strong>、保研喵等。但保研公众号大多有信息延迟，故建议经常浏览最想去的几个梦校的官方网站，以便能及时获取梦校信息。这里建议以txt或者excel的形式整理搜集到的信息，示例如下：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>学校（学院）</th>
<th>夏令营/预推免 截止时间</th>
<th>学院官网招生信息页</th>
</tr>
</thead>
<tbody>
<tr>
<td>厦门大学（电子科学与技术学院）</td>
<td>5月25日-6月15日</td>
<td><a href="https://ese.xmu.edu.cn/info/1083/10259.htm">厦门大学电子科学与技术学院2022年全国优秀大学生暑期夏令营招生指南-厦门大学电子科学与技术学院（国家示范性微电子学院） (xmu.edu.cn)</a></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>其次，注意重要的时间节点。<strong>夏令营</strong>最早的可能会在5月低截止，大多数六月低截止，少数七八月低截止。<strong>预推免</strong>有一部分院校开放得早，可能七八月就开了报名系统，大多数集中在九月初开放。（由于小沈了解得有限，此时间节点仅针对电子专业）</p>
</li>
<li><p>我相信大多数将要保研的同学可能都会疑惑夏令营与预推免的区别，以我面试经历了解的看来，主要有如下区别：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>区别</th>
<th>夏令营</th>
<th>预推免</th>
</tr>
</thead>
<tbody>
<tr>
<td>形式</td>
<td>讲座+活动+面试（疫情原因，往往是线上讲座和面试）</td>
<td>面试（有些学校夏令营和预推免一起招生，也只有面试）</td>
</tr>
<tr>
<td>过初审难度</td>
<td>985、211的同学优势明显、双非可能只要第一或第二名</td>
<td>往年确实是进入预推免的门槛较低，但今年保研形式严峻</td>
</tr>
<tr>
<td>拿offer难度</td>
<td>看运气</td>
<td>看运气</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>通过上述比较，结合今年的保研形式，我的结论是：通常情况下过初审时夏令营确实难于预推免，但双非的同学不要怕，只管往前冲，大胆的投就完事了，往往有运气的成分在的话就会幸运的进了。而且在我看来，双非的同学过211是基本没有问题的，再有一些竞赛的加持的话，中等的985也是不在话下的。所以夏令营一定要敢投，最好能拿到保底的offer，这样在预推免的时候就不会那么慌张了。尤其，今年保研名额普遍增多了（这样对双非保研的同学非常不利，因为多了许多985211的保研对手），预推免的竞争变得异常激烈，可能夏令营能投进去的简历，在预推免都投不进去了。所以今年大家都调侃说：“以为夏令营是保底，预推免时发现那是天花板”。最后，关于二者的难度问题，可能每个保研人都有自己的看法，但在我看来，运气和缘分占了很大一部分比例，有时是面试题刚好对你胃口了，有时是面试老师的温柔和蔼让你放松了发挥好了等等，但实力和自信一定是第一位的，所以各位加油！</li>
</ul>
<h2 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h2><ul>
<li><p>保研前期需要准备的材料主要是个人简历、个人陈述、自我介绍PPT、成绩单与成绩排名证明、推荐信（建议在6月份之间完成）</p>
<p>| 资料准备         | 浅薄之见                                                     |<br>| ———————— | —————————————————————————————— |<br>| 个人简历         | 可以在网上找简历模板，建议选简洁大方的，着重介绍科研与竞赛部分，可以提一提性格（浅提） |<br>| 个人陈述         | 相当于自荐信，建议先写一个1500字的版本，之后再根据学校要求修改其字数 |<br>| 自我介绍PPT      | 建议模板简洁大方，包括个人基本信息、主要竞赛（科研）、未来规划 |<br>| 成绩单与排名证明 | 成绩单与成绩排名证明上最好都盖上学校与学院教务处的章         |<br>| 推荐信           | 准备两份，建议一份找竞赛或科研导师，一份找任课老师           |</p>
</li>
</ul>
<h2 id="联系导师"><a href="#联系导师" class="headerlink" title="联系导师"></a>联系导师</h2><ul>
<li>邮件正文简单有重点的介绍自己的情况（有诚意的话先去看看导师的论文再联系）</li>
<li>个人简历与成绩单放附件</li>
<li>对于自己很想去的学校，一定要提前联系导师！（尤其是对于导师权力比较大的学校）</li>
<li>不要害怕被拒绝，不要因为老师的不理睬而感到气馁！（立马换一个老师联系就行，不要因此丧失了信心）</li>
</ul>
<hr>
<h1 id="面试环节"><a href="#面试环节" class="headerlink" title="面试环节"></a>面试环节</h1><ul>
<li><p>多数学校的面试主要包括英语考察、专业课问答（或抽题）、竞赛与科研问答、自由问答四个环节</p>
<ul>
<li><strong>英语</strong>：自我介绍 or 问答 （仅根据小沈的面试经验，听说别的专业有文献翻译）<a href="https://maiimg.com/dec/a98813351750@pdf">点击此处获取 小沈同学整理的英文面试常见问题</a></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>专业课</strong>：以下为重点复习科目（因为小沈基本报的都是集成电路设计方向，故可能更适用于想学此方向的同学）<a href="https://maiimg.com/dec/a89254355740@pdf">点击此处获取 小沈同学整理的专业课面试常见问题</a> [我整理的答案不一定完全正确，仅供参考，建议自行补充]</p>
<ul>
<li><p>数字集成电路</p>
</li>
<li><p>模拟集成电路</p>
</li>
<li><p>信号与系统</p>
</li>
<li><p>数模电</p>
</li>
<li><p>半导体物理</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>竞赛与科研</strong>：以下是两点小建议</p>
<ul>
<li><p>科研起到的是锦上添花的作用，尤其对于部分工科来说发文章就更难，故如果确定写到简历上就一定要搞明白！</p>
</li>
<li><p>老师并不太在意奖项的数量，更在意的是你是否在含金量高的比赛中都担任了重要的角色，并且学到了更多的技能。据小沈总结，能完完整整说清楚两个比赛就足够了</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>自由问答</strong>：此环节什么都有可能问到，可能是老师即兴出一个问题，问你如何解决；亦或许简单问问为什么选择他们学校or为什么想学此方向or<strong>提前了解过哪位导师</strong>（个人认为这个问题是预推免高频非专业问题）等等</li>
</ul>
<ul>
<li>再来谈谈<strong>面试心态</strong>：双非的同学一定要有<strong>自信</strong>，你要相信只要付出努力学习了，那对课程的掌握程度不会比985211的同学差。小沈曾经也一度怀疑自己，我到底拿什么跟985211的学生比，为什么老师要选我不去选他们？我有个朋友是这么回答我的：985211的同学确实在某些方面要更优秀，但他们又不是天才！所以啊，既然不是天才，那就没什么好怕的了。高考结束是人生的一个新起点，那保研又是另外一个起点，现在你们都站在同一个起点上，而这次的结果只取决于大学三年的努力。而且夏令营和预推免并不限制你报多少学校，大胆去报就行（必须敢报，因为你都对自己不自信的话，老师凭什么要选你），最差的结果也只是不通过从而当作积累经验。相信我，勤勤恳恳三年拿到的保研资格，最后都会有完美的结果！</li>
</ul>
<hr>
<h1 id="系统填报"><a href="#系统填报" class="headerlink" title="系统填报"></a>系统填报</h1><ul>
<li><p>系统填报主要分为两个阶段：注册与志愿填报</p>
<p>| 时间       | 相关操作                                                     |<br>| ————— | —————————————————————————————— |<br>| 9.23~9.27  | 获得推免资格的同学需登录教育部<a href="https://yz.chsi.com.cn/tm/">推荐免试攻读研究生_中国研究生招生信息网 (chsi.com.cn)</a>注册并完善个人信息。不同学校录入保研名额的时间不同，但基本都会在25号左右录入完（只有学校录入完才能注册） |<br>| 9.28~10.20 | 获得推免资格的同学通过教育部<a href="https://yz.chsi.com.cn/tm/">推荐免试攻读研究生_中国研究生招生信息网 (chsi.com.cn)</a>完成报名及志愿填报工作（总共能填三个平行志愿，建议先填最稳的offer），接受并确认招生单位的复试及拟录取通知（对于9.28前拿到学校offer的同学，这一步就是走一个流程） |</p>
</li>
<li><p>注意重要的系统填报时间节点：<strong>9.28日凌晨（00：00）</strong>开始填报志愿，<strong>9.28日12点</strong>各学校开始陆续发放复试通知，通常学校会规定需在半个小时内（不同学校不一样，注意确认的时间就行）接受复试通知，否则认定为自动放弃。在确认复试通知后，耐心等待，学校将发放拟录取通知，而点击确认拟录取通知后，那这次保研的录取工作就正式结束了！（具体示例如下）</p>
<p><img src="/2022/10/23/%E4%BF%9D%E7%A0%94%E5%88%86%E4%BA%AB/image-20221025093326693.png" alt="image-20221025093326693" style="zoom: 33%;"></p>
<p><img src="/2022/10/23/%E4%BF%9D%E7%A0%94%E5%88%86%E4%BA%AB/image-20221025093340803.png" alt="image-20221025093340803" style="zoom: 33%;"></p>
<p><img src="/2022/10/23/%E4%BF%9D%E7%A0%94%E5%88%86%E4%BA%AB/image-20221025093403972.png" alt="image-20221025093403972" style="zoom: 33%;"></p>
<p><img src="/2022/10/23/%E4%BF%9D%E7%A0%94%E5%88%86%E4%BA%AB/image-20221025093420227.png" alt="image-20221025093420227" style="zoom: 33%;"></p>
</li>
<li><p>最后但最重要的是，<strong>不到9.28号填报系统结束那一刻就一定不要放弃</strong>！保研的二八定律，百分之二十的人拿着百分之八十的offer，故很多同学在9.28号之前拿的可能是替补（也就是那些拿到offer的人不去就会有机会录取），但没关系，如果是梦校的替补，一定要等！每年保研鸽子都满天飞，同学A鸽了学校1，导致同学B有机会上学校1，所以B鸽了学校2，导致同学C有机会上学校3，以此类推。而且据我的观察，替补大概率都能替补上（当然，这里可能说得比较绝对，但想表达的是想去就要敢等，以东南微电子为例，今年获得替补的同学有两百多人，录取当天复试通知发到了替补的最后一名）。所以，别放弃，一切皆有可能（我参加厦大夏令营认识的一个朋友，一度觉得快要没书读了，但最终在9.27号接到了上海交大的offer）</p>
</li>
</ul>
<hr>
<h1 id="保研心得"><a href="#保研心得" class="headerlink" title="保研心得"></a>保研心得</h1><ul>
<li><strong>选择相对冷门的学院</strong>：保研时热门专业的竞争会异常激烈，以集成电路设计为例，今年卷到离谱，计算机专业、自动化、材料等专业的同学都来卷了。再加之今年保研名额的增多，想去热们专业读研真是难上加难。所以小沈建议大家可以报名一些相对冷门学院中与自己专业相关的专业，例如前沿交叉学院、航天航空学院（有些学校此学院下面设有集成电路设计专业[我知道的浙大就有]）等等。</li>
<li><strong>不要比较</strong>：保研后一定会有同学朋友或者长辈来问你，保到什么学校了？哪个城市？专业好吗？等等，小沈在这里想说的是这些比较没有任何的意义，因为每个人在意的东西不一样，有人更care城市、有人更care学校title、有人更care学校的科研实力、也有像小沈一样更care18岁时的梦想的。或许有人不理解我想学微电子却没选东南大学，但我有我自己的考虑，我想圆18岁的梦，想去沿海城市，想离家更近，也更喜欢厦大的导师。所以，根据自己的偏爱，做出自己认为对的选择，并且相信它，并为之付出足够的努力，最终都会有美好的人生，毕竟彼方尚有荣光在！</li>
</ul>
<h1 id="选择大于努力-相信大于选择-祝大家都能如愿以偿！"><a href="#选择大于努力-相信大于选择-祝大家都能如愿以偿！" class="headerlink" title="选择大于努力 相信大于选择 祝大家都能如愿以偿！"></a>选择大于努力 相信大于选择 祝大家都能如愿以偿！</h1>]]></content>
      <categories>
        <category>经验之谈</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>保研</tag>
      </tags>
  </entry>
</search>
